diff -BburpN v1.0.old/ardupilotmega/ardupilotmega.h v1.0/ardupilotmega/ardupilotmega.h
--- v1.0.old/ardupilotmega/ardupilotmega.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/ardupilotmega/ardupilotmega.h	2016-06-14 20:22:06.000000000 +0500
@@ -16,7 +16,10 @@ extern "C" {
 #endif
 
 #ifndef MAVLINK_MESSAGE_CRCS
-#define MAVLINK_MESSAGE_CRCS {50, 124, 137, 0, 237, 217, 104, 119, 0, 0, 0, 89, 0, 0, 0, 0, 0, 0, 0, 0, 214, 159, 220, 168, 24, 23, 170, 144, 67, 115, 39, 246, 185, 104, 237, 244, 222, 212, 9, 254, 230, 28, 28, 132, 221, 232, 11, 153, 41, 39, 214, 223, 141, 33, 15, 3, 100, 24, 239, 238, 30, 240, 183, 130, 130, 0, 148, 21, 0, 52, 124, 0, 0, 0, 20, 0, 152, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 231, 183, 63, 54, 0, 0, 0, 0, 0, 0, 0, 175, 102, 158, 208, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 134, 219, 208, 188, 84, 22, 19, 21, 134, 0, 78, 68, 189, 127, 111, 21, 21, 144, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204, 49, 170, 44, 83, 46, 0}
+#define MAVLINK_MESSAGE_CRCS    {50, 124, 137, 0, 237, 217, 104, 119, 0, 0, 0, 89, 0, 0, 0, 0, 0, 0, 0, 0, 214, 159, 220, 168, 24, 23, 170, 144, 67, 115, 39, 246, 185, 104, 237, 244, 222, 212, 9, 254, 230, 28, 28, 132, 221, 232, 11, 153, 41, 39, 214, 223, 141, 33, 15, 3, 100, 24, 239, 238, 30, 240, 183, 130, 130, 0, 148, 21, 0, 52, 124, 0, 0, 0, 20, 0, 152, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 231, 183, 63, 54, 0, 0, 0, 0, 0, 0, 0, 175, 102, 158, 208, 56, 93, 138, 108, 32, 185, 84, 34,  0, 124, 237,  4, 76, 128, 56, 116, 134, 237, 203, 250, 87, 203, 220, 25, 226,  0, 29, 223, 85, 6, 229, 203, 1, 195, 0, 0, 0, 0, 0, 0, 0, 0, 0, 154, 178, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 204, 49, 170, 44, 83, 46, 0}
+//ndef MAVLINK_MESSAGE_CRCS    //0  1     2   3   4    5    6    7   8  9  10 11 12 13 14 15 16 17 18 19  20    21   22   23  24  25   26   27  28   29  30   31   32   33   34   35   36   37 38   39   40  41  42   43   44   45  46   47  48  49  50 51 52 53  54 55 56 57 58 59 60   61   62  63  64   65   66  67 68   69   70 71 72  73  74   75   76   77 78 79 80   81  82  83   84   85 86   87 88   89   90  91  92 93 94 95 96 97 98 99  100  101  102  103 104 105  106  107 108  109 110 111 112  113  114 115 116  117 118  119  120  121  122  123 124  125  126 127  128 129 130  131
+#define MAVLINK_MESSAGE_CRCS_ok {50, 124, 137, 0, 237, 217, 104, 119, 0, 0, 0, 89, 0, 0, 0, 0, 0, 0, 0, 0, 214, 159, 220, 168, 24, 23, 170, 144, 67, 115, 39, 246, 185, 104, 237, 244, 222, 212, 9, 254, 230, 28, 28, 132, 221, 232, 11, 153, 41, 39, 78, 0, 0, 0, 15, 3, 0, 0, 0, 0, 0, 153, 183, 51, 82, 118, 148, 21, 0, 243, 124, 0, 0, 38, 20, 158, 152, 143, 0, 0, 0, 106, 49, 22, 143, 140, 5, 150, 0, 231, 183, 63, 54, 0, 0, 0, 0, 0, 0, 0, 175, 102, 158, 208, 56, 93, 138, 108, 32, 185, 84, 34,  0, 124, 237,  4, 76, 128, 56, 116, 134, 237, 203, 250, 87, 203, 220, 25, 226,  0, 29, 223, 85, 6, 229, 203, 1, 195, 0, 0, 0, 0, 0, 0, 0, 0, 0, 154, 178, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 204, 49, 170, 44, 83, 46, 0}
+
 #endif
 
 #ifndef MAVLINK_MESSAGE_INFO
diff -BburpN v1.0.old/checksum.h v1.0/checksum.h
--- v1.0.old/checksum.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/checksum.h	2015-12-21 12:20:50.000000000 +0500
@@ -24,7 +24,7 @@ extern "C" {
  * @param data new char to hash
  * @param crcAccum the already accumulated checksum
  **/
-static inline void crc_accumulate(uint8_t data, uint16_t *crcAccum)
+static /* inline*/ void crc_accumulate(uint8_t data, uint16_t *crcAccum)
 {
         /*Accumulate one byte of data into the CRC*/
         uint8_t tmp;
diff -BburpN v1.0.old/common/common.h v1.0/common/common.h
--- v1.0.old/common/common.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/common.h	2016-06-14 20:18:25.000000000 +0500
@@ -1,9 +1,13 @@
 /** @file
  *	@brief MAVLink comm protocol generated from common.xml
- *	@see http://qgroundcontrol.org/mavlink/
+ *	@see http://mavlink.org
  */
-#ifndef COMMON_H
-#define COMMON_H
+#ifndef MAVLINK_COMMON_H
+#define MAVLINK_COMMON_H
+
+#ifndef MAVLINK_H
+    #error Wrong include order: MAVLINK_COMMON.H MUST NOT BE DIRECTLY USED. Include mavlink.h from the same directory instead or set ALL AND EVERY defines from MAVLINK.H manually accordingly, including the #define MAVLINK_H call.
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -12,15 +16,15 @@ extern "C" {
 // MESSAGE LENGTHS AND CRCS
 
 #ifndef MAVLINK_MESSAGE_LENGTHS
-#define MAVLINK_MESSAGE_LENGTHS {9, 31, 12, 0, 14, 28, 3, 32, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 25, 23, 30, 101, 22, 26, 16, 14, 28, 32, 28, 28, 22, 22, 21, 6, 6, 37, 4, 4, 2, 2, 4, 2, 2, 3, 13, 12, 19, 17, 15, 15, 27, 25, 18, 18, 20, 20, 9, 34, 26, 46, 36, 0, 6, 4, 0, 21, 18, 0, 0, 0, 20, 0, 33, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 56, 42, 33, 0, 0, 0, 0, 0, 0, 0, 26, 32, 32, 20, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 30, 18, 18, 51, 9, 0}
+#define MAVLINK_MESSAGE_LENGTHS {9, 31, 12, 0, 14, 28, 3, 32, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 25, 23, 30, 101, 22, 26, 16, 14, 28, 32, 28, 28, 22, 22, 21, 6, 6, 37, 4, 4, 2, 2, 4, 2, 2, 3, 13, 12, 37, 0, 0, 0, 27, 25, 0, 0, 0, 0, 0, 68, 26, 185, 181, 42, 6, 4, 0, 11, 18, 0, 0, 37, 20, 35, 33, 3, 0, 0, 0, 22, 39, 37, 53, 51, 53, 51, 0, 28, 56, 42, 33, 0, 0, 0, 0, 0, 0, 0, 26, 32, 32, 20, 32, 62, 44, 64, 84, 9, 254, 16, 0, 36, 44, 64, 22, 6, 14, 12, 97, 2, 2, 113, 35, 6, 79, 35, 35, 0, 13, 255, 14, 18, 43, 8, 22, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 254, 36, 30, 18, 18, 51, 9, 0}
 #endif
 
-#ifndef MAVLINK_MESSAGE_CRCS
-#define MAVLINK_MESSAGE_CRCS {50, 124, 137, 0, 237, 217, 104, 119, 0, 0, 0, 89, 0, 0, 0, 0, 0, 0, 0, 0, 214, 159, 220, 168, 24, 23, 170, 144, 67, 115, 39, 246, 185, 104, 237, 244, 222, 212, 9, 254, 230, 28, 28, 132, 221, 232, 11, 153, 41, 39, 214, 223, 141, 33, 15, 3, 100, 24, 239, 238, 30, 240, 183, 130, 130, 0, 148, 21, 0, 52, 124, 0, 0, 0, 20, 0, 152, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 231, 183, 63, 54, 0, 0, 0, 0, 0, 0, 0, 175, 102, 158, 208, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204, 49, 170, 44, 83, 46, 0}
+#ifndef MAVLINK_MESSAGE_CRCS //0  1     2   3   4    5    6    7   8  9  10 11 12 13 14 15 16 17 18 19  20    21   22   23  24  25   26   27  28   29  30   31   32   33   34   35   36   37 38   39   40  41  42   43   44   45  46   47  48  49  50 51 52 53  54 55 56 57 58 59 60   61   62  63  64   65   66  67 68   69   70 71 72  73  74   75   76   77 78 79 80   81  82  83   84   85 86   87 88   89   90  91  92 93 94 95 96 97 98 99  100  101  102  103 104 105  106  107 108  109 110 111 112  113  114 115 116  117 118  119  120  121  122  123 124  125  126 127  128 129 130  131
+#define MAVLINK_MESSAGE_CRCS {50, 124, 137, 0, 237, 217, 104, 119, 0, 0, 0, 89, 0, 0, 0, 0, 0, 0, 0, 0, 214, 159, 220, 168, 24, 23, 170, 144, 67, 115, 39, 246, 185, 104, 237, 244, 222, 212, 9, 254, 230, 28, 28, 132, 221, 232, 11, 153, 41, 39, 78, 0, 0, 0, 15, 3, 0, 0, 0, 0, 0, 153, 183, 51, 82, 118, 148, 21, 0, 243, 124, 0, 0, 38, 20, 158, 152, 143, 0, 0, 0, 106, 49, 22, 143, 140, 5, 150, 0, 231, 183, 63, 54, 0, 0, 0, 0, 0, 0, 0, 175, 102, 158, 208, 56, 93, 138, 108, 32, 185, 84, 34,  0, 124, 237,  4, 76, 128, 56, 116, 134, 237, 203, 250, 87, 203, 220, 25, 226,  0, 29, 223, 85, 6, 229, 203, 1, 195, 0, 0, 0, 0, 0, 0, 0, 0, 0, 154, 178, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 204, 49, 170, 44, 83, 46, 0}
 #endif
 
 #ifndef MAVLINK_MESSAGE_INFO
-#define MAVLINK_MESSAGE_INFO {MAVLINK_MESSAGE_INFO_HEARTBEAT, MAVLINK_MESSAGE_INFO_SYS_STATUS, MAVLINK_MESSAGE_INFO_SYSTEM_TIME, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_PING, MAVLINK_MESSAGE_INFO_CHANGE_OPERATOR_CONTROL, MAVLINK_MESSAGE_INFO_CHANGE_OPERATOR_CONTROL_ACK, MAVLINK_MESSAGE_INFO_AUTH_KEY, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_SET_MODE, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_PARAM_REQUEST_READ, MAVLINK_MESSAGE_INFO_PARAM_REQUEST_LIST, MAVLINK_MESSAGE_INFO_PARAM_VALUE, MAVLINK_MESSAGE_INFO_PARAM_SET, MAVLINK_MESSAGE_INFO_GPS_RAW_INT, MAVLINK_MESSAGE_INFO_GPS_STATUS, MAVLINK_MESSAGE_INFO_SCALED_IMU, MAVLINK_MESSAGE_INFO_RAW_IMU, MAVLINK_MESSAGE_INFO_RAW_PRESSURE, MAVLINK_MESSAGE_INFO_SCALED_PRESSURE, MAVLINK_MESSAGE_INFO_ATTITUDE, MAVLINK_MESSAGE_INFO_ATTITUDE_QUATERNION, MAVLINK_MESSAGE_INFO_LOCAL_POSITION_NED, MAVLINK_MESSAGE_INFO_GLOBAL_POSITION_INT, MAVLINK_MESSAGE_INFO_RC_CHANNELS_SCALED, MAVLINK_MESSAGE_INFO_RC_CHANNELS_RAW, MAVLINK_MESSAGE_INFO_SERVO_OUTPUT_RAW, MAVLINK_MESSAGE_INFO_MISSION_REQUEST_PARTIAL_LIST, MAVLINK_MESSAGE_INFO_MISSION_WRITE_PARTIAL_LIST, MAVLINK_MESSAGE_INFO_MISSION_ITEM, MAVLINK_MESSAGE_INFO_MISSION_REQUEST, MAVLINK_MESSAGE_INFO_MISSION_SET_CURRENT, MAVLINK_MESSAGE_INFO_MISSION_CURRENT, MAVLINK_MESSAGE_INFO_MISSION_REQUEST_LIST, MAVLINK_MESSAGE_INFO_MISSION_COUNT, MAVLINK_MESSAGE_INFO_MISSION_CLEAR_ALL, MAVLINK_MESSAGE_INFO_MISSION_ITEM_REACHED, MAVLINK_MESSAGE_INFO_MISSION_ACK, MAVLINK_MESSAGE_INFO_SET_GPS_GLOBAL_ORIGIN, MAVLINK_MESSAGE_INFO_GPS_GLOBAL_ORIGIN, MAVLINK_MESSAGE_INFO_SET_LOCAL_POSITION_SETPOINT, MAVLINK_MESSAGE_INFO_LOCAL_POSITION_SETPOINT, MAVLINK_MESSAGE_INFO_GLOBAL_POSITION_SETPOINT_INT, MAVLINK_MESSAGE_INFO_SET_GLOBAL_POSITION_SETPOINT_INT, MAVLINK_MESSAGE_INFO_SAFETY_SET_ALLOWED_AREA, MAVLINK_MESSAGE_INFO_SAFETY_ALLOWED_AREA, MAVLINK_MESSAGE_INFO_SET_ROLL_PITCH_YAW_THRUST, MAVLINK_MESSAGE_INFO_SET_ROLL_PITCH_YAW_SPEED_THRUST, MAVLINK_MESSAGE_INFO_ROLL_PITCH_YAW_THRUST_SETPOINT, MAVLINK_MESSAGE_INFO_ROLL_PITCH_YAW_SPEED_THRUST_SETPOINT, MAVLINK_MESSAGE_INFO_SET_QUAD_MOTORS_SETPOINT, MAVLINK_MESSAGE_INFO_SET_QUAD_SWARM_ROLL_PITCH_YAW_THRUST, MAVLINK_MESSAGE_INFO_NAV_CONTROLLER_OUTPUT, MAVLINK_MESSAGE_INFO_SET_QUAD_SWARM_LED_ROLL_PITCH_YAW_THRUST, MAVLINK_MESSAGE_INFO_STATE_CORRECTION, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_REQUEST_DATA_STREAM, MAVLINK_MESSAGE_INFO_DATA_STREAM, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_MANUAL_CONTROL, MAVLINK_MESSAGE_INFO_RC_CHANNELS_OVERRIDE, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_VFR_HUD, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_COMMAND_LONG, MAVLINK_MESSAGE_INFO_COMMAND_ACK, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET, MAVLINK_MESSAGE_INFO_HIL_STATE, MAVLINK_MESSAGE_INFO_HIL_CONTROLS, MAVLINK_MESSAGE_INFO_HIL_RC_INPUTS_RAW, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_OPTICAL_FLOW, MAVLINK_MESSAGE_INFO_GLOBAL_VISION_POSITION_ESTIMATE, MAVLINK_MESSAGE_INFO_VISION_POSITION_ESTIMATE, MAVLINK_MESSAGE_INFO_VISION_SPEED_ESTIMATE, MAVLINK_MESSAGE_INFO_VICON_POSITION_ESTIMATE, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_MEMORY_VECT, MAVLINK_MESSAGE_INFO_DEBUG_VECT, MAVLINK_MESSAGE_INFO_NAMED_VALUE_FLOAT, MAVLINK_MESSAGE_INFO_NAMED_VALUE_INT, MAVLINK_MESSAGE_INFO_STATUSTEXT, MAVLINK_MESSAGE_INFO_DEBUG, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}}
+#define MAVLINK_MESSAGE_INFO {MAVLINK_MESSAGE_INFO_HEARTBEAT, MAVLINK_MESSAGE_INFO_SYS_STATUS, MAVLINK_MESSAGE_INFO_SYSTEM_TIME, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_PING, MAVLINK_MESSAGE_INFO_CHANGE_OPERATOR_CONTROL, MAVLINK_MESSAGE_INFO_CHANGE_OPERATOR_CONTROL_ACK, MAVLINK_MESSAGE_INFO_AUTH_KEY, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_SET_MODE, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_PARAM_REQUEST_READ, MAVLINK_MESSAGE_INFO_PARAM_REQUEST_LIST, MAVLINK_MESSAGE_INFO_PARAM_VALUE, MAVLINK_MESSAGE_INFO_PARAM_SET, MAVLINK_MESSAGE_INFO_GPS_RAW_INT, MAVLINK_MESSAGE_INFO_GPS_STATUS, MAVLINK_MESSAGE_INFO_SCALED_IMU, MAVLINK_MESSAGE_INFO_RAW_IMU, MAVLINK_MESSAGE_INFO_RAW_PRESSURE, MAVLINK_MESSAGE_INFO_SCALED_PRESSURE, MAVLINK_MESSAGE_INFO_ATTITUDE, MAVLINK_MESSAGE_INFO_ATTITUDE_QUATERNION, MAVLINK_MESSAGE_INFO_LOCAL_POSITION_NED, MAVLINK_MESSAGE_INFO_GLOBAL_POSITION_INT, MAVLINK_MESSAGE_INFO_RC_CHANNELS_SCALED, MAVLINK_MESSAGE_INFO_RC_CHANNELS_RAW, MAVLINK_MESSAGE_INFO_SERVO_OUTPUT_RAW, MAVLINK_MESSAGE_INFO_MISSION_REQUEST_PARTIAL_LIST, MAVLINK_MESSAGE_INFO_MISSION_WRITE_PARTIAL_LIST, MAVLINK_MESSAGE_INFO_MISSION_ITEM, MAVLINK_MESSAGE_INFO_MISSION_REQUEST, MAVLINK_MESSAGE_INFO_MISSION_SET_CURRENT, MAVLINK_MESSAGE_INFO_MISSION_CURRENT, MAVLINK_MESSAGE_INFO_MISSION_REQUEST_LIST, MAVLINK_MESSAGE_INFO_MISSION_COUNT, MAVLINK_MESSAGE_INFO_MISSION_CLEAR_ALL, MAVLINK_MESSAGE_INFO_MISSION_ITEM_REACHED, MAVLINK_MESSAGE_INFO_MISSION_ACK, MAVLINK_MESSAGE_INFO_SET_GPS_GLOBAL_ORIGIN, MAVLINK_MESSAGE_INFO_GPS_GLOBAL_ORIGIN, MAVLINK_MESSAGE_INFO_PARAM_MAP_RC, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_SAFETY_SET_ALLOWED_AREA, MAVLINK_MESSAGE_INFO_SAFETY_ALLOWED_AREA, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_ATTITUDE_QUATERNION_COV, MAVLINK_MESSAGE_INFO_NAV_CONTROLLER_OUTPUT, MAVLINK_MESSAGE_INFO_GLOBAL_POSITION_INT_COV, MAVLINK_MESSAGE_INFO_LOCAL_POSITION_NED_COV, MAVLINK_MESSAGE_INFO_RC_CHANNELS, MAVLINK_MESSAGE_INFO_REQUEST_DATA_STREAM, MAVLINK_MESSAGE_INFO_DATA_STREAM, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_MANUAL_CONTROL, MAVLINK_MESSAGE_INFO_RC_CHANNELS_OVERRIDE, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_MISSION_ITEM_INT, MAVLINK_MESSAGE_INFO_VFR_HUD, MAVLINK_MESSAGE_INFO_COMMAND_INT, MAVLINK_MESSAGE_INFO_COMMAND_LONG, MAVLINK_MESSAGE_INFO_COMMAND_ACK, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_MANUAL_SETPOINT, MAVLINK_MESSAGE_INFO_SET_ATTITUDE_TARGET, MAVLINK_MESSAGE_INFO_ATTITUDE_TARGET, MAVLINK_MESSAGE_INFO_SET_POSITION_TARGET_LOCAL_NED, MAVLINK_MESSAGE_INFO_POSITION_TARGET_LOCAL_NED, MAVLINK_MESSAGE_INFO_SET_POSITION_TARGET_GLOBAL_INT, MAVLINK_MESSAGE_INFO_POSITION_TARGET_GLOBAL_INT, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET, MAVLINK_MESSAGE_INFO_HIL_STATE, MAVLINK_MESSAGE_INFO_HIL_CONTROLS, MAVLINK_MESSAGE_INFO_HIL_RC_INPUTS_RAW, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_OPTICAL_FLOW, MAVLINK_MESSAGE_INFO_GLOBAL_VISION_POSITION_ESTIMATE, MAVLINK_MESSAGE_INFO_VISION_POSITION_ESTIMATE, MAVLINK_MESSAGE_INFO_VISION_SPEED_ESTIMATE, MAVLINK_MESSAGE_INFO_VICON_POSITION_ESTIMATE, MAVLINK_MESSAGE_INFO_HIGHRES_IMU, MAVLINK_MESSAGE_INFO_OPTICAL_FLOW_RAD, MAVLINK_MESSAGE_INFO_HIL_SENSOR, MAVLINK_MESSAGE_INFO_SIM_STATE, MAVLINK_MESSAGE_INFO_RADIO_STATUS, MAVLINK_MESSAGE_INFO_FILE_TRANSFER_PROTOCOL, MAVLINK_MESSAGE_INFO_TIMESYNC, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_HIL_GPS, MAVLINK_MESSAGE_INFO_HIL_OPTICAL_FLOW, MAVLINK_MESSAGE_INFO_HIL_STATE_QUATERNION, MAVLINK_MESSAGE_INFO_SCALED_IMU2, MAVLINK_MESSAGE_INFO_LOG_REQUEST_LIST, MAVLINK_MESSAGE_INFO_LOG_ENTRY, MAVLINK_MESSAGE_INFO_LOG_REQUEST_DATA, MAVLINK_MESSAGE_INFO_LOG_DATA, MAVLINK_MESSAGE_INFO_LOG_ERASE, MAVLINK_MESSAGE_INFO_LOG_REQUEST_END, MAVLINK_MESSAGE_INFO_GPS_INJECT_DATA, MAVLINK_MESSAGE_INFO_GPS2_RAW, MAVLINK_MESSAGE_INFO_POWER_STATUS, MAVLINK_MESSAGE_INFO_SERIAL_CONTROL, MAVLINK_MESSAGE_INFO_GPS_RTK, MAVLINK_MESSAGE_INFO_GPS2_RTK, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_DATA_TRANSMISSION_HANDSHAKE, MAVLINK_MESSAGE_INFO_ENCAPSULATED_DATA, MAVLINK_MESSAGE_INFO_DISTANCE_SENSOR, MAVLINK_MESSAGE_INFO_TERRAIN_REQUEST, MAVLINK_MESSAGE_INFO_TERRAIN_DATA, MAVLINK_MESSAGE_INFO_TERRAIN_CHECK, MAVLINK_MESSAGE_INFO_TERRAIN_REPORT, MAVLINK_MESSAGE_INFO_SCALED_PRESSURE2, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_BATTERY_STATUS, MAVLINK_MESSAGE_INFO_AUTOPILOT_VERSION, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, MAVLINK_MESSAGE_INFO_V2_EXTENSION, MAVLINK_MESSAGE_INFO_MEMORY_VECT, MAVLINK_MESSAGE_INFO_DEBUG_VECT, MAVLINK_MESSAGE_INFO_NAMED_VALUE_FLOAT, MAVLINK_MESSAGE_INFO_NAMED_VALUE_INT, MAVLINK_MESSAGE_INFO_STATUSTEXT, MAVLINK_MESSAGE_INFO_DEBUG, {"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}}
 #endif
 
 #include "../protocol.h"
@@ -33,7 +37,7 @@ extern "C" {
 /** @brief Micro air vehicle / autopilot classes. This identifies the individual model. */
 #ifndef HAVE_ENUM_MAV_AUTOPILOT
 #define HAVE_ENUM_MAV_AUTOPILOT
-enum MAV_AUTOPILOT
+typedef enum MAV_AUTOPILOT
 {
 	MAV_AUTOPILOT_GENERIC=0, /* Generic autopilot, full support for everything | */
 	MAV_AUTOPILOT_PIXHAWK=1, /* PIXHAWK autopilot, http://pixhawk.ethz.ch | */
@@ -47,14 +51,20 @@ enum MAV_AUTOPILOT
 	MAV_AUTOPILOT_PPZ=9, /* PPZ UAV - http://nongnu.org/paparazzi | */
 	MAV_AUTOPILOT_UDB=10, /* UAV Dev Board | */
 	MAV_AUTOPILOT_FP=11, /* FlexiPilot | */
-	MAV_AUTOPILOT_ENUM_END=12, /*  | */
-};
+	MAV_AUTOPILOT_PX4=12, /* PX4 Autopilot - http://pixhawk.ethz.ch/px4/ | */
+	MAV_AUTOPILOT_SMACCMPILOT=13, /* SMACCMPilot - http://smaccmpilot.org | */
+	MAV_AUTOPILOT_AUTOQUAD=14, /* AutoQuad -- http://autoquad.org | */
+	MAV_AUTOPILOT_ARMAZILA=15, /* Armazila -- http://armazila.com | */
+	MAV_AUTOPILOT_AEROB=16, /* Aerob -- http://aerob.ru | */
+	MAV_AUTOPILOT_ASLUAV=17, /* ASLUAV autopilot -- http://www.asl.ethz.ch | */
+	MAV_AUTOPILOT_ENUM_END=18, /*  | */
+} MAV_AUTOPILOT;
 #endif
 
 /** @brief  */
 #ifndef HAVE_ENUM_MAV_TYPE
 #define HAVE_ENUM_MAV_TYPE
-enum MAV_TYPE
+typedef enum MAV_TYPE
 {
 	MAV_TYPE_GENERIC=0, /* Generic micro air vehicle. | */
 	MAV_TYPE_FIXED_WING=1, /* Fixed wing aircraft. | */
@@ -74,14 +84,18 @@ enum MAV_TYPE
 	MAV_TYPE_TRICOPTER=15, /* Octorotor | */
 	MAV_TYPE_FLAPPING_WING=16, /* Flapping wing | */
 	MAV_TYPE_KITE=17, /* Flapping wing | */
-	MAV_TYPE_ENUM_END=18, /*  | */
-};
+	MAV_TYPE_ONBOARD_CONTROLLER=18, /* Onboard companion controller | */
+	MAV_TYPE_VTOL_DUOROTOR=19, /* Two-rotor VTOL using control surfaces in vertical operation in addition. Tailsitter. | */
+	MAV_TYPE_VTOL_QUADROTOR=20, /* Quad-rotor VTOL using a V-shaped quad config in vertical operation. Tailsitter. | */
+	MAV_TYPE_GIMBAL=26, /* Onboard gimbal | */
+	MAV_TYPE_ENUM_END=27, /*  | */
+} MAV_TYPE;
 #endif
 
 /** @brief These flags encode the MAV mode. */
 #ifndef HAVE_ENUM_MAV_MODE_FLAG
 #define HAVE_ENUM_MAV_MODE_FLAG
-enum MAV_MODE_FLAG
+typedef enum MAV_MODE_FLAG
 {
 	MAV_MODE_FLAG_CUSTOM_MODE_ENABLED=1, /* 0b00000001 Reserved for future use. | */
 	MAV_MODE_FLAG_TEST_ENABLED=2, /* 0b00000010 system has a test mode enabled. This flag is intended for temporary system tests and should not be used for stable implementations. | */
@@ -92,13 +106,13 @@ enum MAV_MODE_FLAG
 	MAV_MODE_FLAG_MANUAL_INPUT_ENABLED=64, /* 0b01000000 remote control input is enabled. | */
 	MAV_MODE_FLAG_SAFETY_ARMED=128, /* 0b10000000 MAV safety set to armed. Motors are enabled / running / can start. Ready to fly. | */
 	MAV_MODE_FLAG_ENUM_END=129, /*  | */
-};
+} MAV_MODE_FLAG;
 #endif
 
 /** @brief These values encode the bit positions of the decode position. These values can be used to read the value of a flag bit by combining the base_mode variable with AND with the flag position value. The result will be either 0 or 1, depending on if the flag is set or not. */
 #ifndef HAVE_ENUM_MAV_MODE_FLAG_DECODE_POSITION
 #define HAVE_ENUM_MAV_MODE_FLAG_DECODE_POSITION
-enum MAV_MODE_FLAG_DECODE_POSITION
+typedef enum MAV_MODE_FLAG_DECODE_POSITION
 {
 	MAV_MODE_FLAG_DECODE_POSITION_CUSTOM_MODE=1, /* Eighth bit: 00000001 | */
 	MAV_MODE_FLAG_DECODE_POSITION_TEST=2, /* Seventh bit: 00000010 | */
@@ -109,27 +123,27 @@ enum MAV_MODE_FLAG_DECODE_POSITION
 	MAV_MODE_FLAG_DECODE_POSITION_MANUAL=64, /* Second bit: 01000000 | */
 	MAV_MODE_FLAG_DECODE_POSITION_SAFETY=128, /* First bit:  10000000 | */
 	MAV_MODE_FLAG_DECODE_POSITION_ENUM_END=129, /*  | */
-};
+} MAV_MODE_FLAG_DECODE_POSITION;
 #endif
 
 /** @brief Override command, pauses current mission execution and moves immediately to a position */
 #ifndef HAVE_ENUM_MAV_GOTO
 #define HAVE_ENUM_MAV_GOTO
-enum MAV_GOTO
+typedef enum MAV_GOTO
 {
 	MAV_GOTO_DO_HOLD=0, /* Hold at the current position. | */
 	MAV_GOTO_DO_CONTINUE=1, /* Continue with the next item in mission execution. | */
 	MAV_GOTO_HOLD_AT_CURRENT_POSITION=2, /* Hold at the current position of the system | */
 	MAV_GOTO_HOLD_AT_SPECIFIED_POSITION=3, /* Hold at the position specified in the parameters of the DO_HOLD action | */
 	MAV_GOTO_ENUM_END=4, /*  | */
-};
+} MAV_GOTO;
 #endif
 
 /** @brief These defines are predefined OR-combined mode flags. There is no need to use values from this enum, but it
                simplifies the use of the mode flags. Note that manual input is enabled in all modes as a safety override. */
 #ifndef HAVE_ENUM_MAV_MODE
 #define HAVE_ENUM_MAV_MODE
-enum MAV_MODE
+typedef enum MAV_MODE
 {
 	MAV_MODE_PREFLIGHT=0, /* System is not ready to fly, booting, calibrating, etc. No flag is set. | */
 	MAV_MODE_MANUAL_DISARMED=64, /* System is allowed to be active, under manual (RC) control, no stabilization | */
@@ -143,13 +157,13 @@ enum MAV_MODE
 	MAV_MODE_GUIDED_ARMED=216, /* System is allowed to be active, under autonomous control, manual setpoint | */
 	MAV_MODE_AUTO_ARMED=220, /* System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard and not pre-programmed by MISSIONs) | */
 	MAV_MODE_ENUM_END=221, /*  | */
-};
+} MAV_MODE;
 #endif
 
 /** @brief  */
 #ifndef HAVE_ENUM_MAV_STATE
 #define HAVE_ENUM_MAV_STATE
-enum MAV_STATE
+typedef enum MAV_STATE
 {
 	MAV_STATE_UNINIT=0, /* Uninitialized system, state is unknown. | */
 	MAV_STATE_BOOT=1, /* System is booting up. | */
@@ -160,13 +174,13 @@ enum MAV_STATE
 	MAV_STATE_EMERGENCY=6, /* System is in a non-normal flight mode. It lost control over parts or over the whole airframe. It is in mayday and going down. | */
 	MAV_STATE_POWEROFF=7, /* System just initialized its power-down sequence, will shut down now. | */
 	MAV_STATE_ENUM_END=8, /*  | */
-};
+} MAV_STATE;
 #endif
 
 /** @brief  */
 #ifndef HAVE_ENUM_MAV_COMPONENT
 #define HAVE_ENUM_MAV_COMPONENT
-enum MAV_COMPONENT
+typedef enum MAV_COMPONENT
 {
 	MAV_COMP_ID_ALL=0, /*  | */
 	MAV_COMP_ID_CAMERA=100, /*  | */
@@ -184,6 +198,7 @@ enum MAV_COMPONENT
 	MAV_COMP_ID_SERVO12=151, /*  | */
 	MAV_COMP_ID_SERVO13=152, /*  | */
 	MAV_COMP_ID_SERVO14=153, /*  | */
+	MAV_COMP_ID_GIMBAL=154, /*  | */
 	MAV_COMP_ID_MAPPER=180, /*  | */
 	MAV_COMP_ID_MISSIONPLANNER=190, /*  | */
 	MAV_COMP_ID_PATHPLANNER=195, /*  | */
@@ -195,27 +210,66 @@ enum MAV_COMPONENT
 	MAV_COMP_ID_UART_BRIDGE=241, /*  | */
 	MAV_COMP_ID_SYSTEM_CONTROL=250, /*  | */
 	MAV_COMPONENT_ENUM_END=251, /*  | */
-};
+} MAV_COMPONENT;
+#endif
+
+/** @brief These encode the sensors whose status is sent as part of the SYS_STATUS message. */
+#ifndef HAVE_ENUM_MAV_SYS_STATUS_SENSOR
+#define HAVE_ENUM_MAV_SYS_STATUS_SENSOR
+typedef enum MAV_SYS_STATUS_SENSOR
+{
+	MAV_SYS_STATUS_SENSOR_3D_GYRO=1, /* 0x01 3D gyro | */
+	MAV_SYS_STATUS_SENSOR_3D_ACCEL=2, /* 0x02 3D accelerometer | */
+	MAV_SYS_STATUS_SENSOR_3D_MAG=4, /* 0x04 3D magnetometer | */
+	MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE=8, /* 0x08 absolute pressure | */
+	MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE=16, /* 0x10 differential pressure | */
+	MAV_SYS_STATUS_SENSOR_GPS=32, /* 0x20 GPS | */
+	MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW=64, /* 0x40 optical flow | */
+	MAV_SYS_STATUS_SENSOR_VISION_POSITION=128, /* 0x80 computer vision position | */
+	MAV_SYS_STATUS_SENSOR_LASER_POSITION=256, /* 0x100 laser based position | */
+	MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH=512, /* 0x200 external ground truth (Vicon or Leica) | */
+	MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL=1024, /* 0x400 3D angular rate control | */
+	MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION=2048, /* 0x800 attitude stabilization | */
+	MAV_SYS_STATUS_SENSOR_YAW_POSITION=4096, /* 0x1000 yaw position | */
+	MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL=8192, /* 0x2000 z/altitude control | */
+	MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL=16384, /* 0x4000 x/y position control | */
+	MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS=32768, /* 0x8000 motor outputs / control | */
+	MAV_SYS_STATUS_SENSOR_RC_RECEIVER=65536, /* 0x10000 rc receiver | */
+	MAV_SYS_STATUS_SENSOR_3D_GYRO2=131072, /* 0x20000 2nd 3D gyro | */
+	MAV_SYS_STATUS_SENSOR_3D_ACCEL2=262144, /* 0x40000 2nd 3D accelerometer | */
+	MAV_SYS_STATUS_SENSOR_3D_MAG2=524288, /* 0x80000 2nd 3D magnetometer | */
+	MAV_SYS_STATUS_GEOFENCE=1048576, /* 0x100000 geofence | */
+	MAV_SYS_STATUS_AHRS=2097152, /* 0x200000 AHRS subsystem health | */
+	MAV_SYS_STATUS_TERRAIN=4194304, /* 0x400000 Terrain subsystem health | */
+	MAV_SYS_STATUS_SENSOR_ENUM_END=4194305, /*  | */
+} MAV_SYS_STATUS_SENSOR;
 #endif
 
 /** @brief  */
 #ifndef HAVE_ENUM_MAV_FRAME
 #define HAVE_ENUM_MAV_FRAME
-enum MAV_FRAME
+typedef enum MAV_FRAME
 {
 	MAV_FRAME_GLOBAL=0, /* Global coordinate frame, WGS84 coordinate system. First value / x: latitude, second value / y: longitude, third value / z: positive altitude over mean sea level (MSL) | */
 	MAV_FRAME_LOCAL_NED=1, /* Local coordinate frame, Z-up (x: north, y: east, z: down). | */
 	MAV_FRAME_MISSION=2, /* NOT a coordinate frame, indicates a mission command. | */
 	MAV_FRAME_GLOBAL_RELATIVE_ALT=3, /* Global coordinate frame, WGS84 coordinate system, relative altitude over ground with respect to the home position. First value / x: latitude, second value / y: longitude, third value / z: positive altitude with 0 being at the altitude of the home location. | */
 	MAV_FRAME_LOCAL_ENU=4, /* Local coordinate frame, Z-down (x: east, y: north, z: up) | */
-	MAV_FRAME_ENUM_END=5, /*  | */
-};
+	MAV_FRAME_GLOBAL_INT=5, /* Global coordinate frame, WGS84 coordinate system. First value / x: latitude in degrees*1.0e-7, second value / y: longitude in degrees*1.0e-7, third value / z: positive altitude over mean sea level (MSL) | */
+	MAV_FRAME_GLOBAL_RELATIVE_ALT_INT=6, /* Global coordinate frame, WGS84 coordinate system, relative altitude over ground with respect to the home position. First value / x: latitude in degrees*10e-7, second value / y: longitude in degrees*10e-7, third value / z: positive altitude with 0 being at the altitude of the home location. | */
+	MAV_FRAME_LOCAL_OFFSET_NED=7, /* Offset to the current local frame. Anything expressed in this frame should be added to the current local frame position. | */
+	MAV_FRAME_BODY_NED=8, /* Setpoint in body NED frame. This makes sense if all position control is externalized - e.g. useful to command 2 m/s^2 acceleration to the right. | */
+	MAV_FRAME_BODY_OFFSET_NED=9, /* Offset in body NED frame. This makes sense if adding setpoints to the current flight path, to avoid an obstacle - e.g. useful to command 2 m/s^2 acceleration to the east. | */
+	MAV_FRAME_GLOBAL_TERRAIN_ALT=10, /* Global coordinate frame with above terrain level altitude. WGS84 coordinate system, relative altitude over terrain with respect to the waypoint coordinate. First value / x: latitude in degrees, second value / y: longitude in degrees, third value / z: positive altitude in meters with 0 being at ground level in terrain model. | */
+	MAV_FRAME_GLOBAL_TERRAIN_ALT_INT=11, /* Global coordinate frame with above terrain level altitude. WGS84 coordinate system, relative altitude over terrain with respect to the waypoint coordinate. First value / x: latitude in degrees*10e-7, second value / y: longitude in degrees*10e-7, third value / z: positive altitude in meters with 0 being at ground level in terrain model. | */
+	MAV_FRAME_ENUM_END=12, /*  | */
+} MAV_FRAME;
 #endif
 
 /** @brief  */
 #ifndef HAVE_ENUM_MAVLINK_DATA_STREAM_TYPE
 #define HAVE_ENUM_MAVLINK_DATA_STREAM_TYPE
-enum MAVLINK_DATA_STREAM_TYPE
+typedef enum MAVLINK_DATA_STREAM_TYPE
 {
 	MAVLINK_DATA_STREAM_IMG_JPEG=1, /*  | */
 	MAVLINK_DATA_STREAM_IMG_BMP=2, /*  | */
@@ -224,7 +278,47 @@ enum MAVLINK_DATA_STREAM_TYPE
 	MAVLINK_DATA_STREAM_IMG_PGM=5, /*  | */
 	MAVLINK_DATA_STREAM_IMG_PNG=6, /*  | */
 	MAVLINK_DATA_STREAM_TYPE_ENUM_END=7, /*  | */
-};
+} MAVLINK_DATA_STREAM_TYPE;
+#endif
+
+/** @brief  */
+#ifndef HAVE_ENUM_FENCE_ACTION
+#define HAVE_ENUM_FENCE_ACTION
+typedef enum FENCE_ACTION
+{
+	FENCE_ACTION_NONE=0, /* Disable fenced mode | */
+	FENCE_ACTION_GUIDED=1, /* Switched to guided mode to return point (fence point 0) | */
+	FENCE_ACTION_REPORT=2, /* Report fence breach, but don't take action | */
+	FENCE_ACTION_GUIDED_THR_PASS=3, /* Switched to guided mode to return point (fence point 0) with manual throttle control | */
+	FENCE_ACTION_ENUM_END=4, /*  | */
+} FENCE_ACTION;
+#endif
+
+/** @brief  */
+#ifndef HAVE_ENUM_FENCE_BREACH
+#define HAVE_ENUM_FENCE_BREACH
+typedef enum FENCE_BREACH
+{
+	FENCE_BREACH_NONE=0, /* No last fence breach | */
+	FENCE_BREACH_MINALT=1, /* Breached minimum altitude | */
+	FENCE_BREACH_MAXALT=2, /* Breached maximum altitude | */
+	FENCE_BREACH_BOUNDARY=3, /* Breached fence boundary | */
+	FENCE_BREACH_ENUM_END=4, /*  | */
+} FENCE_BREACH;
+#endif
+
+/** @brief Enumeration of possible mount operation modes */
+#ifndef HAVE_ENUM_MAV_MOUNT_MODE
+#define HAVE_ENUM_MAV_MOUNT_MODE
+typedef enum MAV_MOUNT_MODE
+{
+	MAV_MOUNT_MODE_RETRACT=0, /* Load and keep safe position (Roll,Pitch,Yaw) from permant memory and stop stabilization | */
+	MAV_MOUNT_MODE_NEUTRAL=1, /* Load and keep neutral position (Roll,Pitch,Yaw) from permanent memory. | */
+	MAV_MOUNT_MODE_MAVLINK_TARGETING=2, /* Load neutral position and start MAVLink Roll,Pitch,Yaw control with stabilization | */
+	MAV_MOUNT_MODE_RC_TARGETING=3, /* Load neutral position and start RC Roll,Pitch,Yaw control with stabilization | */
+	MAV_MOUNT_MODE_GPS_POINT=4, /* Load neutral position and start to point to Lat,Lon,Alt | */
+	MAV_MOUNT_MODE_ENUM_END=5, /*  | */
+} MAV_MOUNT_MODE;
 #endif
 
 /** @brief Data stream IDs. A data stream is not a fixed set of messages, but rather a
@@ -232,7 +326,7 @@ enum MAVLINK_DATA_STREAM_TYPE
      the recommended messages. */
 #ifndef HAVE_ENUM_MAV_DATA_STREAM
 #define HAVE_ENUM_MAV_DATA_STREAM
-enum MAV_DATA_STREAM
+typedef enum MAV_DATA_STREAM
 {
 	MAV_DATA_STREAM_ALL=0, /* Enable all data streams | */
 	MAV_DATA_STREAM_RAW_SENSORS=1, /* Enable IMU_RAW, GPS_RAW, GPS_STATUS packets. | */
@@ -244,7 +338,7 @@ enum MAV_DATA_STREAM
 	MAV_DATA_STREAM_EXTRA2=11, /* Dependent on the autopilot | */
 	MAV_DATA_STREAM_EXTRA3=12, /* Dependent on the autopilot | */
 	MAV_DATA_STREAM_ENUM_END=13, /*  | */
-};
+} MAV_DATA_STREAM;
 #endif
 
 /** @brief  The ROI (region of interest) for the vehicle. This can be
@@ -252,7 +346,7 @@ enum MAV_DATA_STREAM
                 MAV_CMD_NAV_ROI). */
 #ifndef HAVE_ENUM_MAV_ROI
 #define HAVE_ENUM_MAV_ROI
-enum MAV_ROI
+typedef enum MAV_ROI
 {
 	MAV_ROI_NONE=0, /* No region of interest. | */
 	MAV_ROI_WPNEXT=1, /* Point toward next MISSION. | */
@@ -260,13 +354,13 @@ enum MAV_ROI
 	MAV_ROI_LOCATION=3, /* Point toward fixed location. | */
 	MAV_ROI_TARGET=4, /* Point toward of given id. | */
 	MAV_ROI_ENUM_END=5, /*  | */
-};
+} MAV_ROI;
 #endif
 
 /** @brief ACK / NACK / ERROR values as a result of MAV_CMDs and for mission item transmission. */
 #ifndef HAVE_ENUM_MAV_CMD_ACK
 #define HAVE_ENUM_MAV_CMD_ACK
-enum MAV_CMD_ACK
+typedef enum MAV_CMD_ACK
 {
 	MAV_CMD_ACK_OK=1, /* Command / mission item is ok. | */
 	MAV_CMD_ACK_ERR_FAIL=2, /* Generic error message if none of the other reasons fails or if no detailed error reporting is implemented. | */
@@ -278,13 +372,32 @@ enum MAV_CMD_ACK
 	MAV_CMD_ACK_ERR_Y_LON_OUT_OF_RANGE=8, /* The Y or longitude value is out of range. | */
 	MAV_CMD_ACK_ERR_Z_ALT_OUT_OF_RANGE=9, /* The Z or altitude value is out of range. | */
 	MAV_CMD_ACK_ENUM_END=10, /*  | */
-};
+} MAV_CMD_ACK;
+#endif
+
+/** @brief Specifies the datatype of a MAVLink parameter. */
+#ifndef HAVE_ENUM_MAV_PARAM_TYPE
+#define HAVE_ENUM_MAV_PARAM_TYPE
+typedef enum MAV_PARAM_TYPE
+{
+	MAV_PARAM_TYPE_UINT8=1, /* 8-bit unsigned integer | */
+	MAV_PARAM_TYPE_INT8=2, /* 8-bit signed integer | */
+	MAV_PARAM_TYPE_UINT16=3, /* 16-bit unsigned integer | */
+	MAV_PARAM_TYPE_INT16=4, /* 16-bit signed integer | */
+	MAV_PARAM_TYPE_UINT32=5, /* 32-bit unsigned integer | */
+	MAV_PARAM_TYPE_INT32=6, /* 32-bit signed integer | */
+	MAV_PARAM_TYPE_UINT64=7, /* 64-bit unsigned integer | */
+	MAV_PARAM_TYPE_INT64=8, /* 64-bit signed integer | */
+	MAV_PARAM_TYPE_REAL32=9, /* 32-bit floating-point | */
+	MAV_PARAM_TYPE_REAL64=10, /* 64-bit floating-point | */
+	MAV_PARAM_TYPE_ENUM_END=11, /*  | */
+} MAV_PARAM_TYPE;
 #endif
 
 /** @brief result from a mavlink command */
 #ifndef HAVE_ENUM_MAV_RESULT
 #define HAVE_ENUM_MAV_RESULT
-enum MAV_RESULT
+typedef enum MAV_RESULT
 {
 	MAV_RESULT_ACCEPTED=0, /* Command ACCEPTED and EXECUTED | */
 	MAV_RESULT_TEMPORARILY_REJECTED=1, /* Command TEMPORARY REJECTED/DENIED | */
@@ -292,13 +405,13 @@ enum MAV_RESULT
 	MAV_RESULT_UNSUPPORTED=3, /* Command UNKNOWN/UNSUPPORTED | */
 	MAV_RESULT_FAILED=4, /* Command executed, but failed | */
 	MAV_RESULT_ENUM_END=5, /*  | */
-};
+} MAV_RESULT;
 #endif
 
 /** @brief result in a mavlink mission ack */
 #ifndef HAVE_ENUM_MAV_MISSION_RESULT
 #define HAVE_ENUM_MAV_MISSION_RESULT
-enum MAV_MISSION_RESULT
+typedef enum MAV_MISSION_RESULT
 {
 	MAV_MISSION_ACCEPTED=0, /* mission accepted OK | */
 	MAV_MISSION_ERROR=1, /* generic error / not accepting mission commands at all right now | */
@@ -316,13 +429,13 @@ enum MAV_MISSION_RESULT
 	MAV_MISSION_INVALID_SEQUENCE=13, /* received waypoint out of sequence | */
 	MAV_MISSION_DENIED=14, /* not accepting any mission commands from this communication partner | */
 	MAV_MISSION_RESULT_ENUM_END=15, /*  | */
-};
+} MAV_MISSION_RESULT;
 #endif
 
 /** @brief Indicates the severity level, generally used for status messages to indicate their relative urgency. Based on RFC-5424 using expanded definitions at: http://www.kiwisyslog.com/kb/info:-syslog-message-levels/. */
 #ifndef HAVE_ENUM_MAV_SEVERITY
 #define HAVE_ENUM_MAV_SEVERITY
-enum MAV_SEVERITY
+typedef enum MAV_SEVERITY
 {
 	MAV_SEVERITY_EMERGENCY=0, /* System is unusable. This is a "panic" condition. | */
 	MAV_SEVERITY_ALERT=1, /* Action should be taken immediately. Indicates error in non-critical systems. | */
@@ -333,7 +446,121 @@ enum MAV_SEVERITY
 	MAV_SEVERITY_INFO=6, /* Normal operational messages. Useful for logging. No action is required for these messages. | */
 	MAV_SEVERITY_DEBUG=7, /* Useful non-operational messages that can assist in debugging. These should not occur during normal operation. | */
 	MAV_SEVERITY_ENUM_END=8, /*  | */
-};
+} MAV_SEVERITY;
+#endif
+
+/** @brief Power supply status flags (bitmask) */
+#ifndef HAVE_ENUM_MAV_POWER_STATUS
+#define HAVE_ENUM_MAV_POWER_STATUS
+typedef enum MAV_POWER_STATUS
+{
+	MAV_POWER_STATUS_BRICK_VALID=1, /* main brick power supply valid | */
+	MAV_POWER_STATUS_SERVO_VALID=2, /* main servo power supply valid for FMU | */
+	MAV_POWER_STATUS_USB_CONNECTED=4, /* USB power is connected | */
+	MAV_POWER_STATUS_PERIPH_OVERCURRENT=8, /* peripheral supply is in over-current state | */
+	MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT=16, /* hi-power peripheral supply is in over-current state | */
+	MAV_POWER_STATUS_CHANGED=32, /* Power status has changed since boot | */
+	MAV_POWER_STATUS_ENUM_END=33, /*  | */
+} MAV_POWER_STATUS;
+#endif
+
+/** @brief SERIAL_CONTROL device types */
+#ifndef HAVE_ENUM_SERIAL_CONTROL_DEV
+#define HAVE_ENUM_SERIAL_CONTROL_DEV
+typedef enum SERIAL_CONTROL_DEV
+{
+	SERIAL_CONTROL_DEV_TELEM1=0, /* First telemetry port | */
+	SERIAL_CONTROL_DEV_TELEM2=1, /* Second telemetry port | */
+	SERIAL_CONTROL_DEV_GPS1=2, /* First GPS port | */
+	SERIAL_CONTROL_DEV_GPS2=3, /* Second GPS port | */
+	SERIAL_CONTROL_DEV_ENUM_END=4, /*  | */
+} SERIAL_CONTROL_DEV;
+#endif
+
+/** @brief SERIAL_CONTROL flags (bitmask) */
+#ifndef HAVE_ENUM_SERIAL_CONTROL_FLAG
+#define HAVE_ENUM_SERIAL_CONTROL_FLAG
+typedef enum SERIAL_CONTROL_FLAG
+{
+	SERIAL_CONTROL_FLAG_REPLY=1, /* Set if this is a reply | */
+	SERIAL_CONTROL_FLAG_RESPOND=2, /* Set if the sender wants the receiver to send a response as another SERIAL_CONTROL message | */
+	SERIAL_CONTROL_FLAG_EXCLUSIVE=4, /* Set if access to the serial port should be removed from whatever driver is currently using it, giving exclusive access to the SERIAL_CONTROL protocol. The port can be handed back by sending a request without this flag set | */
+	SERIAL_CONTROL_FLAG_BLOCKING=8, /* Block on writes to the serial port | */
+	SERIAL_CONTROL_FLAG_MULTI=16, /* Send multiple replies until port is drained | */
+	SERIAL_CONTROL_FLAG_ENUM_END=17, /*  | */
+} SERIAL_CONTROL_FLAG;
+#endif
+
+/** @brief Enumeration of distance sensor types */
+#ifndef HAVE_ENUM_MAV_DISTANCE_SENSOR
+#define HAVE_ENUM_MAV_DISTANCE_SENSOR
+typedef enum MAV_DISTANCE_SENSOR
+{
+	MAV_DISTANCE_SENSOR_LASER=0, /* Laser altimeter, e.g. LightWare SF02/F or PulsedLight units | */
+	MAV_DISTANCE_SENSOR_ULTRASOUND=1, /* Ultrasound altimeter, e.g. MaxBotix units | */
+	MAV_DISTANCE_SENSOR_ENUM_END=2, /*  | */
+} MAV_DISTANCE_SENSOR;
+#endif
+
+/** @brief Bitmask of (optional) autopilot capabilities (64 bit). If a bit is set, the autopilot supports this capability. */
+#ifndef HAVE_ENUM_MAV_PROTOCOL_CAPABILITY
+#define HAVE_ENUM_MAV_PROTOCOL_CAPABILITY
+typedef enum MAV_PROTOCOL_CAPABILITY
+{
+	MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT=1, /* Autopilot supports MISSION float message type. | */
+	MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT=2, /* Autopilot supports the new param float message type. | */
+	MAV_PROTOCOL_CAPABILITY_MISSION_INT=4, /* Autopilot supports MISSION_INT scaled integer message type. | */
+	MAV_PROTOCOL_CAPABILITY_COMMAND_INT=8, /* Autopilot supports COMMAND_INT scaled integer message type. | */
+	MAV_PROTOCOL_CAPABILITY_PARAM_UNION=16, /* Autopilot supports the new param union message type. | */
+	MAV_PROTOCOL_CAPABILITY_FTP=32, /* Autopilot supports the new param union message type. | */
+	MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET=64, /* Autopilot supports commanding attitude offboard. | */
+	MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED=128, /* Autopilot supports commanding position and velocity targets in local NED frame. | */
+	MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT=256, /* Autopilot supports commanding position and velocity targets in global scaled integers. | */
+	MAV_PROTOCOL_CAPABILITY_TERRAIN=512, /* Autopilot supports terrain protocol / data handling. | */
+	MAV_PROTOCOL_CAPABILITY_ENUM_END=513, /*  | */
+} MAV_PROTOCOL_CAPABILITY;
+#endif
+
+/** @brief Enumeration of estimator types */
+#ifndef HAVE_ENUM_MAV_ESTIMATOR_TYPE
+#define HAVE_ENUM_MAV_ESTIMATOR_TYPE
+typedef enum MAV_ESTIMATOR_TYPE
+{
+	MAV_ESTIMATOR_TYPE_NAIVE=1, /* This is a naive estimator without any real covariance feedback. | */
+	MAV_ESTIMATOR_TYPE_VISION=2, /* Computer vision based estimate. Might be up to scale. | */
+	MAV_ESTIMATOR_TYPE_VIO=3, /* Visual-inertial estimate. | */
+	MAV_ESTIMATOR_TYPE_GPS=4, /* Plain GPS estimate. | */
+	MAV_ESTIMATOR_TYPE_GPS_INS=5, /* Estimator integrating GPS and inertial sensing. | */
+	MAV_ESTIMATOR_TYPE_ENUM_END=6, /*  | */
+} MAV_ESTIMATOR_TYPE;
+#endif
+
+/** @brief Enumeration of battery types */
+#ifndef HAVE_ENUM_MAV_BATTERY_TYPE
+#define HAVE_ENUM_MAV_BATTERY_TYPE
+typedef enum MAV_BATTERY_TYPE
+{
+	MAV_BATTERY_TYPE_UNKNOWN=0, /* Not specified. | */
+	MAV_BATTERY_TYPE_LIPO=1, /* Lithium polymere battery | */
+	MAV_BATTERY_TYPE_LIFE=2, /* Lithium ferrite battery | */
+	MAV_BATTERY_TYPE_LION=3, /* Lithium-ION battery | */
+	MAV_BATTERY_TYPE_NIMH=4, /* Nickel metal hydride battery | */
+	MAV_BATTERY_TYPE_ENUM_END=5, /*  | */
+} MAV_BATTERY_TYPE;
+#endif
+
+/** @brief Enumeration of battery functions */
+#ifndef HAVE_ENUM_MAV_BATTERY_FUNCTION
+#define HAVE_ENUM_MAV_BATTERY_FUNCTION
+typedef enum MAV_BATTERY_FUNCTION
+{
+	MAV_BATTERY_FUNCTION_UNKNOWN=0, /* Lithium polymere battery | */
+	MAV_BATTERY_FUNCTION_ALL=1, /* Battery supports all flight systems | */
+	MAV_BATTERY_FUNCTION_PROPULSION=2, /* Battery for the propulsion system | */
+	MAV_BATTERY_FUNCTION_AVIONICS=3, /* Avionics battery | */
+	MAV_BATTERY_TYPE_PAYLOAD=4, /* Payload battery | */
+	MAV_BATTERY_FUNCTION_ENUM_END=5, /*  | */
+} MAV_BATTERY_FUNCTION;
 #endif
 
 
@@ -388,28 +615,30 @@ enum MAV_SEVERITY
 #include "./mavlink_msg_mission_ack.h"
 #include "./mavlink_msg_set_gps_global_origin.h"
 #include "./mavlink_msg_gps_global_origin.h"
-#include "./mavlink_msg_set_local_position_setpoint.h"
-#include "./mavlink_msg_local_position_setpoint.h"
-#include "./mavlink_msg_global_position_setpoint_int.h"
-#include "./mavlink_msg_set_global_position_setpoint_int.h"
+#include "./mavlink_msg_param_map_rc.h"
 #include "./mavlink_msg_safety_set_allowed_area.h"
 #include "./mavlink_msg_safety_allowed_area.h"
-#include "./mavlink_msg_set_roll_pitch_yaw_thrust.h"
-#include "./mavlink_msg_set_roll_pitch_yaw_speed_thrust.h"
-#include "./mavlink_msg_roll_pitch_yaw_thrust_setpoint.h"
-#include "./mavlink_msg_roll_pitch_yaw_speed_thrust_setpoint.h"
-#include "./mavlink_msg_set_quad_motors_setpoint.h"
-#include "./mavlink_msg_set_quad_swarm_roll_pitch_yaw_thrust.h"
+#include "./mavlink_msg_attitude_quaternion_cov.h"
 #include "./mavlink_msg_nav_controller_output.h"
-#include "./mavlink_msg_set_quad_swarm_led_roll_pitch_yaw_thrust.h"
-#include "./mavlink_msg_state_correction.h"
+#include "./mavlink_msg_global_position_int_cov.h"
+#include "./mavlink_msg_local_position_ned_cov.h"
+#include "./mavlink_msg_rc_channels.h"
 #include "./mavlink_msg_request_data_stream.h"
 #include "./mavlink_msg_data_stream.h"
 #include "./mavlink_msg_manual_control.h"
 #include "./mavlink_msg_rc_channels_override.h"
+#include "./mavlink_msg_mission_item_int.h"
 #include "./mavlink_msg_vfr_hud.h"
+#include "./mavlink_msg_command_int.h"
 #include "./mavlink_msg_command_long.h"
 #include "./mavlink_msg_command_ack.h"
+#include "./mavlink_msg_manual_setpoint.h"
+#include "./mavlink_msg_set_attitude_target.h"
+#include "./mavlink_msg_attitude_target.h"
+#include "./mavlink_msg_set_position_target_local_ned.h"
+#include "./mavlink_msg_position_target_local_ned.h"
+#include "./mavlink_msg_set_position_target_global_int.h"
+#include "./mavlink_msg_position_target_global_int.h"
 #include "./mavlink_msg_local_position_ned_system_global_offset.h"
 #include "./mavlink_msg_hil_state.h"
 #include "./mavlink_msg_hil_controls.h"
@@ -419,6 +648,40 @@ enum MAV_SEVERITY
 #include "./mavlink_msg_vision_position_estimate.h"
 #include "./mavlink_msg_vision_speed_estimate.h"
 #include "./mavlink_msg_vicon_position_estimate.h"
+#include "./mavlink_msg_highres_imu.h"
+#include "./mavlink_msg_optical_flow_rad.h"
+#include "./mavlink_msg_hil_sensor.h"
+#include "./mavlink_msg_sim_state.h"
+#include "./mavlink_msg_radio_status.h"
+#include "./mavlink_msg_file_transfer_protocol.h"
+#include "./mavlink_msg_timesync.h"
+#include "./mavlink_msg_hil_gps.h"
+#include "./mavlink_msg_hil_optical_flow.h"
+#include "./mavlink_msg_hil_state_quaternion.h"
+#include "./mavlink_msg_scaled_imu2.h"
+#include "./mavlink_msg_log_request_list.h"
+#include "./mavlink_msg_log_entry.h"
+#include "./mavlink_msg_log_request_data.h"
+#include "./mavlink_msg_log_data.h"
+#include "./mavlink_msg_log_erase.h"
+#include "./mavlink_msg_log_request_end.h"
+#include "./mavlink_msg_gps_inject_data.h"
+#include "./mavlink_msg_gps2_raw.h"
+#include "./mavlink_msg_power_status.h"
+#include "./mavlink_msg_serial_control.h"
+#include "./mavlink_msg_gps_rtk.h"
+#include "./mavlink_msg_gps2_rtk.h"
+#include "./mavlink_msg_data_transmission_handshake.h"
+#include "./mavlink_msg_encapsulated_data.h"
+#include "./mavlink_msg_distance_sensor.h"
+#include "./mavlink_msg_terrain_request.h"
+#include "./mavlink_msg_terrain_data.h"
+#include "./mavlink_msg_terrain_check.h"
+#include "./mavlink_msg_terrain_report.h"
+#include "./mavlink_msg_scaled_pressure2.h"
+#include "./mavlink_msg_battery_status.h"
+#include "./mavlink_msg_autopilot_version.h"
+#include "./mavlink_msg_v2_extension.h"
 #include "./mavlink_msg_memory_vect.h"
 #include "./mavlink_msg_debug_vect.h"
 #include "./mavlink_msg_named_value_float.h"
@@ -429,4 +692,4 @@ enum MAV_SEVERITY
 #ifdef __cplusplus
 }
 #endif // __cplusplus
-#endif // COMMON_H
+#endif // MAVLINK_COMMON_H
diff -BburpN v1.0.old/common/mavlink.h v1.0/common/mavlink.h
--- v1.0.old/common/mavlink.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink.h	2015-02-06 11:50:58.000000000 +0500
@@ -1,6 +1,6 @@
 /** @file
  *	@brief MAVLink comm protocol built from common.xml
- *	@see http://pixhawk.ethz.ch/software/mavlink
+ *	@see http://mavlink.org
  */
 #ifndef MAVLINK_H
 #define MAVLINK_H
diff -BburpN v1.0.old/common/mavlink_msg_attitude.h v1.0/common/mavlink_msg_attitude.h
--- v1.0.old/common/mavlink_msg_attitude.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_attitude.h	2015-02-06 11:50:58.000000000 +0500
@@ -5,9 +5,9 @@
 typedef struct __mavlink_attitude_t
 {
  uint32_t time_boot_ms; ///< Timestamp (milliseconds since system boot)
- float roll; ///< Roll angle (rad)
- float pitch; ///< Pitch angle (rad)
- float yaw; ///< Yaw angle (rad)
+ float roll; ///< Roll angle (rad, -pi..+pi)
+ float pitch; ///< Pitch angle (rad, -pi..+pi)
+ float yaw; ///< Yaw angle (rad, -pi..+pi)
  float rollspeed; ///< Roll angular speed (rad/s)
  float pitchspeed; ///< Pitch angular speed (rad/s)
  float yawspeed; ///< Yaw angular speed (rad/s)
@@ -16,6 +16,9 @@ typedef struct __mavlink_attitude_t
 #define MAVLINK_MSG_ID_ATTITUDE_LEN 28
 #define MAVLINK_MSG_ID_30_LEN 28
 
+#define MAVLINK_MSG_ID_ATTITUDE_CRC 39
+#define MAVLINK_MSG_ID_30_CRC 39
+
 
 
 #define MAVLINK_MESSAGE_INFO_ATTITUDE { \
@@ -39,9 +42,9 @@ typedef struct __mavlink_attitude_t
  * @param msg The MAVLink message to compress the data into
  *
  * @param time_boot_ms Timestamp (milliseconds since system boot)
- * @param roll Roll angle (rad)
- * @param pitch Pitch angle (rad)
- * @param yaw Yaw angle (rad)
+ * @param roll Roll angle (rad, -pi..+pi)
+ * @param pitch Pitch angle (rad, -pi..+pi)
+ * @param yaw Yaw angle (rad, -pi..+pi)
  * @param rollspeed Roll angular speed (rad/s)
  * @param pitchspeed Pitch angular speed (rad/s)
  * @param yawspeed Yaw angular speed (rad/s)
@@ -51,7 +54,7 @@ static inline uint16_t mavlink_msg_attit
 						       uint32_t time_boot_ms, float roll, float pitch, float yaw, float rollspeed, float pitchspeed, float yawspeed)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[28];
+	char buf[MAVLINK_MSG_ID_ATTITUDE_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, roll);
 	_mav_put_float(buf, 8, pitch);
@@ -60,7 +63,7 @@ static inline uint16_t mavlink_msg_attit
 	_mav_put_float(buf, 20, pitchspeed);
 	_mav_put_float(buf, 24, yawspeed);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_ATTITUDE_LEN);
 #else
 	mavlink_attitude_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -71,23 +74,27 @@ static inline uint16_t mavlink_msg_attit
 	packet.pitchspeed = pitchspeed;
 	packet.yawspeed = yawspeed;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_ATTITUDE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_ATTITUDE;
-	return mavlink_finalize_message(msg, system_id, component_id, 28, 39);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_ATTITUDE_LEN, MAVLINK_MSG_ID_ATTITUDE_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_ATTITUDE_LEN);
+#endif
 }
 
 /**
  * @brief Pack a attitude message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_boot_ms Timestamp (milliseconds since system boot)
- * @param roll Roll angle (rad)
- * @param pitch Pitch angle (rad)
- * @param yaw Yaw angle (rad)
+ * @param roll Roll angle (rad, -pi..+pi)
+ * @param pitch Pitch angle (rad, -pi..+pi)
+ * @param yaw Yaw angle (rad, -pi..+pi)
  * @param rollspeed Roll angular speed (rad/s)
  * @param pitchspeed Pitch angular speed (rad/s)
  * @param yawspeed Yaw angular speed (rad/s)
@@ -98,7 +105,7 @@ static inline uint16_t mavlink_msg_attit
 						           uint32_t time_boot_ms,float roll,float pitch,float yaw,float rollspeed,float pitchspeed,float yawspeed)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[28];
+	char buf[MAVLINK_MSG_ID_ATTITUDE_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, roll);
 	_mav_put_float(buf, 8, pitch);
@@ -107,7 +114,7 @@ static inline uint16_t mavlink_msg_attit
 	_mav_put_float(buf, 20, pitchspeed);
 	_mav_put_float(buf, 24, yawspeed);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_ATTITUDE_LEN);
 #else
 	mavlink_attitude_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -118,15 +125,19 @@ static inline uint16_t mavlink_msg_attit
 	packet.pitchspeed = pitchspeed;
 	packet.yawspeed = yawspeed;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_ATTITUDE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_ATTITUDE;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 28, 39);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_ATTITUDE_LEN, MAVLINK_MSG_ID_ATTITUDE_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_ATTITUDE_LEN);
+#endif
 }
 
 /**
- * @brief Encode a attitude struct into a message
+ * @brief Encode a attitude struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -139,13 +150,27 @@ static inline uint16_t mavlink_msg_attit
 }
 
 /**
+ * @brief Encode a attitude struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param attitude C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_attitude_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_attitude_t* attitude)
+{
+	return mavlink_msg_attitude_pack_chan(system_id, component_id, chan, msg, attitude->time_boot_ms, attitude->roll, attitude->pitch, attitude->yaw, attitude->rollspeed, attitude->pitchspeed, attitude->yawspeed);
+}
+
+/**
  * @brief Send a attitude message
  * @param chan MAVLink channel to send the message
  *
  * @param time_boot_ms Timestamp (milliseconds since system boot)
- * @param roll Roll angle (rad)
- * @param pitch Pitch angle (rad)
- * @param yaw Yaw angle (rad)
+ * @param roll Roll angle (rad, -pi..+pi)
+ * @param pitch Pitch angle (rad, -pi..+pi)
+ * @param yaw Yaw angle (rad, -pi..+pi)
  * @param rollspeed Roll angular speed (rad/s)
  * @param pitchspeed Pitch angular speed (rad/s)
  * @param yawspeed Yaw angular speed (rad/s)
@@ -155,7 +180,7 @@ static inline uint16_t mavlink_msg_attit
 static inline void mavlink_msg_attitude_send(mavlink_channel_t chan, uint32_t time_boot_ms, float roll, float pitch, float yaw, float rollspeed, float pitchspeed, float yawspeed)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[28];
+	char buf[MAVLINK_MSG_ID_ATTITUDE_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, roll);
 	_mav_put_float(buf, 8, pitch);
@@ -164,7 +189,11 @@ static inline void mavlink_msg_attitude_
 	_mav_put_float(buf, 20, pitchspeed);
 	_mav_put_float(buf, 24, yawspeed);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE, buf, 28, 39);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE, buf, MAVLINK_MSG_ID_ATTITUDE_LEN, MAVLINK_MSG_ID_ATTITUDE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE, buf, MAVLINK_MSG_ID_ATTITUDE_LEN);
+#endif
 #else
 	mavlink_attitude_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -175,9 +204,57 @@ static inline void mavlink_msg_attitude_
 	packet.pitchspeed = pitchspeed;
 	packet.yawspeed = yawspeed;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE, (const char *)&packet, 28, 39);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE, (const char *)&packet, MAVLINK_MSG_ID_ATTITUDE_LEN, MAVLINK_MSG_ID_ATTITUDE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE, (const char *)&packet, MAVLINK_MSG_ID_ATTITUDE_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_ATTITUDE_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_attitude_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, float roll, float pitch, float yaw, float rollspeed, float pitchspeed, float yawspeed)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, roll);
+	_mav_put_float(buf, 8, pitch);
+	_mav_put_float(buf, 12, yaw);
+	_mav_put_float(buf, 16, rollspeed);
+	_mav_put_float(buf, 20, pitchspeed);
+	_mav_put_float(buf, 24, yawspeed);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE, buf, MAVLINK_MSG_ID_ATTITUDE_LEN, MAVLINK_MSG_ID_ATTITUDE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE, buf, MAVLINK_MSG_ID_ATTITUDE_LEN);
+#endif
+#else
+	mavlink_attitude_t *packet = (mavlink_attitude_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->roll = roll;
+	packet->pitch = pitch;
+	packet->yaw = yaw;
+	packet->rollspeed = rollspeed;
+	packet->pitchspeed = pitchspeed;
+	packet->yawspeed = yawspeed;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE, (const char *)packet, MAVLINK_MSG_ID_ATTITUDE_LEN, MAVLINK_MSG_ID_ATTITUDE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE, (const char *)packet, MAVLINK_MSG_ID_ATTITUDE_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -197,7 +274,7 @@ static inline uint32_t mavlink_msg_attit
 /**
  * @brief Get field roll from attitude message
  *
- * @return Roll angle (rad)
+ * @return Roll angle (rad, -pi..+pi)
  */
 static inline float mavlink_msg_attitude_get_roll(const mavlink_message_t* msg)
 {
@@ -207,7 +284,7 @@ static inline float mavlink_msg_attitude
 /**
  * @brief Get field pitch from attitude message
  *
- * @return Pitch angle (rad)
+ * @return Pitch angle (rad, -pi..+pi)
  */
 static inline float mavlink_msg_attitude_get_pitch(const mavlink_message_t* msg)
 {
@@ -217,7 +294,7 @@ static inline float mavlink_msg_attitude
 /**
  * @brief Get field yaw from attitude message
  *
- * @return Yaw angle (rad)
+ * @return Yaw angle (rad, -pi..+pi)
  */
 static inline float mavlink_msg_attitude_get_yaw(const mavlink_message_t* msg)
 {
@@ -271,6 +348,6 @@ static inline void mavlink_msg_attitude_
 	attitude->pitchspeed = mavlink_msg_attitude_get_pitchspeed(msg);
 	attitude->yawspeed = mavlink_msg_attitude_get_yawspeed(msg);
 #else
-	memcpy(attitude, _MAV_PAYLOAD(msg), 28);
+	memcpy(attitude, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_ATTITUDE_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_attitude_quaternion_cov.h v1.0/common/mavlink_msg_attitude_quaternion_cov.h
--- v1.0.old/common/mavlink_msg_attitude_quaternion_cov.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_attitude_quaternion_cov.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,322 @@
+// MESSAGE ATTITUDE_QUATERNION_COV PACKING
+
+#define MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV 61
+
+typedef struct __mavlink_attitude_quaternion_cov_t
+{
+ uint32_t time_boot_ms; ///< Timestamp (milliseconds since system boot)
+ float q[4]; ///< Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)
+ float rollspeed; ///< Roll angular speed (rad/s)
+ float pitchspeed; ///< Pitch angular speed (rad/s)
+ float yawspeed; ///< Yaw angular speed (rad/s)
+ float covariance[9]; ///< Attitude covariance
+} mavlink_attitude_quaternion_cov_t;
+
+#define MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN 68
+#define MAVLINK_MSG_ID_61_LEN 68
+
+#define MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_CRC 153
+#define MAVLINK_MSG_ID_61_CRC 153
+
+#define MAVLINK_MSG_ATTITUDE_QUATERNION_COV_FIELD_Q_LEN 4
+#define MAVLINK_MSG_ATTITUDE_QUATERNION_COV_FIELD_COVARIANCE_LEN 9
+
+#define MAVLINK_MESSAGE_INFO_ATTITUDE_QUATERNION_COV { \
+	"ATTITUDE_QUATERNION_COV", \
+	6, \
+	{  { "time_boot_ms", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_attitude_quaternion_cov_t, time_boot_ms) }, \
+         { "q", NULL, MAVLINK_TYPE_FLOAT, 4, 4, offsetof(mavlink_attitude_quaternion_cov_t, q) }, \
+         { "rollspeed", NULL, MAVLINK_TYPE_FLOAT, 0, 20, offsetof(mavlink_attitude_quaternion_cov_t, rollspeed) }, \
+         { "pitchspeed", NULL, MAVLINK_TYPE_FLOAT, 0, 24, offsetof(mavlink_attitude_quaternion_cov_t, pitchspeed) }, \
+         { "yawspeed", NULL, MAVLINK_TYPE_FLOAT, 0, 28, offsetof(mavlink_attitude_quaternion_cov_t, yawspeed) }, \
+         { "covariance", NULL, MAVLINK_TYPE_FLOAT, 9, 32, offsetof(mavlink_attitude_quaternion_cov_t, covariance) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a attitude_quaternion_cov message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param q Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)
+ * @param rollspeed Roll angular speed (rad/s)
+ * @param pitchspeed Pitch angular speed (rad/s)
+ * @param yawspeed Yaw angular speed (rad/s)
+ * @param covariance Attitude covariance
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_attitude_quaternion_cov_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint32_t time_boot_ms, const float *q, float rollspeed, float pitchspeed, float yawspeed, const float *covariance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 20, rollspeed);
+	_mav_put_float(buf, 24, pitchspeed);
+	_mav_put_float(buf, 28, yawspeed);
+	_mav_put_float_array(buf, 4, q, 4);
+	_mav_put_float_array(buf, 32, covariance, 9);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN);
+#else
+	mavlink_attitude_quaternion_cov_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.rollspeed = rollspeed;
+	packet.pitchspeed = pitchspeed;
+	packet.yawspeed = yawspeed;
+	mav_array_memcpy(packet.q, q, sizeof(float)*4);
+	mav_array_memcpy(packet.covariance, covariance, sizeof(float)*9);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a attitude_quaternion_cov message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param q Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)
+ * @param rollspeed Roll angular speed (rad/s)
+ * @param pitchspeed Pitch angular speed (rad/s)
+ * @param yawspeed Yaw angular speed (rad/s)
+ * @param covariance Attitude covariance
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_attitude_quaternion_cov_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint32_t time_boot_ms,const float *q,float rollspeed,float pitchspeed,float yawspeed,const float *covariance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 20, rollspeed);
+	_mav_put_float(buf, 24, pitchspeed);
+	_mav_put_float(buf, 28, yawspeed);
+	_mav_put_float_array(buf, 4, q, 4);
+	_mav_put_float_array(buf, 32, covariance, 9);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN);
+#else
+	mavlink_attitude_quaternion_cov_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.rollspeed = rollspeed;
+	packet.pitchspeed = pitchspeed;
+	packet.yawspeed = yawspeed;
+	mav_array_memcpy(packet.q, q, sizeof(float)*4);
+	mav_array_memcpy(packet.covariance, covariance, sizeof(float)*9);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a attitude_quaternion_cov struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param attitude_quaternion_cov C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_attitude_quaternion_cov_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_attitude_quaternion_cov_t* attitude_quaternion_cov)
+{
+	return mavlink_msg_attitude_quaternion_cov_pack(system_id, component_id, msg, attitude_quaternion_cov->time_boot_ms, attitude_quaternion_cov->q, attitude_quaternion_cov->rollspeed, attitude_quaternion_cov->pitchspeed, attitude_quaternion_cov->yawspeed, attitude_quaternion_cov->covariance);
+}
+
+/**
+ * @brief Encode a attitude_quaternion_cov struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param attitude_quaternion_cov C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_attitude_quaternion_cov_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_attitude_quaternion_cov_t* attitude_quaternion_cov)
+{
+	return mavlink_msg_attitude_quaternion_cov_pack_chan(system_id, component_id, chan, msg, attitude_quaternion_cov->time_boot_ms, attitude_quaternion_cov->q, attitude_quaternion_cov->rollspeed, attitude_quaternion_cov->pitchspeed, attitude_quaternion_cov->yawspeed, attitude_quaternion_cov->covariance);
+}
+
+/**
+ * @brief Send a attitude_quaternion_cov message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param q Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)
+ * @param rollspeed Roll angular speed (rad/s)
+ * @param pitchspeed Pitch angular speed (rad/s)
+ * @param yawspeed Yaw angular speed (rad/s)
+ * @param covariance Attitude covariance
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_attitude_quaternion_cov_send(mavlink_channel_t chan, uint32_t time_boot_ms, const float *q, float rollspeed, float pitchspeed, float yawspeed, const float *covariance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 20, rollspeed);
+	_mav_put_float(buf, 24, pitchspeed);
+	_mav_put_float(buf, 28, yawspeed);
+	_mav_put_float_array(buf, 4, q, 4);
+	_mav_put_float_array(buf, 32, covariance, 9);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV, buf, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV, buf, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN);
+#endif
+#else
+	mavlink_attitude_quaternion_cov_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.rollspeed = rollspeed;
+	packet.pitchspeed = pitchspeed;
+	packet.yawspeed = yawspeed;
+	mav_array_memcpy(packet.q, q, sizeof(float)*4);
+	mav_array_memcpy(packet.covariance, covariance, sizeof(float)*9);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV, (const char *)&packet, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV, (const char *)&packet, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_attitude_quaternion_cov_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, const float *q, float rollspeed, float pitchspeed, float yawspeed, const float *covariance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 20, rollspeed);
+	_mav_put_float(buf, 24, pitchspeed);
+	_mav_put_float(buf, 28, yawspeed);
+	_mav_put_float_array(buf, 4, q, 4);
+	_mav_put_float_array(buf, 32, covariance, 9);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV, buf, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV, buf, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN);
+#endif
+#else
+	mavlink_attitude_quaternion_cov_t *packet = (mavlink_attitude_quaternion_cov_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->rollspeed = rollspeed;
+	packet->pitchspeed = pitchspeed;
+	packet->yawspeed = yawspeed;
+	mav_array_memcpy(packet->q, q, sizeof(float)*4);
+	mav_array_memcpy(packet->covariance, covariance, sizeof(float)*9);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV, (const char *)packet, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV, (const char *)packet, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE ATTITUDE_QUATERNION_COV UNPACKING
+
+
+/**
+ * @brief Get field time_boot_ms from attitude_quaternion_cov message
+ *
+ * @return Timestamp (milliseconds since system boot)
+ */
+static inline uint32_t mavlink_msg_attitude_quaternion_cov_get_time_boot_ms(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field q from attitude_quaternion_cov message
+ *
+ * @return Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)
+ */
+static inline uint16_t mavlink_msg_attitude_quaternion_cov_get_q(const mavlink_message_t* msg, float *q)
+{
+	return _MAV_RETURN_float_array(msg, q, 4,  4);
+}
+
+/**
+ * @brief Get field rollspeed from attitude_quaternion_cov message
+ *
+ * @return Roll angular speed (rad/s)
+ */
+static inline float mavlink_msg_attitude_quaternion_cov_get_rollspeed(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  20);
+}
+
+/**
+ * @brief Get field pitchspeed from attitude_quaternion_cov message
+ *
+ * @return Pitch angular speed (rad/s)
+ */
+static inline float mavlink_msg_attitude_quaternion_cov_get_pitchspeed(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  24);
+}
+
+/**
+ * @brief Get field yawspeed from attitude_quaternion_cov message
+ *
+ * @return Yaw angular speed (rad/s)
+ */
+static inline float mavlink_msg_attitude_quaternion_cov_get_yawspeed(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  28);
+}
+
+/**
+ * @brief Get field covariance from attitude_quaternion_cov message
+ *
+ * @return Attitude covariance
+ */
+static inline uint16_t mavlink_msg_attitude_quaternion_cov_get_covariance(const mavlink_message_t* msg, float *covariance)
+{
+	return _MAV_RETURN_float_array(msg, covariance, 9,  32);
+}
+
+/**
+ * @brief Decode a attitude_quaternion_cov message into a struct
+ *
+ * @param msg The message to decode
+ * @param attitude_quaternion_cov C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_attitude_quaternion_cov_decode(const mavlink_message_t* msg, mavlink_attitude_quaternion_cov_t* attitude_quaternion_cov)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	attitude_quaternion_cov->time_boot_ms = mavlink_msg_attitude_quaternion_cov_get_time_boot_ms(msg);
+	mavlink_msg_attitude_quaternion_cov_get_q(msg, attitude_quaternion_cov->q);
+	attitude_quaternion_cov->rollspeed = mavlink_msg_attitude_quaternion_cov_get_rollspeed(msg);
+	attitude_quaternion_cov->pitchspeed = mavlink_msg_attitude_quaternion_cov_get_pitchspeed(msg);
+	attitude_quaternion_cov->yawspeed = mavlink_msg_attitude_quaternion_cov_get_yawspeed(msg);
+	mavlink_msg_attitude_quaternion_cov_get_covariance(msg, attitude_quaternion_cov->covariance);
+#else
+	memcpy(attitude_quaternion_cov, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_attitude_quaternion.h v1.0/common/mavlink_msg_attitude_quaternion.h
--- v1.0.old/common/mavlink_msg_attitude_quaternion.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_attitude_quaternion.h	2015-02-06 11:50:58.000000000 +0500
@@ -5,10 +5,10 @@
 typedef struct __mavlink_attitude_quaternion_t
 {
  uint32_t time_boot_ms; ///< Timestamp (milliseconds since system boot)
- float q1; ///< Quaternion component 1
- float q2; ///< Quaternion component 2
- float q3; ///< Quaternion component 3
- float q4; ///< Quaternion component 4
+ float q1; ///< Quaternion component 1, w (1 in null-rotation)
+ float q2; ///< Quaternion component 2, x (0 in null-rotation)
+ float q3; ///< Quaternion component 3, y (0 in null-rotation)
+ float q4; ///< Quaternion component 4, z (0 in null-rotation)
  float rollspeed; ///< Roll angular speed (rad/s)
  float pitchspeed; ///< Pitch angular speed (rad/s)
  float yawspeed; ///< Yaw angular speed (rad/s)
@@ -17,6 +17,9 @@ typedef struct __mavlink_attitude_quater
 #define MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN 32
 #define MAVLINK_MSG_ID_31_LEN 32
 
+#define MAVLINK_MSG_ID_ATTITUDE_QUATERNION_CRC 246
+#define MAVLINK_MSG_ID_31_CRC 246
+
 
 
 #define MAVLINK_MESSAGE_INFO_ATTITUDE_QUATERNION { \
@@ -41,10 +44,10 @@ typedef struct __mavlink_attitude_quater
  * @param msg The MAVLink message to compress the data into
  *
  * @param time_boot_ms Timestamp (milliseconds since system boot)
- * @param q1 Quaternion component 1
- * @param q2 Quaternion component 2
- * @param q3 Quaternion component 3
- * @param q4 Quaternion component 4
+ * @param q1 Quaternion component 1, w (1 in null-rotation)
+ * @param q2 Quaternion component 2, x (0 in null-rotation)
+ * @param q3 Quaternion component 3, y (0 in null-rotation)
+ * @param q4 Quaternion component 4, z (0 in null-rotation)
  * @param rollspeed Roll angular speed (rad/s)
  * @param pitchspeed Pitch angular speed (rad/s)
  * @param yawspeed Yaw angular speed (rad/s)
@@ -54,7 +57,7 @@ static inline uint16_t mavlink_msg_attit
 						       uint32_t time_boot_ms, float q1, float q2, float q3, float q4, float rollspeed, float pitchspeed, float yawspeed)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[32];
+	char buf[MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, q1);
 	_mav_put_float(buf, 8, q2);
@@ -64,7 +67,7 @@ static inline uint16_t mavlink_msg_attit
 	_mav_put_float(buf, 24, pitchspeed);
 	_mav_put_float(buf, 28, yawspeed);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN);
 #else
 	mavlink_attitude_quaternion_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -76,24 +79,28 @@ static inline uint16_t mavlink_msg_attit
 	packet.pitchspeed = pitchspeed;
 	packet.yawspeed = yawspeed;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_ATTITUDE_QUATERNION;
-	return mavlink_finalize_message(msg, system_id, component_id, 32, 246);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN);
+#endif
 }
 
 /**
  * @brief Pack a attitude_quaternion message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_boot_ms Timestamp (milliseconds since system boot)
- * @param q1 Quaternion component 1
- * @param q2 Quaternion component 2
- * @param q3 Quaternion component 3
- * @param q4 Quaternion component 4
+ * @param q1 Quaternion component 1, w (1 in null-rotation)
+ * @param q2 Quaternion component 2, x (0 in null-rotation)
+ * @param q3 Quaternion component 3, y (0 in null-rotation)
+ * @param q4 Quaternion component 4, z (0 in null-rotation)
  * @param rollspeed Roll angular speed (rad/s)
  * @param pitchspeed Pitch angular speed (rad/s)
  * @param yawspeed Yaw angular speed (rad/s)
@@ -104,7 +111,7 @@ static inline uint16_t mavlink_msg_attit
 						           uint32_t time_boot_ms,float q1,float q2,float q3,float q4,float rollspeed,float pitchspeed,float yawspeed)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[32];
+	char buf[MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, q1);
 	_mav_put_float(buf, 8, q2);
@@ -114,7 +121,7 @@ static inline uint16_t mavlink_msg_attit
 	_mav_put_float(buf, 24, pitchspeed);
 	_mav_put_float(buf, 28, yawspeed);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN);
 #else
 	mavlink_attitude_quaternion_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -126,15 +133,19 @@ static inline uint16_t mavlink_msg_attit
 	packet.pitchspeed = pitchspeed;
 	packet.yawspeed = yawspeed;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_ATTITUDE_QUATERNION;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 32, 246);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN);
+#endif
 }
 
 /**
- * @brief Encode a attitude_quaternion struct into a message
+ * @brief Encode a attitude_quaternion struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -147,14 +158,28 @@ static inline uint16_t mavlink_msg_attit
 }
 
 /**
+ * @brief Encode a attitude_quaternion struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param attitude_quaternion C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_attitude_quaternion_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_attitude_quaternion_t* attitude_quaternion)
+{
+	return mavlink_msg_attitude_quaternion_pack_chan(system_id, component_id, chan, msg, attitude_quaternion->time_boot_ms, attitude_quaternion->q1, attitude_quaternion->q2, attitude_quaternion->q3, attitude_quaternion->q4, attitude_quaternion->rollspeed, attitude_quaternion->pitchspeed, attitude_quaternion->yawspeed);
+}
+
+/**
  * @brief Send a attitude_quaternion message
  * @param chan MAVLink channel to send the message
  *
  * @param time_boot_ms Timestamp (milliseconds since system boot)
- * @param q1 Quaternion component 1
- * @param q2 Quaternion component 2
- * @param q3 Quaternion component 3
- * @param q4 Quaternion component 4
+ * @param q1 Quaternion component 1, w (1 in null-rotation)
+ * @param q2 Quaternion component 2, x (0 in null-rotation)
+ * @param q3 Quaternion component 3, y (0 in null-rotation)
+ * @param q4 Quaternion component 4, z (0 in null-rotation)
  * @param rollspeed Roll angular speed (rad/s)
  * @param pitchspeed Pitch angular speed (rad/s)
  * @param yawspeed Yaw angular speed (rad/s)
@@ -164,7 +189,7 @@ static inline uint16_t mavlink_msg_attit
 static inline void mavlink_msg_attitude_quaternion_send(mavlink_channel_t chan, uint32_t time_boot_ms, float q1, float q2, float q3, float q4, float rollspeed, float pitchspeed, float yawspeed)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[32];
+	char buf[MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, q1);
 	_mav_put_float(buf, 8, q2);
@@ -174,7 +199,11 @@ static inline void mavlink_msg_attitude_
 	_mav_put_float(buf, 24, pitchspeed);
 	_mav_put_float(buf, 28, yawspeed);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION, buf, 32, 246);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION, buf, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION, buf, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN);
+#endif
 #else
 	mavlink_attitude_quaternion_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -186,10 +215,60 @@ static inline void mavlink_msg_attitude_
 	packet.pitchspeed = pitchspeed;
 	packet.yawspeed = yawspeed;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION, (const char *)&packet, 32, 246);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION, (const char *)&packet, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION, (const char *)&packet, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_attitude_quaternion_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, float q1, float q2, float q3, float q4, float rollspeed, float pitchspeed, float yawspeed)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, q1);
+	_mav_put_float(buf, 8, q2);
+	_mav_put_float(buf, 12, q3);
+	_mav_put_float(buf, 16, q4);
+	_mav_put_float(buf, 20, rollspeed);
+	_mav_put_float(buf, 24, pitchspeed);
+	_mav_put_float(buf, 28, yawspeed);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION, buf, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION, buf, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN);
+#endif
+#else
+	mavlink_attitude_quaternion_t *packet = (mavlink_attitude_quaternion_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->q1 = q1;
+	packet->q2 = q2;
+	packet->q3 = q3;
+	packet->q4 = q4;
+	packet->rollspeed = rollspeed;
+	packet->pitchspeed = pitchspeed;
+	packet->yawspeed = yawspeed;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION, (const char *)packet, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_QUATERNION, (const char *)packet, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE ATTITUDE_QUATERNION UNPACKING
@@ -208,7 +287,7 @@ static inline uint32_t mavlink_msg_attit
 /**
  * @brief Get field q1 from attitude_quaternion message
  *
- * @return Quaternion component 1
+ * @return Quaternion component 1, w (1 in null-rotation)
  */
 static inline float mavlink_msg_attitude_quaternion_get_q1(const mavlink_message_t* msg)
 {
@@ -218,7 +297,7 @@ static inline float mavlink_msg_attitude
 /**
  * @brief Get field q2 from attitude_quaternion message
  *
- * @return Quaternion component 2
+ * @return Quaternion component 2, x (0 in null-rotation)
  */
 static inline float mavlink_msg_attitude_quaternion_get_q2(const mavlink_message_t* msg)
 {
@@ -228,7 +307,7 @@ static inline float mavlink_msg_attitude
 /**
  * @brief Get field q3 from attitude_quaternion message
  *
- * @return Quaternion component 3
+ * @return Quaternion component 3, y (0 in null-rotation)
  */
 static inline float mavlink_msg_attitude_quaternion_get_q3(const mavlink_message_t* msg)
 {
@@ -238,7 +317,7 @@ static inline float mavlink_msg_attitude
 /**
  * @brief Get field q4 from attitude_quaternion message
  *
- * @return Quaternion component 4
+ * @return Quaternion component 4, z (0 in null-rotation)
  */
 static inline float mavlink_msg_attitude_quaternion_get_q4(const mavlink_message_t* msg)
 {
@@ -293,6 +372,6 @@ static inline void mavlink_msg_attitude_
 	attitude_quaternion->pitchspeed = mavlink_msg_attitude_quaternion_get_pitchspeed(msg);
 	attitude_quaternion->yawspeed = mavlink_msg_attitude_quaternion_get_yawspeed(msg);
 #else
-	memcpy(attitude_quaternion, _MAV_PAYLOAD(msg), 32);
+	memcpy(attitude_quaternion, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_attitude_target.h v1.0/common/mavlink_msg_attitude_target.h
--- v1.0.old/common/mavlink_msg_attitude_target.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_attitude_target.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,345 @@
+// MESSAGE ATTITUDE_TARGET PACKING
+
+#define MAVLINK_MSG_ID_ATTITUDE_TARGET 83
+
+typedef struct __mavlink_attitude_target_t
+{
+ uint32_t time_boot_ms; ///< Timestamp in milliseconds since system boot
+ float q[4]; ///< Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
+ float body_roll_rate; ///< Body roll rate in radians per second
+ float body_pitch_rate; ///< Body roll rate in radians per second
+ float body_yaw_rate; ///< Body roll rate in radians per second
+ float thrust; ///< Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
+ uint8_t type_mask; ///< Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude
+} mavlink_attitude_target_t;
+
+#define MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN 37
+#define MAVLINK_MSG_ID_83_LEN 37
+
+#define MAVLINK_MSG_ID_ATTITUDE_TARGET_CRC 22
+#define MAVLINK_MSG_ID_83_CRC 22
+
+#define MAVLINK_MSG_ATTITUDE_TARGET_FIELD_Q_LEN 4
+
+#define MAVLINK_MESSAGE_INFO_ATTITUDE_TARGET { \
+	"ATTITUDE_TARGET", \
+	7, \
+	{  { "time_boot_ms", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_attitude_target_t, time_boot_ms) }, \
+         { "q", NULL, MAVLINK_TYPE_FLOAT, 4, 4, offsetof(mavlink_attitude_target_t, q) }, \
+         { "body_roll_rate", NULL, MAVLINK_TYPE_FLOAT, 0, 20, offsetof(mavlink_attitude_target_t, body_roll_rate) }, \
+         { "body_pitch_rate", NULL, MAVLINK_TYPE_FLOAT, 0, 24, offsetof(mavlink_attitude_target_t, body_pitch_rate) }, \
+         { "body_yaw_rate", NULL, MAVLINK_TYPE_FLOAT, 0, 28, offsetof(mavlink_attitude_target_t, body_yaw_rate) }, \
+         { "thrust", NULL, MAVLINK_TYPE_FLOAT, 0, 32, offsetof(mavlink_attitude_target_t, thrust) }, \
+         { "type_mask", NULL, MAVLINK_TYPE_UINT8_T, 0, 36, offsetof(mavlink_attitude_target_t, type_mask) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a attitude_target message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_boot_ms Timestamp in milliseconds since system boot
+ * @param type_mask Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude
+ * @param q Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
+ * @param body_roll_rate Body roll rate in radians per second
+ * @param body_pitch_rate Body roll rate in radians per second
+ * @param body_yaw_rate Body roll rate in radians per second
+ * @param thrust Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_attitude_target_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint32_t time_boot_ms, uint8_t type_mask, const float *q, float body_roll_rate, float body_pitch_rate, float body_yaw_rate, float thrust)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 20, body_roll_rate);
+	_mav_put_float(buf, 24, body_pitch_rate);
+	_mav_put_float(buf, 28, body_yaw_rate);
+	_mav_put_float(buf, 32, thrust);
+	_mav_put_uint8_t(buf, 36, type_mask);
+	_mav_put_float_array(buf, 4, q, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN);
+#else
+	mavlink_attitude_target_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.body_roll_rate = body_roll_rate;
+	packet.body_pitch_rate = body_pitch_rate;
+	packet.body_yaw_rate = body_yaw_rate;
+	packet.thrust = thrust;
+	packet.type_mask = type_mask;
+	mav_array_memcpy(packet.q, q, sizeof(float)*4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_ATTITUDE_TARGET;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN, MAVLINK_MSG_ID_ATTITUDE_TARGET_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a attitude_target message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_boot_ms Timestamp in milliseconds since system boot
+ * @param type_mask Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude
+ * @param q Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
+ * @param body_roll_rate Body roll rate in radians per second
+ * @param body_pitch_rate Body roll rate in radians per second
+ * @param body_yaw_rate Body roll rate in radians per second
+ * @param thrust Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_attitude_target_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint32_t time_boot_ms,uint8_t type_mask,const float *q,float body_roll_rate,float body_pitch_rate,float body_yaw_rate,float thrust)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 20, body_roll_rate);
+	_mav_put_float(buf, 24, body_pitch_rate);
+	_mav_put_float(buf, 28, body_yaw_rate);
+	_mav_put_float(buf, 32, thrust);
+	_mav_put_uint8_t(buf, 36, type_mask);
+	_mav_put_float_array(buf, 4, q, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN);
+#else
+	mavlink_attitude_target_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.body_roll_rate = body_roll_rate;
+	packet.body_pitch_rate = body_pitch_rate;
+	packet.body_yaw_rate = body_yaw_rate;
+	packet.thrust = thrust;
+	packet.type_mask = type_mask;
+	mav_array_memcpy(packet.q, q, sizeof(float)*4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_ATTITUDE_TARGET;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN, MAVLINK_MSG_ID_ATTITUDE_TARGET_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a attitude_target struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param attitude_target C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_attitude_target_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_attitude_target_t* attitude_target)
+{
+	return mavlink_msg_attitude_target_pack(system_id, component_id, msg, attitude_target->time_boot_ms, attitude_target->type_mask, attitude_target->q, attitude_target->body_roll_rate, attitude_target->body_pitch_rate, attitude_target->body_yaw_rate, attitude_target->thrust);
+}
+
+/**
+ * @brief Encode a attitude_target struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param attitude_target C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_attitude_target_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_attitude_target_t* attitude_target)
+{
+	return mavlink_msg_attitude_target_pack_chan(system_id, component_id, chan, msg, attitude_target->time_boot_ms, attitude_target->type_mask, attitude_target->q, attitude_target->body_roll_rate, attitude_target->body_pitch_rate, attitude_target->body_yaw_rate, attitude_target->thrust);
+}
+
+/**
+ * @brief Send a attitude_target message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_boot_ms Timestamp in milliseconds since system boot
+ * @param type_mask Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude
+ * @param q Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
+ * @param body_roll_rate Body roll rate in radians per second
+ * @param body_pitch_rate Body roll rate in radians per second
+ * @param body_yaw_rate Body roll rate in radians per second
+ * @param thrust Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_attitude_target_send(mavlink_channel_t chan, uint32_t time_boot_ms, uint8_t type_mask, const float *q, float body_roll_rate, float body_pitch_rate, float body_yaw_rate, float thrust)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 20, body_roll_rate);
+	_mav_put_float(buf, 24, body_pitch_rate);
+	_mav_put_float(buf, 28, body_yaw_rate);
+	_mav_put_float(buf, 32, thrust);
+	_mav_put_uint8_t(buf, 36, type_mask);
+	_mav_put_float_array(buf, 4, q, 4);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_TARGET, buf, MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN, MAVLINK_MSG_ID_ATTITUDE_TARGET_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_TARGET, buf, MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN);
+#endif
+#else
+	mavlink_attitude_target_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.body_roll_rate = body_roll_rate;
+	packet.body_pitch_rate = body_pitch_rate;
+	packet.body_yaw_rate = body_yaw_rate;
+	packet.thrust = thrust;
+	packet.type_mask = type_mask;
+	mav_array_memcpy(packet.q, q, sizeof(float)*4);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_TARGET, (const char *)&packet, MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN, MAVLINK_MSG_ID_ATTITUDE_TARGET_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_TARGET, (const char *)&packet, MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_attitude_target_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, uint8_t type_mask, const float *q, float body_roll_rate, float body_pitch_rate, float body_yaw_rate, float thrust)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 20, body_roll_rate);
+	_mav_put_float(buf, 24, body_pitch_rate);
+	_mav_put_float(buf, 28, body_yaw_rate);
+	_mav_put_float(buf, 32, thrust);
+	_mav_put_uint8_t(buf, 36, type_mask);
+	_mav_put_float_array(buf, 4, q, 4);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_TARGET, buf, MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN, MAVLINK_MSG_ID_ATTITUDE_TARGET_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_TARGET, buf, MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN);
+#endif
+#else
+	mavlink_attitude_target_t *packet = (mavlink_attitude_target_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->body_roll_rate = body_roll_rate;
+	packet->body_pitch_rate = body_pitch_rate;
+	packet->body_yaw_rate = body_yaw_rate;
+	packet->thrust = thrust;
+	packet->type_mask = type_mask;
+	mav_array_memcpy(packet->q, q, sizeof(float)*4);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_TARGET, (const char *)packet, MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN, MAVLINK_MSG_ID_ATTITUDE_TARGET_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ATTITUDE_TARGET, (const char *)packet, MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE ATTITUDE_TARGET UNPACKING
+
+
+/**
+ * @brief Get field time_boot_ms from attitude_target message
+ *
+ * @return Timestamp in milliseconds since system boot
+ */
+static inline uint32_t mavlink_msg_attitude_target_get_time_boot_ms(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field type_mask from attitude_target message
+ *
+ * @return Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude
+ */
+static inline uint8_t mavlink_msg_attitude_target_get_type_mask(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  36);
+}
+
+/**
+ * @brief Get field q from attitude_target message
+ *
+ * @return Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
+ */
+static inline uint16_t mavlink_msg_attitude_target_get_q(const mavlink_message_t* msg, float *q)
+{
+	return _MAV_RETURN_float_array(msg, q, 4,  4);
+}
+
+/**
+ * @brief Get field body_roll_rate from attitude_target message
+ *
+ * @return Body roll rate in radians per second
+ */
+static inline float mavlink_msg_attitude_target_get_body_roll_rate(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  20);
+}
+
+/**
+ * @brief Get field body_pitch_rate from attitude_target message
+ *
+ * @return Body roll rate in radians per second
+ */
+static inline float mavlink_msg_attitude_target_get_body_pitch_rate(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  24);
+}
+
+/**
+ * @brief Get field body_yaw_rate from attitude_target message
+ *
+ * @return Body roll rate in radians per second
+ */
+static inline float mavlink_msg_attitude_target_get_body_yaw_rate(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  28);
+}
+
+/**
+ * @brief Get field thrust from attitude_target message
+ *
+ * @return Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
+ */
+static inline float mavlink_msg_attitude_target_get_thrust(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  32);
+}
+
+/**
+ * @brief Decode a attitude_target message into a struct
+ *
+ * @param msg The message to decode
+ * @param attitude_target C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_attitude_target_decode(const mavlink_message_t* msg, mavlink_attitude_target_t* attitude_target)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	attitude_target->time_boot_ms = mavlink_msg_attitude_target_get_time_boot_ms(msg);
+	mavlink_msg_attitude_target_get_q(msg, attitude_target->q);
+	attitude_target->body_roll_rate = mavlink_msg_attitude_target_get_body_roll_rate(msg);
+	attitude_target->body_pitch_rate = mavlink_msg_attitude_target_get_body_pitch_rate(msg);
+	attitude_target->body_yaw_rate = mavlink_msg_attitude_target_get_body_yaw_rate(msg);
+	attitude_target->thrust = mavlink_msg_attitude_target_get_thrust(msg);
+	attitude_target->type_mask = mavlink_msg_attitude_target_get_type_mask(msg);
+#else
+	memcpy(attitude_target, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_ATTITUDE_TARGET_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_auth_key.h v1.0/common/mavlink_msg_auth_key.h
--- v1.0.old/common/mavlink_msg_auth_key.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_auth_key.h	2015-02-06 11:50:58.000000000 +0500
@@ -10,6 +10,9 @@ typedef struct __mavlink_auth_key_t
 #define MAVLINK_MSG_ID_AUTH_KEY_LEN 32
 #define MAVLINK_MSG_ID_7_LEN 32
 
+#define MAVLINK_MSG_ID_AUTH_KEY_CRC 119
+#define MAVLINK_MSG_ID_7_CRC 119
+
 #define MAVLINK_MSG_AUTH_KEY_FIELD_KEY_LEN 32
 
 #define MAVLINK_MESSAGE_INFO_AUTH_KEY { \
@@ -33,26 +36,30 @@ static inline uint16_t mavlink_msg_auth_
 						       const char *key)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[32];
+	char buf[MAVLINK_MSG_ID_AUTH_KEY_LEN];
 
 	_mav_put_char_array(buf, 0, key, 32);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_AUTH_KEY_LEN);
 #else
 	mavlink_auth_key_t packet;
 
 	mav_array_memcpy(packet.key, key, sizeof(char)*32);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_AUTH_KEY_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_AUTH_KEY;
-	return mavlink_finalize_message(msg, system_id, component_id, 32, 119);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_AUTH_KEY_LEN, MAVLINK_MSG_ID_AUTH_KEY_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_AUTH_KEY_LEN);
+#endif
 }
 
 /**
  * @brief Pack a auth_key message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param key key
  * @return length of the message in bytes (excluding serial stream start sign)
@@ -62,23 +69,27 @@ static inline uint16_t mavlink_msg_auth_
 						           const char *key)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[32];
+	char buf[MAVLINK_MSG_ID_AUTH_KEY_LEN];
 
 	_mav_put_char_array(buf, 0, key, 32);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_AUTH_KEY_LEN);
 #else
 	mavlink_auth_key_t packet;
 
 	mav_array_memcpy(packet.key, key, sizeof(char)*32);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_AUTH_KEY_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_AUTH_KEY;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 32, 119);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_AUTH_KEY_LEN, MAVLINK_MSG_ID_AUTH_KEY_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_AUTH_KEY_LEN);
+#endif
 }
 
 /**
- * @brief Encode a auth_key struct into a message
+ * @brief Encode a auth_key struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -91,6 +102,20 @@ static inline uint16_t mavlink_msg_auth_
 }
 
 /**
+ * @brief Encode a auth_key struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param auth_key C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_auth_key_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_auth_key_t* auth_key)
+{
+	return mavlink_msg_auth_key_pack_chan(system_id, component_id, chan, msg, auth_key->key);
+}
+
+/**
  * @brief Send a auth_key message
  * @param chan MAVLink channel to send the message
  *
@@ -101,18 +126,58 @@ static inline uint16_t mavlink_msg_auth_
 static inline void mavlink_msg_auth_key_send(mavlink_channel_t chan, const char *key)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[32];
+	char buf[MAVLINK_MSG_ID_AUTH_KEY_LEN];
 
 	_mav_put_char_array(buf, 0, key, 32);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTH_KEY, buf, 32, 119);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTH_KEY, buf, MAVLINK_MSG_ID_AUTH_KEY_LEN, MAVLINK_MSG_ID_AUTH_KEY_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTH_KEY, buf, MAVLINK_MSG_ID_AUTH_KEY_LEN);
+#endif
 #else
 	mavlink_auth_key_t packet;
 
 	mav_array_memcpy(packet.key, key, sizeof(char)*32);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTH_KEY, (const char *)&packet, 32, 119);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTH_KEY, (const char *)&packet, MAVLINK_MSG_ID_AUTH_KEY_LEN, MAVLINK_MSG_ID_AUTH_KEY_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTH_KEY, (const char *)&packet, MAVLINK_MSG_ID_AUTH_KEY_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_AUTH_KEY_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_auth_key_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  const char *key)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+
+	_mav_put_char_array(buf, 0, key, 32);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTH_KEY, buf, MAVLINK_MSG_ID_AUTH_KEY_LEN, MAVLINK_MSG_ID_AUTH_KEY_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTH_KEY, buf, MAVLINK_MSG_ID_AUTH_KEY_LEN);
+#endif
+#else
+	mavlink_auth_key_t *packet = (mavlink_auth_key_t *)msgbuf;
+
+	mav_array_memcpy(packet->key, key, sizeof(char)*32);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTH_KEY, (const char *)packet, MAVLINK_MSG_ID_AUTH_KEY_LEN, MAVLINK_MSG_ID_AUTH_KEY_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTH_KEY, (const char *)packet, MAVLINK_MSG_ID_AUTH_KEY_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE AUTH_KEY UNPACKING
@@ -139,6 +204,6 @@ static inline void mavlink_msg_auth_key_
 #if MAVLINK_NEED_BYTE_SWAP
 	mavlink_msg_auth_key_get_key(msg, auth_key->key);
 #else
-	memcpy(auth_key, _MAV_PAYLOAD(msg), 32);
+	memcpy(auth_key, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_AUTH_KEY_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_autopilot_version.h v1.0/common/mavlink_msg_autopilot_version.h
--- v1.0.old/common/mavlink_msg_autopilot_version.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_autopilot_version.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,443 @@
+// MESSAGE AUTOPILOT_VERSION PACKING
+
+#define MAVLINK_MSG_ID_AUTOPILOT_VERSION 148
+
+typedef struct __mavlink_autopilot_version_t
+{
+ uint64_t capabilities; ///< bitmask of capabilities (see MAV_PROTOCOL_CAPABILITY enum)
+ uint64_t uid; ///< UID if provided by hardware
+ uint32_t flight_sw_version; ///< Firmware version number
+ uint32_t middleware_sw_version; ///< Middleware version number
+ uint32_t os_sw_version; ///< Operating system version number
+ uint32_t board_version; ///< HW / board version (last 8 bytes should be silicon ID, if any)
+ uint16_t vendor_id; ///< ID of the board vendor
+ uint16_t product_id; ///< ID of the product
+ uint8_t flight_custom_version[8]; ///< Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
+ uint8_t middleware_custom_version[8]; ///< Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
+ uint8_t os_custom_version[8]; ///< Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
+} mavlink_autopilot_version_t;
+
+#define MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN 60
+#define MAVLINK_MSG_ID_148_LEN 60
+
+#define MAVLINK_MSG_ID_AUTOPILOT_VERSION_CRC 178
+#define MAVLINK_MSG_ID_148_CRC 178
+
+#define MAVLINK_MSG_AUTOPILOT_VERSION_FIELD_FLIGHT_CUSTOM_VERSION_LEN 8
+#define MAVLINK_MSG_AUTOPILOT_VERSION_FIELD_MIDDLEWARE_CUSTOM_VERSION_LEN 8
+#define MAVLINK_MSG_AUTOPILOT_VERSION_FIELD_OS_CUSTOM_VERSION_LEN 8
+
+#define MAVLINK_MESSAGE_INFO_AUTOPILOT_VERSION { \
+	"AUTOPILOT_VERSION", \
+	11, \
+	{  { "capabilities", NULL, MAVLINK_TYPE_UINT64_T, 0, 0, offsetof(mavlink_autopilot_version_t, capabilities) }, \
+         { "uid", NULL, MAVLINK_TYPE_UINT64_T, 0, 8, offsetof(mavlink_autopilot_version_t, uid) }, \
+         { "flight_sw_version", NULL, MAVLINK_TYPE_UINT32_T, 0, 16, offsetof(mavlink_autopilot_version_t, flight_sw_version) }, \
+         { "middleware_sw_version", NULL, MAVLINK_TYPE_UINT32_T, 0, 20, offsetof(mavlink_autopilot_version_t, middleware_sw_version) }, \
+         { "os_sw_version", NULL, MAVLINK_TYPE_UINT32_T, 0, 24, offsetof(mavlink_autopilot_version_t, os_sw_version) }, \
+         { "board_version", NULL, MAVLINK_TYPE_UINT32_T, 0, 28, offsetof(mavlink_autopilot_version_t, board_version) }, \
+         { "vendor_id", NULL, MAVLINK_TYPE_UINT16_T, 0, 32, offsetof(mavlink_autopilot_version_t, vendor_id) }, \
+         { "product_id", NULL, MAVLINK_TYPE_UINT16_T, 0, 34, offsetof(mavlink_autopilot_version_t, product_id) }, \
+         { "flight_custom_version", NULL, MAVLINK_TYPE_UINT8_T, 8, 36, offsetof(mavlink_autopilot_version_t, flight_custom_version) }, \
+         { "middleware_custom_version", NULL, MAVLINK_TYPE_UINT8_T, 8, 44, offsetof(mavlink_autopilot_version_t, middleware_custom_version) }, \
+         { "os_custom_version", NULL, MAVLINK_TYPE_UINT8_T, 8, 52, offsetof(mavlink_autopilot_version_t, os_custom_version) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a autopilot_version message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param capabilities bitmask of capabilities (see MAV_PROTOCOL_CAPABILITY enum)
+ * @param flight_sw_version Firmware version number
+ * @param middleware_sw_version Middleware version number
+ * @param os_sw_version Operating system version number
+ * @param board_version HW / board version (last 8 bytes should be silicon ID, if any)
+ * @param flight_custom_version Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
+ * @param middleware_custom_version Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
+ * @param os_custom_version Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
+ * @param vendor_id ID of the board vendor
+ * @param product_id ID of the product
+ * @param uid UID if provided by hardware
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_autopilot_version_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint64_t capabilities, uint32_t flight_sw_version, uint32_t middleware_sw_version, uint32_t os_sw_version, uint32_t board_version, const uint8_t *flight_custom_version, const uint8_t *middleware_custom_version, const uint8_t *os_custom_version, uint16_t vendor_id, uint16_t product_id, uint64_t uid)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN];
+	_mav_put_uint64_t(buf, 0, capabilities);
+	_mav_put_uint64_t(buf, 8, uid);
+	_mav_put_uint32_t(buf, 16, flight_sw_version);
+	_mav_put_uint32_t(buf, 20, middleware_sw_version);
+	_mav_put_uint32_t(buf, 24, os_sw_version);
+	_mav_put_uint32_t(buf, 28, board_version);
+	_mav_put_uint16_t(buf, 32, vendor_id);
+	_mav_put_uint16_t(buf, 34, product_id);
+	_mav_put_uint8_t_array(buf, 36, flight_custom_version, 8);
+	_mav_put_uint8_t_array(buf, 44, middleware_custom_version, 8);
+	_mav_put_uint8_t_array(buf, 52, os_custom_version, 8);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN);
+#else
+	mavlink_autopilot_version_t packet;
+	packet.capabilities = capabilities;
+	packet.uid = uid;
+	packet.flight_sw_version = flight_sw_version;
+	packet.middleware_sw_version = middleware_sw_version;
+	packet.os_sw_version = os_sw_version;
+	packet.board_version = board_version;
+	packet.vendor_id = vendor_id;
+	packet.product_id = product_id;
+	mav_array_memcpy(packet.flight_custom_version, flight_custom_version, sizeof(uint8_t)*8);
+	mav_array_memcpy(packet.middleware_custom_version, middleware_custom_version, sizeof(uint8_t)*8);
+	mav_array_memcpy(packet.os_custom_version, os_custom_version, sizeof(uint8_t)*8);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_AUTOPILOT_VERSION;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN, MAVLINK_MSG_ID_AUTOPILOT_VERSION_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a autopilot_version message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param capabilities bitmask of capabilities (see MAV_PROTOCOL_CAPABILITY enum)
+ * @param flight_sw_version Firmware version number
+ * @param middleware_sw_version Middleware version number
+ * @param os_sw_version Operating system version number
+ * @param board_version HW / board version (last 8 bytes should be silicon ID, if any)
+ * @param flight_custom_version Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
+ * @param middleware_custom_version Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
+ * @param os_custom_version Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
+ * @param vendor_id ID of the board vendor
+ * @param product_id ID of the product
+ * @param uid UID if provided by hardware
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_autopilot_version_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint64_t capabilities,uint32_t flight_sw_version,uint32_t middleware_sw_version,uint32_t os_sw_version,uint32_t board_version,const uint8_t *flight_custom_version,const uint8_t *middleware_custom_version,const uint8_t *os_custom_version,uint16_t vendor_id,uint16_t product_id,uint64_t uid)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN];
+	_mav_put_uint64_t(buf, 0, capabilities);
+	_mav_put_uint64_t(buf, 8, uid);
+	_mav_put_uint32_t(buf, 16, flight_sw_version);
+	_mav_put_uint32_t(buf, 20, middleware_sw_version);
+	_mav_put_uint32_t(buf, 24, os_sw_version);
+	_mav_put_uint32_t(buf, 28, board_version);
+	_mav_put_uint16_t(buf, 32, vendor_id);
+	_mav_put_uint16_t(buf, 34, product_id);
+	_mav_put_uint8_t_array(buf, 36, flight_custom_version, 8);
+	_mav_put_uint8_t_array(buf, 44, middleware_custom_version, 8);
+	_mav_put_uint8_t_array(buf, 52, os_custom_version, 8);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN);
+#else
+	mavlink_autopilot_version_t packet;
+	packet.capabilities = capabilities;
+	packet.uid = uid;
+	packet.flight_sw_version = flight_sw_version;
+	packet.middleware_sw_version = middleware_sw_version;
+	packet.os_sw_version = os_sw_version;
+	packet.board_version = board_version;
+	packet.vendor_id = vendor_id;
+	packet.product_id = product_id;
+	mav_array_memcpy(packet.flight_custom_version, flight_custom_version, sizeof(uint8_t)*8);
+	mav_array_memcpy(packet.middleware_custom_version, middleware_custom_version, sizeof(uint8_t)*8);
+	mav_array_memcpy(packet.os_custom_version, os_custom_version, sizeof(uint8_t)*8);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_AUTOPILOT_VERSION;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN, MAVLINK_MSG_ID_AUTOPILOT_VERSION_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a autopilot_version struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param autopilot_version C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_autopilot_version_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_autopilot_version_t* autopilot_version)
+{
+	return mavlink_msg_autopilot_version_pack(system_id, component_id, msg, autopilot_version->capabilities, autopilot_version->flight_sw_version, autopilot_version->middleware_sw_version, autopilot_version->os_sw_version, autopilot_version->board_version, autopilot_version->flight_custom_version, autopilot_version->middleware_custom_version, autopilot_version->os_custom_version, autopilot_version->vendor_id, autopilot_version->product_id, autopilot_version->uid);
+}
+
+/**
+ * @brief Encode a autopilot_version struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param autopilot_version C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_autopilot_version_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_autopilot_version_t* autopilot_version)
+{
+	return mavlink_msg_autopilot_version_pack_chan(system_id, component_id, chan, msg, autopilot_version->capabilities, autopilot_version->flight_sw_version, autopilot_version->middleware_sw_version, autopilot_version->os_sw_version, autopilot_version->board_version, autopilot_version->flight_custom_version, autopilot_version->middleware_custom_version, autopilot_version->os_custom_version, autopilot_version->vendor_id, autopilot_version->product_id, autopilot_version->uid);
+}
+
+/**
+ * @brief Send a autopilot_version message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param capabilities bitmask of capabilities (see MAV_PROTOCOL_CAPABILITY enum)
+ * @param flight_sw_version Firmware version number
+ * @param middleware_sw_version Middleware version number
+ * @param os_sw_version Operating system version number
+ * @param board_version HW / board version (last 8 bytes should be silicon ID, if any)
+ * @param flight_custom_version Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
+ * @param middleware_custom_version Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
+ * @param os_custom_version Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
+ * @param vendor_id ID of the board vendor
+ * @param product_id ID of the product
+ * @param uid UID if provided by hardware
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_autopilot_version_send(mavlink_channel_t chan, uint64_t capabilities, uint32_t flight_sw_version, uint32_t middleware_sw_version, uint32_t os_sw_version, uint32_t board_version, const uint8_t *flight_custom_version, const uint8_t *middleware_custom_version, const uint8_t *os_custom_version, uint16_t vendor_id, uint16_t product_id, uint64_t uid)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN];
+	_mav_put_uint64_t(buf, 0, capabilities);
+	_mav_put_uint64_t(buf, 8, uid);
+	_mav_put_uint32_t(buf, 16, flight_sw_version);
+	_mav_put_uint32_t(buf, 20, middleware_sw_version);
+	_mav_put_uint32_t(buf, 24, os_sw_version);
+	_mav_put_uint32_t(buf, 28, board_version);
+	_mav_put_uint16_t(buf, 32, vendor_id);
+	_mav_put_uint16_t(buf, 34, product_id);
+	_mav_put_uint8_t_array(buf, 36, flight_custom_version, 8);
+	_mav_put_uint8_t_array(buf, 44, middleware_custom_version, 8);
+	_mav_put_uint8_t_array(buf, 52, os_custom_version, 8);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTOPILOT_VERSION, buf, MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN, MAVLINK_MSG_ID_AUTOPILOT_VERSION_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTOPILOT_VERSION, buf, MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN);
+#endif
+#else
+	mavlink_autopilot_version_t packet;
+	packet.capabilities = capabilities;
+	packet.uid = uid;
+	packet.flight_sw_version = flight_sw_version;
+	packet.middleware_sw_version = middleware_sw_version;
+	packet.os_sw_version = os_sw_version;
+	packet.board_version = board_version;
+	packet.vendor_id = vendor_id;
+	packet.product_id = product_id;
+	mav_array_memcpy(packet.flight_custom_version, flight_custom_version, sizeof(uint8_t)*8);
+	mav_array_memcpy(packet.middleware_custom_version, middleware_custom_version, sizeof(uint8_t)*8);
+	mav_array_memcpy(packet.os_custom_version, os_custom_version, sizeof(uint8_t)*8);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTOPILOT_VERSION, (const char *)&packet, MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN, MAVLINK_MSG_ID_AUTOPILOT_VERSION_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTOPILOT_VERSION, (const char *)&packet, MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_autopilot_version_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t capabilities, uint32_t flight_sw_version, uint32_t middleware_sw_version, uint32_t os_sw_version, uint32_t board_version, const uint8_t *flight_custom_version, const uint8_t *middleware_custom_version, const uint8_t *os_custom_version, uint16_t vendor_id, uint16_t product_id, uint64_t uid)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, capabilities);
+	_mav_put_uint64_t(buf, 8, uid);
+	_mav_put_uint32_t(buf, 16, flight_sw_version);
+	_mav_put_uint32_t(buf, 20, middleware_sw_version);
+	_mav_put_uint32_t(buf, 24, os_sw_version);
+	_mav_put_uint32_t(buf, 28, board_version);
+	_mav_put_uint16_t(buf, 32, vendor_id);
+	_mav_put_uint16_t(buf, 34, product_id);
+	_mav_put_uint8_t_array(buf, 36, flight_custom_version, 8);
+	_mav_put_uint8_t_array(buf, 44, middleware_custom_version, 8);
+	_mav_put_uint8_t_array(buf, 52, os_custom_version, 8);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTOPILOT_VERSION, buf, MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN, MAVLINK_MSG_ID_AUTOPILOT_VERSION_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTOPILOT_VERSION, buf, MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN);
+#endif
+#else
+	mavlink_autopilot_version_t *packet = (mavlink_autopilot_version_t *)msgbuf;
+	packet->capabilities = capabilities;
+	packet->uid = uid;
+	packet->flight_sw_version = flight_sw_version;
+	packet->middleware_sw_version = middleware_sw_version;
+	packet->os_sw_version = os_sw_version;
+	packet->board_version = board_version;
+	packet->vendor_id = vendor_id;
+	packet->product_id = product_id;
+	mav_array_memcpy(packet->flight_custom_version, flight_custom_version, sizeof(uint8_t)*8);
+	mav_array_memcpy(packet->middleware_custom_version, middleware_custom_version, sizeof(uint8_t)*8);
+	mav_array_memcpy(packet->os_custom_version, os_custom_version, sizeof(uint8_t)*8);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTOPILOT_VERSION, (const char *)packet, MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN, MAVLINK_MSG_ID_AUTOPILOT_VERSION_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_AUTOPILOT_VERSION, (const char *)packet, MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE AUTOPILOT_VERSION UNPACKING
+
+
+/**
+ * @brief Get field capabilities from autopilot_version message
+ *
+ * @return bitmask of capabilities (see MAV_PROTOCOL_CAPABILITY enum)
+ */
+static inline uint64_t mavlink_msg_autopilot_version_get_capabilities(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint64_t(msg,  0);
+}
+
+/**
+ * @brief Get field flight_sw_version from autopilot_version message
+ *
+ * @return Firmware version number
+ */
+static inline uint32_t mavlink_msg_autopilot_version_get_flight_sw_version(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  16);
+}
+
+/**
+ * @brief Get field middleware_sw_version from autopilot_version message
+ *
+ * @return Middleware version number
+ */
+static inline uint32_t mavlink_msg_autopilot_version_get_middleware_sw_version(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  20);
+}
+
+/**
+ * @brief Get field os_sw_version from autopilot_version message
+ *
+ * @return Operating system version number
+ */
+static inline uint32_t mavlink_msg_autopilot_version_get_os_sw_version(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  24);
+}
+
+/**
+ * @brief Get field board_version from autopilot_version message
+ *
+ * @return HW / board version (last 8 bytes should be silicon ID, if any)
+ */
+static inline uint32_t mavlink_msg_autopilot_version_get_board_version(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  28);
+}
+
+/**
+ * @brief Get field flight_custom_version from autopilot_version message
+ *
+ * @return Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
+ */
+static inline uint16_t mavlink_msg_autopilot_version_get_flight_custom_version(const mavlink_message_t* msg, uint8_t *flight_custom_version)
+{
+	return _MAV_RETURN_uint8_t_array(msg, flight_custom_version, 8,  36);
+}
+
+/**
+ * @brief Get field middleware_custom_version from autopilot_version message
+ *
+ * @return Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
+ */
+static inline uint16_t mavlink_msg_autopilot_version_get_middleware_custom_version(const mavlink_message_t* msg, uint8_t *middleware_custom_version)
+{
+	return _MAV_RETURN_uint8_t_array(msg, middleware_custom_version, 8,  44);
+}
+
+/**
+ * @brief Get field os_custom_version from autopilot_version message
+ *
+ * @return Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
+ */
+static inline uint16_t mavlink_msg_autopilot_version_get_os_custom_version(const mavlink_message_t* msg, uint8_t *os_custom_version)
+{
+	return _MAV_RETURN_uint8_t_array(msg, os_custom_version, 8,  52);
+}
+
+/**
+ * @brief Get field vendor_id from autopilot_version message
+ *
+ * @return ID of the board vendor
+ */
+static inline uint16_t mavlink_msg_autopilot_version_get_vendor_id(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  32);
+}
+
+/**
+ * @brief Get field product_id from autopilot_version message
+ *
+ * @return ID of the product
+ */
+static inline uint16_t mavlink_msg_autopilot_version_get_product_id(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  34);
+}
+
+/**
+ * @brief Get field uid from autopilot_version message
+ *
+ * @return UID if provided by hardware
+ */
+static inline uint64_t mavlink_msg_autopilot_version_get_uid(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint64_t(msg,  8);
+}
+
+/**
+ * @brief Decode a autopilot_version message into a struct
+ *
+ * @param msg The message to decode
+ * @param autopilot_version C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_autopilot_version_decode(const mavlink_message_t* msg, mavlink_autopilot_version_t* autopilot_version)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	autopilot_version->capabilities = mavlink_msg_autopilot_version_get_capabilities(msg);
+	autopilot_version->uid = mavlink_msg_autopilot_version_get_uid(msg);
+	autopilot_version->flight_sw_version = mavlink_msg_autopilot_version_get_flight_sw_version(msg);
+	autopilot_version->middleware_sw_version = mavlink_msg_autopilot_version_get_middleware_sw_version(msg);
+	autopilot_version->os_sw_version = mavlink_msg_autopilot_version_get_os_sw_version(msg);
+	autopilot_version->board_version = mavlink_msg_autopilot_version_get_board_version(msg);
+	autopilot_version->vendor_id = mavlink_msg_autopilot_version_get_vendor_id(msg);
+	autopilot_version->product_id = mavlink_msg_autopilot_version_get_product_id(msg);
+	mavlink_msg_autopilot_version_get_flight_custom_version(msg, autopilot_version->flight_custom_version);
+	mavlink_msg_autopilot_version_get_middleware_custom_version(msg, autopilot_version->middleware_custom_version);
+	mavlink_msg_autopilot_version_get_os_custom_version(msg, autopilot_version->os_custom_version);
+#else
+	memcpy(autopilot_version, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_AUTOPILOT_VERSION_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_battery_status.h v1.0/common/mavlink_msg_battery_status.h
--- v1.0.old/common/mavlink_msg_battery_status.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_battery_status.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,393 @@
+// MESSAGE BATTERY_STATUS PACKING
+
+#define MAVLINK_MSG_ID_BATTERY_STATUS 147
+
+typedef struct __mavlink_battery_status_t
+{
+ int32_t current_consumed; ///< Consumed charge, in milliampere hours (1 = 1 mAh), -1: autopilot does not provide mAh consumption estimate
+ int32_t energy_consumed; ///< Consumed energy, in 100*Joules (intergrated U*I*dt)  (1 = 100 Joule), -1: autopilot does not provide energy consumption estimate
+ int16_t temperature; ///< Temperature of the battery in centi-degrees celsius. INT16_MAX for unknown temperature.
+ uint16_t voltages[10]; ///< Battery voltage of cells, in millivolts (1 = 1 millivolt)
+ int16_t current_battery; ///< Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
+ uint8_t id; ///< Battery ID
+ uint8_t battery_function; ///< Function of the battery
+ uint8_t type; ///< Type (chemistry) of the battery
+ int8_t battery_remaining; ///< Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot does not estimate the remaining battery
+} mavlink_battery_status_t;
+
+#define MAVLINK_MSG_ID_BATTERY_STATUS_LEN 36
+#define MAVLINK_MSG_ID_147_LEN 36
+
+#define MAVLINK_MSG_ID_BATTERY_STATUS_CRC 154
+#define MAVLINK_MSG_ID_147_CRC 154
+
+#define MAVLINK_MSG_BATTERY_STATUS_FIELD_VOLTAGES_LEN 10
+
+#define MAVLINK_MESSAGE_INFO_BATTERY_STATUS { \
+	"BATTERY_STATUS", \
+	9, \
+	{  { "current_consumed", NULL, MAVLINK_TYPE_INT32_T, 0, 0, offsetof(mavlink_battery_status_t, current_consumed) }, \
+         { "energy_consumed", NULL, MAVLINK_TYPE_INT32_T, 0, 4, offsetof(mavlink_battery_status_t, energy_consumed) }, \
+         { "temperature", NULL, MAVLINK_TYPE_INT16_T, 0, 8, offsetof(mavlink_battery_status_t, temperature) }, \
+         { "voltages", NULL, MAVLINK_TYPE_UINT16_T, 10, 10, offsetof(mavlink_battery_status_t, voltages) }, \
+         { "current_battery", NULL, MAVLINK_TYPE_INT16_T, 0, 30, offsetof(mavlink_battery_status_t, current_battery) }, \
+         { "id", NULL, MAVLINK_TYPE_UINT8_T, 0, 32, offsetof(mavlink_battery_status_t, id) }, \
+         { "battery_function", NULL, MAVLINK_TYPE_UINT8_T, 0, 33, offsetof(mavlink_battery_status_t, battery_function) }, \
+         { "type", NULL, MAVLINK_TYPE_UINT8_T, 0, 34, offsetof(mavlink_battery_status_t, type) }, \
+         { "battery_remaining", NULL, MAVLINK_TYPE_INT8_T, 0, 35, offsetof(mavlink_battery_status_t, battery_remaining) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a battery_status message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param id Battery ID
+ * @param battery_function Function of the battery
+ * @param type Type (chemistry) of the battery
+ * @param temperature Temperature of the battery in centi-degrees celsius. INT16_MAX for unknown temperature.
+ * @param voltages Battery voltage of cells, in millivolts (1 = 1 millivolt)
+ * @param current_battery Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
+ * @param current_consumed Consumed charge, in milliampere hours (1 = 1 mAh), -1: autopilot does not provide mAh consumption estimate
+ * @param energy_consumed Consumed energy, in 100*Joules (intergrated U*I*dt)  (1 = 100 Joule), -1: autopilot does not provide energy consumption estimate
+ * @param battery_remaining Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot does not estimate the remaining battery
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_battery_status_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint8_t id, uint8_t battery_function, uint8_t type, int16_t temperature, const uint16_t *voltages, int16_t current_battery, int32_t current_consumed, int32_t energy_consumed, int8_t battery_remaining)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_BATTERY_STATUS_LEN];
+	_mav_put_int32_t(buf, 0, current_consumed);
+	_mav_put_int32_t(buf, 4, energy_consumed);
+	_mav_put_int16_t(buf, 8, temperature);
+	_mav_put_int16_t(buf, 30, current_battery);
+	_mav_put_uint8_t(buf, 32, id);
+	_mav_put_uint8_t(buf, 33, battery_function);
+	_mav_put_uint8_t(buf, 34, type);
+	_mav_put_int8_t(buf, 35, battery_remaining);
+	_mav_put_uint16_t_array(buf, 10, voltages, 10);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_BATTERY_STATUS_LEN);
+#else
+	mavlink_battery_status_t packet;
+	packet.current_consumed = current_consumed;
+	packet.energy_consumed = energy_consumed;
+	packet.temperature = temperature;
+	packet.current_battery = current_battery;
+	packet.id = id;
+	packet.battery_function = battery_function;
+	packet.type = type;
+	packet.battery_remaining = battery_remaining;
+	mav_array_memcpy(packet.voltages, voltages, sizeof(uint16_t)*10);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_BATTERY_STATUS_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_BATTERY_STATUS;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_BATTERY_STATUS_LEN, MAVLINK_MSG_ID_BATTERY_STATUS_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_BATTERY_STATUS_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a battery_status message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param id Battery ID
+ * @param battery_function Function of the battery
+ * @param type Type (chemistry) of the battery
+ * @param temperature Temperature of the battery in centi-degrees celsius. INT16_MAX for unknown temperature.
+ * @param voltages Battery voltage of cells, in millivolts (1 = 1 millivolt)
+ * @param current_battery Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
+ * @param current_consumed Consumed charge, in milliampere hours (1 = 1 mAh), -1: autopilot does not provide mAh consumption estimate
+ * @param energy_consumed Consumed energy, in 100*Joules (intergrated U*I*dt)  (1 = 100 Joule), -1: autopilot does not provide energy consumption estimate
+ * @param battery_remaining Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot does not estimate the remaining battery
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_battery_status_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint8_t id,uint8_t battery_function,uint8_t type,int16_t temperature,const uint16_t *voltages,int16_t current_battery,int32_t current_consumed,int32_t energy_consumed,int8_t battery_remaining)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_BATTERY_STATUS_LEN];
+	_mav_put_int32_t(buf, 0, current_consumed);
+	_mav_put_int32_t(buf, 4, energy_consumed);
+	_mav_put_int16_t(buf, 8, temperature);
+	_mav_put_int16_t(buf, 30, current_battery);
+	_mav_put_uint8_t(buf, 32, id);
+	_mav_put_uint8_t(buf, 33, battery_function);
+	_mav_put_uint8_t(buf, 34, type);
+	_mav_put_int8_t(buf, 35, battery_remaining);
+	_mav_put_uint16_t_array(buf, 10, voltages, 10);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_BATTERY_STATUS_LEN);
+#else
+	mavlink_battery_status_t packet;
+	packet.current_consumed = current_consumed;
+	packet.energy_consumed = energy_consumed;
+	packet.temperature = temperature;
+	packet.current_battery = current_battery;
+	packet.id = id;
+	packet.battery_function = battery_function;
+	packet.type = type;
+	packet.battery_remaining = battery_remaining;
+	mav_array_memcpy(packet.voltages, voltages, sizeof(uint16_t)*10);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_BATTERY_STATUS_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_BATTERY_STATUS;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_BATTERY_STATUS_LEN, MAVLINK_MSG_ID_BATTERY_STATUS_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_BATTERY_STATUS_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a battery_status struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param battery_status C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_battery_status_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_battery_status_t* battery_status)
+{
+	return mavlink_msg_battery_status_pack(system_id, component_id, msg, battery_status->id, battery_status->battery_function, battery_status->type, battery_status->temperature, battery_status->voltages, battery_status->current_battery, battery_status->current_consumed, battery_status->energy_consumed, battery_status->battery_remaining);
+}
+
+/**
+ * @brief Encode a battery_status struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param battery_status C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_battery_status_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_battery_status_t* battery_status)
+{
+	return mavlink_msg_battery_status_pack_chan(system_id, component_id, chan, msg, battery_status->id, battery_status->battery_function, battery_status->type, battery_status->temperature, battery_status->voltages, battery_status->current_battery, battery_status->current_consumed, battery_status->energy_consumed, battery_status->battery_remaining);
+}
+
+/**
+ * @brief Send a battery_status message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param id Battery ID
+ * @param battery_function Function of the battery
+ * @param type Type (chemistry) of the battery
+ * @param temperature Temperature of the battery in centi-degrees celsius. INT16_MAX for unknown temperature.
+ * @param voltages Battery voltage of cells, in millivolts (1 = 1 millivolt)
+ * @param current_battery Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
+ * @param current_consumed Consumed charge, in milliampere hours (1 = 1 mAh), -1: autopilot does not provide mAh consumption estimate
+ * @param energy_consumed Consumed energy, in 100*Joules (intergrated U*I*dt)  (1 = 100 Joule), -1: autopilot does not provide energy consumption estimate
+ * @param battery_remaining Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot does not estimate the remaining battery
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_battery_status_send(mavlink_channel_t chan, uint8_t id, uint8_t battery_function, uint8_t type, int16_t temperature, const uint16_t *voltages, int16_t current_battery, int32_t current_consumed, int32_t energy_consumed, int8_t battery_remaining)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_BATTERY_STATUS_LEN];
+	_mav_put_int32_t(buf, 0, current_consumed);
+	_mav_put_int32_t(buf, 4, energy_consumed);
+	_mav_put_int16_t(buf, 8, temperature);
+	_mav_put_int16_t(buf, 30, current_battery);
+	_mav_put_uint8_t(buf, 32, id);
+	_mav_put_uint8_t(buf, 33, battery_function);
+	_mav_put_uint8_t(buf, 34, type);
+	_mav_put_int8_t(buf, 35, battery_remaining);
+	_mav_put_uint16_t_array(buf, 10, voltages, 10);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_BATTERY_STATUS, buf, MAVLINK_MSG_ID_BATTERY_STATUS_LEN, MAVLINK_MSG_ID_BATTERY_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_BATTERY_STATUS, buf, MAVLINK_MSG_ID_BATTERY_STATUS_LEN);
+#endif
+#else
+	mavlink_battery_status_t packet;
+	packet.current_consumed = current_consumed;
+	packet.energy_consumed = energy_consumed;
+	packet.temperature = temperature;
+	packet.current_battery = current_battery;
+	packet.id = id;
+	packet.battery_function = battery_function;
+	packet.type = type;
+	packet.battery_remaining = battery_remaining;
+	mav_array_memcpy(packet.voltages, voltages, sizeof(uint16_t)*10);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_BATTERY_STATUS, (const char *)&packet, MAVLINK_MSG_ID_BATTERY_STATUS_LEN, MAVLINK_MSG_ID_BATTERY_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_BATTERY_STATUS, (const char *)&packet, MAVLINK_MSG_ID_BATTERY_STATUS_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_BATTERY_STATUS_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_battery_status_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t id, uint8_t battery_function, uint8_t type, int16_t temperature, const uint16_t *voltages, int16_t current_battery, int32_t current_consumed, int32_t energy_consumed, int8_t battery_remaining)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_int32_t(buf, 0, current_consumed);
+	_mav_put_int32_t(buf, 4, energy_consumed);
+	_mav_put_int16_t(buf, 8, temperature);
+	_mav_put_int16_t(buf, 30, current_battery);
+	_mav_put_uint8_t(buf, 32, id);
+	_mav_put_uint8_t(buf, 33, battery_function);
+	_mav_put_uint8_t(buf, 34, type);
+	_mav_put_int8_t(buf, 35, battery_remaining);
+	_mav_put_uint16_t_array(buf, 10, voltages, 10);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_BATTERY_STATUS, buf, MAVLINK_MSG_ID_BATTERY_STATUS_LEN, MAVLINK_MSG_ID_BATTERY_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_BATTERY_STATUS, buf, MAVLINK_MSG_ID_BATTERY_STATUS_LEN);
+#endif
+#else
+	mavlink_battery_status_t *packet = (mavlink_battery_status_t *)msgbuf;
+	packet->current_consumed = current_consumed;
+	packet->energy_consumed = energy_consumed;
+	packet->temperature = temperature;
+	packet->current_battery = current_battery;
+	packet->id = id;
+	packet->battery_function = battery_function;
+	packet->type = type;
+	packet->battery_remaining = battery_remaining;
+	mav_array_memcpy(packet->voltages, voltages, sizeof(uint16_t)*10);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_BATTERY_STATUS, (const char *)packet, MAVLINK_MSG_ID_BATTERY_STATUS_LEN, MAVLINK_MSG_ID_BATTERY_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_BATTERY_STATUS, (const char *)packet, MAVLINK_MSG_ID_BATTERY_STATUS_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE BATTERY_STATUS UNPACKING
+
+
+/**
+ * @brief Get field id from battery_status message
+ *
+ * @return Battery ID
+ */
+static inline uint8_t mavlink_msg_battery_status_get_id(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  32);
+}
+
+/**
+ * @brief Get field battery_function from battery_status message
+ *
+ * @return Function of the battery
+ */
+static inline uint8_t mavlink_msg_battery_status_get_battery_function(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  33);
+}
+
+/**
+ * @brief Get field type from battery_status message
+ *
+ * @return Type (chemistry) of the battery
+ */
+static inline uint8_t mavlink_msg_battery_status_get_type(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  34);
+}
+
+/**
+ * @brief Get field temperature from battery_status message
+ *
+ * @return Temperature of the battery in centi-degrees celsius. INT16_MAX for unknown temperature.
+ */
+static inline int16_t mavlink_msg_battery_status_get_temperature(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  8);
+}
+
+/**
+ * @brief Get field voltages from battery_status message
+ *
+ * @return Battery voltage of cells, in millivolts (1 = 1 millivolt)
+ */
+static inline uint16_t mavlink_msg_battery_status_get_voltages(const mavlink_message_t* msg, uint16_t *voltages)
+{
+	return _MAV_RETURN_uint16_t_array(msg, voltages, 10,  10);
+}
+
+/**
+ * @brief Get field current_battery from battery_status message
+ *
+ * @return Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
+ */
+static inline int16_t mavlink_msg_battery_status_get_current_battery(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  30);
+}
+
+/**
+ * @brief Get field current_consumed from battery_status message
+ *
+ * @return Consumed charge, in milliampere hours (1 = 1 mAh), -1: autopilot does not provide mAh consumption estimate
+ */
+static inline int32_t mavlink_msg_battery_status_get_current_consumed(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  0);
+}
+
+/**
+ * @brief Get field energy_consumed from battery_status message
+ *
+ * @return Consumed energy, in 100*Joules (intergrated U*I*dt)  (1 = 100 Joule), -1: autopilot does not provide energy consumption estimate
+ */
+static inline int32_t mavlink_msg_battery_status_get_energy_consumed(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  4);
+}
+
+/**
+ * @brief Get field battery_remaining from battery_status message
+ *
+ * @return Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot does not estimate the remaining battery
+ */
+static inline int8_t mavlink_msg_battery_status_get_battery_remaining(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int8_t(msg,  35);
+}
+
+/**
+ * @brief Decode a battery_status message into a struct
+ *
+ * @param msg The message to decode
+ * @param battery_status C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_battery_status_decode(const mavlink_message_t* msg, mavlink_battery_status_t* battery_status)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	battery_status->current_consumed = mavlink_msg_battery_status_get_current_consumed(msg);
+	battery_status->energy_consumed = mavlink_msg_battery_status_get_energy_consumed(msg);
+	battery_status->temperature = mavlink_msg_battery_status_get_temperature(msg);
+	mavlink_msg_battery_status_get_voltages(msg, battery_status->voltages);
+	battery_status->current_battery = mavlink_msg_battery_status_get_current_battery(msg);
+	battery_status->id = mavlink_msg_battery_status_get_id(msg);
+	battery_status->battery_function = mavlink_msg_battery_status_get_battery_function(msg);
+	battery_status->type = mavlink_msg_battery_status_get_type(msg);
+	battery_status->battery_remaining = mavlink_msg_battery_status_get_battery_remaining(msg);
+#else
+	memcpy(battery_status, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_BATTERY_STATUS_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_change_operator_control_ack.h v1.0/common/mavlink_msg_change_operator_control_ack.h
--- v1.0.old/common/mavlink_msg_change_operator_control_ack.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_change_operator_control_ack.h	2015-02-06 11:50:58.000000000 +0500
@@ -12,6 +12,9 @@ typedef struct __mavlink_change_operator
 #define MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN 3
 #define MAVLINK_MSG_ID_6_LEN 3
 
+#define MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_CRC 104
+#define MAVLINK_MSG_ID_6_CRC 104
+
 
 
 #define MAVLINK_MESSAGE_INFO_CHANGE_OPERATOR_CONTROL_ACK { \
@@ -39,30 +42,34 @@ static inline uint16_t mavlink_msg_chang
 						       uint8_t gcs_system_id, uint8_t control_request, uint8_t ack)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[3];
+	char buf[MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN];
 	_mav_put_uint8_t(buf, 0, gcs_system_id);
 	_mav_put_uint8_t(buf, 1, control_request);
 	_mav_put_uint8_t(buf, 2, ack);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 3);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN);
 #else
 	mavlink_change_operator_control_ack_t packet;
 	packet.gcs_system_id = gcs_system_id;
 	packet.control_request = control_request;
 	packet.ack = ack;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 3);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK;
-	return mavlink_finalize_message(msg, system_id, component_id, 3, 104);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN);
+#endif
 }
 
 /**
  * @brief Pack a change_operator_control_ack message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param gcs_system_id ID of the GCS this message 
  * @param control_request 0: request control of this MAV, 1: Release control of this MAV
@@ -74,27 +81,31 @@ static inline uint16_t mavlink_msg_chang
 						           uint8_t gcs_system_id,uint8_t control_request,uint8_t ack)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[3];
+	char buf[MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN];
 	_mav_put_uint8_t(buf, 0, gcs_system_id);
 	_mav_put_uint8_t(buf, 1, control_request);
 	_mav_put_uint8_t(buf, 2, ack);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 3);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN);
 #else
 	mavlink_change_operator_control_ack_t packet;
 	packet.gcs_system_id = gcs_system_id;
 	packet.control_request = control_request;
 	packet.ack = ack;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 3);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 3, 104);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN);
+#endif
 }
 
 /**
- * @brief Encode a change_operator_control_ack struct into a message
+ * @brief Encode a change_operator_control_ack struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -107,6 +118,20 @@ static inline uint16_t mavlink_msg_chang
 }
 
 /**
+ * @brief Encode a change_operator_control_ack struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param change_operator_control_ack C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_change_operator_control_ack_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_change_operator_control_ack_t* change_operator_control_ack)
+{
+	return mavlink_msg_change_operator_control_ack_pack_chan(system_id, component_id, chan, msg, change_operator_control_ack->gcs_system_id, change_operator_control_ack->control_request, change_operator_control_ack->ack);
+}
+
+/**
  * @brief Send a change_operator_control_ack message
  * @param chan MAVLink channel to send the message
  *
@@ -119,21 +144,65 @@ static inline uint16_t mavlink_msg_chang
 static inline void mavlink_msg_change_operator_control_ack_send(mavlink_channel_t chan, uint8_t gcs_system_id, uint8_t control_request, uint8_t ack)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[3];
+	char buf[MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN];
 	_mav_put_uint8_t(buf, 0, gcs_system_id);
 	_mav_put_uint8_t(buf, 1, control_request);
 	_mav_put_uint8_t(buf, 2, ack);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK, buf, 3, 104);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK, buf, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK, buf, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN);
+#endif
 #else
 	mavlink_change_operator_control_ack_t packet;
 	packet.gcs_system_id = gcs_system_id;
 	packet.control_request = control_request;
 	packet.ack = ack;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK, (const char *)&packet, 3, 104);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK, (const char *)&packet, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK, (const char *)&packet, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_change_operator_control_ack_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t gcs_system_id, uint8_t control_request, uint8_t ack)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint8_t(buf, 0, gcs_system_id);
+	_mav_put_uint8_t(buf, 1, control_request);
+	_mav_put_uint8_t(buf, 2, ack);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK, buf, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK, buf, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN);
+#endif
+#else
+	mavlink_change_operator_control_ack_t *packet = (mavlink_change_operator_control_ack_t *)msgbuf;
+	packet->gcs_system_id = gcs_system_id;
+	packet->control_request = control_request;
+	packet->ack = ack;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK, (const char *)packet, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK, (const char *)packet, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -183,6 +252,6 @@ static inline void mavlink_msg_change_op
 	change_operator_control_ack->control_request = mavlink_msg_change_operator_control_ack_get_control_request(msg);
 	change_operator_control_ack->ack = mavlink_msg_change_operator_control_ack_get_ack(msg);
 #else
-	memcpy(change_operator_control_ack, _MAV_PAYLOAD(msg), 3);
+	memcpy(change_operator_control_ack, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_change_operator_control.h v1.0/common/mavlink_msg_change_operator_control.h
--- v1.0.old/common/mavlink_msg_change_operator_control.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_change_operator_control.h	2015-02-06 11:50:58.000000000 +0500
@@ -13,6 +13,9 @@ typedef struct __mavlink_change_operator
 #define MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN 28
 #define MAVLINK_MSG_ID_5_LEN 28
 
+#define MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_CRC 217
+#define MAVLINK_MSG_ID_5_CRC 217
+
 #define MAVLINK_MSG_CHANGE_OPERATOR_CONTROL_FIELD_PASSKEY_LEN 25
 
 #define MAVLINK_MESSAGE_INFO_CHANGE_OPERATOR_CONTROL { \
@@ -42,30 +45,34 @@ static inline uint16_t mavlink_msg_chang
 						       uint8_t target_system, uint8_t control_request, uint8_t version, const char *passkey)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[28];
+	char buf[MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN];
 	_mav_put_uint8_t(buf, 0, target_system);
 	_mav_put_uint8_t(buf, 1, control_request);
 	_mav_put_uint8_t(buf, 2, version);
 	_mav_put_char_array(buf, 3, passkey, 25);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN);
 #else
 	mavlink_change_operator_control_t packet;
 	packet.target_system = target_system;
 	packet.control_request = control_request;
 	packet.version = version;
 	mav_array_memcpy(packet.passkey, passkey, sizeof(char)*25);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL;
-	return mavlink_finalize_message(msg, system_id, component_id, 28, 217);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN);
+#endif
 }
 
 /**
  * @brief Pack a change_operator_control message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system System the GCS requests control for
  * @param control_request 0: request control of this MAV, 1: Release control of this MAV
@@ -78,27 +85,31 @@ static inline uint16_t mavlink_msg_chang
 						           uint8_t target_system,uint8_t control_request,uint8_t version,const char *passkey)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[28];
+	char buf[MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN];
 	_mav_put_uint8_t(buf, 0, target_system);
 	_mav_put_uint8_t(buf, 1, control_request);
 	_mav_put_uint8_t(buf, 2, version);
 	_mav_put_char_array(buf, 3, passkey, 25);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN);
 #else
 	mavlink_change_operator_control_t packet;
 	packet.target_system = target_system;
 	packet.control_request = control_request;
 	packet.version = version;
 	mav_array_memcpy(packet.passkey, passkey, sizeof(char)*25);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 28, 217);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN);
+#endif
 }
 
 /**
- * @brief Encode a change_operator_control struct into a message
+ * @brief Encode a change_operator_control struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -111,6 +122,20 @@ static inline uint16_t mavlink_msg_chang
 }
 
 /**
+ * @brief Encode a change_operator_control struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param change_operator_control C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_change_operator_control_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_change_operator_control_t* change_operator_control)
+{
+	return mavlink_msg_change_operator_control_pack_chan(system_id, component_id, chan, msg, change_operator_control->target_system, change_operator_control->control_request, change_operator_control->version, change_operator_control->passkey);
+}
+
+/**
  * @brief Send a change_operator_control message
  * @param chan MAVLink channel to send the message
  *
@@ -124,22 +149,66 @@ static inline uint16_t mavlink_msg_chang
 static inline void mavlink_msg_change_operator_control_send(mavlink_channel_t chan, uint8_t target_system, uint8_t control_request, uint8_t version, const char *passkey)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[28];
+	char buf[MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN];
 	_mav_put_uint8_t(buf, 0, target_system);
 	_mav_put_uint8_t(buf, 1, control_request);
 	_mav_put_uint8_t(buf, 2, version);
 	_mav_put_char_array(buf, 3, passkey, 25);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL, buf, 28, 217);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL, buf, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL, buf, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN);
+#endif
 #else
 	mavlink_change_operator_control_t packet;
 	packet.target_system = target_system;
 	packet.control_request = control_request;
 	packet.version = version;
 	mav_array_memcpy(packet.passkey, passkey, sizeof(char)*25);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL, (const char *)&packet, 28, 217);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL, (const char *)&packet, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL, (const char *)&packet, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_change_operator_control_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t control_request, uint8_t version, const char *passkey)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint8_t(buf, 0, target_system);
+	_mav_put_uint8_t(buf, 1, control_request);
+	_mav_put_uint8_t(buf, 2, version);
+	_mav_put_char_array(buf, 3, passkey, 25);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL, buf, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL, buf, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN);
+#endif
+#else
+	mavlink_change_operator_control_t *packet = (mavlink_change_operator_control_t *)msgbuf;
+	packet->target_system = target_system;
+	packet->control_request = control_request;
+	packet->version = version;
+	mav_array_memcpy(packet->passkey, passkey, sizeof(char)*25);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL, (const char *)packet, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL, (const char *)packet, MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE CHANGE_OPERATOR_CONTROL UNPACKING
@@ -199,6 +268,6 @@ static inline void mavlink_msg_change_op
 	change_operator_control->version = mavlink_msg_change_operator_control_get_version(msg);
 	mavlink_msg_change_operator_control_get_passkey(msg, change_operator_control->passkey);
 #else
-	memcpy(change_operator_control, _MAV_PAYLOAD(msg), 28);
+	memcpy(change_operator_control, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_command_ack.h v1.0/common/mavlink_msg_command_ack.h
--- v1.0.old/common/mavlink_msg_command_ack.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_command_ack.h	2015-02-06 11:50:58.000000000 +0500
@@ -11,6 +11,9 @@ typedef struct __mavlink_command_ack_t
 #define MAVLINK_MSG_ID_COMMAND_ACK_LEN 3
 #define MAVLINK_MSG_ID_77_LEN 3
 
+#define MAVLINK_MSG_ID_COMMAND_ACK_CRC 143
+#define MAVLINK_MSG_ID_77_CRC 143
+
 
 
 #define MAVLINK_MESSAGE_INFO_COMMAND_ACK { \
@@ -36,28 +39,32 @@ static inline uint16_t mavlink_msg_comma
 						       uint16_t command, uint8_t result)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[3];
+	char buf[MAVLINK_MSG_ID_COMMAND_ACK_LEN];
 	_mav_put_uint16_t(buf, 0, command);
 	_mav_put_uint8_t(buf, 2, result);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 3);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_COMMAND_ACK_LEN);
 #else
 	mavlink_command_ack_t packet;
 	packet.command = command;
 	packet.result = result;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 3);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_COMMAND_ACK_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_COMMAND_ACK;
-	return mavlink_finalize_message(msg, system_id, component_id, 3, 143);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_COMMAND_ACK_LEN, MAVLINK_MSG_ID_COMMAND_ACK_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_COMMAND_ACK_LEN);
+#endif
 }
 
 /**
  * @brief Pack a command_ack message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param command Command ID, as defined by MAV_CMD enum.
  * @param result See MAV_RESULT enum
@@ -68,25 +75,29 @@ static inline uint16_t mavlink_msg_comma
 						           uint16_t command,uint8_t result)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[3];
+	char buf[MAVLINK_MSG_ID_COMMAND_ACK_LEN];
 	_mav_put_uint16_t(buf, 0, command);
 	_mav_put_uint8_t(buf, 2, result);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 3);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_COMMAND_ACK_LEN);
 #else
 	mavlink_command_ack_t packet;
 	packet.command = command;
 	packet.result = result;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 3);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_COMMAND_ACK_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_COMMAND_ACK;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 3, 143);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_COMMAND_ACK_LEN, MAVLINK_MSG_ID_COMMAND_ACK_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_COMMAND_ACK_LEN);
+#endif
 }
 
 /**
- * @brief Encode a command_ack struct into a message
+ * @brief Encode a command_ack struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -99,6 +110,20 @@ static inline uint16_t mavlink_msg_comma
 }
 
 /**
+ * @brief Encode a command_ack struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param command_ack C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_command_ack_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_command_ack_t* command_ack)
+{
+	return mavlink_msg_command_ack_pack_chan(system_id, component_id, chan, msg, command_ack->command, command_ack->result);
+}
+
+/**
  * @brief Send a command_ack message
  * @param chan MAVLink channel to send the message
  *
@@ -110,20 +135,62 @@ static inline uint16_t mavlink_msg_comma
 static inline void mavlink_msg_command_ack_send(mavlink_channel_t chan, uint16_t command, uint8_t result)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[3];
+	char buf[MAVLINK_MSG_ID_COMMAND_ACK_LEN];
 	_mav_put_uint16_t(buf, 0, command);
 	_mav_put_uint8_t(buf, 2, result);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_ACK, buf, 3, 143);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_ACK, buf, MAVLINK_MSG_ID_COMMAND_ACK_LEN, MAVLINK_MSG_ID_COMMAND_ACK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_ACK, buf, MAVLINK_MSG_ID_COMMAND_ACK_LEN);
+#endif
 #else
 	mavlink_command_ack_t packet;
 	packet.command = command;
 	packet.result = result;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_ACK, (const char *)&packet, 3, 143);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_ACK, (const char *)&packet, MAVLINK_MSG_ID_COMMAND_ACK_LEN, MAVLINK_MSG_ID_COMMAND_ACK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_ACK, (const char *)&packet, MAVLINK_MSG_ID_COMMAND_ACK_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_COMMAND_ACK_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_command_ack_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint16_t command, uint8_t result)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint16_t(buf, 0, command);
+	_mav_put_uint8_t(buf, 2, result);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_ACK, buf, MAVLINK_MSG_ID_COMMAND_ACK_LEN, MAVLINK_MSG_ID_COMMAND_ACK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_ACK, buf, MAVLINK_MSG_ID_COMMAND_ACK_LEN);
+#endif
+#else
+	mavlink_command_ack_t *packet = (mavlink_command_ack_t *)msgbuf;
+	packet->command = command;
+	packet->result = result;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_ACK, (const char *)packet, MAVLINK_MSG_ID_COMMAND_ACK_LEN, MAVLINK_MSG_ID_COMMAND_ACK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_ACK, (const char *)packet, MAVLINK_MSG_ID_COMMAND_ACK_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE COMMAND_ACK UNPACKING
@@ -161,6 +228,6 @@ static inline void mavlink_msg_command_a
 	command_ack->command = mavlink_msg_command_ack_get_command(msg);
 	command_ack->result = mavlink_msg_command_ack_get_result(msg);
 #else
-	memcpy(command_ack, _MAV_PAYLOAD(msg), 3);
+	memcpy(command_ack, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_COMMAND_ACK_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_command_int.h v1.0/common/mavlink_msg_command_int.h
--- v1.0.old/common/mavlink_msg_command_int.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_command_int.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,497 @@
+// MESSAGE COMMAND_INT PACKING
+
+#define MAVLINK_MSG_ID_COMMAND_INT 75
+
+typedef struct __mavlink_command_int_t
+{
+ float param1; ///< PARAM1, see MAV_CMD enum
+ float param2; ///< PARAM2, see MAV_CMD enum
+ float param3; ///< PARAM3, see MAV_CMD enum
+ float param4; ///< PARAM4, see MAV_CMD enum
+ int32_t x; ///< PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
+ int32_t y; ///< PARAM6 / local: y position in meters * 1e4, global: longitude in degrees * 10^7
+ float z; ///< PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.
+ uint16_t command; ///< The scheduled action for the mission item. see MAV_CMD in common.xml MAVLink specs
+ uint8_t target_system; ///< System ID
+ uint8_t target_component; ///< Component ID
+ uint8_t frame; ///< The coordinate system of the COMMAND. see MAV_FRAME in mavlink_types.h
+ uint8_t current; ///< false:0, true:1
+ uint8_t autocontinue; ///< autocontinue to next wp
+} mavlink_command_int_t;
+
+#define MAVLINK_MSG_ID_COMMAND_INT_LEN 35
+#define MAVLINK_MSG_ID_75_LEN 35
+
+#define MAVLINK_MSG_ID_COMMAND_INT_CRC 158
+#define MAVLINK_MSG_ID_75_CRC 158
+
+
+
+#define MAVLINK_MESSAGE_INFO_COMMAND_INT { \
+	"COMMAND_INT", \
+	13, \
+	{  { "param1", NULL, MAVLINK_TYPE_FLOAT, 0, 0, offsetof(mavlink_command_int_t, param1) }, \
+         { "param2", NULL, MAVLINK_TYPE_FLOAT, 0, 4, offsetof(mavlink_command_int_t, param2) }, \
+         { "param3", NULL, MAVLINK_TYPE_FLOAT, 0, 8, offsetof(mavlink_command_int_t, param3) }, \
+         { "param4", NULL, MAVLINK_TYPE_FLOAT, 0, 12, offsetof(mavlink_command_int_t, param4) }, \
+         { "x", NULL, MAVLINK_TYPE_INT32_T, 0, 16, offsetof(mavlink_command_int_t, x) }, \
+         { "y", NULL, MAVLINK_TYPE_INT32_T, 0, 20, offsetof(mavlink_command_int_t, y) }, \
+         { "z", NULL, MAVLINK_TYPE_FLOAT, 0, 24, offsetof(mavlink_command_int_t, z) }, \
+         { "command", NULL, MAVLINK_TYPE_UINT16_T, 0, 28, offsetof(mavlink_command_int_t, command) }, \
+         { "target_system", NULL, MAVLINK_TYPE_UINT8_T, 0, 30, offsetof(mavlink_command_int_t, target_system) }, \
+         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 31, offsetof(mavlink_command_int_t, target_component) }, \
+         { "frame", NULL, MAVLINK_TYPE_UINT8_T, 0, 32, offsetof(mavlink_command_int_t, frame) }, \
+         { "current", NULL, MAVLINK_TYPE_UINT8_T, 0, 33, offsetof(mavlink_command_int_t, current) }, \
+         { "autocontinue", NULL, MAVLINK_TYPE_UINT8_T, 0, 34, offsetof(mavlink_command_int_t, autocontinue) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a command_int message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param frame The coordinate system of the COMMAND. see MAV_FRAME in mavlink_types.h
+ * @param command The scheduled action for the mission item. see MAV_CMD in common.xml MAVLink specs
+ * @param current false:0, true:1
+ * @param autocontinue autocontinue to next wp
+ * @param param1 PARAM1, see MAV_CMD enum
+ * @param param2 PARAM2, see MAV_CMD enum
+ * @param param3 PARAM3, see MAV_CMD enum
+ * @param param4 PARAM4, see MAV_CMD enum
+ * @param x PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
+ * @param y PARAM6 / local: y position in meters * 1e4, global: longitude in degrees * 10^7
+ * @param z PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_command_int_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint8_t target_system, uint8_t target_component, uint8_t frame, uint16_t command, uint8_t current, uint8_t autocontinue, float param1, float param2, float param3, float param4, int32_t x, int32_t y, float z)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_COMMAND_INT_LEN];
+	_mav_put_float(buf, 0, param1);
+	_mav_put_float(buf, 4, param2);
+	_mav_put_float(buf, 8, param3);
+	_mav_put_float(buf, 12, param4);
+	_mav_put_int32_t(buf, 16, x);
+	_mav_put_int32_t(buf, 20, y);
+	_mav_put_float(buf, 24, z);
+	_mav_put_uint16_t(buf, 28, command);
+	_mav_put_uint8_t(buf, 30, target_system);
+	_mav_put_uint8_t(buf, 31, target_component);
+	_mav_put_uint8_t(buf, 32, frame);
+	_mav_put_uint8_t(buf, 33, current);
+	_mav_put_uint8_t(buf, 34, autocontinue);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_COMMAND_INT_LEN);
+#else
+	mavlink_command_int_t packet;
+	packet.param1 = param1;
+	packet.param2 = param2;
+	packet.param3 = param3;
+	packet.param4 = param4;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.command = command;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.frame = frame;
+	packet.current = current;
+	packet.autocontinue = autocontinue;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_COMMAND_INT_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_COMMAND_INT;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_COMMAND_INT_LEN, MAVLINK_MSG_ID_COMMAND_INT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_COMMAND_INT_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a command_int message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param frame The coordinate system of the COMMAND. see MAV_FRAME in mavlink_types.h
+ * @param command The scheduled action for the mission item. see MAV_CMD in common.xml MAVLink specs
+ * @param current false:0, true:1
+ * @param autocontinue autocontinue to next wp
+ * @param param1 PARAM1, see MAV_CMD enum
+ * @param param2 PARAM2, see MAV_CMD enum
+ * @param param3 PARAM3, see MAV_CMD enum
+ * @param param4 PARAM4, see MAV_CMD enum
+ * @param x PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
+ * @param y PARAM6 / local: y position in meters * 1e4, global: longitude in degrees * 10^7
+ * @param z PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_command_int_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint8_t target_system,uint8_t target_component,uint8_t frame,uint16_t command,uint8_t current,uint8_t autocontinue,float param1,float param2,float param3,float param4,int32_t x,int32_t y,float z)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_COMMAND_INT_LEN];
+	_mav_put_float(buf, 0, param1);
+	_mav_put_float(buf, 4, param2);
+	_mav_put_float(buf, 8, param3);
+	_mav_put_float(buf, 12, param4);
+	_mav_put_int32_t(buf, 16, x);
+	_mav_put_int32_t(buf, 20, y);
+	_mav_put_float(buf, 24, z);
+	_mav_put_uint16_t(buf, 28, command);
+	_mav_put_uint8_t(buf, 30, target_system);
+	_mav_put_uint8_t(buf, 31, target_component);
+	_mav_put_uint8_t(buf, 32, frame);
+	_mav_put_uint8_t(buf, 33, current);
+	_mav_put_uint8_t(buf, 34, autocontinue);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_COMMAND_INT_LEN);
+#else
+	mavlink_command_int_t packet;
+	packet.param1 = param1;
+	packet.param2 = param2;
+	packet.param3 = param3;
+	packet.param4 = param4;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.command = command;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.frame = frame;
+	packet.current = current;
+	packet.autocontinue = autocontinue;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_COMMAND_INT_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_COMMAND_INT;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_COMMAND_INT_LEN, MAVLINK_MSG_ID_COMMAND_INT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_COMMAND_INT_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a command_int struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param command_int C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_command_int_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_command_int_t* command_int)
+{
+	return mavlink_msg_command_int_pack(system_id, component_id, msg, command_int->target_system, command_int->target_component, command_int->frame, command_int->command, command_int->current, command_int->autocontinue, command_int->param1, command_int->param2, command_int->param3, command_int->param4, command_int->x, command_int->y, command_int->z);
+}
+
+/**
+ * @brief Encode a command_int struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param command_int C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_command_int_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_command_int_t* command_int)
+{
+	return mavlink_msg_command_int_pack_chan(system_id, component_id, chan, msg, command_int->target_system, command_int->target_component, command_int->frame, command_int->command, command_int->current, command_int->autocontinue, command_int->param1, command_int->param2, command_int->param3, command_int->param4, command_int->x, command_int->y, command_int->z);
+}
+
+/**
+ * @brief Send a command_int message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param frame The coordinate system of the COMMAND. see MAV_FRAME in mavlink_types.h
+ * @param command The scheduled action for the mission item. see MAV_CMD in common.xml MAVLink specs
+ * @param current false:0, true:1
+ * @param autocontinue autocontinue to next wp
+ * @param param1 PARAM1, see MAV_CMD enum
+ * @param param2 PARAM2, see MAV_CMD enum
+ * @param param3 PARAM3, see MAV_CMD enum
+ * @param param4 PARAM4, see MAV_CMD enum
+ * @param x PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
+ * @param y PARAM6 / local: y position in meters * 1e4, global: longitude in degrees * 10^7
+ * @param z PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_command_int_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, uint8_t frame, uint16_t command, uint8_t current, uint8_t autocontinue, float param1, float param2, float param3, float param4, int32_t x, int32_t y, float z)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_COMMAND_INT_LEN];
+	_mav_put_float(buf, 0, param1);
+	_mav_put_float(buf, 4, param2);
+	_mav_put_float(buf, 8, param3);
+	_mav_put_float(buf, 12, param4);
+	_mav_put_int32_t(buf, 16, x);
+	_mav_put_int32_t(buf, 20, y);
+	_mav_put_float(buf, 24, z);
+	_mav_put_uint16_t(buf, 28, command);
+	_mav_put_uint8_t(buf, 30, target_system);
+	_mav_put_uint8_t(buf, 31, target_component);
+	_mav_put_uint8_t(buf, 32, frame);
+	_mav_put_uint8_t(buf, 33, current);
+	_mav_put_uint8_t(buf, 34, autocontinue);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_INT, buf, MAVLINK_MSG_ID_COMMAND_INT_LEN, MAVLINK_MSG_ID_COMMAND_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_INT, buf, MAVLINK_MSG_ID_COMMAND_INT_LEN);
+#endif
+#else
+	mavlink_command_int_t packet;
+	packet.param1 = param1;
+	packet.param2 = param2;
+	packet.param3 = param3;
+	packet.param4 = param4;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.command = command;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.frame = frame;
+	packet.current = current;
+	packet.autocontinue = autocontinue;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_INT, (const char *)&packet, MAVLINK_MSG_ID_COMMAND_INT_LEN, MAVLINK_MSG_ID_COMMAND_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_INT, (const char *)&packet, MAVLINK_MSG_ID_COMMAND_INT_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_COMMAND_INT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_command_int_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, uint8_t frame, uint16_t command, uint8_t current, uint8_t autocontinue, float param1, float param2, float param3, float param4, int32_t x, int32_t y, float z)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_float(buf, 0, param1);
+	_mav_put_float(buf, 4, param2);
+	_mav_put_float(buf, 8, param3);
+	_mav_put_float(buf, 12, param4);
+	_mav_put_int32_t(buf, 16, x);
+	_mav_put_int32_t(buf, 20, y);
+	_mav_put_float(buf, 24, z);
+	_mav_put_uint16_t(buf, 28, command);
+	_mav_put_uint8_t(buf, 30, target_system);
+	_mav_put_uint8_t(buf, 31, target_component);
+	_mav_put_uint8_t(buf, 32, frame);
+	_mav_put_uint8_t(buf, 33, current);
+	_mav_put_uint8_t(buf, 34, autocontinue);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_INT, buf, MAVLINK_MSG_ID_COMMAND_INT_LEN, MAVLINK_MSG_ID_COMMAND_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_INT, buf, MAVLINK_MSG_ID_COMMAND_INT_LEN);
+#endif
+#else
+	mavlink_command_int_t *packet = (mavlink_command_int_t *)msgbuf;
+	packet->param1 = param1;
+	packet->param2 = param2;
+	packet->param3 = param3;
+	packet->param4 = param4;
+	packet->x = x;
+	packet->y = y;
+	packet->z = z;
+	packet->command = command;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+	packet->frame = frame;
+	packet->current = current;
+	packet->autocontinue = autocontinue;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_INT, (const char *)packet, MAVLINK_MSG_ID_COMMAND_INT_LEN, MAVLINK_MSG_ID_COMMAND_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_INT, (const char *)packet, MAVLINK_MSG_ID_COMMAND_INT_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE COMMAND_INT UNPACKING
+
+
+/**
+ * @brief Get field target_system from command_int message
+ *
+ * @return System ID
+ */
+static inline uint8_t mavlink_msg_command_int_get_target_system(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  30);
+}
+
+/**
+ * @brief Get field target_component from command_int message
+ *
+ * @return Component ID
+ */
+static inline uint8_t mavlink_msg_command_int_get_target_component(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  31);
+}
+
+/**
+ * @brief Get field frame from command_int message
+ *
+ * @return The coordinate system of the COMMAND. see MAV_FRAME in mavlink_types.h
+ */
+static inline uint8_t mavlink_msg_command_int_get_frame(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  32);
+}
+
+/**
+ * @brief Get field command from command_int message
+ *
+ * @return The scheduled action for the mission item. see MAV_CMD in common.xml MAVLink specs
+ */
+static inline uint16_t mavlink_msg_command_int_get_command(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  28);
+}
+
+/**
+ * @brief Get field current from command_int message
+ *
+ * @return false:0, true:1
+ */
+static inline uint8_t mavlink_msg_command_int_get_current(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  33);
+}
+
+/**
+ * @brief Get field autocontinue from command_int message
+ *
+ * @return autocontinue to next wp
+ */
+static inline uint8_t mavlink_msg_command_int_get_autocontinue(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  34);
+}
+
+/**
+ * @brief Get field param1 from command_int message
+ *
+ * @return PARAM1, see MAV_CMD enum
+ */
+static inline float mavlink_msg_command_int_get_param1(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  0);
+}
+
+/**
+ * @brief Get field param2 from command_int message
+ *
+ * @return PARAM2, see MAV_CMD enum
+ */
+static inline float mavlink_msg_command_int_get_param2(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  4);
+}
+
+/**
+ * @brief Get field param3 from command_int message
+ *
+ * @return PARAM3, see MAV_CMD enum
+ */
+static inline float mavlink_msg_command_int_get_param3(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  8);
+}
+
+/**
+ * @brief Get field param4 from command_int message
+ *
+ * @return PARAM4, see MAV_CMD enum
+ */
+static inline float mavlink_msg_command_int_get_param4(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  12);
+}
+
+/**
+ * @brief Get field x from command_int message
+ *
+ * @return PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
+ */
+static inline int32_t mavlink_msg_command_int_get_x(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  16);
+}
+
+/**
+ * @brief Get field y from command_int message
+ *
+ * @return PARAM6 / local: y position in meters * 1e4, global: longitude in degrees * 10^7
+ */
+static inline int32_t mavlink_msg_command_int_get_y(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  20);
+}
+
+/**
+ * @brief Get field z from command_int message
+ *
+ * @return PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.
+ */
+static inline float mavlink_msg_command_int_get_z(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  24);
+}
+
+/**
+ * @brief Decode a command_int message into a struct
+ *
+ * @param msg The message to decode
+ * @param command_int C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_command_int_decode(const mavlink_message_t* msg, mavlink_command_int_t* command_int)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	command_int->param1 = mavlink_msg_command_int_get_param1(msg);
+	command_int->param2 = mavlink_msg_command_int_get_param2(msg);
+	command_int->param3 = mavlink_msg_command_int_get_param3(msg);
+	command_int->param4 = mavlink_msg_command_int_get_param4(msg);
+	command_int->x = mavlink_msg_command_int_get_x(msg);
+	command_int->y = mavlink_msg_command_int_get_y(msg);
+	command_int->z = mavlink_msg_command_int_get_z(msg);
+	command_int->command = mavlink_msg_command_int_get_command(msg);
+	command_int->target_system = mavlink_msg_command_int_get_target_system(msg);
+	command_int->target_component = mavlink_msg_command_int_get_target_component(msg);
+	command_int->frame = mavlink_msg_command_int_get_frame(msg);
+	command_int->current = mavlink_msg_command_int_get_current(msg);
+	command_int->autocontinue = mavlink_msg_command_int_get_autocontinue(msg);
+#else
+	memcpy(command_int, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_COMMAND_INT_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_command_long.h v1.0/common/mavlink_msg_command_long.h
--- v1.0.old/common/mavlink_msg_command_long.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_command_long.h	2015-02-06 11:50:58.000000000 +0500
@@ -20,6 +20,9 @@ typedef struct __mavlink_command_long_t
 #define MAVLINK_MSG_ID_COMMAND_LONG_LEN 33
 #define MAVLINK_MSG_ID_76_LEN 33
 
+#define MAVLINK_MSG_ID_COMMAND_LONG_CRC 152
+#define MAVLINK_MSG_ID_76_CRC 152
+
 
 
 #define MAVLINK_MESSAGE_INFO_COMMAND_LONG { \
@@ -63,7 +66,7 @@ static inline uint16_t mavlink_msg_comma
 						       uint8_t target_system, uint8_t target_component, uint16_t command, uint8_t confirmation, float param1, float param2, float param3, float param4, float param5, float param6, float param7)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[33];
+	char buf[MAVLINK_MSG_ID_COMMAND_LONG_LEN];
 	_mav_put_float(buf, 0, param1);
 	_mav_put_float(buf, 4, param2);
 	_mav_put_float(buf, 8, param3);
@@ -76,7 +79,7 @@ static inline uint16_t mavlink_msg_comma
 	_mav_put_uint8_t(buf, 31, target_component);
 	_mav_put_uint8_t(buf, 32, confirmation);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 33);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_COMMAND_LONG_LEN);
 #else
 	mavlink_command_long_t packet;
 	packet.param1 = param1;
@@ -91,18 +94,22 @@ static inline uint16_t mavlink_msg_comma
 	packet.target_component = target_component;
 	packet.confirmation = confirmation;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 33);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_COMMAND_LONG_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_COMMAND_LONG;
-	return mavlink_finalize_message(msg, system_id, component_id, 33, 152);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_COMMAND_LONG_LEN, MAVLINK_MSG_ID_COMMAND_LONG_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_COMMAND_LONG_LEN);
+#endif
 }
 
 /**
  * @brief Pack a command_long message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system System which should execute the command
  * @param target_component Component which should execute the command, 0 for all components
@@ -122,7 +129,7 @@ static inline uint16_t mavlink_msg_comma
 						           uint8_t target_system,uint8_t target_component,uint16_t command,uint8_t confirmation,float param1,float param2,float param3,float param4,float param5,float param6,float param7)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[33];
+	char buf[MAVLINK_MSG_ID_COMMAND_LONG_LEN];
 	_mav_put_float(buf, 0, param1);
 	_mav_put_float(buf, 4, param2);
 	_mav_put_float(buf, 8, param3);
@@ -135,7 +142,7 @@ static inline uint16_t mavlink_msg_comma
 	_mav_put_uint8_t(buf, 31, target_component);
 	_mav_put_uint8_t(buf, 32, confirmation);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 33);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_COMMAND_LONG_LEN);
 #else
 	mavlink_command_long_t packet;
 	packet.param1 = param1;
@@ -150,15 +157,19 @@ static inline uint16_t mavlink_msg_comma
 	packet.target_component = target_component;
 	packet.confirmation = confirmation;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 33);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_COMMAND_LONG_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_COMMAND_LONG;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 33, 152);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_COMMAND_LONG_LEN, MAVLINK_MSG_ID_COMMAND_LONG_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_COMMAND_LONG_LEN);
+#endif
 }
 
 /**
- * @brief Encode a command_long struct into a message
+ * @brief Encode a command_long struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -171,6 +182,20 @@ static inline uint16_t mavlink_msg_comma
 }
 
 /**
+ * @brief Encode a command_long struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param command_long C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_command_long_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_command_long_t* command_long)
+{
+	return mavlink_msg_command_long_pack_chan(system_id, component_id, chan, msg, command_long->target_system, command_long->target_component, command_long->command, command_long->confirmation, command_long->param1, command_long->param2, command_long->param3, command_long->param4, command_long->param5, command_long->param6, command_long->param7);
+}
+
+/**
  * @brief Send a command_long message
  * @param chan MAVLink channel to send the message
  *
@@ -191,7 +216,7 @@ static inline uint16_t mavlink_msg_comma
 static inline void mavlink_msg_command_long_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, uint16_t command, uint8_t confirmation, float param1, float param2, float param3, float param4, float param5, float param6, float param7)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[33];
+	char buf[MAVLINK_MSG_ID_COMMAND_LONG_LEN];
 	_mav_put_float(buf, 0, param1);
 	_mav_put_float(buf, 4, param2);
 	_mav_put_float(buf, 8, param3);
@@ -204,7 +229,11 @@ static inline void mavlink_msg_command_l
 	_mav_put_uint8_t(buf, 31, target_component);
 	_mav_put_uint8_t(buf, 32, confirmation);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_LONG, buf, 33, 152);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_LONG, buf, MAVLINK_MSG_ID_COMMAND_LONG_LEN, MAVLINK_MSG_ID_COMMAND_LONG_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_LONG, buf, MAVLINK_MSG_ID_COMMAND_LONG_LEN);
+#endif
 #else
 	mavlink_command_long_t packet;
 	packet.param1 = param1;
@@ -219,9 +248,65 @@ static inline void mavlink_msg_command_l
 	packet.target_component = target_component;
 	packet.confirmation = confirmation;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_LONG, (const char *)&packet, 33, 152);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_LONG, (const char *)&packet, MAVLINK_MSG_ID_COMMAND_LONG_LEN, MAVLINK_MSG_ID_COMMAND_LONG_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_LONG, (const char *)&packet, MAVLINK_MSG_ID_COMMAND_LONG_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_COMMAND_LONG_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_command_long_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, uint16_t command, uint8_t confirmation, float param1, float param2, float param3, float param4, float param5, float param6, float param7)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_float(buf, 0, param1);
+	_mav_put_float(buf, 4, param2);
+	_mav_put_float(buf, 8, param3);
+	_mav_put_float(buf, 12, param4);
+	_mav_put_float(buf, 16, param5);
+	_mav_put_float(buf, 20, param6);
+	_mav_put_float(buf, 24, param7);
+	_mav_put_uint16_t(buf, 28, command);
+	_mav_put_uint8_t(buf, 30, target_system);
+	_mav_put_uint8_t(buf, 31, target_component);
+	_mav_put_uint8_t(buf, 32, confirmation);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_LONG, buf, MAVLINK_MSG_ID_COMMAND_LONG_LEN, MAVLINK_MSG_ID_COMMAND_LONG_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_LONG, buf, MAVLINK_MSG_ID_COMMAND_LONG_LEN);
+#endif
+#else
+	mavlink_command_long_t *packet = (mavlink_command_long_t *)msgbuf;
+	packet->param1 = param1;
+	packet->param2 = param2;
+	packet->param3 = param3;
+	packet->param4 = param4;
+	packet->param5 = param5;
+	packet->param6 = param6;
+	packet->param7 = param7;
+	packet->command = command;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+	packet->confirmation = confirmation;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_LONG, (const char *)packet, MAVLINK_MSG_ID_COMMAND_LONG_LEN, MAVLINK_MSG_ID_COMMAND_LONG_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_COMMAND_LONG, (const char *)packet, MAVLINK_MSG_ID_COMMAND_LONG_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -359,6 +444,6 @@ static inline void mavlink_msg_command_l
 	command_long->target_component = mavlink_msg_command_long_get_target_component(msg);
 	command_long->confirmation = mavlink_msg_command_long_get_confirmation(msg);
 #else
-	memcpy(command_long, _MAV_PAYLOAD(msg), 33);
+	memcpy(command_long, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_COMMAND_LONG_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_data_stream.h v1.0/common/mavlink_msg_data_stream.h
--- v1.0.old/common/mavlink_msg_data_stream.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_data_stream.h	2015-02-06 11:50:58.000000000 +0500
@@ -12,6 +12,9 @@ typedef struct __mavlink_data_stream_t
 #define MAVLINK_MSG_ID_DATA_STREAM_LEN 4
 #define MAVLINK_MSG_ID_67_LEN 4
 
+#define MAVLINK_MSG_ID_DATA_STREAM_CRC 21
+#define MAVLINK_MSG_ID_67_CRC 21
+
 
 
 #define MAVLINK_MESSAGE_INFO_DATA_STREAM { \
@@ -39,30 +42,34 @@ static inline uint16_t mavlink_msg_data_
 						       uint8_t stream_id, uint16_t message_rate, uint8_t on_off)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[4];
+	char buf[MAVLINK_MSG_ID_DATA_STREAM_LEN];
 	_mav_put_uint16_t(buf, 0, message_rate);
 	_mav_put_uint8_t(buf, 2, stream_id);
 	_mav_put_uint8_t(buf, 3, on_off);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_DATA_STREAM_LEN);
 #else
 	mavlink_data_stream_t packet;
 	packet.message_rate = message_rate;
 	packet.stream_id = stream_id;
 	packet.on_off = on_off;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_DATA_STREAM_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_DATA_STREAM;
-	return mavlink_finalize_message(msg, system_id, component_id, 4, 21);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_DATA_STREAM_LEN, MAVLINK_MSG_ID_DATA_STREAM_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_DATA_STREAM_LEN);
+#endif
 }
 
 /**
  * @brief Pack a data_stream message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param stream_id The ID of the requested data stream
  * @param message_rate The requested interval between two messages of this type
@@ -74,27 +81,31 @@ static inline uint16_t mavlink_msg_data_
 						           uint8_t stream_id,uint16_t message_rate,uint8_t on_off)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[4];
+	char buf[MAVLINK_MSG_ID_DATA_STREAM_LEN];
 	_mav_put_uint16_t(buf, 0, message_rate);
 	_mav_put_uint8_t(buf, 2, stream_id);
 	_mav_put_uint8_t(buf, 3, on_off);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_DATA_STREAM_LEN);
 #else
 	mavlink_data_stream_t packet;
 	packet.message_rate = message_rate;
 	packet.stream_id = stream_id;
 	packet.on_off = on_off;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_DATA_STREAM_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_DATA_STREAM;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 4, 21);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_DATA_STREAM_LEN, MAVLINK_MSG_ID_DATA_STREAM_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_DATA_STREAM_LEN);
+#endif
 }
 
 /**
- * @brief Encode a data_stream struct into a message
+ * @brief Encode a data_stream struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -107,6 +118,20 @@ static inline uint16_t mavlink_msg_data_
 }
 
 /**
+ * @brief Encode a data_stream struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param data_stream C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_data_stream_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_data_stream_t* data_stream)
+{
+	return mavlink_msg_data_stream_pack_chan(system_id, component_id, chan, msg, data_stream->stream_id, data_stream->message_rate, data_stream->on_off);
+}
+
+/**
  * @brief Send a data_stream message
  * @param chan MAVLink channel to send the message
  *
@@ -119,21 +144,65 @@ static inline uint16_t mavlink_msg_data_
 static inline void mavlink_msg_data_stream_send(mavlink_channel_t chan, uint8_t stream_id, uint16_t message_rate, uint8_t on_off)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[4];
+	char buf[MAVLINK_MSG_ID_DATA_STREAM_LEN];
 	_mav_put_uint16_t(buf, 0, message_rate);
 	_mav_put_uint8_t(buf, 2, stream_id);
 	_mav_put_uint8_t(buf, 3, on_off);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_STREAM, buf, 4, 21);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_STREAM, buf, MAVLINK_MSG_ID_DATA_STREAM_LEN, MAVLINK_MSG_ID_DATA_STREAM_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_STREAM, buf, MAVLINK_MSG_ID_DATA_STREAM_LEN);
+#endif
 #else
 	mavlink_data_stream_t packet;
 	packet.message_rate = message_rate;
 	packet.stream_id = stream_id;
 	packet.on_off = on_off;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_STREAM, (const char *)&packet, 4, 21);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_STREAM, (const char *)&packet, MAVLINK_MSG_ID_DATA_STREAM_LEN, MAVLINK_MSG_ID_DATA_STREAM_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_STREAM, (const char *)&packet, MAVLINK_MSG_ID_DATA_STREAM_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_DATA_STREAM_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_data_stream_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t stream_id, uint16_t message_rate, uint8_t on_off)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint16_t(buf, 0, message_rate);
+	_mav_put_uint8_t(buf, 2, stream_id);
+	_mav_put_uint8_t(buf, 3, on_off);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_STREAM, buf, MAVLINK_MSG_ID_DATA_STREAM_LEN, MAVLINK_MSG_ID_DATA_STREAM_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_STREAM, buf, MAVLINK_MSG_ID_DATA_STREAM_LEN);
+#endif
+#else
+	mavlink_data_stream_t *packet = (mavlink_data_stream_t *)msgbuf;
+	packet->message_rate = message_rate;
+	packet->stream_id = stream_id;
+	packet->on_off = on_off;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_STREAM, (const char *)packet, MAVLINK_MSG_ID_DATA_STREAM_LEN, MAVLINK_MSG_ID_DATA_STREAM_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_STREAM, (const char *)packet, MAVLINK_MSG_ID_DATA_STREAM_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -183,6 +252,6 @@ static inline void mavlink_msg_data_stre
 	data_stream->stream_id = mavlink_msg_data_stream_get_stream_id(msg);
 	data_stream->on_off = mavlink_msg_data_stream_get_on_off(msg);
 #else
-	memcpy(data_stream, _MAV_PAYLOAD(msg), 4);
+	memcpy(data_stream, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_DATA_STREAM_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_data_transmission_handshake.h v1.0/common/mavlink_msg_data_transmission_handshake.h
--- v1.0.old/common/mavlink_msg_data_transmission_handshake.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_data_transmission_handshake.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,353 @@
+// MESSAGE DATA_TRANSMISSION_HANDSHAKE PACKING
+
+#define MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE 130
+
+typedef struct __mavlink_data_transmission_handshake_t
+{
+ uint32_t size; ///< total data size in bytes (set on ACK only)
+ uint16_t width; ///< Width of a matrix or image
+ uint16_t height; ///< Height of a matrix or image
+ uint16_t packets; ///< number of packets beeing sent (set on ACK only)
+ uint8_t type; ///< type of requested/acknowledged data (as defined in ENUM DATA_TYPES in mavlink/include/mavlink_types.h)
+ uint8_t payload; ///< payload size per packet (normally 253 byte, see DATA field size in message ENCAPSULATED_DATA) (set on ACK only)
+ uint8_t jpg_quality; ///< JPEG quality out of [1,100]
+} mavlink_data_transmission_handshake_t;
+
+#define MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN 13
+#define MAVLINK_MSG_ID_130_LEN 13
+
+#define MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_CRC 29
+#define MAVLINK_MSG_ID_130_CRC 29
+
+
+
+#define MAVLINK_MESSAGE_INFO_DATA_TRANSMISSION_HANDSHAKE { \
+	"DATA_TRANSMISSION_HANDSHAKE", \
+	7, \
+	{  { "size", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_data_transmission_handshake_t, size) }, \
+         { "width", NULL, MAVLINK_TYPE_UINT16_T, 0, 4, offsetof(mavlink_data_transmission_handshake_t, width) }, \
+         { "height", NULL, MAVLINK_TYPE_UINT16_T, 0, 6, offsetof(mavlink_data_transmission_handshake_t, height) }, \
+         { "packets", NULL, MAVLINK_TYPE_UINT16_T, 0, 8, offsetof(mavlink_data_transmission_handshake_t, packets) }, \
+         { "type", NULL, MAVLINK_TYPE_UINT8_T, 0, 10, offsetof(mavlink_data_transmission_handshake_t, type) }, \
+         { "payload", NULL, MAVLINK_TYPE_UINT8_T, 0, 11, offsetof(mavlink_data_transmission_handshake_t, payload) }, \
+         { "jpg_quality", NULL, MAVLINK_TYPE_UINT8_T, 0, 12, offsetof(mavlink_data_transmission_handshake_t, jpg_quality) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a data_transmission_handshake message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param type type of requested/acknowledged data (as defined in ENUM DATA_TYPES in mavlink/include/mavlink_types.h)
+ * @param size total data size in bytes (set on ACK only)
+ * @param width Width of a matrix or image
+ * @param height Height of a matrix or image
+ * @param packets number of packets beeing sent (set on ACK only)
+ * @param payload payload size per packet (normally 253 byte, see DATA field size in message ENCAPSULATED_DATA) (set on ACK only)
+ * @param jpg_quality JPEG quality out of [1,100]
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_data_transmission_handshake_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint8_t type, uint32_t size, uint16_t width, uint16_t height, uint16_t packets, uint8_t payload, uint8_t jpg_quality)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN];
+	_mav_put_uint32_t(buf, 0, size);
+	_mav_put_uint16_t(buf, 4, width);
+	_mav_put_uint16_t(buf, 6, height);
+	_mav_put_uint16_t(buf, 8, packets);
+	_mav_put_uint8_t(buf, 10, type);
+	_mav_put_uint8_t(buf, 11, payload);
+	_mav_put_uint8_t(buf, 12, jpg_quality);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN);
+#else
+	mavlink_data_transmission_handshake_t packet;
+	packet.size = size;
+	packet.width = width;
+	packet.height = height;
+	packet.packets = packets;
+	packet.type = type;
+	packet.payload = payload;
+	packet.jpg_quality = jpg_quality;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a data_transmission_handshake message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param type type of requested/acknowledged data (as defined in ENUM DATA_TYPES in mavlink/include/mavlink_types.h)
+ * @param size total data size in bytes (set on ACK only)
+ * @param width Width of a matrix or image
+ * @param height Height of a matrix or image
+ * @param packets number of packets beeing sent (set on ACK only)
+ * @param payload payload size per packet (normally 253 byte, see DATA field size in message ENCAPSULATED_DATA) (set on ACK only)
+ * @param jpg_quality JPEG quality out of [1,100]
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_data_transmission_handshake_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint8_t type,uint32_t size,uint16_t width,uint16_t height,uint16_t packets,uint8_t payload,uint8_t jpg_quality)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN];
+	_mav_put_uint32_t(buf, 0, size);
+	_mav_put_uint16_t(buf, 4, width);
+	_mav_put_uint16_t(buf, 6, height);
+	_mav_put_uint16_t(buf, 8, packets);
+	_mav_put_uint8_t(buf, 10, type);
+	_mav_put_uint8_t(buf, 11, payload);
+	_mav_put_uint8_t(buf, 12, jpg_quality);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN);
+#else
+	mavlink_data_transmission_handshake_t packet;
+	packet.size = size;
+	packet.width = width;
+	packet.height = height;
+	packet.packets = packets;
+	packet.type = type;
+	packet.payload = payload;
+	packet.jpg_quality = jpg_quality;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a data_transmission_handshake struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param data_transmission_handshake C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_data_transmission_handshake_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_data_transmission_handshake_t* data_transmission_handshake)
+{
+	return mavlink_msg_data_transmission_handshake_pack(system_id, component_id, msg, data_transmission_handshake->type, data_transmission_handshake->size, data_transmission_handshake->width, data_transmission_handshake->height, data_transmission_handshake->packets, data_transmission_handshake->payload, data_transmission_handshake->jpg_quality);
+}
+
+/**
+ * @brief Encode a data_transmission_handshake struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param data_transmission_handshake C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_data_transmission_handshake_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_data_transmission_handshake_t* data_transmission_handshake)
+{
+	return mavlink_msg_data_transmission_handshake_pack_chan(system_id, component_id, chan, msg, data_transmission_handshake->type, data_transmission_handshake->size, data_transmission_handshake->width, data_transmission_handshake->height, data_transmission_handshake->packets, data_transmission_handshake->payload, data_transmission_handshake->jpg_quality);
+}
+
+/**
+ * @brief Send a data_transmission_handshake message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param type type of requested/acknowledged data (as defined in ENUM DATA_TYPES in mavlink/include/mavlink_types.h)
+ * @param size total data size in bytes (set on ACK only)
+ * @param width Width of a matrix or image
+ * @param height Height of a matrix or image
+ * @param packets number of packets beeing sent (set on ACK only)
+ * @param payload payload size per packet (normally 253 byte, see DATA field size in message ENCAPSULATED_DATA) (set on ACK only)
+ * @param jpg_quality JPEG quality out of [1,100]
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_data_transmission_handshake_send(mavlink_channel_t chan, uint8_t type, uint32_t size, uint16_t width, uint16_t height, uint16_t packets, uint8_t payload, uint8_t jpg_quality)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN];
+	_mav_put_uint32_t(buf, 0, size);
+	_mav_put_uint16_t(buf, 4, width);
+	_mav_put_uint16_t(buf, 6, height);
+	_mav_put_uint16_t(buf, 8, packets);
+	_mav_put_uint8_t(buf, 10, type);
+	_mav_put_uint8_t(buf, 11, payload);
+	_mav_put_uint8_t(buf, 12, jpg_quality);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE, buf, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE, buf, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN);
+#endif
+#else
+	mavlink_data_transmission_handshake_t packet;
+	packet.size = size;
+	packet.width = width;
+	packet.height = height;
+	packet.packets = packets;
+	packet.type = type;
+	packet.payload = payload;
+	packet.jpg_quality = jpg_quality;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE, (const char *)&packet, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE, (const char *)&packet, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_data_transmission_handshake_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t type, uint32_t size, uint16_t width, uint16_t height, uint16_t packets, uint8_t payload, uint8_t jpg_quality)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, size);
+	_mav_put_uint16_t(buf, 4, width);
+	_mav_put_uint16_t(buf, 6, height);
+	_mav_put_uint16_t(buf, 8, packets);
+	_mav_put_uint8_t(buf, 10, type);
+	_mav_put_uint8_t(buf, 11, payload);
+	_mav_put_uint8_t(buf, 12, jpg_quality);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE, buf, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE, buf, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN);
+#endif
+#else
+	mavlink_data_transmission_handshake_t *packet = (mavlink_data_transmission_handshake_t *)msgbuf;
+	packet->size = size;
+	packet->width = width;
+	packet->height = height;
+	packet->packets = packets;
+	packet->type = type;
+	packet->payload = payload;
+	packet->jpg_quality = jpg_quality;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE, (const char *)packet, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE, (const char *)packet, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE DATA_TRANSMISSION_HANDSHAKE UNPACKING
+
+
+/**
+ * @brief Get field type from data_transmission_handshake message
+ *
+ * @return type of requested/acknowledged data (as defined in ENUM DATA_TYPES in mavlink/include/mavlink_types.h)
+ */
+static inline uint8_t mavlink_msg_data_transmission_handshake_get_type(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  10);
+}
+
+/**
+ * @brief Get field size from data_transmission_handshake message
+ *
+ * @return total data size in bytes (set on ACK only)
+ */
+static inline uint32_t mavlink_msg_data_transmission_handshake_get_size(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field width from data_transmission_handshake message
+ *
+ * @return Width of a matrix or image
+ */
+static inline uint16_t mavlink_msg_data_transmission_handshake_get_width(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  4);
+}
+
+/**
+ * @brief Get field height from data_transmission_handshake message
+ *
+ * @return Height of a matrix or image
+ */
+static inline uint16_t mavlink_msg_data_transmission_handshake_get_height(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  6);
+}
+
+/**
+ * @brief Get field packets from data_transmission_handshake message
+ *
+ * @return number of packets beeing sent (set on ACK only)
+ */
+static inline uint16_t mavlink_msg_data_transmission_handshake_get_packets(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  8);
+}
+
+/**
+ * @brief Get field payload from data_transmission_handshake message
+ *
+ * @return payload size per packet (normally 253 byte, see DATA field size in message ENCAPSULATED_DATA) (set on ACK only)
+ */
+static inline uint8_t mavlink_msg_data_transmission_handshake_get_payload(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  11);
+}
+
+/**
+ * @brief Get field jpg_quality from data_transmission_handshake message
+ *
+ * @return JPEG quality out of [1,100]
+ */
+static inline uint8_t mavlink_msg_data_transmission_handshake_get_jpg_quality(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  12);
+}
+
+/**
+ * @brief Decode a data_transmission_handshake message into a struct
+ *
+ * @param msg The message to decode
+ * @param data_transmission_handshake C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_data_transmission_handshake_decode(const mavlink_message_t* msg, mavlink_data_transmission_handshake_t* data_transmission_handshake)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	data_transmission_handshake->size = mavlink_msg_data_transmission_handshake_get_size(msg);
+	data_transmission_handshake->width = mavlink_msg_data_transmission_handshake_get_width(msg);
+	data_transmission_handshake->height = mavlink_msg_data_transmission_handshake_get_height(msg);
+	data_transmission_handshake->packets = mavlink_msg_data_transmission_handshake_get_packets(msg);
+	data_transmission_handshake->type = mavlink_msg_data_transmission_handshake_get_type(msg);
+	data_transmission_handshake->payload = mavlink_msg_data_transmission_handshake_get_payload(msg);
+	data_transmission_handshake->jpg_quality = mavlink_msg_data_transmission_handshake_get_jpg_quality(msg);
+#else
+	memcpy(data_transmission_handshake, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_debug.h v1.0/common/mavlink_msg_debug.h
--- v1.0.old/common/mavlink_msg_debug.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_debug.h	2015-02-06 11:50:58.000000000 +0500
@@ -12,6 +12,9 @@ typedef struct __mavlink_debug_t
 #define MAVLINK_MSG_ID_DEBUG_LEN 9
 #define MAVLINK_MSG_ID_254_LEN 9
 
+#define MAVLINK_MSG_ID_DEBUG_CRC 46
+#define MAVLINK_MSG_ID_254_CRC 46
+
 
 
 #define MAVLINK_MESSAGE_INFO_DEBUG { \
@@ -39,30 +42,34 @@ static inline uint16_t mavlink_msg_debug
 						       uint32_t time_boot_ms, uint8_t ind, float value)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[9];
+	char buf[MAVLINK_MSG_ID_DEBUG_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, value);
 	_mav_put_uint8_t(buf, 8, ind);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 9);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_DEBUG_LEN);
 #else
 	mavlink_debug_t packet;
 	packet.time_boot_ms = time_boot_ms;
 	packet.value = value;
 	packet.ind = ind;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 9);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_DEBUG_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_DEBUG;
-	return mavlink_finalize_message(msg, system_id, component_id, 9, 46);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_DEBUG_LEN, MAVLINK_MSG_ID_DEBUG_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_DEBUG_LEN);
+#endif
 }
 
 /**
  * @brief Pack a debug message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_boot_ms Timestamp (milliseconds since system boot)
  * @param ind index of debug variable
@@ -74,27 +81,31 @@ static inline uint16_t mavlink_msg_debug
 						           uint32_t time_boot_ms,uint8_t ind,float value)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[9];
+	char buf[MAVLINK_MSG_ID_DEBUG_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, value);
 	_mav_put_uint8_t(buf, 8, ind);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 9);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_DEBUG_LEN);
 #else
 	mavlink_debug_t packet;
 	packet.time_boot_ms = time_boot_ms;
 	packet.value = value;
 	packet.ind = ind;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 9);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_DEBUG_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_DEBUG;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 9, 46);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_DEBUG_LEN, MAVLINK_MSG_ID_DEBUG_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_DEBUG_LEN);
+#endif
 }
 
 /**
- * @brief Encode a debug struct into a message
+ * @brief Encode a debug struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -107,6 +118,20 @@ static inline uint16_t mavlink_msg_debug
 }
 
 /**
+ * @brief Encode a debug struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param debug C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_debug_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_debug_t* debug)
+{
+	return mavlink_msg_debug_pack_chan(system_id, component_id, chan, msg, debug->time_boot_ms, debug->ind, debug->value);
+}
+
+/**
  * @brief Send a debug message
  * @param chan MAVLink channel to send the message
  *
@@ -119,21 +144,65 @@ static inline uint16_t mavlink_msg_debug
 static inline void mavlink_msg_debug_send(mavlink_channel_t chan, uint32_t time_boot_ms, uint8_t ind, float value)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[9];
+	char buf[MAVLINK_MSG_ID_DEBUG_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, value);
 	_mav_put_uint8_t(buf, 8, ind);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG, buf, 9, 46);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG, buf, MAVLINK_MSG_ID_DEBUG_LEN, MAVLINK_MSG_ID_DEBUG_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG, buf, MAVLINK_MSG_ID_DEBUG_LEN);
+#endif
 #else
 	mavlink_debug_t packet;
 	packet.time_boot_ms = time_boot_ms;
 	packet.value = value;
 	packet.ind = ind;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG, (const char *)&packet, 9, 46);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG, (const char *)&packet, MAVLINK_MSG_ID_DEBUG_LEN, MAVLINK_MSG_ID_DEBUG_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG, (const char *)&packet, MAVLINK_MSG_ID_DEBUG_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_DEBUG_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_debug_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, uint8_t ind, float value)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, value);
+	_mav_put_uint8_t(buf, 8, ind);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG, buf, MAVLINK_MSG_ID_DEBUG_LEN, MAVLINK_MSG_ID_DEBUG_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG, buf, MAVLINK_MSG_ID_DEBUG_LEN);
+#endif
+#else
+	mavlink_debug_t *packet = (mavlink_debug_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->value = value;
+	packet->ind = ind;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG, (const char *)packet, MAVLINK_MSG_ID_DEBUG_LEN, MAVLINK_MSG_ID_DEBUG_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG, (const char *)packet, MAVLINK_MSG_ID_DEBUG_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -183,6 +252,6 @@ static inline void mavlink_msg_debug_dec
 	debug->value = mavlink_msg_debug_get_value(msg);
 	debug->ind = mavlink_msg_debug_get_ind(msg);
 #else
-	memcpy(debug, _MAV_PAYLOAD(msg), 9);
+	memcpy(debug, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_DEBUG_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_debug_vect.h v1.0/common/mavlink_msg_debug_vect.h
--- v1.0.old/common/mavlink_msg_debug_vect.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_debug_vect.h	2015-02-06 11:50:58.000000000 +0500
@@ -14,6 +14,9 @@ typedef struct __mavlink_debug_vect_t
 #define MAVLINK_MSG_ID_DEBUG_VECT_LEN 30
 #define MAVLINK_MSG_ID_250_LEN 30
 
+#define MAVLINK_MSG_ID_DEBUG_VECT_CRC 49
+#define MAVLINK_MSG_ID_250_CRC 49
+
 #define MAVLINK_MSG_DEBUG_VECT_FIELD_NAME_LEN 10
 
 #define MAVLINK_MESSAGE_INFO_DEBUG_VECT { \
@@ -45,13 +48,13 @@ static inline uint16_t mavlink_msg_debug
 						       const char *name, uint64_t time_usec, float x, float y, float z)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[30];
+	char buf[MAVLINK_MSG_ID_DEBUG_VECT_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_float(buf, 8, x);
 	_mav_put_float(buf, 12, y);
 	_mav_put_float(buf, 16, z);
 	_mav_put_char_array(buf, 20, name, 10);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 30);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_DEBUG_VECT_LEN);
 #else
 	mavlink_debug_vect_t packet;
 	packet.time_usec = time_usec;
@@ -59,18 +62,22 @@ static inline uint16_t mavlink_msg_debug
 	packet.y = y;
 	packet.z = z;
 	mav_array_memcpy(packet.name, name, sizeof(char)*10);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 30);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_DEBUG_VECT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_DEBUG_VECT;
-	return mavlink_finalize_message(msg, system_id, component_id, 30, 49);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_DEBUG_VECT_LEN, MAVLINK_MSG_ID_DEBUG_VECT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_DEBUG_VECT_LEN);
+#endif
 }
 
 /**
  * @brief Pack a debug_vect message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param name Name
  * @param time_usec Timestamp
@@ -84,13 +91,13 @@ static inline uint16_t mavlink_msg_debug
 						           const char *name,uint64_t time_usec,float x,float y,float z)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[30];
+	char buf[MAVLINK_MSG_ID_DEBUG_VECT_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_float(buf, 8, x);
 	_mav_put_float(buf, 12, y);
 	_mav_put_float(buf, 16, z);
 	_mav_put_char_array(buf, 20, name, 10);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 30);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_DEBUG_VECT_LEN);
 #else
 	mavlink_debug_vect_t packet;
 	packet.time_usec = time_usec;
@@ -98,15 +105,19 @@ static inline uint16_t mavlink_msg_debug
 	packet.y = y;
 	packet.z = z;
 	mav_array_memcpy(packet.name, name, sizeof(char)*10);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 30);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_DEBUG_VECT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_DEBUG_VECT;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 30, 49);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_DEBUG_VECT_LEN, MAVLINK_MSG_ID_DEBUG_VECT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_DEBUG_VECT_LEN);
+#endif
 }
 
 /**
- * @brief Encode a debug_vect struct into a message
+ * @brief Encode a debug_vect struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -119,6 +130,20 @@ static inline uint16_t mavlink_msg_debug
 }
 
 /**
+ * @brief Encode a debug_vect struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param debug_vect C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_debug_vect_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_debug_vect_t* debug_vect)
+{
+	return mavlink_msg_debug_vect_pack_chan(system_id, component_id, chan, msg, debug_vect->name, debug_vect->time_usec, debug_vect->x, debug_vect->y, debug_vect->z);
+}
+
+/**
  * @brief Send a debug_vect message
  * @param chan MAVLink channel to send the message
  *
@@ -133,13 +158,17 @@ static inline uint16_t mavlink_msg_debug
 static inline void mavlink_msg_debug_vect_send(mavlink_channel_t chan, const char *name, uint64_t time_usec, float x, float y, float z)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[30];
+	char buf[MAVLINK_MSG_ID_DEBUG_VECT_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_float(buf, 8, x);
 	_mav_put_float(buf, 12, y);
 	_mav_put_float(buf, 16, z);
 	_mav_put_char_array(buf, 20, name, 10);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG_VECT, buf, 30, 49);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG_VECT, buf, MAVLINK_MSG_ID_DEBUG_VECT_LEN, MAVLINK_MSG_ID_DEBUG_VECT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG_VECT, buf, MAVLINK_MSG_ID_DEBUG_VECT_LEN);
+#endif
 #else
 	mavlink_debug_vect_t packet;
 	packet.time_usec = time_usec;
@@ -147,9 +176,51 @@ static inline void mavlink_msg_debug_vec
 	packet.y = y;
 	packet.z = z;
 	mav_array_memcpy(packet.name, name, sizeof(char)*10);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG_VECT, (const char *)&packet, 30, 49);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG_VECT, (const char *)&packet, MAVLINK_MSG_ID_DEBUG_VECT_LEN, MAVLINK_MSG_ID_DEBUG_VECT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG_VECT, (const char *)&packet, MAVLINK_MSG_ID_DEBUG_VECT_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_DEBUG_VECT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_debug_vect_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  const char *name, uint64_t time_usec, float x, float y, float z)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_float(buf, 8, x);
+	_mav_put_float(buf, 12, y);
+	_mav_put_float(buf, 16, z);
+	_mav_put_char_array(buf, 20, name, 10);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG_VECT, buf, MAVLINK_MSG_ID_DEBUG_VECT_LEN, MAVLINK_MSG_ID_DEBUG_VECT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG_VECT, buf, MAVLINK_MSG_ID_DEBUG_VECT_LEN);
+#endif
+#else
+	mavlink_debug_vect_t *packet = (mavlink_debug_vect_t *)msgbuf;
+	packet->time_usec = time_usec;
+	packet->x = x;
+	packet->y = y;
+	packet->z = z;
+	mav_array_memcpy(packet->name, name, sizeof(char)*10);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG_VECT, (const char *)packet, MAVLINK_MSG_ID_DEBUG_VECT_LEN, MAVLINK_MSG_ID_DEBUG_VECT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DEBUG_VECT, (const char *)packet, MAVLINK_MSG_ID_DEBUG_VECT_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -221,6 +292,6 @@ static inline void mavlink_msg_debug_vec
 	debug_vect->z = mavlink_msg_debug_vect_get_z(msg);
 	mavlink_msg_debug_vect_get_name(msg, debug_vect->name);
 #else
-	memcpy(debug_vect, _MAV_PAYLOAD(msg), 30);
+	memcpy(debug_vect, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_DEBUG_VECT_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_distance_sensor.h v1.0/common/mavlink_msg_distance_sensor.h
--- v1.0.old/common/mavlink_msg_distance_sensor.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_distance_sensor.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,377 @@
+// MESSAGE DISTANCE_SENSOR PACKING
+
+#define MAVLINK_MSG_ID_DISTANCE_SENSOR 132
+
+typedef struct __mavlink_distance_sensor_t
+{
+ uint32_t time_boot_ms; ///< Time since system boot
+ uint16_t min_distance; ///< Minimum distance the sensor can measure in centimeters
+ uint16_t max_distance; ///< Maximum distance the sensor can measure in centimeters
+ uint16_t current_distance; ///< Current distance reading
+ uint8_t type; ///< Type from MAV_DISTANCE_SENSOR enum.
+ uint8_t id; ///< Onboard ID of the sensor
+ uint8_t orientation; ///< Direction the sensor faces from FIXME enum.
+ uint8_t covariance; ///< Measurement covariance in centimeters, 0 for unknown / invalid readings
+} mavlink_distance_sensor_t;
+
+#define MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN 14
+#define MAVLINK_MSG_ID_132_LEN 14
+
+#define MAVLINK_MSG_ID_DISTANCE_SENSOR_CRC 85
+#define MAVLINK_MSG_ID_132_CRC 85
+
+
+
+#define MAVLINK_MESSAGE_INFO_DISTANCE_SENSOR { \
+	"DISTANCE_SENSOR", \
+	8, \
+	{  { "time_boot_ms", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_distance_sensor_t, time_boot_ms) }, \
+         { "min_distance", NULL, MAVLINK_TYPE_UINT16_T, 0, 4, offsetof(mavlink_distance_sensor_t, min_distance) }, \
+         { "max_distance", NULL, MAVLINK_TYPE_UINT16_T, 0, 6, offsetof(mavlink_distance_sensor_t, max_distance) }, \
+         { "current_distance", NULL, MAVLINK_TYPE_UINT16_T, 0, 8, offsetof(mavlink_distance_sensor_t, current_distance) }, \
+         { "type", NULL, MAVLINK_TYPE_UINT8_T, 0, 10, offsetof(mavlink_distance_sensor_t, type) }, \
+         { "id", NULL, MAVLINK_TYPE_UINT8_T, 0, 11, offsetof(mavlink_distance_sensor_t, id) }, \
+         { "orientation", NULL, MAVLINK_TYPE_UINT8_T, 0, 12, offsetof(mavlink_distance_sensor_t, orientation) }, \
+         { "covariance", NULL, MAVLINK_TYPE_UINT8_T, 0, 13, offsetof(mavlink_distance_sensor_t, covariance) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a distance_sensor message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_boot_ms Time since system boot
+ * @param min_distance Minimum distance the sensor can measure in centimeters
+ * @param max_distance Maximum distance the sensor can measure in centimeters
+ * @param current_distance Current distance reading
+ * @param type Type from MAV_DISTANCE_SENSOR enum.
+ * @param id Onboard ID of the sensor
+ * @param orientation Direction the sensor faces from FIXME enum.
+ * @param covariance Measurement covariance in centimeters, 0 for unknown / invalid readings
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_distance_sensor_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint32_t time_boot_ms, uint16_t min_distance, uint16_t max_distance, uint16_t current_distance, uint8_t type, uint8_t id, uint8_t orientation, uint8_t covariance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_uint16_t(buf, 4, min_distance);
+	_mav_put_uint16_t(buf, 6, max_distance);
+	_mav_put_uint16_t(buf, 8, current_distance);
+	_mav_put_uint8_t(buf, 10, type);
+	_mav_put_uint8_t(buf, 11, id);
+	_mav_put_uint8_t(buf, 12, orientation);
+	_mav_put_uint8_t(buf, 13, covariance);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN);
+#else
+	mavlink_distance_sensor_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.min_distance = min_distance;
+	packet.max_distance = max_distance;
+	packet.current_distance = current_distance;
+	packet.type = type;
+	packet.id = id;
+	packet.orientation = orientation;
+	packet.covariance = covariance;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_DISTANCE_SENSOR;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN, MAVLINK_MSG_ID_DISTANCE_SENSOR_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a distance_sensor message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_boot_ms Time since system boot
+ * @param min_distance Minimum distance the sensor can measure in centimeters
+ * @param max_distance Maximum distance the sensor can measure in centimeters
+ * @param current_distance Current distance reading
+ * @param type Type from MAV_DISTANCE_SENSOR enum.
+ * @param id Onboard ID of the sensor
+ * @param orientation Direction the sensor faces from FIXME enum.
+ * @param covariance Measurement covariance in centimeters, 0 for unknown / invalid readings
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_distance_sensor_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint32_t time_boot_ms,uint16_t min_distance,uint16_t max_distance,uint16_t current_distance,uint8_t type,uint8_t id,uint8_t orientation,uint8_t covariance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_uint16_t(buf, 4, min_distance);
+	_mav_put_uint16_t(buf, 6, max_distance);
+	_mav_put_uint16_t(buf, 8, current_distance);
+	_mav_put_uint8_t(buf, 10, type);
+	_mav_put_uint8_t(buf, 11, id);
+	_mav_put_uint8_t(buf, 12, orientation);
+	_mav_put_uint8_t(buf, 13, covariance);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN);
+#else
+	mavlink_distance_sensor_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.min_distance = min_distance;
+	packet.max_distance = max_distance;
+	packet.current_distance = current_distance;
+	packet.type = type;
+	packet.id = id;
+	packet.orientation = orientation;
+	packet.covariance = covariance;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_DISTANCE_SENSOR;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN, MAVLINK_MSG_ID_DISTANCE_SENSOR_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a distance_sensor struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param distance_sensor C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_distance_sensor_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_distance_sensor_t* distance_sensor)
+{
+	return mavlink_msg_distance_sensor_pack(system_id, component_id, msg, distance_sensor->time_boot_ms, distance_sensor->min_distance, distance_sensor->max_distance, distance_sensor->current_distance, distance_sensor->type, distance_sensor->id, distance_sensor->orientation, distance_sensor->covariance);
+}
+
+/**
+ * @brief Encode a distance_sensor struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param distance_sensor C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_distance_sensor_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_distance_sensor_t* distance_sensor)
+{
+	return mavlink_msg_distance_sensor_pack_chan(system_id, component_id, chan, msg, distance_sensor->time_boot_ms, distance_sensor->min_distance, distance_sensor->max_distance, distance_sensor->current_distance, distance_sensor->type, distance_sensor->id, distance_sensor->orientation, distance_sensor->covariance);
+}
+
+/**
+ * @brief Send a distance_sensor message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_boot_ms Time since system boot
+ * @param min_distance Minimum distance the sensor can measure in centimeters
+ * @param max_distance Maximum distance the sensor can measure in centimeters
+ * @param current_distance Current distance reading
+ * @param type Type from MAV_DISTANCE_SENSOR enum.
+ * @param id Onboard ID of the sensor
+ * @param orientation Direction the sensor faces from FIXME enum.
+ * @param covariance Measurement covariance in centimeters, 0 for unknown / invalid readings
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_distance_sensor_send(mavlink_channel_t chan, uint32_t time_boot_ms, uint16_t min_distance, uint16_t max_distance, uint16_t current_distance, uint8_t type, uint8_t id, uint8_t orientation, uint8_t covariance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_uint16_t(buf, 4, min_distance);
+	_mav_put_uint16_t(buf, 6, max_distance);
+	_mav_put_uint16_t(buf, 8, current_distance);
+	_mav_put_uint8_t(buf, 10, type);
+	_mav_put_uint8_t(buf, 11, id);
+	_mav_put_uint8_t(buf, 12, orientation);
+	_mav_put_uint8_t(buf, 13, covariance);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DISTANCE_SENSOR, buf, MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN, MAVLINK_MSG_ID_DISTANCE_SENSOR_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DISTANCE_SENSOR, buf, MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN);
+#endif
+#else
+	mavlink_distance_sensor_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.min_distance = min_distance;
+	packet.max_distance = max_distance;
+	packet.current_distance = current_distance;
+	packet.type = type;
+	packet.id = id;
+	packet.orientation = orientation;
+	packet.covariance = covariance;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DISTANCE_SENSOR, (const char *)&packet, MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN, MAVLINK_MSG_ID_DISTANCE_SENSOR_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DISTANCE_SENSOR, (const char *)&packet, MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_distance_sensor_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, uint16_t min_distance, uint16_t max_distance, uint16_t current_distance, uint8_t type, uint8_t id, uint8_t orientation, uint8_t covariance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_uint16_t(buf, 4, min_distance);
+	_mav_put_uint16_t(buf, 6, max_distance);
+	_mav_put_uint16_t(buf, 8, current_distance);
+	_mav_put_uint8_t(buf, 10, type);
+	_mav_put_uint8_t(buf, 11, id);
+	_mav_put_uint8_t(buf, 12, orientation);
+	_mav_put_uint8_t(buf, 13, covariance);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DISTANCE_SENSOR, buf, MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN, MAVLINK_MSG_ID_DISTANCE_SENSOR_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DISTANCE_SENSOR, buf, MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN);
+#endif
+#else
+	mavlink_distance_sensor_t *packet = (mavlink_distance_sensor_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->min_distance = min_distance;
+	packet->max_distance = max_distance;
+	packet->current_distance = current_distance;
+	packet->type = type;
+	packet->id = id;
+	packet->orientation = orientation;
+	packet->covariance = covariance;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DISTANCE_SENSOR, (const char *)packet, MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN, MAVLINK_MSG_ID_DISTANCE_SENSOR_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_DISTANCE_SENSOR, (const char *)packet, MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE DISTANCE_SENSOR UNPACKING
+
+
+/**
+ * @brief Get field time_boot_ms from distance_sensor message
+ *
+ * @return Time since system boot
+ */
+static inline uint32_t mavlink_msg_distance_sensor_get_time_boot_ms(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field min_distance from distance_sensor message
+ *
+ * @return Minimum distance the sensor can measure in centimeters
+ */
+static inline uint16_t mavlink_msg_distance_sensor_get_min_distance(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  4);
+}
+
+/**
+ * @brief Get field max_distance from distance_sensor message
+ *
+ * @return Maximum distance the sensor can measure in centimeters
+ */
+static inline uint16_t mavlink_msg_distance_sensor_get_max_distance(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  6);
+}
+
+/**
+ * @brief Get field current_distance from distance_sensor message
+ *
+ * @return Current distance reading
+ */
+static inline uint16_t mavlink_msg_distance_sensor_get_current_distance(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  8);
+}
+
+/**
+ * @brief Get field type from distance_sensor message
+ *
+ * @return Type from MAV_DISTANCE_SENSOR enum.
+ */
+static inline uint8_t mavlink_msg_distance_sensor_get_type(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  10);
+}
+
+/**
+ * @brief Get field id from distance_sensor message
+ *
+ * @return Onboard ID of the sensor
+ */
+static inline uint8_t mavlink_msg_distance_sensor_get_id(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  11);
+}
+
+/**
+ * @brief Get field orientation from distance_sensor message
+ *
+ * @return Direction the sensor faces from FIXME enum.
+ */
+static inline uint8_t mavlink_msg_distance_sensor_get_orientation(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  12);
+}
+
+/**
+ * @brief Get field covariance from distance_sensor message
+ *
+ * @return Measurement covariance in centimeters, 0 for unknown / invalid readings
+ */
+static inline uint8_t mavlink_msg_distance_sensor_get_covariance(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  13);
+}
+
+/**
+ * @brief Decode a distance_sensor message into a struct
+ *
+ * @param msg The message to decode
+ * @param distance_sensor C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_distance_sensor_decode(const mavlink_message_t* msg, mavlink_distance_sensor_t* distance_sensor)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	distance_sensor->time_boot_ms = mavlink_msg_distance_sensor_get_time_boot_ms(msg);
+	distance_sensor->min_distance = mavlink_msg_distance_sensor_get_min_distance(msg);
+	distance_sensor->max_distance = mavlink_msg_distance_sensor_get_max_distance(msg);
+	distance_sensor->current_distance = mavlink_msg_distance_sensor_get_current_distance(msg);
+	distance_sensor->type = mavlink_msg_distance_sensor_get_type(msg);
+	distance_sensor->id = mavlink_msg_distance_sensor_get_id(msg);
+	distance_sensor->orientation = mavlink_msg_distance_sensor_get_orientation(msg);
+	distance_sensor->covariance = mavlink_msg_distance_sensor_get_covariance(msg);
+#else
+	memcpy(distance_sensor, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_DISTANCE_SENSOR_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_encapsulated_data.h v1.0/common/mavlink_msg_encapsulated_data.h
--- v1.0.old/common/mavlink_msg_encapsulated_data.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_encapsulated_data.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,225 @@
+// MESSAGE ENCAPSULATED_DATA PACKING
+
+#define MAVLINK_MSG_ID_ENCAPSULATED_DATA 131
+
+typedef struct __mavlink_encapsulated_data_t
+{
+ uint16_t seqnr; ///< sequence number (starting with 0 on every transmission)
+ uint8_t data[253]; ///< image data bytes
+} mavlink_encapsulated_data_t;
+
+#define MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN 255
+#define MAVLINK_MSG_ID_131_LEN 255
+
+#define MAVLINK_MSG_ID_ENCAPSULATED_DATA_CRC 223
+#define MAVLINK_MSG_ID_131_CRC 223
+
+#define MAVLINK_MSG_ENCAPSULATED_DATA_FIELD_DATA_LEN 253
+
+#define MAVLINK_MESSAGE_INFO_ENCAPSULATED_DATA { \
+	"ENCAPSULATED_DATA", \
+	2, \
+	{  { "seqnr", NULL, MAVLINK_TYPE_UINT16_T, 0, 0, offsetof(mavlink_encapsulated_data_t, seqnr) }, \
+         { "data", NULL, MAVLINK_TYPE_UINT8_T, 253, 2, offsetof(mavlink_encapsulated_data_t, data) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a encapsulated_data message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param seqnr sequence number (starting with 0 on every transmission)
+ * @param data image data bytes
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_encapsulated_data_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint16_t seqnr, const uint8_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN];
+	_mav_put_uint16_t(buf, 0, seqnr);
+	_mav_put_uint8_t_array(buf, 2, data, 253);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN);
+#else
+	mavlink_encapsulated_data_t packet;
+	packet.seqnr = seqnr;
+	mav_array_memcpy(packet.data, data, sizeof(uint8_t)*253);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_ENCAPSULATED_DATA;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN, MAVLINK_MSG_ID_ENCAPSULATED_DATA_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a encapsulated_data message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param seqnr sequence number (starting with 0 on every transmission)
+ * @param data image data bytes
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_encapsulated_data_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint16_t seqnr,const uint8_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN];
+	_mav_put_uint16_t(buf, 0, seqnr);
+	_mav_put_uint8_t_array(buf, 2, data, 253);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN);
+#else
+	mavlink_encapsulated_data_t packet;
+	packet.seqnr = seqnr;
+	mav_array_memcpy(packet.data, data, sizeof(uint8_t)*253);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_ENCAPSULATED_DATA;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN, MAVLINK_MSG_ID_ENCAPSULATED_DATA_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a encapsulated_data struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param encapsulated_data C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_encapsulated_data_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_encapsulated_data_t* encapsulated_data)
+{
+	return mavlink_msg_encapsulated_data_pack(system_id, component_id, msg, encapsulated_data->seqnr, encapsulated_data->data);
+}
+
+/**
+ * @brief Encode a encapsulated_data struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param encapsulated_data C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_encapsulated_data_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_encapsulated_data_t* encapsulated_data)
+{
+	return mavlink_msg_encapsulated_data_pack_chan(system_id, component_id, chan, msg, encapsulated_data->seqnr, encapsulated_data->data);
+}
+
+/**
+ * @brief Send a encapsulated_data message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param seqnr sequence number (starting with 0 on every transmission)
+ * @param data image data bytes
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_encapsulated_data_send(mavlink_channel_t chan, uint16_t seqnr, const uint8_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN];
+	_mav_put_uint16_t(buf, 0, seqnr);
+	_mav_put_uint8_t_array(buf, 2, data, 253);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ENCAPSULATED_DATA, buf, MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN, MAVLINK_MSG_ID_ENCAPSULATED_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ENCAPSULATED_DATA, buf, MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN);
+#endif
+#else
+	mavlink_encapsulated_data_t packet;
+	packet.seqnr = seqnr;
+	mav_array_memcpy(packet.data, data, sizeof(uint8_t)*253);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ENCAPSULATED_DATA, (const char *)&packet, MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN, MAVLINK_MSG_ID_ENCAPSULATED_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ENCAPSULATED_DATA, (const char *)&packet, MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_encapsulated_data_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint16_t seqnr, const uint8_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint16_t(buf, 0, seqnr);
+	_mav_put_uint8_t_array(buf, 2, data, 253);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ENCAPSULATED_DATA, buf, MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN, MAVLINK_MSG_ID_ENCAPSULATED_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ENCAPSULATED_DATA, buf, MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN);
+#endif
+#else
+	mavlink_encapsulated_data_t *packet = (mavlink_encapsulated_data_t *)msgbuf;
+	packet->seqnr = seqnr;
+	mav_array_memcpy(packet->data, data, sizeof(uint8_t)*253);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ENCAPSULATED_DATA, (const char *)packet, MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN, MAVLINK_MSG_ID_ENCAPSULATED_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_ENCAPSULATED_DATA, (const char *)packet, MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE ENCAPSULATED_DATA UNPACKING
+
+
+/**
+ * @brief Get field seqnr from encapsulated_data message
+ *
+ * @return sequence number (starting with 0 on every transmission)
+ */
+static inline uint16_t mavlink_msg_encapsulated_data_get_seqnr(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  0);
+}
+
+/**
+ * @brief Get field data from encapsulated_data message
+ *
+ * @return image data bytes
+ */
+static inline uint16_t mavlink_msg_encapsulated_data_get_data(const mavlink_message_t* msg, uint8_t *data)
+{
+	return _MAV_RETURN_uint8_t_array(msg, data, 253,  2);
+}
+
+/**
+ * @brief Decode a encapsulated_data message into a struct
+ *
+ * @param msg The message to decode
+ * @param encapsulated_data C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_encapsulated_data_decode(const mavlink_message_t* msg, mavlink_encapsulated_data_t* encapsulated_data)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	encapsulated_data->seqnr = mavlink_msg_encapsulated_data_get_seqnr(msg);
+	mavlink_msg_encapsulated_data_get_data(msg, encapsulated_data->data);
+#else
+	memcpy(encapsulated_data, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_ENCAPSULATED_DATA_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_file_transfer_protocol.h v1.0/common/mavlink_msg_file_transfer_protocol.h
--- v1.0.old/common/mavlink_msg_file_transfer_protocol.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_file_transfer_protocol.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,273 @@
+// MESSAGE FILE_TRANSFER_PROTOCOL PACKING
+
+#define MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL 110
+
+typedef struct __mavlink_file_transfer_protocol_t
+{
+ uint8_t target_network; ///< Network ID (0 for broadcast)
+ uint8_t target_system; ///< System ID (0 for broadcast)
+ uint8_t target_component; ///< Component ID (0 for broadcast)
+ uint8_t payload[251]; ///< Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.
+} mavlink_file_transfer_protocol_t;
+
+#define MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN 254
+#define MAVLINK_MSG_ID_110_LEN 254
+
+#define MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_CRC 84
+#define MAVLINK_MSG_ID_110_CRC 84
+
+#define MAVLINK_MSG_FILE_TRANSFER_PROTOCOL_FIELD_PAYLOAD_LEN 251
+
+#define MAVLINK_MESSAGE_INFO_FILE_TRANSFER_PROTOCOL { \
+	"FILE_TRANSFER_PROTOCOL", \
+	4, \
+	{  { "target_network", NULL, MAVLINK_TYPE_UINT8_T, 0, 0, offsetof(mavlink_file_transfer_protocol_t, target_network) }, \
+         { "target_system", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_file_transfer_protocol_t, target_system) }, \
+         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 2, offsetof(mavlink_file_transfer_protocol_t, target_component) }, \
+         { "payload", NULL, MAVLINK_TYPE_UINT8_T, 251, 3, offsetof(mavlink_file_transfer_protocol_t, payload) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a file_transfer_protocol message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param target_network Network ID (0 for broadcast)
+ * @param target_system System ID (0 for broadcast)
+ * @param target_component Component ID (0 for broadcast)
+ * @param payload Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_file_transfer_protocol_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint8_t target_network, uint8_t target_system, uint8_t target_component, const uint8_t *payload)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN];
+	_mav_put_uint8_t(buf, 0, target_network);
+	_mav_put_uint8_t(buf, 1, target_system);
+	_mav_put_uint8_t(buf, 2, target_component);
+	_mav_put_uint8_t_array(buf, 3, payload, 251);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN);
+#else
+	mavlink_file_transfer_protocol_t packet;
+	packet.target_network = target_network;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	mav_array_memcpy(packet.payload, payload, sizeof(uint8_t)*251);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a file_transfer_protocol message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param target_network Network ID (0 for broadcast)
+ * @param target_system System ID (0 for broadcast)
+ * @param target_component Component ID (0 for broadcast)
+ * @param payload Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_file_transfer_protocol_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint8_t target_network,uint8_t target_system,uint8_t target_component,const uint8_t *payload)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN];
+	_mav_put_uint8_t(buf, 0, target_network);
+	_mav_put_uint8_t(buf, 1, target_system);
+	_mav_put_uint8_t(buf, 2, target_component);
+	_mav_put_uint8_t_array(buf, 3, payload, 251);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN);
+#else
+	mavlink_file_transfer_protocol_t packet;
+	packet.target_network = target_network;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	mav_array_memcpy(packet.payload, payload, sizeof(uint8_t)*251);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a file_transfer_protocol struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param file_transfer_protocol C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_file_transfer_protocol_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_file_transfer_protocol_t* file_transfer_protocol)
+{
+	return mavlink_msg_file_transfer_protocol_pack(system_id, component_id, msg, file_transfer_protocol->target_network, file_transfer_protocol->target_system, file_transfer_protocol->target_component, file_transfer_protocol->payload);
+}
+
+/**
+ * @brief Encode a file_transfer_protocol struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param file_transfer_protocol C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_file_transfer_protocol_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_file_transfer_protocol_t* file_transfer_protocol)
+{
+	return mavlink_msg_file_transfer_protocol_pack_chan(system_id, component_id, chan, msg, file_transfer_protocol->target_network, file_transfer_protocol->target_system, file_transfer_protocol->target_component, file_transfer_protocol->payload);
+}
+
+/**
+ * @brief Send a file_transfer_protocol message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param target_network Network ID (0 for broadcast)
+ * @param target_system System ID (0 for broadcast)
+ * @param target_component Component ID (0 for broadcast)
+ * @param payload Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_file_transfer_protocol_send(mavlink_channel_t chan, uint8_t target_network, uint8_t target_system, uint8_t target_component, const uint8_t *payload)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN];
+	_mav_put_uint8_t(buf, 0, target_network);
+	_mav_put_uint8_t(buf, 1, target_system);
+	_mav_put_uint8_t(buf, 2, target_component);
+	_mav_put_uint8_t_array(buf, 3, payload, 251);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL, buf, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL, buf, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN);
+#endif
+#else
+	mavlink_file_transfer_protocol_t packet;
+	packet.target_network = target_network;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	mav_array_memcpy(packet.payload, payload, sizeof(uint8_t)*251);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL, (const char *)&packet, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL, (const char *)&packet, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_file_transfer_protocol_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_network, uint8_t target_system, uint8_t target_component, const uint8_t *payload)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint8_t(buf, 0, target_network);
+	_mav_put_uint8_t(buf, 1, target_system);
+	_mav_put_uint8_t(buf, 2, target_component);
+	_mav_put_uint8_t_array(buf, 3, payload, 251);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL, buf, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL, buf, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN);
+#endif
+#else
+	mavlink_file_transfer_protocol_t *packet = (mavlink_file_transfer_protocol_t *)msgbuf;
+	packet->target_network = target_network;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+	mav_array_memcpy(packet->payload, payload, sizeof(uint8_t)*251);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL, (const char *)packet, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL, (const char *)packet, MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE FILE_TRANSFER_PROTOCOL UNPACKING
+
+
+/**
+ * @brief Get field target_network from file_transfer_protocol message
+ *
+ * @return Network ID (0 for broadcast)
+ */
+static inline uint8_t mavlink_msg_file_transfer_protocol_get_target_network(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  0);
+}
+
+/**
+ * @brief Get field target_system from file_transfer_protocol message
+ *
+ * @return System ID (0 for broadcast)
+ */
+static inline uint8_t mavlink_msg_file_transfer_protocol_get_target_system(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  1);
+}
+
+/**
+ * @brief Get field target_component from file_transfer_protocol message
+ *
+ * @return Component ID (0 for broadcast)
+ */
+static inline uint8_t mavlink_msg_file_transfer_protocol_get_target_component(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  2);
+}
+
+/**
+ * @brief Get field payload from file_transfer_protocol message
+ *
+ * @return Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.
+ */
+static inline uint16_t mavlink_msg_file_transfer_protocol_get_payload(const mavlink_message_t* msg, uint8_t *payload)
+{
+	return _MAV_RETURN_uint8_t_array(msg, payload, 251,  3);
+}
+
+/**
+ * @brief Decode a file_transfer_protocol message into a struct
+ *
+ * @param msg The message to decode
+ * @param file_transfer_protocol C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_file_transfer_protocol_decode(const mavlink_message_t* msg, mavlink_file_transfer_protocol_t* file_transfer_protocol)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	file_transfer_protocol->target_network = mavlink_msg_file_transfer_protocol_get_target_network(msg);
+	file_transfer_protocol->target_system = mavlink_msg_file_transfer_protocol_get_target_system(msg);
+	file_transfer_protocol->target_component = mavlink_msg_file_transfer_protocol_get_target_component(msg);
+	mavlink_msg_file_transfer_protocol_get_payload(msg, file_transfer_protocol->payload);
+#else
+	memcpy(file_transfer_protocol, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_global_position_int_cov.h v1.0/common/mavlink_msg_global_position_int_cov.h
--- v1.0.old/common/mavlink_msg_global_position_int_cov.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_global_position_int_cov.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,441 @@
+// MESSAGE GLOBAL_POSITION_INT_COV PACKING
+
+#define MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV 63
+
+typedef struct __mavlink_global_position_int_cov_t
+{
+ uint64_t time_utc; ///< Timestamp (microseconds since UNIX epoch) in UTC. 0 for unknown. Commonly filled by the precision time source of a GPS receiver.
+ uint32_t time_boot_ms; ///< Timestamp (milliseconds since system boot)
+ int32_t lat; ///< Latitude, expressed as degrees * 1E7
+ int32_t lon; ///< Longitude, expressed as degrees * 1E7
+ int32_t alt; ///< Altitude in meters, expressed as * 1000 (millimeters), above MSL
+ int32_t relative_alt; ///< Altitude above ground in meters, expressed as * 1000 (millimeters)
+ float vx; ///< Ground X Speed (Latitude), expressed as m/s
+ float vy; ///< Ground Y Speed (Longitude), expressed as m/s
+ float vz; ///< Ground Z Speed (Altitude), expressed as m/s
+ float covariance[36]; ///< Covariance matrix (first six entries are the first ROW, next six entries are the second row, etc.)
+ uint8_t estimator_type; ///< Class id of the estimator this estimate originated from.
+} mavlink_global_position_int_cov_t;
+
+#define MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN 185
+#define MAVLINK_MSG_ID_63_LEN 185
+
+#define MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_CRC 51
+#define MAVLINK_MSG_ID_63_CRC 51
+
+#define MAVLINK_MSG_GLOBAL_POSITION_INT_COV_FIELD_COVARIANCE_LEN 36
+
+#define MAVLINK_MESSAGE_INFO_GLOBAL_POSITION_INT_COV { \
+	"GLOBAL_POSITION_INT_COV", \
+	11, \
+	{  { "time_utc", NULL, MAVLINK_TYPE_UINT64_T, 0, 0, offsetof(mavlink_global_position_int_cov_t, time_utc) }, \
+         { "time_boot_ms", NULL, MAVLINK_TYPE_UINT32_T, 0, 8, offsetof(mavlink_global_position_int_cov_t, time_boot_ms) }, \
+         { "lat", NULL, MAVLINK_TYPE_INT32_T, 0, 12, offsetof(mavlink_global_position_int_cov_t, lat) }, \
+         { "lon", NULL, MAVLINK_TYPE_INT32_T, 0, 16, offsetof(mavlink_global_position_int_cov_t, lon) }, \
+         { "alt", NULL, MAVLINK_TYPE_INT32_T, 0, 20, offsetof(mavlink_global_position_int_cov_t, alt) }, \
+         { "relative_alt", NULL, MAVLINK_TYPE_INT32_T, 0, 24, offsetof(mavlink_global_position_int_cov_t, relative_alt) }, \
+         { "vx", NULL, MAVLINK_TYPE_FLOAT, 0, 28, offsetof(mavlink_global_position_int_cov_t, vx) }, \
+         { "vy", NULL, MAVLINK_TYPE_FLOAT, 0, 32, offsetof(mavlink_global_position_int_cov_t, vy) }, \
+         { "vz", NULL, MAVLINK_TYPE_FLOAT, 0, 36, offsetof(mavlink_global_position_int_cov_t, vz) }, \
+         { "covariance", NULL, MAVLINK_TYPE_FLOAT, 36, 40, offsetof(mavlink_global_position_int_cov_t, covariance) }, \
+         { "estimator_type", NULL, MAVLINK_TYPE_UINT8_T, 0, 184, offsetof(mavlink_global_position_int_cov_t, estimator_type) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a global_position_int_cov message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param time_utc Timestamp (microseconds since UNIX epoch) in UTC. 0 for unknown. Commonly filled by the precision time source of a GPS receiver.
+ * @param estimator_type Class id of the estimator this estimate originated from.
+ * @param lat Latitude, expressed as degrees * 1E7
+ * @param lon Longitude, expressed as degrees * 1E7
+ * @param alt Altitude in meters, expressed as * 1000 (millimeters), above MSL
+ * @param relative_alt Altitude above ground in meters, expressed as * 1000 (millimeters)
+ * @param vx Ground X Speed (Latitude), expressed as m/s
+ * @param vy Ground Y Speed (Longitude), expressed as m/s
+ * @param vz Ground Z Speed (Altitude), expressed as m/s
+ * @param covariance Covariance matrix (first six entries are the first ROW, next six entries are the second row, etc.)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_global_position_int_cov_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint32_t time_boot_ms, uint64_t time_utc, uint8_t estimator_type, int32_t lat, int32_t lon, int32_t alt, int32_t relative_alt, float vx, float vy, float vz, const float *covariance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN];
+	_mav_put_uint64_t(buf, 0, time_utc);
+	_mav_put_uint32_t(buf, 8, time_boot_ms);
+	_mav_put_int32_t(buf, 12, lat);
+	_mav_put_int32_t(buf, 16, lon);
+	_mav_put_int32_t(buf, 20, alt);
+	_mav_put_int32_t(buf, 24, relative_alt);
+	_mav_put_float(buf, 28, vx);
+	_mav_put_float(buf, 32, vy);
+	_mav_put_float(buf, 36, vz);
+	_mav_put_uint8_t(buf, 184, estimator_type);
+	_mav_put_float_array(buf, 40, covariance, 36);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN);
+#else
+	mavlink_global_position_int_cov_t packet;
+	packet.time_utc = time_utc;
+	packet.time_boot_ms = time_boot_ms;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.alt = alt;
+	packet.relative_alt = relative_alt;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.estimator_type = estimator_type;
+	mav_array_memcpy(packet.covariance, covariance, sizeof(float)*36);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a global_position_int_cov message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param time_utc Timestamp (microseconds since UNIX epoch) in UTC. 0 for unknown. Commonly filled by the precision time source of a GPS receiver.
+ * @param estimator_type Class id of the estimator this estimate originated from.
+ * @param lat Latitude, expressed as degrees * 1E7
+ * @param lon Longitude, expressed as degrees * 1E7
+ * @param alt Altitude in meters, expressed as * 1000 (millimeters), above MSL
+ * @param relative_alt Altitude above ground in meters, expressed as * 1000 (millimeters)
+ * @param vx Ground X Speed (Latitude), expressed as m/s
+ * @param vy Ground Y Speed (Longitude), expressed as m/s
+ * @param vz Ground Z Speed (Altitude), expressed as m/s
+ * @param covariance Covariance matrix (first six entries are the first ROW, next six entries are the second row, etc.)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_global_position_int_cov_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint32_t time_boot_ms,uint64_t time_utc,uint8_t estimator_type,int32_t lat,int32_t lon,int32_t alt,int32_t relative_alt,float vx,float vy,float vz,const float *covariance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN];
+	_mav_put_uint64_t(buf, 0, time_utc);
+	_mav_put_uint32_t(buf, 8, time_boot_ms);
+	_mav_put_int32_t(buf, 12, lat);
+	_mav_put_int32_t(buf, 16, lon);
+	_mav_put_int32_t(buf, 20, alt);
+	_mav_put_int32_t(buf, 24, relative_alt);
+	_mav_put_float(buf, 28, vx);
+	_mav_put_float(buf, 32, vy);
+	_mav_put_float(buf, 36, vz);
+	_mav_put_uint8_t(buf, 184, estimator_type);
+	_mav_put_float_array(buf, 40, covariance, 36);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN);
+#else
+	mavlink_global_position_int_cov_t packet;
+	packet.time_utc = time_utc;
+	packet.time_boot_ms = time_boot_ms;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.alt = alt;
+	packet.relative_alt = relative_alt;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.estimator_type = estimator_type;
+	mav_array_memcpy(packet.covariance, covariance, sizeof(float)*36);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a global_position_int_cov struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param global_position_int_cov C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_global_position_int_cov_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_global_position_int_cov_t* global_position_int_cov)
+{
+	return mavlink_msg_global_position_int_cov_pack(system_id, component_id, msg, global_position_int_cov->time_boot_ms, global_position_int_cov->time_utc, global_position_int_cov->estimator_type, global_position_int_cov->lat, global_position_int_cov->lon, global_position_int_cov->alt, global_position_int_cov->relative_alt, global_position_int_cov->vx, global_position_int_cov->vy, global_position_int_cov->vz, global_position_int_cov->covariance);
+}
+
+/**
+ * @brief Encode a global_position_int_cov struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param global_position_int_cov C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_global_position_int_cov_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_global_position_int_cov_t* global_position_int_cov)
+{
+	return mavlink_msg_global_position_int_cov_pack_chan(system_id, component_id, chan, msg, global_position_int_cov->time_boot_ms, global_position_int_cov->time_utc, global_position_int_cov->estimator_type, global_position_int_cov->lat, global_position_int_cov->lon, global_position_int_cov->alt, global_position_int_cov->relative_alt, global_position_int_cov->vx, global_position_int_cov->vy, global_position_int_cov->vz, global_position_int_cov->covariance);
+}
+
+/**
+ * @brief Send a global_position_int_cov message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param time_utc Timestamp (microseconds since UNIX epoch) in UTC. 0 for unknown. Commonly filled by the precision time source of a GPS receiver.
+ * @param estimator_type Class id of the estimator this estimate originated from.
+ * @param lat Latitude, expressed as degrees * 1E7
+ * @param lon Longitude, expressed as degrees * 1E7
+ * @param alt Altitude in meters, expressed as * 1000 (millimeters), above MSL
+ * @param relative_alt Altitude above ground in meters, expressed as * 1000 (millimeters)
+ * @param vx Ground X Speed (Latitude), expressed as m/s
+ * @param vy Ground Y Speed (Longitude), expressed as m/s
+ * @param vz Ground Z Speed (Altitude), expressed as m/s
+ * @param covariance Covariance matrix (first six entries are the first ROW, next six entries are the second row, etc.)
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_global_position_int_cov_send(mavlink_channel_t chan, uint32_t time_boot_ms, uint64_t time_utc, uint8_t estimator_type, int32_t lat, int32_t lon, int32_t alt, int32_t relative_alt, float vx, float vy, float vz, const float *covariance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN];
+	_mav_put_uint64_t(buf, 0, time_utc);
+	_mav_put_uint32_t(buf, 8, time_boot_ms);
+	_mav_put_int32_t(buf, 12, lat);
+	_mav_put_int32_t(buf, 16, lon);
+	_mav_put_int32_t(buf, 20, alt);
+	_mav_put_int32_t(buf, 24, relative_alt);
+	_mav_put_float(buf, 28, vx);
+	_mav_put_float(buf, 32, vy);
+	_mav_put_float(buf, 36, vz);
+	_mav_put_uint8_t(buf, 184, estimator_type);
+	_mav_put_float_array(buf, 40, covariance, 36);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV, buf, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV, buf, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN);
+#endif
+#else
+	mavlink_global_position_int_cov_t packet;
+	packet.time_utc = time_utc;
+	packet.time_boot_ms = time_boot_ms;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.alt = alt;
+	packet.relative_alt = relative_alt;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.estimator_type = estimator_type;
+	mav_array_memcpy(packet.covariance, covariance, sizeof(float)*36);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV, (const char *)&packet, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV, (const char *)&packet, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_global_position_int_cov_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, uint64_t time_utc, uint8_t estimator_type, int32_t lat, int32_t lon, int32_t alt, int32_t relative_alt, float vx, float vy, float vz, const float *covariance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_utc);
+	_mav_put_uint32_t(buf, 8, time_boot_ms);
+	_mav_put_int32_t(buf, 12, lat);
+	_mav_put_int32_t(buf, 16, lon);
+	_mav_put_int32_t(buf, 20, alt);
+	_mav_put_int32_t(buf, 24, relative_alt);
+	_mav_put_float(buf, 28, vx);
+	_mav_put_float(buf, 32, vy);
+	_mav_put_float(buf, 36, vz);
+	_mav_put_uint8_t(buf, 184, estimator_type);
+	_mav_put_float_array(buf, 40, covariance, 36);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV, buf, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV, buf, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN);
+#endif
+#else
+	mavlink_global_position_int_cov_t *packet = (mavlink_global_position_int_cov_t *)msgbuf;
+	packet->time_utc = time_utc;
+	packet->time_boot_ms = time_boot_ms;
+	packet->lat = lat;
+	packet->lon = lon;
+	packet->alt = alt;
+	packet->relative_alt = relative_alt;
+	packet->vx = vx;
+	packet->vy = vy;
+	packet->vz = vz;
+	packet->estimator_type = estimator_type;
+	mav_array_memcpy(packet->covariance, covariance, sizeof(float)*36);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV, (const char *)packet, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV, (const char *)packet, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE GLOBAL_POSITION_INT_COV UNPACKING
+
+
+/**
+ * @brief Get field time_boot_ms from global_position_int_cov message
+ *
+ * @return Timestamp (milliseconds since system boot)
+ */
+static inline uint32_t mavlink_msg_global_position_int_cov_get_time_boot_ms(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  8);
+}
+
+/**
+ * @brief Get field time_utc from global_position_int_cov message
+ *
+ * @return Timestamp (microseconds since UNIX epoch) in UTC. 0 for unknown. Commonly filled by the precision time source of a GPS receiver.
+ */
+static inline uint64_t mavlink_msg_global_position_int_cov_get_time_utc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint64_t(msg,  0);
+}
+
+/**
+ * @brief Get field estimator_type from global_position_int_cov message
+ *
+ * @return Class id of the estimator this estimate originated from.
+ */
+static inline uint8_t mavlink_msg_global_position_int_cov_get_estimator_type(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  184);
+}
+
+/**
+ * @brief Get field lat from global_position_int_cov message
+ *
+ * @return Latitude, expressed as degrees * 1E7
+ */
+static inline int32_t mavlink_msg_global_position_int_cov_get_lat(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  12);
+}
+
+/**
+ * @brief Get field lon from global_position_int_cov message
+ *
+ * @return Longitude, expressed as degrees * 1E7
+ */
+static inline int32_t mavlink_msg_global_position_int_cov_get_lon(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  16);
+}
+
+/**
+ * @brief Get field alt from global_position_int_cov message
+ *
+ * @return Altitude in meters, expressed as * 1000 (millimeters), above MSL
+ */
+static inline int32_t mavlink_msg_global_position_int_cov_get_alt(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  20);
+}
+
+/**
+ * @brief Get field relative_alt from global_position_int_cov message
+ *
+ * @return Altitude above ground in meters, expressed as * 1000 (millimeters)
+ */
+static inline int32_t mavlink_msg_global_position_int_cov_get_relative_alt(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  24);
+}
+
+/**
+ * @brief Get field vx from global_position_int_cov message
+ *
+ * @return Ground X Speed (Latitude), expressed as m/s
+ */
+static inline float mavlink_msg_global_position_int_cov_get_vx(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  28);
+}
+
+/**
+ * @brief Get field vy from global_position_int_cov message
+ *
+ * @return Ground Y Speed (Longitude), expressed as m/s
+ */
+static inline float mavlink_msg_global_position_int_cov_get_vy(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  32);
+}
+
+/**
+ * @brief Get field vz from global_position_int_cov message
+ *
+ * @return Ground Z Speed (Altitude), expressed as m/s
+ */
+static inline float mavlink_msg_global_position_int_cov_get_vz(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  36);
+}
+
+/**
+ * @brief Get field covariance from global_position_int_cov message
+ *
+ * @return Covariance matrix (first six entries are the first ROW, next six entries are the second row, etc.)
+ */
+static inline uint16_t mavlink_msg_global_position_int_cov_get_covariance(const mavlink_message_t* msg, float *covariance)
+{
+	return _MAV_RETURN_float_array(msg, covariance, 36,  40);
+}
+
+/**
+ * @brief Decode a global_position_int_cov message into a struct
+ *
+ * @param msg The message to decode
+ * @param global_position_int_cov C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_global_position_int_cov_decode(const mavlink_message_t* msg, mavlink_global_position_int_cov_t* global_position_int_cov)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	global_position_int_cov->time_utc = mavlink_msg_global_position_int_cov_get_time_utc(msg);
+	global_position_int_cov->time_boot_ms = mavlink_msg_global_position_int_cov_get_time_boot_ms(msg);
+	global_position_int_cov->lat = mavlink_msg_global_position_int_cov_get_lat(msg);
+	global_position_int_cov->lon = mavlink_msg_global_position_int_cov_get_lon(msg);
+	global_position_int_cov->alt = mavlink_msg_global_position_int_cov_get_alt(msg);
+	global_position_int_cov->relative_alt = mavlink_msg_global_position_int_cov_get_relative_alt(msg);
+	global_position_int_cov->vx = mavlink_msg_global_position_int_cov_get_vx(msg);
+	global_position_int_cov->vy = mavlink_msg_global_position_int_cov_get_vy(msg);
+	global_position_int_cov->vz = mavlink_msg_global_position_int_cov_get_vz(msg);
+	mavlink_msg_global_position_int_cov_get_covariance(msg, global_position_int_cov->covariance);
+	global_position_int_cov->estimator_type = mavlink_msg_global_position_int_cov_get_estimator_type(msg);
+#else
+	memcpy(global_position_int_cov, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_global_position_int.h v1.0/common/mavlink_msg_global_position_int.h
--- v1.0.old/common/mavlink_msg_global_position_int.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_global_position_int.h	2015-02-06 11:50:58.000000000 +0500
@@ -7,17 +7,20 @@ typedef struct __mavlink_global_position
  uint32_t time_boot_ms; ///< Timestamp (milliseconds since system boot)
  int32_t lat; ///< Latitude, expressed as * 1E7
  int32_t lon; ///< Longitude, expressed as * 1E7
- int32_t alt; ///< Altitude in meters, expressed as * 1000 (millimeters), above MSL
+ int32_t alt; ///< Altitude in meters, expressed as * 1000 (millimeters), AMSL (not WGS84 - note that virtually all GPS modules provide the AMSL as well)
  int32_t relative_alt; ///< Altitude above ground in meters, expressed as * 1000 (millimeters)
  int16_t vx; ///< Ground X Speed (Latitude), expressed as m/s * 100
  int16_t vy; ///< Ground Y Speed (Longitude), expressed as m/s * 100
  int16_t vz; ///< Ground Z Speed (Altitude), expressed as m/s * 100
- uint16_t hdg; ///< Compass heading in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535
+ uint16_t hdg; ///< Compass heading in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
 } mavlink_global_position_int_t;
 
 #define MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN 28
 #define MAVLINK_MSG_ID_33_LEN 28
 
+#define MAVLINK_MSG_ID_GLOBAL_POSITION_INT_CRC 104
+#define MAVLINK_MSG_ID_33_CRC 104
+
 
 
 #define MAVLINK_MESSAGE_INFO_GLOBAL_POSITION_INT { \
@@ -45,19 +48,19 @@ typedef struct __mavlink_global_position
  * @param time_boot_ms Timestamp (milliseconds since system boot)
  * @param lat Latitude, expressed as * 1E7
  * @param lon Longitude, expressed as * 1E7
- * @param alt Altitude in meters, expressed as * 1000 (millimeters), above MSL
+ * @param alt Altitude in meters, expressed as * 1000 (millimeters), AMSL (not WGS84 - note that virtually all GPS modules provide the AMSL as well)
  * @param relative_alt Altitude above ground in meters, expressed as * 1000 (millimeters)
  * @param vx Ground X Speed (Latitude), expressed as m/s * 100
  * @param vy Ground Y Speed (Longitude), expressed as m/s * 100
  * @param vz Ground Z Speed (Altitude), expressed as m/s * 100
- * @param hdg Compass heading in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535
+ * @param hdg Compass heading in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_global_position_int_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
 						       uint32_t time_boot_ms, int32_t lat, int32_t lon, int32_t alt, int32_t relative_alt, int16_t vx, int16_t vy, int16_t vz, uint16_t hdg)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[28];
+	char buf[MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_int32_t(buf, 4, lat);
 	_mav_put_int32_t(buf, 8, lon);
@@ -68,7 +71,7 @@ static inline uint16_t mavlink_msg_globa
 	_mav_put_int16_t(buf, 24, vz);
 	_mav_put_uint16_t(buf, 26, hdg);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN);
 #else
 	mavlink_global_position_int_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -81,28 +84,32 @@ static inline uint16_t mavlink_msg_globa
 	packet.vz = vz;
 	packet.hdg = hdg;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_GLOBAL_POSITION_INT;
-	return mavlink_finalize_message(msg, system_id, component_id, 28, 104);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN);
+#endif
 }
 
 /**
  * @brief Pack a global_position_int message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_boot_ms Timestamp (milliseconds since system boot)
  * @param lat Latitude, expressed as * 1E7
  * @param lon Longitude, expressed as * 1E7
- * @param alt Altitude in meters, expressed as * 1000 (millimeters), above MSL
+ * @param alt Altitude in meters, expressed as * 1000 (millimeters), AMSL (not WGS84 - note that virtually all GPS modules provide the AMSL as well)
  * @param relative_alt Altitude above ground in meters, expressed as * 1000 (millimeters)
  * @param vx Ground X Speed (Latitude), expressed as m/s * 100
  * @param vy Ground Y Speed (Longitude), expressed as m/s * 100
  * @param vz Ground Z Speed (Altitude), expressed as m/s * 100
- * @param hdg Compass heading in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535
+ * @param hdg Compass heading in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_global_position_int_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
@@ -110,7 +117,7 @@ static inline uint16_t mavlink_msg_globa
 						           uint32_t time_boot_ms,int32_t lat,int32_t lon,int32_t alt,int32_t relative_alt,int16_t vx,int16_t vy,int16_t vz,uint16_t hdg)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[28];
+	char buf[MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_int32_t(buf, 4, lat);
 	_mav_put_int32_t(buf, 8, lon);
@@ -121,7 +128,7 @@ static inline uint16_t mavlink_msg_globa
 	_mav_put_int16_t(buf, 24, vz);
 	_mav_put_uint16_t(buf, 26, hdg);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN);
 #else
 	mavlink_global_position_int_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -134,15 +141,19 @@ static inline uint16_t mavlink_msg_globa
 	packet.vz = vz;
 	packet.hdg = hdg;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_GLOBAL_POSITION_INT;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 28, 104);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN);
+#endif
 }
 
 /**
- * @brief Encode a global_position_int struct into a message
+ * @brief Encode a global_position_int struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -155,25 +166,39 @@ static inline uint16_t mavlink_msg_globa
 }
 
 /**
+ * @brief Encode a global_position_int struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param global_position_int C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_global_position_int_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_global_position_int_t* global_position_int)
+{
+	return mavlink_msg_global_position_int_pack_chan(system_id, component_id, chan, msg, global_position_int->time_boot_ms, global_position_int->lat, global_position_int->lon, global_position_int->alt, global_position_int->relative_alt, global_position_int->vx, global_position_int->vy, global_position_int->vz, global_position_int->hdg);
+}
+
+/**
  * @brief Send a global_position_int message
  * @param chan MAVLink channel to send the message
  *
  * @param time_boot_ms Timestamp (milliseconds since system boot)
  * @param lat Latitude, expressed as * 1E7
  * @param lon Longitude, expressed as * 1E7
- * @param alt Altitude in meters, expressed as * 1000 (millimeters), above MSL
+ * @param alt Altitude in meters, expressed as * 1000 (millimeters), AMSL (not WGS84 - note that virtually all GPS modules provide the AMSL as well)
  * @param relative_alt Altitude above ground in meters, expressed as * 1000 (millimeters)
  * @param vx Ground X Speed (Latitude), expressed as m/s * 100
  * @param vy Ground Y Speed (Longitude), expressed as m/s * 100
  * @param vz Ground Z Speed (Altitude), expressed as m/s * 100
- * @param hdg Compass heading in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535
+ * @param hdg Compass heading in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
  */
 #ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
 
 static inline void mavlink_msg_global_position_int_send(mavlink_channel_t chan, uint32_t time_boot_ms, int32_t lat, int32_t lon, int32_t alt, int32_t relative_alt, int16_t vx, int16_t vy, int16_t vz, uint16_t hdg)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[28];
+	char buf[MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_int32_t(buf, 4, lat);
 	_mav_put_int32_t(buf, 8, lon);
@@ -184,7 +209,11 @@ static inline void mavlink_msg_global_po
 	_mav_put_int16_t(buf, 24, vz);
 	_mav_put_uint16_t(buf, 26, hdg);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT, buf, 28, 104);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT, buf, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT, buf, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN);
+#endif
 #else
 	mavlink_global_position_int_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -197,9 +226,61 @@ static inline void mavlink_msg_global_po
 	packet.vz = vz;
 	packet.hdg = hdg;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT, (const char *)&packet, 28, 104);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT, (const char *)&packet, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT, (const char *)&packet, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_global_position_int_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, int32_t lat, int32_t lon, int32_t alt, int32_t relative_alt, int16_t vx, int16_t vy, int16_t vz, uint16_t hdg)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_int32_t(buf, 4, lat);
+	_mav_put_int32_t(buf, 8, lon);
+	_mav_put_int32_t(buf, 12, alt);
+	_mav_put_int32_t(buf, 16, relative_alt);
+	_mav_put_int16_t(buf, 20, vx);
+	_mav_put_int16_t(buf, 22, vy);
+	_mav_put_int16_t(buf, 24, vz);
+	_mav_put_uint16_t(buf, 26, hdg);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT, buf, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT, buf, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN);
+#endif
+#else
+	mavlink_global_position_int_t *packet = (mavlink_global_position_int_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->lat = lat;
+	packet->lon = lon;
+	packet->alt = alt;
+	packet->relative_alt = relative_alt;
+	packet->vx = vx;
+	packet->vy = vy;
+	packet->vz = vz;
+	packet->hdg = hdg;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT, (const char *)packet, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_POSITION_INT, (const char *)packet, MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -239,7 +320,7 @@ static inline int32_t mavlink_msg_global
 /**
  * @brief Get field alt from global_position_int message
  *
- * @return Altitude in meters, expressed as * 1000 (millimeters), above MSL
+ * @return Altitude in meters, expressed as * 1000 (millimeters), AMSL (not WGS84 - note that virtually all GPS modules provide the AMSL as well)
  */
 static inline int32_t mavlink_msg_global_position_int_get_alt(const mavlink_message_t* msg)
 {
@@ -289,7 +370,7 @@ static inline int16_t mavlink_msg_global
 /**
  * @brief Get field hdg from global_position_int message
  *
- * @return Compass heading in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535
+ * @return Compass heading in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
  */
 static inline uint16_t mavlink_msg_global_position_int_get_hdg(const mavlink_message_t* msg)
 {
@@ -315,6 +396,6 @@ static inline void mavlink_msg_global_po
 	global_position_int->vz = mavlink_msg_global_position_int_get_vz(msg);
 	global_position_int->hdg = mavlink_msg_global_position_int_get_hdg(msg);
 #else
-	memcpy(global_position_int, _MAV_PAYLOAD(msg), 28);
+	memcpy(global_position_int, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_global_vision_position_estimate.h v1.0/common/mavlink_msg_global_vision_position_estimate.h
--- v1.0.old/common/mavlink_msg_global_vision_position_estimate.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_global_vision_position_estimate.h	2015-02-06 11:50:58.000000000 +0500
@@ -4,7 +4,7 @@
 
 typedef struct __mavlink_global_vision_position_estimate_t
 {
- uint64_t usec; ///< Timestamp (milliseconds)
+ uint64_t usec; ///< Timestamp (microseconds, synced to UNIX time or since system boot)
  float x; ///< Global X position
  float y; ///< Global Y position
  float z; ///< Global Z position
@@ -16,6 +16,9 @@ typedef struct __mavlink_global_vision_p
 #define MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN 32
 #define MAVLINK_MSG_ID_101_LEN 32
 
+#define MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_CRC 102
+#define MAVLINK_MSG_ID_101_CRC 102
+
 
 
 #define MAVLINK_MESSAGE_INFO_GLOBAL_VISION_POSITION_ESTIMATE { \
@@ -38,7 +41,7 @@ typedef struct __mavlink_global_vision_p
  * @param component_id ID of this component (e.g. 200 for IMU)
  * @param msg The MAVLink message to compress the data into
  *
- * @param usec Timestamp (milliseconds)
+ * @param usec Timestamp (microseconds, synced to UNIX time or since system boot)
  * @param x Global X position
  * @param y Global Y position
  * @param z Global Z position
@@ -51,7 +54,7 @@ static inline uint16_t mavlink_msg_globa
 						       uint64_t usec, float x, float y, float z, float roll, float pitch, float yaw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[32];
+	char buf[MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN];
 	_mav_put_uint64_t(buf, 0, usec);
 	_mav_put_float(buf, 8, x);
 	_mav_put_float(buf, 12, y);
@@ -60,7 +63,7 @@ static inline uint16_t mavlink_msg_globa
 	_mav_put_float(buf, 24, pitch);
 	_mav_put_float(buf, 28, yaw);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN);
 #else
 	mavlink_global_vision_position_estimate_t packet;
 	packet.usec = usec;
@@ -71,20 +74,24 @@ static inline uint16_t mavlink_msg_globa
 	packet.pitch = pitch;
 	packet.yaw = yaw;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE;
-	return mavlink_finalize_message(msg, system_id, component_id, 32, 102);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN);
+#endif
 }
 
 /**
  * @brief Pack a global_vision_position_estimate message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
- * @param usec Timestamp (milliseconds)
+ * @param usec Timestamp (microseconds, synced to UNIX time or since system boot)
  * @param x Global X position
  * @param y Global Y position
  * @param z Global Z position
@@ -98,7 +105,7 @@ static inline uint16_t mavlink_msg_globa
 						           uint64_t usec,float x,float y,float z,float roll,float pitch,float yaw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[32];
+	char buf[MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN];
 	_mav_put_uint64_t(buf, 0, usec);
 	_mav_put_float(buf, 8, x);
 	_mav_put_float(buf, 12, y);
@@ -107,7 +114,7 @@ static inline uint16_t mavlink_msg_globa
 	_mav_put_float(buf, 24, pitch);
 	_mav_put_float(buf, 28, yaw);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN);
 #else
 	mavlink_global_vision_position_estimate_t packet;
 	packet.usec = usec;
@@ -118,15 +125,19 @@ static inline uint16_t mavlink_msg_globa
 	packet.pitch = pitch;
 	packet.yaw = yaw;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 32, 102);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN);
+#endif
 }
 
 /**
- * @brief Encode a global_vision_position_estimate struct into a message
+ * @brief Encode a global_vision_position_estimate struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -139,10 +150,24 @@ static inline uint16_t mavlink_msg_globa
 }
 
 /**
+ * @brief Encode a global_vision_position_estimate struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param global_vision_position_estimate C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_global_vision_position_estimate_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_global_vision_position_estimate_t* global_vision_position_estimate)
+{
+	return mavlink_msg_global_vision_position_estimate_pack_chan(system_id, component_id, chan, msg, global_vision_position_estimate->usec, global_vision_position_estimate->x, global_vision_position_estimate->y, global_vision_position_estimate->z, global_vision_position_estimate->roll, global_vision_position_estimate->pitch, global_vision_position_estimate->yaw);
+}
+
+/**
  * @brief Send a global_vision_position_estimate message
  * @param chan MAVLink channel to send the message
  *
- * @param usec Timestamp (milliseconds)
+ * @param usec Timestamp (microseconds, synced to UNIX time or since system boot)
  * @param x Global X position
  * @param y Global Y position
  * @param z Global Z position
@@ -155,7 +180,7 @@ static inline uint16_t mavlink_msg_globa
 static inline void mavlink_msg_global_vision_position_estimate_send(mavlink_channel_t chan, uint64_t usec, float x, float y, float z, float roll, float pitch, float yaw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[32];
+	char buf[MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN];
 	_mav_put_uint64_t(buf, 0, usec);
 	_mav_put_float(buf, 8, x);
 	_mav_put_float(buf, 12, y);
@@ -164,7 +189,11 @@ static inline void mavlink_msg_global_vi
 	_mav_put_float(buf, 24, pitch);
 	_mav_put_float(buf, 28, yaw);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE, buf, 32, 102);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE, buf, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE, buf, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN);
+#endif
 #else
 	mavlink_global_vision_position_estimate_t packet;
 	packet.usec = usec;
@@ -175,9 +204,57 @@ static inline void mavlink_msg_global_vi
 	packet.pitch = pitch;
 	packet.yaw = yaw;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE, (const char *)&packet, 32, 102);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE, (const char *)&packet, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE, (const char *)&packet, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_global_vision_position_estimate_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t usec, float x, float y, float z, float roll, float pitch, float yaw)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, usec);
+	_mav_put_float(buf, 8, x);
+	_mav_put_float(buf, 12, y);
+	_mav_put_float(buf, 16, z);
+	_mav_put_float(buf, 20, roll);
+	_mav_put_float(buf, 24, pitch);
+	_mav_put_float(buf, 28, yaw);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE, buf, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE, buf, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN);
+#endif
+#else
+	mavlink_global_vision_position_estimate_t *packet = (mavlink_global_vision_position_estimate_t *)msgbuf;
+	packet->usec = usec;
+	packet->x = x;
+	packet->y = y;
+	packet->z = z;
+	packet->roll = roll;
+	packet->pitch = pitch;
+	packet->yaw = yaw;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE, (const char *)packet, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE, (const char *)packet, MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -187,7 +264,7 @@ static inline void mavlink_msg_global_vi
 /**
  * @brief Get field usec from global_vision_position_estimate message
  *
- * @return Timestamp (milliseconds)
+ * @return Timestamp (microseconds, synced to UNIX time or since system boot)
  */
 static inline uint64_t mavlink_msg_global_vision_position_estimate_get_usec(const mavlink_message_t* msg)
 {
@@ -271,6 +348,6 @@ static inline void mavlink_msg_global_vi
 	global_vision_position_estimate->pitch = mavlink_msg_global_vision_position_estimate_get_pitch(msg);
 	global_vision_position_estimate->yaw = mavlink_msg_global_vision_position_estimate_get_yaw(msg);
 #else
-	memcpy(global_vision_position_estimate, _MAV_PAYLOAD(msg), 32);
+	memcpy(global_vision_position_estimate, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_gps2_raw.h v1.0/common/mavlink_msg_gps2_raw.h
--- v1.0.old/common/mavlink_msg_gps2_raw.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_gps2_raw.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,473 @@
+// MESSAGE GPS2_RAW PACKING
+
+#define MAVLINK_MSG_ID_GPS2_RAW 124
+
+typedef struct __mavlink_gps2_raw_t
+{
+ uint64_t time_usec; ///< Timestamp (microseconds since UNIX epoch or microseconds since system boot)
+ int32_t lat; ///< Latitude (WGS84), in degrees * 1E7
+ int32_t lon; ///< Longitude (WGS84), in degrees * 1E7
+ int32_t alt; ///< Altitude (AMSL, not WGS84), in meters * 1000 (positive for up)
+ uint32_t dgps_age; ///< Age of DGPS info
+ uint16_t eph; ///< GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ uint16_t epv; ///< GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ uint16_t vel; ///< GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX
+ uint16_t cog; ///< Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
+ uint8_t fix_type; ///< 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS fix, 5: RTK Fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
+ uint8_t satellites_visible; ///< Number of satellites visible. If unknown, set to 255
+ uint8_t dgps_numch; ///< Number of DGPS satellites
+} mavlink_gps2_raw_t;
+
+#define MAVLINK_MSG_ID_GPS2_RAW_LEN 35
+#define MAVLINK_MSG_ID_124_LEN 35
+
+#define MAVLINK_MSG_ID_GPS2_RAW_CRC 87
+#define MAVLINK_MSG_ID_124_CRC 87
+
+
+
+#define MAVLINK_MESSAGE_INFO_GPS2_RAW { \
+	"GPS2_RAW", \
+	12, \
+	{  { "time_usec", NULL, MAVLINK_TYPE_UINT64_T, 0, 0, offsetof(mavlink_gps2_raw_t, time_usec) }, \
+         { "lat", NULL, MAVLINK_TYPE_INT32_T, 0, 8, offsetof(mavlink_gps2_raw_t, lat) }, \
+         { "lon", NULL, MAVLINK_TYPE_INT32_T, 0, 12, offsetof(mavlink_gps2_raw_t, lon) }, \
+         { "alt", NULL, MAVLINK_TYPE_INT32_T, 0, 16, offsetof(mavlink_gps2_raw_t, alt) }, \
+         { "dgps_age", NULL, MAVLINK_TYPE_UINT32_T, 0, 20, offsetof(mavlink_gps2_raw_t, dgps_age) }, \
+         { "eph", NULL, MAVLINK_TYPE_UINT16_T, 0, 24, offsetof(mavlink_gps2_raw_t, eph) }, \
+         { "epv", NULL, MAVLINK_TYPE_UINT16_T, 0, 26, offsetof(mavlink_gps2_raw_t, epv) }, \
+         { "vel", NULL, MAVLINK_TYPE_UINT16_T, 0, 28, offsetof(mavlink_gps2_raw_t, vel) }, \
+         { "cog", NULL, MAVLINK_TYPE_UINT16_T, 0, 30, offsetof(mavlink_gps2_raw_t, cog) }, \
+         { "fix_type", NULL, MAVLINK_TYPE_UINT8_T, 0, 32, offsetof(mavlink_gps2_raw_t, fix_type) }, \
+         { "satellites_visible", NULL, MAVLINK_TYPE_UINT8_T, 0, 33, offsetof(mavlink_gps2_raw_t, satellites_visible) }, \
+         { "dgps_numch", NULL, MAVLINK_TYPE_UINT8_T, 0, 34, offsetof(mavlink_gps2_raw_t, dgps_numch) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a gps2_raw message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
+ * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS fix, 5: RTK Fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
+ * @param lat Latitude (WGS84), in degrees * 1E7
+ * @param lon Longitude (WGS84), in degrees * 1E7
+ * @param alt Altitude (AMSL, not WGS84), in meters * 1000 (positive for up)
+ * @param eph GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ * @param epv GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ * @param vel GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX
+ * @param cog Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
+ * @param satellites_visible Number of satellites visible. If unknown, set to 255
+ * @param dgps_numch Number of DGPS satellites
+ * @param dgps_age Age of DGPS info
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_gps2_raw_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint64_t time_usec, uint8_t fix_type, int32_t lat, int32_t lon, int32_t alt, uint16_t eph, uint16_t epv, uint16_t vel, uint16_t cog, uint8_t satellites_visible, uint8_t dgps_numch, uint32_t dgps_age)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_GPS2_RAW_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_int32_t(buf, 8, lat);
+	_mav_put_int32_t(buf, 12, lon);
+	_mav_put_int32_t(buf, 16, alt);
+	_mav_put_uint32_t(buf, 20, dgps_age);
+	_mav_put_uint16_t(buf, 24, eph);
+	_mav_put_uint16_t(buf, 26, epv);
+	_mav_put_uint16_t(buf, 28, vel);
+	_mav_put_uint16_t(buf, 30, cog);
+	_mav_put_uint8_t(buf, 32, fix_type);
+	_mav_put_uint8_t(buf, 33, satellites_visible);
+	_mav_put_uint8_t(buf, 34, dgps_numch);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS2_RAW_LEN);
+#else
+	mavlink_gps2_raw_t packet;
+	packet.time_usec = time_usec;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.alt = alt;
+	packet.dgps_age = dgps_age;
+	packet.eph = eph;
+	packet.epv = epv;
+	packet.vel = vel;
+	packet.cog = cog;
+	packet.fix_type = fix_type;
+	packet.satellites_visible = satellites_visible;
+	packet.dgps_numch = dgps_numch;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS2_RAW_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_GPS2_RAW;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS2_RAW_LEN, MAVLINK_MSG_ID_GPS2_RAW_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS2_RAW_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a gps2_raw message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
+ * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS fix, 5: RTK Fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
+ * @param lat Latitude (WGS84), in degrees * 1E7
+ * @param lon Longitude (WGS84), in degrees * 1E7
+ * @param alt Altitude (AMSL, not WGS84), in meters * 1000 (positive for up)
+ * @param eph GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ * @param epv GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ * @param vel GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX
+ * @param cog Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
+ * @param satellites_visible Number of satellites visible. If unknown, set to 255
+ * @param dgps_numch Number of DGPS satellites
+ * @param dgps_age Age of DGPS info
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_gps2_raw_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint64_t time_usec,uint8_t fix_type,int32_t lat,int32_t lon,int32_t alt,uint16_t eph,uint16_t epv,uint16_t vel,uint16_t cog,uint8_t satellites_visible,uint8_t dgps_numch,uint32_t dgps_age)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_GPS2_RAW_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_int32_t(buf, 8, lat);
+	_mav_put_int32_t(buf, 12, lon);
+	_mav_put_int32_t(buf, 16, alt);
+	_mav_put_uint32_t(buf, 20, dgps_age);
+	_mav_put_uint16_t(buf, 24, eph);
+	_mav_put_uint16_t(buf, 26, epv);
+	_mav_put_uint16_t(buf, 28, vel);
+	_mav_put_uint16_t(buf, 30, cog);
+	_mav_put_uint8_t(buf, 32, fix_type);
+	_mav_put_uint8_t(buf, 33, satellites_visible);
+	_mav_put_uint8_t(buf, 34, dgps_numch);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS2_RAW_LEN);
+#else
+	mavlink_gps2_raw_t packet;
+	packet.time_usec = time_usec;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.alt = alt;
+	packet.dgps_age = dgps_age;
+	packet.eph = eph;
+	packet.epv = epv;
+	packet.vel = vel;
+	packet.cog = cog;
+	packet.fix_type = fix_type;
+	packet.satellites_visible = satellites_visible;
+	packet.dgps_numch = dgps_numch;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS2_RAW_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_GPS2_RAW;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GPS2_RAW_LEN, MAVLINK_MSG_ID_GPS2_RAW_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GPS2_RAW_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a gps2_raw struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param gps2_raw C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_gps2_raw_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_gps2_raw_t* gps2_raw)
+{
+	return mavlink_msg_gps2_raw_pack(system_id, component_id, msg, gps2_raw->time_usec, gps2_raw->fix_type, gps2_raw->lat, gps2_raw->lon, gps2_raw->alt, gps2_raw->eph, gps2_raw->epv, gps2_raw->vel, gps2_raw->cog, gps2_raw->satellites_visible, gps2_raw->dgps_numch, gps2_raw->dgps_age);
+}
+
+/**
+ * @brief Encode a gps2_raw struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param gps2_raw C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_gps2_raw_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_gps2_raw_t* gps2_raw)
+{
+	return mavlink_msg_gps2_raw_pack_chan(system_id, component_id, chan, msg, gps2_raw->time_usec, gps2_raw->fix_type, gps2_raw->lat, gps2_raw->lon, gps2_raw->alt, gps2_raw->eph, gps2_raw->epv, gps2_raw->vel, gps2_raw->cog, gps2_raw->satellites_visible, gps2_raw->dgps_numch, gps2_raw->dgps_age);
+}
+
+/**
+ * @brief Send a gps2_raw message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
+ * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS fix, 5: RTK Fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
+ * @param lat Latitude (WGS84), in degrees * 1E7
+ * @param lon Longitude (WGS84), in degrees * 1E7
+ * @param alt Altitude (AMSL, not WGS84), in meters * 1000 (positive for up)
+ * @param eph GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ * @param epv GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ * @param vel GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX
+ * @param cog Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
+ * @param satellites_visible Number of satellites visible. If unknown, set to 255
+ * @param dgps_numch Number of DGPS satellites
+ * @param dgps_age Age of DGPS info
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_gps2_raw_send(mavlink_channel_t chan, uint64_t time_usec, uint8_t fix_type, int32_t lat, int32_t lon, int32_t alt, uint16_t eph, uint16_t epv, uint16_t vel, uint16_t cog, uint8_t satellites_visible, uint8_t dgps_numch, uint32_t dgps_age)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_GPS2_RAW_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_int32_t(buf, 8, lat);
+	_mav_put_int32_t(buf, 12, lon);
+	_mav_put_int32_t(buf, 16, alt);
+	_mav_put_uint32_t(buf, 20, dgps_age);
+	_mav_put_uint16_t(buf, 24, eph);
+	_mav_put_uint16_t(buf, 26, epv);
+	_mav_put_uint16_t(buf, 28, vel);
+	_mav_put_uint16_t(buf, 30, cog);
+	_mav_put_uint8_t(buf, 32, fix_type);
+	_mav_put_uint8_t(buf, 33, satellites_visible);
+	_mav_put_uint8_t(buf, 34, dgps_numch);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS2_RAW, buf, MAVLINK_MSG_ID_GPS2_RAW_LEN, MAVLINK_MSG_ID_GPS2_RAW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS2_RAW, buf, MAVLINK_MSG_ID_GPS2_RAW_LEN);
+#endif
+#else
+	mavlink_gps2_raw_t packet;
+	packet.time_usec = time_usec;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.alt = alt;
+	packet.dgps_age = dgps_age;
+	packet.eph = eph;
+	packet.epv = epv;
+	packet.vel = vel;
+	packet.cog = cog;
+	packet.fix_type = fix_type;
+	packet.satellites_visible = satellites_visible;
+	packet.dgps_numch = dgps_numch;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS2_RAW, (const char *)&packet, MAVLINK_MSG_ID_GPS2_RAW_LEN, MAVLINK_MSG_ID_GPS2_RAW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS2_RAW, (const char *)&packet, MAVLINK_MSG_ID_GPS2_RAW_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_GPS2_RAW_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_gps2_raw_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t time_usec, uint8_t fix_type, int32_t lat, int32_t lon, int32_t alt, uint16_t eph, uint16_t epv, uint16_t vel, uint16_t cog, uint8_t satellites_visible, uint8_t dgps_numch, uint32_t dgps_age)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_int32_t(buf, 8, lat);
+	_mav_put_int32_t(buf, 12, lon);
+	_mav_put_int32_t(buf, 16, alt);
+	_mav_put_uint32_t(buf, 20, dgps_age);
+	_mav_put_uint16_t(buf, 24, eph);
+	_mav_put_uint16_t(buf, 26, epv);
+	_mav_put_uint16_t(buf, 28, vel);
+	_mav_put_uint16_t(buf, 30, cog);
+	_mav_put_uint8_t(buf, 32, fix_type);
+	_mav_put_uint8_t(buf, 33, satellites_visible);
+	_mav_put_uint8_t(buf, 34, dgps_numch);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS2_RAW, buf, MAVLINK_MSG_ID_GPS2_RAW_LEN, MAVLINK_MSG_ID_GPS2_RAW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS2_RAW, buf, MAVLINK_MSG_ID_GPS2_RAW_LEN);
+#endif
+#else
+	mavlink_gps2_raw_t *packet = (mavlink_gps2_raw_t *)msgbuf;
+	packet->time_usec = time_usec;
+	packet->lat = lat;
+	packet->lon = lon;
+	packet->alt = alt;
+	packet->dgps_age = dgps_age;
+	packet->eph = eph;
+	packet->epv = epv;
+	packet->vel = vel;
+	packet->cog = cog;
+	packet->fix_type = fix_type;
+	packet->satellites_visible = satellites_visible;
+	packet->dgps_numch = dgps_numch;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS2_RAW, (const char *)packet, MAVLINK_MSG_ID_GPS2_RAW_LEN, MAVLINK_MSG_ID_GPS2_RAW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS2_RAW, (const char *)packet, MAVLINK_MSG_ID_GPS2_RAW_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE GPS2_RAW UNPACKING
+
+
+/**
+ * @brief Get field time_usec from gps2_raw message
+ *
+ * @return Timestamp (microseconds since UNIX epoch or microseconds since system boot)
+ */
+static inline uint64_t mavlink_msg_gps2_raw_get_time_usec(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint64_t(msg,  0);
+}
+
+/**
+ * @brief Get field fix_type from gps2_raw message
+ *
+ * @return 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS fix, 5: RTK Fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
+ */
+static inline uint8_t mavlink_msg_gps2_raw_get_fix_type(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  32);
+}
+
+/**
+ * @brief Get field lat from gps2_raw message
+ *
+ * @return Latitude (WGS84), in degrees * 1E7
+ */
+static inline int32_t mavlink_msg_gps2_raw_get_lat(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  8);
+}
+
+/**
+ * @brief Get field lon from gps2_raw message
+ *
+ * @return Longitude (WGS84), in degrees * 1E7
+ */
+static inline int32_t mavlink_msg_gps2_raw_get_lon(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  12);
+}
+
+/**
+ * @brief Get field alt from gps2_raw message
+ *
+ * @return Altitude (AMSL, not WGS84), in meters * 1000 (positive for up)
+ */
+static inline int32_t mavlink_msg_gps2_raw_get_alt(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  16);
+}
+
+/**
+ * @brief Get field eph from gps2_raw message
+ *
+ * @return GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ */
+static inline uint16_t mavlink_msg_gps2_raw_get_eph(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  24);
+}
+
+/**
+ * @brief Get field epv from gps2_raw message
+ *
+ * @return GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ */
+static inline uint16_t mavlink_msg_gps2_raw_get_epv(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  26);
+}
+
+/**
+ * @brief Get field vel from gps2_raw message
+ *
+ * @return GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX
+ */
+static inline uint16_t mavlink_msg_gps2_raw_get_vel(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  28);
+}
+
+/**
+ * @brief Get field cog from gps2_raw message
+ *
+ * @return Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
+ */
+static inline uint16_t mavlink_msg_gps2_raw_get_cog(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  30);
+}
+
+/**
+ * @brief Get field satellites_visible from gps2_raw message
+ *
+ * @return Number of satellites visible. If unknown, set to 255
+ */
+static inline uint8_t mavlink_msg_gps2_raw_get_satellites_visible(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  33);
+}
+
+/**
+ * @brief Get field dgps_numch from gps2_raw message
+ *
+ * @return Number of DGPS satellites
+ */
+static inline uint8_t mavlink_msg_gps2_raw_get_dgps_numch(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  34);
+}
+
+/**
+ * @brief Get field dgps_age from gps2_raw message
+ *
+ * @return Age of DGPS info
+ */
+static inline uint32_t mavlink_msg_gps2_raw_get_dgps_age(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  20);
+}
+
+/**
+ * @brief Decode a gps2_raw message into a struct
+ *
+ * @param msg The message to decode
+ * @param gps2_raw C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_gps2_raw_decode(const mavlink_message_t* msg, mavlink_gps2_raw_t* gps2_raw)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	gps2_raw->time_usec = mavlink_msg_gps2_raw_get_time_usec(msg);
+	gps2_raw->lat = mavlink_msg_gps2_raw_get_lat(msg);
+	gps2_raw->lon = mavlink_msg_gps2_raw_get_lon(msg);
+	gps2_raw->alt = mavlink_msg_gps2_raw_get_alt(msg);
+	gps2_raw->dgps_age = mavlink_msg_gps2_raw_get_dgps_age(msg);
+	gps2_raw->eph = mavlink_msg_gps2_raw_get_eph(msg);
+	gps2_raw->epv = mavlink_msg_gps2_raw_get_epv(msg);
+	gps2_raw->vel = mavlink_msg_gps2_raw_get_vel(msg);
+	gps2_raw->cog = mavlink_msg_gps2_raw_get_cog(msg);
+	gps2_raw->fix_type = mavlink_msg_gps2_raw_get_fix_type(msg);
+	gps2_raw->satellites_visible = mavlink_msg_gps2_raw_get_satellites_visible(msg);
+	gps2_raw->dgps_numch = mavlink_msg_gps2_raw_get_dgps_numch(msg);
+#else
+	memcpy(gps2_raw, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_GPS2_RAW_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_gps2_rtk.h v1.0/common/mavlink_msg_gps2_rtk.h
--- v1.0.old/common/mavlink_msg_gps2_rtk.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_gps2_rtk.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,497 @@
+// MESSAGE GPS2_RTK PACKING
+
+#define MAVLINK_MSG_ID_GPS2_RTK 128
+
+typedef struct __mavlink_gps2_rtk_t
+{
+ uint32_t time_last_baseline_ms; ///< Time since boot of last baseline message received in ms.
+ uint32_t tow; ///< GPS Time of Week of last baseline
+ int32_t baseline_a_mm; ///< Current baseline in ECEF x or NED north component in mm.
+ int32_t baseline_b_mm; ///< Current baseline in ECEF y or NED east component in mm.
+ int32_t baseline_c_mm; ///< Current baseline in ECEF z or NED down component in mm.
+ uint32_t accuracy; ///< Current estimate of baseline accuracy.
+ int32_t iar_num_hypotheses; ///< Current number of integer ambiguity hypotheses.
+ uint16_t wn; ///< GPS Week Number of last baseline
+ uint8_t rtk_receiver_id; ///< Identification of connected RTK receiver.
+ uint8_t rtk_health; ///< GPS-specific health report for RTK data.
+ uint8_t rtk_rate; ///< Rate of baseline messages being received by GPS, in HZ
+ uint8_t nsats; ///< Current number of sats used for RTK calculation.
+ uint8_t baseline_coords_type; ///< Coordinate system of baseline. 0 == ECEF, 1 == NED
+} mavlink_gps2_rtk_t;
+
+#define MAVLINK_MSG_ID_GPS2_RTK_LEN 35
+#define MAVLINK_MSG_ID_128_LEN 35
+
+#define MAVLINK_MSG_ID_GPS2_RTK_CRC 226
+#define MAVLINK_MSG_ID_128_CRC 226
+
+
+
+#define MAVLINK_MESSAGE_INFO_GPS2_RTK { \
+	"GPS2_RTK", \
+	13, \
+	{  { "time_last_baseline_ms", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_gps2_rtk_t, time_last_baseline_ms) }, \
+         { "tow", NULL, MAVLINK_TYPE_UINT32_T, 0, 4, offsetof(mavlink_gps2_rtk_t, tow) }, \
+         { "baseline_a_mm", NULL, MAVLINK_TYPE_INT32_T, 0, 8, offsetof(mavlink_gps2_rtk_t, baseline_a_mm) }, \
+         { "baseline_b_mm", NULL, MAVLINK_TYPE_INT32_T, 0, 12, offsetof(mavlink_gps2_rtk_t, baseline_b_mm) }, \
+         { "baseline_c_mm", NULL, MAVLINK_TYPE_INT32_T, 0, 16, offsetof(mavlink_gps2_rtk_t, baseline_c_mm) }, \
+         { "accuracy", NULL, MAVLINK_TYPE_UINT32_T, 0, 20, offsetof(mavlink_gps2_rtk_t, accuracy) }, \
+         { "iar_num_hypotheses", NULL, MAVLINK_TYPE_INT32_T, 0, 24, offsetof(mavlink_gps2_rtk_t, iar_num_hypotheses) }, \
+         { "wn", NULL, MAVLINK_TYPE_UINT16_T, 0, 28, offsetof(mavlink_gps2_rtk_t, wn) }, \
+         { "rtk_receiver_id", NULL, MAVLINK_TYPE_UINT8_T, 0, 30, offsetof(mavlink_gps2_rtk_t, rtk_receiver_id) }, \
+         { "rtk_health", NULL, MAVLINK_TYPE_UINT8_T, 0, 31, offsetof(mavlink_gps2_rtk_t, rtk_health) }, \
+         { "rtk_rate", NULL, MAVLINK_TYPE_UINT8_T, 0, 32, offsetof(mavlink_gps2_rtk_t, rtk_rate) }, \
+         { "nsats", NULL, MAVLINK_TYPE_UINT8_T, 0, 33, offsetof(mavlink_gps2_rtk_t, nsats) }, \
+         { "baseline_coords_type", NULL, MAVLINK_TYPE_UINT8_T, 0, 34, offsetof(mavlink_gps2_rtk_t, baseline_coords_type) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a gps2_rtk message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_last_baseline_ms Time since boot of last baseline message received in ms.
+ * @param rtk_receiver_id Identification of connected RTK receiver.
+ * @param wn GPS Week Number of last baseline
+ * @param tow GPS Time of Week of last baseline
+ * @param rtk_health GPS-specific health report for RTK data.
+ * @param rtk_rate Rate of baseline messages being received by GPS, in HZ
+ * @param nsats Current number of sats used for RTK calculation.
+ * @param baseline_coords_type Coordinate system of baseline. 0 == ECEF, 1 == NED
+ * @param baseline_a_mm Current baseline in ECEF x or NED north component in mm.
+ * @param baseline_b_mm Current baseline in ECEF y or NED east component in mm.
+ * @param baseline_c_mm Current baseline in ECEF z or NED down component in mm.
+ * @param accuracy Current estimate of baseline accuracy.
+ * @param iar_num_hypotheses Current number of integer ambiguity hypotheses.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_gps2_rtk_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint32_t time_last_baseline_ms, uint8_t rtk_receiver_id, uint16_t wn, uint32_t tow, uint8_t rtk_health, uint8_t rtk_rate, uint8_t nsats, uint8_t baseline_coords_type, int32_t baseline_a_mm, int32_t baseline_b_mm, int32_t baseline_c_mm, uint32_t accuracy, int32_t iar_num_hypotheses)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_GPS2_RTK_LEN];
+	_mav_put_uint32_t(buf, 0, time_last_baseline_ms);
+	_mav_put_uint32_t(buf, 4, tow);
+	_mav_put_int32_t(buf, 8, baseline_a_mm);
+	_mav_put_int32_t(buf, 12, baseline_b_mm);
+	_mav_put_int32_t(buf, 16, baseline_c_mm);
+	_mav_put_uint32_t(buf, 20, accuracy);
+	_mav_put_int32_t(buf, 24, iar_num_hypotheses);
+	_mav_put_uint16_t(buf, 28, wn);
+	_mav_put_uint8_t(buf, 30, rtk_receiver_id);
+	_mav_put_uint8_t(buf, 31, rtk_health);
+	_mav_put_uint8_t(buf, 32, rtk_rate);
+	_mav_put_uint8_t(buf, 33, nsats);
+	_mav_put_uint8_t(buf, 34, baseline_coords_type);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS2_RTK_LEN);
+#else
+	mavlink_gps2_rtk_t packet;
+	packet.time_last_baseline_ms = time_last_baseline_ms;
+	packet.tow = tow;
+	packet.baseline_a_mm = baseline_a_mm;
+	packet.baseline_b_mm = baseline_b_mm;
+	packet.baseline_c_mm = baseline_c_mm;
+	packet.accuracy = accuracy;
+	packet.iar_num_hypotheses = iar_num_hypotheses;
+	packet.wn = wn;
+	packet.rtk_receiver_id = rtk_receiver_id;
+	packet.rtk_health = rtk_health;
+	packet.rtk_rate = rtk_rate;
+	packet.nsats = nsats;
+	packet.baseline_coords_type = baseline_coords_type;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS2_RTK_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_GPS2_RTK;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS2_RTK_LEN, MAVLINK_MSG_ID_GPS2_RTK_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS2_RTK_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a gps2_rtk message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_last_baseline_ms Time since boot of last baseline message received in ms.
+ * @param rtk_receiver_id Identification of connected RTK receiver.
+ * @param wn GPS Week Number of last baseline
+ * @param tow GPS Time of Week of last baseline
+ * @param rtk_health GPS-specific health report for RTK data.
+ * @param rtk_rate Rate of baseline messages being received by GPS, in HZ
+ * @param nsats Current number of sats used for RTK calculation.
+ * @param baseline_coords_type Coordinate system of baseline. 0 == ECEF, 1 == NED
+ * @param baseline_a_mm Current baseline in ECEF x or NED north component in mm.
+ * @param baseline_b_mm Current baseline in ECEF y or NED east component in mm.
+ * @param baseline_c_mm Current baseline in ECEF z or NED down component in mm.
+ * @param accuracy Current estimate of baseline accuracy.
+ * @param iar_num_hypotheses Current number of integer ambiguity hypotheses.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_gps2_rtk_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint32_t time_last_baseline_ms,uint8_t rtk_receiver_id,uint16_t wn,uint32_t tow,uint8_t rtk_health,uint8_t rtk_rate,uint8_t nsats,uint8_t baseline_coords_type,int32_t baseline_a_mm,int32_t baseline_b_mm,int32_t baseline_c_mm,uint32_t accuracy,int32_t iar_num_hypotheses)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_GPS2_RTK_LEN];
+	_mav_put_uint32_t(buf, 0, time_last_baseline_ms);
+	_mav_put_uint32_t(buf, 4, tow);
+	_mav_put_int32_t(buf, 8, baseline_a_mm);
+	_mav_put_int32_t(buf, 12, baseline_b_mm);
+	_mav_put_int32_t(buf, 16, baseline_c_mm);
+	_mav_put_uint32_t(buf, 20, accuracy);
+	_mav_put_int32_t(buf, 24, iar_num_hypotheses);
+	_mav_put_uint16_t(buf, 28, wn);
+	_mav_put_uint8_t(buf, 30, rtk_receiver_id);
+	_mav_put_uint8_t(buf, 31, rtk_health);
+	_mav_put_uint8_t(buf, 32, rtk_rate);
+	_mav_put_uint8_t(buf, 33, nsats);
+	_mav_put_uint8_t(buf, 34, baseline_coords_type);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS2_RTK_LEN);
+#else
+	mavlink_gps2_rtk_t packet;
+	packet.time_last_baseline_ms = time_last_baseline_ms;
+	packet.tow = tow;
+	packet.baseline_a_mm = baseline_a_mm;
+	packet.baseline_b_mm = baseline_b_mm;
+	packet.baseline_c_mm = baseline_c_mm;
+	packet.accuracy = accuracy;
+	packet.iar_num_hypotheses = iar_num_hypotheses;
+	packet.wn = wn;
+	packet.rtk_receiver_id = rtk_receiver_id;
+	packet.rtk_health = rtk_health;
+	packet.rtk_rate = rtk_rate;
+	packet.nsats = nsats;
+	packet.baseline_coords_type = baseline_coords_type;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS2_RTK_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_GPS2_RTK;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GPS2_RTK_LEN, MAVLINK_MSG_ID_GPS2_RTK_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GPS2_RTK_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a gps2_rtk struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param gps2_rtk C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_gps2_rtk_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_gps2_rtk_t* gps2_rtk)
+{
+	return mavlink_msg_gps2_rtk_pack(system_id, component_id, msg, gps2_rtk->time_last_baseline_ms, gps2_rtk->rtk_receiver_id, gps2_rtk->wn, gps2_rtk->tow, gps2_rtk->rtk_health, gps2_rtk->rtk_rate, gps2_rtk->nsats, gps2_rtk->baseline_coords_type, gps2_rtk->baseline_a_mm, gps2_rtk->baseline_b_mm, gps2_rtk->baseline_c_mm, gps2_rtk->accuracy, gps2_rtk->iar_num_hypotheses);
+}
+
+/**
+ * @brief Encode a gps2_rtk struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param gps2_rtk C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_gps2_rtk_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_gps2_rtk_t* gps2_rtk)
+{
+	return mavlink_msg_gps2_rtk_pack_chan(system_id, component_id, chan, msg, gps2_rtk->time_last_baseline_ms, gps2_rtk->rtk_receiver_id, gps2_rtk->wn, gps2_rtk->tow, gps2_rtk->rtk_health, gps2_rtk->rtk_rate, gps2_rtk->nsats, gps2_rtk->baseline_coords_type, gps2_rtk->baseline_a_mm, gps2_rtk->baseline_b_mm, gps2_rtk->baseline_c_mm, gps2_rtk->accuracy, gps2_rtk->iar_num_hypotheses);
+}
+
+/**
+ * @brief Send a gps2_rtk message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_last_baseline_ms Time since boot of last baseline message received in ms.
+ * @param rtk_receiver_id Identification of connected RTK receiver.
+ * @param wn GPS Week Number of last baseline
+ * @param tow GPS Time of Week of last baseline
+ * @param rtk_health GPS-specific health report for RTK data.
+ * @param rtk_rate Rate of baseline messages being received by GPS, in HZ
+ * @param nsats Current number of sats used for RTK calculation.
+ * @param baseline_coords_type Coordinate system of baseline. 0 == ECEF, 1 == NED
+ * @param baseline_a_mm Current baseline in ECEF x or NED north component in mm.
+ * @param baseline_b_mm Current baseline in ECEF y or NED east component in mm.
+ * @param baseline_c_mm Current baseline in ECEF z or NED down component in mm.
+ * @param accuracy Current estimate of baseline accuracy.
+ * @param iar_num_hypotheses Current number of integer ambiguity hypotheses.
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_gps2_rtk_send(mavlink_channel_t chan, uint32_t time_last_baseline_ms, uint8_t rtk_receiver_id, uint16_t wn, uint32_t tow, uint8_t rtk_health, uint8_t rtk_rate, uint8_t nsats, uint8_t baseline_coords_type, int32_t baseline_a_mm, int32_t baseline_b_mm, int32_t baseline_c_mm, uint32_t accuracy, int32_t iar_num_hypotheses)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_GPS2_RTK_LEN];
+	_mav_put_uint32_t(buf, 0, time_last_baseline_ms);
+	_mav_put_uint32_t(buf, 4, tow);
+	_mav_put_int32_t(buf, 8, baseline_a_mm);
+	_mav_put_int32_t(buf, 12, baseline_b_mm);
+	_mav_put_int32_t(buf, 16, baseline_c_mm);
+	_mav_put_uint32_t(buf, 20, accuracy);
+	_mav_put_int32_t(buf, 24, iar_num_hypotheses);
+	_mav_put_uint16_t(buf, 28, wn);
+	_mav_put_uint8_t(buf, 30, rtk_receiver_id);
+	_mav_put_uint8_t(buf, 31, rtk_health);
+	_mav_put_uint8_t(buf, 32, rtk_rate);
+	_mav_put_uint8_t(buf, 33, nsats);
+	_mav_put_uint8_t(buf, 34, baseline_coords_type);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS2_RTK, buf, MAVLINK_MSG_ID_GPS2_RTK_LEN, MAVLINK_MSG_ID_GPS2_RTK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS2_RTK, buf, MAVLINK_MSG_ID_GPS2_RTK_LEN);
+#endif
+#else
+	mavlink_gps2_rtk_t packet;
+	packet.time_last_baseline_ms = time_last_baseline_ms;
+	packet.tow = tow;
+	packet.baseline_a_mm = baseline_a_mm;
+	packet.baseline_b_mm = baseline_b_mm;
+	packet.baseline_c_mm = baseline_c_mm;
+	packet.accuracy = accuracy;
+	packet.iar_num_hypotheses = iar_num_hypotheses;
+	packet.wn = wn;
+	packet.rtk_receiver_id = rtk_receiver_id;
+	packet.rtk_health = rtk_health;
+	packet.rtk_rate = rtk_rate;
+	packet.nsats = nsats;
+	packet.baseline_coords_type = baseline_coords_type;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS2_RTK, (const char *)&packet, MAVLINK_MSG_ID_GPS2_RTK_LEN, MAVLINK_MSG_ID_GPS2_RTK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS2_RTK, (const char *)&packet, MAVLINK_MSG_ID_GPS2_RTK_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_GPS2_RTK_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_gps2_rtk_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_last_baseline_ms, uint8_t rtk_receiver_id, uint16_t wn, uint32_t tow, uint8_t rtk_health, uint8_t rtk_rate, uint8_t nsats, uint8_t baseline_coords_type, int32_t baseline_a_mm, int32_t baseline_b_mm, int32_t baseline_c_mm, uint32_t accuracy, int32_t iar_num_hypotheses)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_last_baseline_ms);
+	_mav_put_uint32_t(buf, 4, tow);
+	_mav_put_int32_t(buf, 8, baseline_a_mm);
+	_mav_put_int32_t(buf, 12, baseline_b_mm);
+	_mav_put_int32_t(buf, 16, baseline_c_mm);
+	_mav_put_uint32_t(buf, 20, accuracy);
+	_mav_put_int32_t(buf, 24, iar_num_hypotheses);
+	_mav_put_uint16_t(buf, 28, wn);
+	_mav_put_uint8_t(buf, 30, rtk_receiver_id);
+	_mav_put_uint8_t(buf, 31, rtk_health);
+	_mav_put_uint8_t(buf, 32, rtk_rate);
+	_mav_put_uint8_t(buf, 33, nsats);
+	_mav_put_uint8_t(buf, 34, baseline_coords_type);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS2_RTK, buf, MAVLINK_MSG_ID_GPS2_RTK_LEN, MAVLINK_MSG_ID_GPS2_RTK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS2_RTK, buf, MAVLINK_MSG_ID_GPS2_RTK_LEN);
+#endif
+#else
+	mavlink_gps2_rtk_t *packet = (mavlink_gps2_rtk_t *)msgbuf;
+	packet->time_last_baseline_ms = time_last_baseline_ms;
+	packet->tow = tow;
+	packet->baseline_a_mm = baseline_a_mm;
+	packet->baseline_b_mm = baseline_b_mm;
+	packet->baseline_c_mm = baseline_c_mm;
+	packet->accuracy = accuracy;
+	packet->iar_num_hypotheses = iar_num_hypotheses;
+	packet->wn = wn;
+	packet->rtk_receiver_id = rtk_receiver_id;
+	packet->rtk_health = rtk_health;
+	packet->rtk_rate = rtk_rate;
+	packet->nsats = nsats;
+	packet->baseline_coords_type = baseline_coords_type;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS2_RTK, (const char *)packet, MAVLINK_MSG_ID_GPS2_RTK_LEN, MAVLINK_MSG_ID_GPS2_RTK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS2_RTK, (const char *)packet, MAVLINK_MSG_ID_GPS2_RTK_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE GPS2_RTK UNPACKING
+
+
+/**
+ * @brief Get field time_last_baseline_ms from gps2_rtk message
+ *
+ * @return Time since boot of last baseline message received in ms.
+ */
+static inline uint32_t mavlink_msg_gps2_rtk_get_time_last_baseline_ms(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field rtk_receiver_id from gps2_rtk message
+ *
+ * @return Identification of connected RTK receiver.
+ */
+static inline uint8_t mavlink_msg_gps2_rtk_get_rtk_receiver_id(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  30);
+}
+
+/**
+ * @brief Get field wn from gps2_rtk message
+ *
+ * @return GPS Week Number of last baseline
+ */
+static inline uint16_t mavlink_msg_gps2_rtk_get_wn(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  28);
+}
+
+/**
+ * @brief Get field tow from gps2_rtk message
+ *
+ * @return GPS Time of Week of last baseline
+ */
+static inline uint32_t mavlink_msg_gps2_rtk_get_tow(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  4);
+}
+
+/**
+ * @brief Get field rtk_health from gps2_rtk message
+ *
+ * @return GPS-specific health report for RTK data.
+ */
+static inline uint8_t mavlink_msg_gps2_rtk_get_rtk_health(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  31);
+}
+
+/**
+ * @brief Get field rtk_rate from gps2_rtk message
+ *
+ * @return Rate of baseline messages being received by GPS, in HZ
+ */
+static inline uint8_t mavlink_msg_gps2_rtk_get_rtk_rate(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  32);
+}
+
+/**
+ * @brief Get field nsats from gps2_rtk message
+ *
+ * @return Current number of sats used for RTK calculation.
+ */
+static inline uint8_t mavlink_msg_gps2_rtk_get_nsats(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  33);
+}
+
+/**
+ * @brief Get field baseline_coords_type from gps2_rtk message
+ *
+ * @return Coordinate system of baseline. 0 == ECEF, 1 == NED
+ */
+static inline uint8_t mavlink_msg_gps2_rtk_get_baseline_coords_type(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  34);
+}
+
+/**
+ * @brief Get field baseline_a_mm from gps2_rtk message
+ *
+ * @return Current baseline in ECEF x or NED north component in mm.
+ */
+static inline int32_t mavlink_msg_gps2_rtk_get_baseline_a_mm(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  8);
+}
+
+/**
+ * @brief Get field baseline_b_mm from gps2_rtk message
+ *
+ * @return Current baseline in ECEF y or NED east component in mm.
+ */
+static inline int32_t mavlink_msg_gps2_rtk_get_baseline_b_mm(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  12);
+}
+
+/**
+ * @brief Get field baseline_c_mm from gps2_rtk message
+ *
+ * @return Current baseline in ECEF z or NED down component in mm.
+ */
+static inline int32_t mavlink_msg_gps2_rtk_get_baseline_c_mm(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  16);
+}
+
+/**
+ * @brief Get field accuracy from gps2_rtk message
+ *
+ * @return Current estimate of baseline accuracy.
+ */
+static inline uint32_t mavlink_msg_gps2_rtk_get_accuracy(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  20);
+}
+
+/**
+ * @brief Get field iar_num_hypotheses from gps2_rtk message
+ *
+ * @return Current number of integer ambiguity hypotheses.
+ */
+static inline int32_t mavlink_msg_gps2_rtk_get_iar_num_hypotheses(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  24);
+}
+
+/**
+ * @brief Decode a gps2_rtk message into a struct
+ *
+ * @param msg The message to decode
+ * @param gps2_rtk C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_gps2_rtk_decode(const mavlink_message_t* msg, mavlink_gps2_rtk_t* gps2_rtk)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	gps2_rtk->time_last_baseline_ms = mavlink_msg_gps2_rtk_get_time_last_baseline_ms(msg);
+	gps2_rtk->tow = mavlink_msg_gps2_rtk_get_tow(msg);
+	gps2_rtk->baseline_a_mm = mavlink_msg_gps2_rtk_get_baseline_a_mm(msg);
+	gps2_rtk->baseline_b_mm = mavlink_msg_gps2_rtk_get_baseline_b_mm(msg);
+	gps2_rtk->baseline_c_mm = mavlink_msg_gps2_rtk_get_baseline_c_mm(msg);
+	gps2_rtk->accuracy = mavlink_msg_gps2_rtk_get_accuracy(msg);
+	gps2_rtk->iar_num_hypotheses = mavlink_msg_gps2_rtk_get_iar_num_hypotheses(msg);
+	gps2_rtk->wn = mavlink_msg_gps2_rtk_get_wn(msg);
+	gps2_rtk->rtk_receiver_id = mavlink_msg_gps2_rtk_get_rtk_receiver_id(msg);
+	gps2_rtk->rtk_health = mavlink_msg_gps2_rtk_get_rtk_health(msg);
+	gps2_rtk->rtk_rate = mavlink_msg_gps2_rtk_get_rtk_rate(msg);
+	gps2_rtk->nsats = mavlink_msg_gps2_rtk_get_nsats(msg);
+	gps2_rtk->baseline_coords_type = mavlink_msg_gps2_rtk_get_baseline_coords_type(msg);
+#else
+	memcpy(gps2_rtk, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_GPS2_RTK_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_gps_global_origin.h v1.0/common/mavlink_msg_gps_global_origin.h
--- v1.0.old/common/mavlink_msg_gps_global_origin.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_gps_global_origin.h	2015-02-06 11:50:58.000000000 +0500
@@ -4,14 +4,17 @@
 
 typedef struct __mavlink_gps_global_origin_t
 {
- int32_t latitude; ///< Latitude (WGS84), expressed as * 1E7
- int32_t longitude; ///< Longitude (WGS84), expressed as * 1E7
- int32_t altitude; ///< Altitude(WGS84), expressed as * 1000
+ int32_t latitude; ///< Latitude (WGS84), in degrees * 1E7
+ int32_t longitude; ///< Longitude (WGS84), in degrees * 1E7
+ int32_t altitude; ///< Altitude (AMSL), in meters * 1000 (positive for up)
 } mavlink_gps_global_origin_t;
 
 #define MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN 12
 #define MAVLINK_MSG_ID_49_LEN 12
 
+#define MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_CRC 39
+#define MAVLINK_MSG_ID_49_CRC 39
+
 
 
 #define MAVLINK_MESSAGE_INFO_GPS_GLOBAL_ORIGIN { \
@@ -30,43 +33,47 @@ typedef struct __mavlink_gps_global_orig
  * @param component_id ID of this component (e.g. 200 for IMU)
  * @param msg The MAVLink message to compress the data into
  *
- * @param latitude Latitude (WGS84), expressed as * 1E7
- * @param longitude Longitude (WGS84), expressed as * 1E7
- * @param altitude Altitude(WGS84), expressed as * 1000
+ * @param latitude Latitude (WGS84), in degrees * 1E7
+ * @param longitude Longitude (WGS84), in degrees * 1E7
+ * @param altitude Altitude (AMSL), in meters * 1000 (positive for up)
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_gps_global_origin_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
 						       int32_t latitude, int32_t longitude, int32_t altitude)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[12];
+	char buf[MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN];
 	_mav_put_int32_t(buf, 0, latitude);
 	_mav_put_int32_t(buf, 4, longitude);
 	_mav_put_int32_t(buf, 8, altitude);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 12);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN);
 #else
 	mavlink_gps_global_origin_t packet;
 	packet.latitude = latitude;
 	packet.longitude = longitude;
 	packet.altitude = altitude;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 12);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN;
-	return mavlink_finalize_message(msg, system_id, component_id, 12, 39);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN);
+#endif
 }
 
 /**
  * @brief Pack a gps_global_origin message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
- * @param latitude Latitude (WGS84), expressed as * 1E7
- * @param longitude Longitude (WGS84), expressed as * 1E7
- * @param altitude Altitude(WGS84), expressed as * 1000
+ * @param latitude Latitude (WGS84), in degrees * 1E7
+ * @param longitude Longitude (WGS84), in degrees * 1E7
+ * @param altitude Altitude (AMSL), in meters * 1000 (positive for up)
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_gps_global_origin_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
@@ -74,27 +81,31 @@ static inline uint16_t mavlink_msg_gps_g
 						           int32_t latitude,int32_t longitude,int32_t altitude)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[12];
+	char buf[MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN];
 	_mav_put_int32_t(buf, 0, latitude);
 	_mav_put_int32_t(buf, 4, longitude);
 	_mav_put_int32_t(buf, 8, altitude);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 12);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN);
 #else
 	mavlink_gps_global_origin_t packet;
 	packet.latitude = latitude;
 	packet.longitude = longitude;
 	packet.altitude = altitude;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 12);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 12, 39);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN);
+#endif
 }
 
 /**
- * @brief Encode a gps_global_origin struct into a message
+ * @brief Encode a gps_global_origin struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -107,33 +118,91 @@ static inline uint16_t mavlink_msg_gps_g
 }
 
 /**
+ * @brief Encode a gps_global_origin struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param gps_global_origin C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_gps_global_origin_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_gps_global_origin_t* gps_global_origin)
+{
+	return mavlink_msg_gps_global_origin_pack_chan(system_id, component_id, chan, msg, gps_global_origin->latitude, gps_global_origin->longitude, gps_global_origin->altitude);
+}
+
+/**
  * @brief Send a gps_global_origin message
  * @param chan MAVLink channel to send the message
  *
- * @param latitude Latitude (WGS84), expressed as * 1E7
- * @param longitude Longitude (WGS84), expressed as * 1E7
- * @param altitude Altitude(WGS84), expressed as * 1000
+ * @param latitude Latitude (WGS84), in degrees * 1E7
+ * @param longitude Longitude (WGS84), in degrees * 1E7
+ * @param altitude Altitude (AMSL), in meters * 1000 (positive for up)
  */
 #ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
 
 static inline void mavlink_msg_gps_global_origin_send(mavlink_channel_t chan, int32_t latitude, int32_t longitude, int32_t altitude)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[12];
+	char buf[MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN];
 	_mav_put_int32_t(buf, 0, latitude);
 	_mav_put_int32_t(buf, 4, longitude);
 	_mav_put_int32_t(buf, 8, altitude);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN, buf, 12, 39);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN, buf, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN, buf, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN);
+#endif
 #else
 	mavlink_gps_global_origin_t packet;
 	packet.latitude = latitude;
 	packet.longitude = longitude;
 	packet.altitude = altitude;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN, (const char *)&packet, 12, 39);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN, (const char *)&packet, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN, (const char *)&packet, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_gps_global_origin_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  int32_t latitude, int32_t longitude, int32_t altitude)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_int32_t(buf, 0, latitude);
+	_mav_put_int32_t(buf, 4, longitude);
+	_mav_put_int32_t(buf, 8, altitude);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN, buf, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN, buf, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN);
+#endif
+#else
+	mavlink_gps_global_origin_t *packet = (mavlink_gps_global_origin_t *)msgbuf;
+	packet->latitude = latitude;
+	packet->longitude = longitude;
+	packet->altitude = altitude;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN, (const char *)packet, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN, (const char *)packet, MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -143,7 +212,7 @@ static inline void mavlink_msg_gps_globa
 /**
  * @brief Get field latitude from gps_global_origin message
  *
- * @return Latitude (WGS84), expressed as * 1E7
+ * @return Latitude (WGS84), in degrees * 1E7
  */
 static inline int32_t mavlink_msg_gps_global_origin_get_latitude(const mavlink_message_t* msg)
 {
@@ -153,7 +222,7 @@ static inline int32_t mavlink_msg_gps_gl
 /**
  * @brief Get field longitude from gps_global_origin message
  *
- * @return Longitude (WGS84), expressed as * 1E7
+ * @return Longitude (WGS84), in degrees * 1E7
  */
 static inline int32_t mavlink_msg_gps_global_origin_get_longitude(const mavlink_message_t* msg)
 {
@@ -163,7 +232,7 @@ static inline int32_t mavlink_msg_gps_gl
 /**
  * @brief Get field altitude from gps_global_origin message
  *
- * @return Altitude(WGS84), expressed as * 1000
+ * @return Altitude (AMSL), in meters * 1000 (positive for up)
  */
 static inline int32_t mavlink_msg_gps_global_origin_get_altitude(const mavlink_message_t* msg)
 {
@@ -183,6 +252,6 @@ static inline void mavlink_msg_gps_globa
 	gps_global_origin->longitude = mavlink_msg_gps_global_origin_get_longitude(msg);
 	gps_global_origin->altitude = mavlink_msg_gps_global_origin_get_altitude(msg);
 #else
-	memcpy(gps_global_origin, _MAV_PAYLOAD(msg), 12);
+	memcpy(gps_global_origin, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_gps_inject_data.h v1.0/common/mavlink_msg_gps_inject_data.h
--- v1.0.old/common/mavlink_msg_gps_inject_data.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_gps_inject_data.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,273 @@
+// MESSAGE GPS_INJECT_DATA PACKING
+
+#define MAVLINK_MSG_ID_GPS_INJECT_DATA 123
+
+typedef struct __mavlink_gps_inject_data_t
+{
+ uint8_t target_system; ///< System ID
+ uint8_t target_component; ///< Component ID
+ uint8_t len; ///< data length
+ uint8_t data[110]; ///< raw data (110 is enough for 12 satellites of RTCMv2)
+} mavlink_gps_inject_data_t;
+
+#define MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN 113
+#define MAVLINK_MSG_ID_123_LEN 113
+
+#define MAVLINK_MSG_ID_GPS_INJECT_DATA_CRC 250
+#define MAVLINK_MSG_ID_123_CRC 250
+
+#define MAVLINK_MSG_GPS_INJECT_DATA_FIELD_DATA_LEN 110
+
+#define MAVLINK_MESSAGE_INFO_GPS_INJECT_DATA { \
+	"GPS_INJECT_DATA", \
+	4, \
+	{  { "target_system", NULL, MAVLINK_TYPE_UINT8_T, 0, 0, offsetof(mavlink_gps_inject_data_t, target_system) }, \
+         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_gps_inject_data_t, target_component) }, \
+         { "len", NULL, MAVLINK_TYPE_UINT8_T, 0, 2, offsetof(mavlink_gps_inject_data_t, len) }, \
+         { "data", NULL, MAVLINK_TYPE_UINT8_T, 110, 3, offsetof(mavlink_gps_inject_data_t, data) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a gps_inject_data message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param len data length
+ * @param data raw data (110 is enough for 12 satellites of RTCMv2)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_gps_inject_data_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint8_t target_system, uint8_t target_component, uint8_t len, const uint8_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN];
+	_mav_put_uint8_t(buf, 0, target_system);
+	_mav_put_uint8_t(buf, 1, target_component);
+	_mav_put_uint8_t(buf, 2, len);
+	_mav_put_uint8_t_array(buf, 3, data, 110);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN);
+#else
+	mavlink_gps_inject_data_t packet;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.len = len;
+	mav_array_memcpy(packet.data, data, sizeof(uint8_t)*110);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_GPS_INJECT_DATA;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN, MAVLINK_MSG_ID_GPS_INJECT_DATA_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a gps_inject_data message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param len data length
+ * @param data raw data (110 is enough for 12 satellites of RTCMv2)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_gps_inject_data_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint8_t target_system,uint8_t target_component,uint8_t len,const uint8_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN];
+	_mav_put_uint8_t(buf, 0, target_system);
+	_mav_put_uint8_t(buf, 1, target_component);
+	_mav_put_uint8_t(buf, 2, len);
+	_mav_put_uint8_t_array(buf, 3, data, 110);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN);
+#else
+	mavlink_gps_inject_data_t packet;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.len = len;
+	mav_array_memcpy(packet.data, data, sizeof(uint8_t)*110);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_GPS_INJECT_DATA;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN, MAVLINK_MSG_ID_GPS_INJECT_DATA_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a gps_inject_data struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param gps_inject_data C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_gps_inject_data_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_gps_inject_data_t* gps_inject_data)
+{
+	return mavlink_msg_gps_inject_data_pack(system_id, component_id, msg, gps_inject_data->target_system, gps_inject_data->target_component, gps_inject_data->len, gps_inject_data->data);
+}
+
+/**
+ * @brief Encode a gps_inject_data struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param gps_inject_data C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_gps_inject_data_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_gps_inject_data_t* gps_inject_data)
+{
+	return mavlink_msg_gps_inject_data_pack_chan(system_id, component_id, chan, msg, gps_inject_data->target_system, gps_inject_data->target_component, gps_inject_data->len, gps_inject_data->data);
+}
+
+/**
+ * @brief Send a gps_inject_data message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param len data length
+ * @param data raw data (110 is enough for 12 satellites of RTCMv2)
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_gps_inject_data_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, uint8_t len, const uint8_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN];
+	_mav_put_uint8_t(buf, 0, target_system);
+	_mav_put_uint8_t(buf, 1, target_component);
+	_mav_put_uint8_t(buf, 2, len);
+	_mav_put_uint8_t_array(buf, 3, data, 110);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_INJECT_DATA, buf, MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN, MAVLINK_MSG_ID_GPS_INJECT_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_INJECT_DATA, buf, MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN);
+#endif
+#else
+	mavlink_gps_inject_data_t packet;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.len = len;
+	mav_array_memcpy(packet.data, data, sizeof(uint8_t)*110);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_INJECT_DATA, (const char *)&packet, MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN, MAVLINK_MSG_ID_GPS_INJECT_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_INJECT_DATA, (const char *)&packet, MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_gps_inject_data_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, uint8_t len, const uint8_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint8_t(buf, 0, target_system);
+	_mav_put_uint8_t(buf, 1, target_component);
+	_mav_put_uint8_t(buf, 2, len);
+	_mav_put_uint8_t_array(buf, 3, data, 110);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_INJECT_DATA, buf, MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN, MAVLINK_MSG_ID_GPS_INJECT_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_INJECT_DATA, buf, MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN);
+#endif
+#else
+	mavlink_gps_inject_data_t *packet = (mavlink_gps_inject_data_t *)msgbuf;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+	packet->len = len;
+	mav_array_memcpy(packet->data, data, sizeof(uint8_t)*110);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_INJECT_DATA, (const char *)packet, MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN, MAVLINK_MSG_ID_GPS_INJECT_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_INJECT_DATA, (const char *)packet, MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE GPS_INJECT_DATA UNPACKING
+
+
+/**
+ * @brief Get field target_system from gps_inject_data message
+ *
+ * @return System ID
+ */
+static inline uint8_t mavlink_msg_gps_inject_data_get_target_system(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  0);
+}
+
+/**
+ * @brief Get field target_component from gps_inject_data message
+ *
+ * @return Component ID
+ */
+static inline uint8_t mavlink_msg_gps_inject_data_get_target_component(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  1);
+}
+
+/**
+ * @brief Get field len from gps_inject_data message
+ *
+ * @return data length
+ */
+static inline uint8_t mavlink_msg_gps_inject_data_get_len(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  2);
+}
+
+/**
+ * @brief Get field data from gps_inject_data message
+ *
+ * @return raw data (110 is enough for 12 satellites of RTCMv2)
+ */
+static inline uint16_t mavlink_msg_gps_inject_data_get_data(const mavlink_message_t* msg, uint8_t *data)
+{
+	return _MAV_RETURN_uint8_t_array(msg, data, 110,  3);
+}
+
+/**
+ * @brief Decode a gps_inject_data message into a struct
+ *
+ * @param msg The message to decode
+ * @param gps_inject_data C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_gps_inject_data_decode(const mavlink_message_t* msg, mavlink_gps_inject_data_t* gps_inject_data)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	gps_inject_data->target_system = mavlink_msg_gps_inject_data_get_target_system(msg);
+	gps_inject_data->target_component = mavlink_msg_gps_inject_data_get_target_component(msg);
+	gps_inject_data->len = mavlink_msg_gps_inject_data_get_len(msg);
+	mavlink_msg_gps_inject_data_get_data(msg, gps_inject_data->data);
+#else
+	memcpy(gps_inject_data, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_GPS_INJECT_DATA_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_gps_raw_int.h v1.0/common/mavlink_msg_gps_raw_int.h
--- v1.0.old/common/mavlink_msg_gps_raw_int.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_gps_raw_int.h	2015-02-06 11:50:58.000000000 +0500
@@ -5,20 +5,23 @@
 typedef struct __mavlink_gps_raw_int_t
 {
  uint64_t time_usec; ///< Timestamp (microseconds since UNIX epoch or microseconds since system boot)
- int32_t lat; ///< Latitude in 1E7 degrees
- int32_t lon; ///< Longitude in 1E7 degrees
- int32_t alt; ///< Altitude in 1E3 meters (millimeters) above MSL
- uint16_t eph; ///< GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535
- uint16_t epv; ///< GPS VDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535
- uint16_t vel; ///< GPS ground speed (m/s * 100). If unknown, set to: 65535
- uint16_t cog; ///< Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535
- uint8_t fix_type; ///< 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
+ int32_t lat; ///< Latitude (WGS84), in degrees * 1E7
+ int32_t lon; ///< Longitude (WGS84), in degrees * 1E7
+ int32_t alt; ///< Altitude (AMSL, NOT WGS84), in meters * 1000 (positive for up). Note that virtually all GPS modules provide the AMSL altitude in addition to the WGS84 altitude.
+ uint16_t eph; ///< GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ uint16_t epv; ///< GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ uint16_t vel; ///< GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX
+ uint16_t cog; ///< Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
+ uint8_t fix_type; ///< 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS, 5: RTK. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
  uint8_t satellites_visible; ///< Number of satellites visible. If unknown, set to 255
 } mavlink_gps_raw_int_t;
 
 #define MAVLINK_MSG_ID_GPS_RAW_INT_LEN 30
 #define MAVLINK_MSG_ID_24_LEN 30
 
+#define MAVLINK_MSG_ID_GPS_RAW_INT_CRC 24
+#define MAVLINK_MSG_ID_24_CRC 24
+
 
 
 #define MAVLINK_MESSAGE_INFO_GPS_RAW_INT { \
@@ -45,14 +48,14 @@ typedef struct __mavlink_gps_raw_int_t
  * @param msg The MAVLink message to compress the data into
  *
  * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
- * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
- * @param lat Latitude in 1E7 degrees
- * @param lon Longitude in 1E7 degrees
- * @param alt Altitude in 1E3 meters (millimeters) above MSL
- * @param eph GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535
- * @param epv GPS VDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535
- * @param vel GPS ground speed (m/s * 100). If unknown, set to: 65535
- * @param cog Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535
+ * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS, 5: RTK. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
+ * @param lat Latitude (WGS84), in degrees * 1E7
+ * @param lon Longitude (WGS84), in degrees * 1E7
+ * @param alt Altitude (AMSL, NOT WGS84), in meters * 1000 (positive for up). Note that virtually all GPS modules provide the AMSL altitude in addition to the WGS84 altitude.
+ * @param eph GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ * @param epv GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ * @param vel GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX
+ * @param cog Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
  * @param satellites_visible Number of satellites visible. If unknown, set to 255
  * @return length of the message in bytes (excluding serial stream start sign)
  */
@@ -60,7 +63,7 @@ static inline uint16_t mavlink_msg_gps_r
 						       uint64_t time_usec, uint8_t fix_type, int32_t lat, int32_t lon, int32_t alt, uint16_t eph, uint16_t epv, uint16_t vel, uint16_t cog, uint8_t satellites_visible)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[30];
+	char buf[MAVLINK_MSG_ID_GPS_RAW_INT_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_int32_t(buf, 8, lat);
 	_mav_put_int32_t(buf, 12, lon);
@@ -72,7 +75,7 @@ static inline uint16_t mavlink_msg_gps_r
 	_mav_put_uint8_t(buf, 28, fix_type);
 	_mav_put_uint8_t(buf, 29, satellites_visible);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 30);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
 #else
 	mavlink_gps_raw_int_t packet;
 	packet.time_usec = time_usec;
@@ -86,28 +89,32 @@ static inline uint16_t mavlink_msg_gps_r
 	packet.fix_type = fix_type;
 	packet.satellites_visible = satellites_visible;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 30);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_GPS_RAW_INT;
-	return mavlink_finalize_message(msg, system_id, component_id, 30, 24);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS_RAW_INT_LEN, MAVLINK_MSG_ID_GPS_RAW_INT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
+#endif
 }
 
 /**
  * @brief Pack a gps_raw_int message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
- * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
- * @param lat Latitude in 1E7 degrees
- * @param lon Longitude in 1E7 degrees
- * @param alt Altitude in 1E3 meters (millimeters) above MSL
- * @param eph GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535
- * @param epv GPS VDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535
- * @param vel GPS ground speed (m/s * 100). If unknown, set to: 65535
- * @param cog Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535
+ * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS, 5: RTK. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
+ * @param lat Latitude (WGS84), in degrees * 1E7
+ * @param lon Longitude (WGS84), in degrees * 1E7
+ * @param alt Altitude (AMSL, NOT WGS84), in meters * 1000 (positive for up). Note that virtually all GPS modules provide the AMSL altitude in addition to the WGS84 altitude.
+ * @param eph GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ * @param epv GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ * @param vel GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX
+ * @param cog Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
  * @param satellites_visible Number of satellites visible. If unknown, set to 255
  * @return length of the message in bytes (excluding serial stream start sign)
  */
@@ -116,7 +123,7 @@ static inline uint16_t mavlink_msg_gps_r
 						           uint64_t time_usec,uint8_t fix_type,int32_t lat,int32_t lon,int32_t alt,uint16_t eph,uint16_t epv,uint16_t vel,uint16_t cog,uint8_t satellites_visible)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[30];
+	char buf[MAVLINK_MSG_ID_GPS_RAW_INT_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_int32_t(buf, 8, lat);
 	_mav_put_int32_t(buf, 12, lon);
@@ -128,7 +135,7 @@ static inline uint16_t mavlink_msg_gps_r
 	_mav_put_uint8_t(buf, 28, fix_type);
 	_mav_put_uint8_t(buf, 29, satellites_visible);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 30);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
 #else
 	mavlink_gps_raw_int_t packet;
 	packet.time_usec = time_usec;
@@ -142,15 +149,19 @@ static inline uint16_t mavlink_msg_gps_r
 	packet.fix_type = fix_type;
 	packet.satellites_visible = satellites_visible;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 30);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_GPS_RAW_INT;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 30, 24);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GPS_RAW_INT_LEN, MAVLINK_MSG_ID_GPS_RAW_INT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
+#endif
 }
 
 /**
- * @brief Encode a gps_raw_int struct into a message
+ * @brief Encode a gps_raw_int struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -163,18 +174,32 @@ static inline uint16_t mavlink_msg_gps_r
 }
 
 /**
+ * @brief Encode a gps_raw_int struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param gps_raw_int C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_gps_raw_int_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_gps_raw_int_t* gps_raw_int)
+{
+	return mavlink_msg_gps_raw_int_pack_chan(system_id, component_id, chan, msg, gps_raw_int->time_usec, gps_raw_int->fix_type, gps_raw_int->lat, gps_raw_int->lon, gps_raw_int->alt, gps_raw_int->eph, gps_raw_int->epv, gps_raw_int->vel, gps_raw_int->cog, gps_raw_int->satellites_visible);
+}
+
+/**
  * @brief Send a gps_raw_int message
  * @param chan MAVLink channel to send the message
  *
  * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
- * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
- * @param lat Latitude in 1E7 degrees
- * @param lon Longitude in 1E7 degrees
- * @param alt Altitude in 1E3 meters (millimeters) above MSL
- * @param eph GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535
- * @param epv GPS VDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535
- * @param vel GPS ground speed (m/s * 100). If unknown, set to: 65535
- * @param cog Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535
+ * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS, 5: RTK. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
+ * @param lat Latitude (WGS84), in degrees * 1E7
+ * @param lon Longitude (WGS84), in degrees * 1E7
+ * @param alt Altitude (AMSL, NOT WGS84), in meters * 1000 (positive for up). Note that virtually all GPS modules provide the AMSL altitude in addition to the WGS84 altitude.
+ * @param eph GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ * @param epv GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
+ * @param vel GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX
+ * @param cog Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
  * @param satellites_visible Number of satellites visible. If unknown, set to 255
  */
 #ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
@@ -182,7 +207,7 @@ static inline uint16_t mavlink_msg_gps_r
 static inline void mavlink_msg_gps_raw_int_send(mavlink_channel_t chan, uint64_t time_usec, uint8_t fix_type, int32_t lat, int32_t lon, int32_t alt, uint16_t eph, uint16_t epv, uint16_t vel, uint16_t cog, uint8_t satellites_visible)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[30];
+	char buf[MAVLINK_MSG_ID_GPS_RAW_INT_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_int32_t(buf, 8, lat);
 	_mav_put_int32_t(buf, 12, lon);
@@ -194,7 +219,11 @@ static inline void mavlink_msg_gps_raw_i
 	_mav_put_uint8_t(buf, 28, fix_type);
 	_mav_put_uint8_t(buf, 29, satellites_visible);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RAW_INT, buf, 30, 24);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RAW_INT, buf, MAVLINK_MSG_ID_GPS_RAW_INT_LEN, MAVLINK_MSG_ID_GPS_RAW_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RAW_INT, buf, MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
+#endif
 #else
 	mavlink_gps_raw_int_t packet;
 	packet.time_usec = time_usec;
@@ -208,10 +237,64 @@ static inline void mavlink_msg_gps_raw_i
 	packet.fix_type = fix_type;
 	packet.satellites_visible = satellites_visible;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RAW_INT, (const char *)&packet, 30, 24);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RAW_INT, (const char *)&packet, MAVLINK_MSG_ID_GPS_RAW_INT_LEN, MAVLINK_MSG_ID_GPS_RAW_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RAW_INT, (const char *)&packet, MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_GPS_RAW_INT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_gps_raw_int_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t time_usec, uint8_t fix_type, int32_t lat, int32_t lon, int32_t alt, uint16_t eph, uint16_t epv, uint16_t vel, uint16_t cog, uint8_t satellites_visible)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_int32_t(buf, 8, lat);
+	_mav_put_int32_t(buf, 12, lon);
+	_mav_put_int32_t(buf, 16, alt);
+	_mav_put_uint16_t(buf, 20, eph);
+	_mav_put_uint16_t(buf, 22, epv);
+	_mav_put_uint16_t(buf, 24, vel);
+	_mav_put_uint16_t(buf, 26, cog);
+	_mav_put_uint8_t(buf, 28, fix_type);
+	_mav_put_uint8_t(buf, 29, satellites_visible);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RAW_INT, buf, MAVLINK_MSG_ID_GPS_RAW_INT_LEN, MAVLINK_MSG_ID_GPS_RAW_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RAW_INT, buf, MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
+#endif
+#else
+	mavlink_gps_raw_int_t *packet = (mavlink_gps_raw_int_t *)msgbuf;
+	packet->time_usec = time_usec;
+	packet->lat = lat;
+	packet->lon = lon;
+	packet->alt = alt;
+	packet->eph = eph;
+	packet->epv = epv;
+	packet->vel = vel;
+	packet->cog = cog;
+	packet->fix_type = fix_type;
+	packet->satellites_visible = satellites_visible;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RAW_INT, (const char *)packet, MAVLINK_MSG_ID_GPS_RAW_INT_LEN, MAVLINK_MSG_ID_GPS_RAW_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RAW_INT, (const char *)packet, MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE GPS_RAW_INT UNPACKING
@@ -230,7 +313,7 @@ static inline uint64_t mavlink_msg_gps_r
 /**
  * @brief Get field fix_type from gps_raw_int message
  *
- * @return 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
+ * @return 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS, 5: RTK. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
  */
 static inline uint8_t mavlink_msg_gps_raw_int_get_fix_type(const mavlink_message_t* msg)
 {
@@ -240,7 +323,7 @@ static inline uint8_t mavlink_msg_gps_ra
 /**
  * @brief Get field lat from gps_raw_int message
  *
- * @return Latitude in 1E7 degrees
+ * @return Latitude (WGS84), in degrees * 1E7
  */
 static inline int32_t mavlink_msg_gps_raw_int_get_lat(const mavlink_message_t* msg)
 {
@@ -250,7 +333,7 @@ static inline int32_t mavlink_msg_gps_ra
 /**
  * @brief Get field lon from gps_raw_int message
  *
- * @return Longitude in 1E7 degrees
+ * @return Longitude (WGS84), in degrees * 1E7
  */
 static inline int32_t mavlink_msg_gps_raw_int_get_lon(const mavlink_message_t* msg)
 {
@@ -260,7 +343,7 @@ static inline int32_t mavlink_msg_gps_ra
 /**
  * @brief Get field alt from gps_raw_int message
  *
- * @return Altitude in 1E3 meters (millimeters) above MSL
+ * @return Altitude (AMSL, NOT WGS84), in meters * 1000 (positive for up). Note that virtually all GPS modules provide the AMSL altitude in addition to the WGS84 altitude.
  */
 static inline int32_t mavlink_msg_gps_raw_int_get_alt(const mavlink_message_t* msg)
 {
@@ -270,7 +353,7 @@ static inline int32_t mavlink_msg_gps_ra
 /**
  * @brief Get field eph from gps_raw_int message
  *
- * @return GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535
+ * @return GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
  */
 static inline uint16_t mavlink_msg_gps_raw_int_get_eph(const mavlink_message_t* msg)
 {
@@ -280,7 +363,7 @@ static inline uint16_t mavlink_msg_gps_r
 /**
  * @brief Get field epv from gps_raw_int message
  *
- * @return GPS VDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535
+ * @return GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
  */
 static inline uint16_t mavlink_msg_gps_raw_int_get_epv(const mavlink_message_t* msg)
 {
@@ -290,7 +373,7 @@ static inline uint16_t mavlink_msg_gps_r
 /**
  * @brief Get field vel from gps_raw_int message
  *
- * @return GPS ground speed (m/s * 100). If unknown, set to: 65535
+ * @return GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX
  */
 static inline uint16_t mavlink_msg_gps_raw_int_get_vel(const mavlink_message_t* msg)
 {
@@ -300,7 +383,7 @@ static inline uint16_t mavlink_msg_gps_r
 /**
  * @brief Get field cog from gps_raw_int message
  *
- * @return Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535
+ * @return Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
  */
 static inline uint16_t mavlink_msg_gps_raw_int_get_cog(const mavlink_message_t* msg)
 {
@@ -337,6 +420,6 @@ static inline void mavlink_msg_gps_raw_i
 	gps_raw_int->fix_type = mavlink_msg_gps_raw_int_get_fix_type(msg);
 	gps_raw_int->satellites_visible = mavlink_msg_gps_raw_int_get_satellites_visible(msg);
 #else
-	memcpy(gps_raw_int, _MAV_PAYLOAD(msg), 30);
+	memcpy(gps_raw_int, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_gps_rtk.h v1.0/common/mavlink_msg_gps_rtk.h
--- v1.0.old/common/mavlink_msg_gps_rtk.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_gps_rtk.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,497 @@
+// MESSAGE GPS_RTK PACKING
+
+#define MAVLINK_MSG_ID_GPS_RTK 127
+
+typedef struct __mavlink_gps_rtk_t
+{
+ uint32_t time_last_baseline_ms; ///< Time since boot of last baseline message received in ms.
+ uint32_t tow; ///< GPS Time of Week of last baseline
+ int32_t baseline_a_mm; ///< Current baseline in ECEF x or NED north component in mm.
+ int32_t baseline_b_mm; ///< Current baseline in ECEF y or NED east component in mm.
+ int32_t baseline_c_mm; ///< Current baseline in ECEF z or NED down component in mm.
+ uint32_t accuracy; ///< Current estimate of baseline accuracy.
+ int32_t iar_num_hypotheses; ///< Current number of integer ambiguity hypotheses.
+ uint16_t wn; ///< GPS Week Number of last baseline
+ uint8_t rtk_receiver_id; ///< Identification of connected RTK receiver.
+ uint8_t rtk_health; ///< GPS-specific health report for RTK data.
+ uint8_t rtk_rate; ///< Rate of baseline messages being received by GPS, in HZ
+ uint8_t nsats; ///< Current number of sats used for RTK calculation.
+ uint8_t baseline_coords_type; ///< Coordinate system of baseline. 0 == ECEF, 1 == NED
+} mavlink_gps_rtk_t;
+
+#define MAVLINK_MSG_ID_GPS_RTK_LEN 35
+#define MAVLINK_MSG_ID_127_LEN 35
+
+#define MAVLINK_MSG_ID_GPS_RTK_CRC 25
+#define MAVLINK_MSG_ID_127_CRC 25
+
+
+
+#define MAVLINK_MESSAGE_INFO_GPS_RTK { \
+	"GPS_RTK", \
+	13, \
+	{  { "time_last_baseline_ms", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_gps_rtk_t, time_last_baseline_ms) }, \
+         { "tow", NULL, MAVLINK_TYPE_UINT32_T, 0, 4, offsetof(mavlink_gps_rtk_t, tow) }, \
+         { "baseline_a_mm", NULL, MAVLINK_TYPE_INT32_T, 0, 8, offsetof(mavlink_gps_rtk_t, baseline_a_mm) }, \
+         { "baseline_b_mm", NULL, MAVLINK_TYPE_INT32_T, 0, 12, offsetof(mavlink_gps_rtk_t, baseline_b_mm) }, \
+         { "baseline_c_mm", NULL, MAVLINK_TYPE_INT32_T, 0, 16, offsetof(mavlink_gps_rtk_t, baseline_c_mm) }, \
+         { "accuracy", NULL, MAVLINK_TYPE_UINT32_T, 0, 20, offsetof(mavlink_gps_rtk_t, accuracy) }, \
+         { "iar_num_hypotheses", NULL, MAVLINK_TYPE_INT32_T, 0, 24, offsetof(mavlink_gps_rtk_t, iar_num_hypotheses) }, \
+         { "wn", NULL, MAVLINK_TYPE_UINT16_T, 0, 28, offsetof(mavlink_gps_rtk_t, wn) }, \
+         { "rtk_receiver_id", NULL, MAVLINK_TYPE_UINT8_T, 0, 30, offsetof(mavlink_gps_rtk_t, rtk_receiver_id) }, \
+         { "rtk_health", NULL, MAVLINK_TYPE_UINT8_T, 0, 31, offsetof(mavlink_gps_rtk_t, rtk_health) }, \
+         { "rtk_rate", NULL, MAVLINK_TYPE_UINT8_T, 0, 32, offsetof(mavlink_gps_rtk_t, rtk_rate) }, \
+         { "nsats", NULL, MAVLINK_TYPE_UINT8_T, 0, 33, offsetof(mavlink_gps_rtk_t, nsats) }, \
+         { "baseline_coords_type", NULL, MAVLINK_TYPE_UINT8_T, 0, 34, offsetof(mavlink_gps_rtk_t, baseline_coords_type) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a gps_rtk message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_last_baseline_ms Time since boot of last baseline message received in ms.
+ * @param rtk_receiver_id Identification of connected RTK receiver.
+ * @param wn GPS Week Number of last baseline
+ * @param tow GPS Time of Week of last baseline
+ * @param rtk_health GPS-specific health report for RTK data.
+ * @param rtk_rate Rate of baseline messages being received by GPS, in HZ
+ * @param nsats Current number of sats used for RTK calculation.
+ * @param baseline_coords_type Coordinate system of baseline. 0 == ECEF, 1 == NED
+ * @param baseline_a_mm Current baseline in ECEF x or NED north component in mm.
+ * @param baseline_b_mm Current baseline in ECEF y or NED east component in mm.
+ * @param baseline_c_mm Current baseline in ECEF z or NED down component in mm.
+ * @param accuracy Current estimate of baseline accuracy.
+ * @param iar_num_hypotheses Current number of integer ambiguity hypotheses.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_gps_rtk_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint32_t time_last_baseline_ms, uint8_t rtk_receiver_id, uint16_t wn, uint32_t tow, uint8_t rtk_health, uint8_t rtk_rate, uint8_t nsats, uint8_t baseline_coords_type, int32_t baseline_a_mm, int32_t baseline_b_mm, int32_t baseline_c_mm, uint32_t accuracy, int32_t iar_num_hypotheses)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_GPS_RTK_LEN];
+	_mav_put_uint32_t(buf, 0, time_last_baseline_ms);
+	_mav_put_uint32_t(buf, 4, tow);
+	_mav_put_int32_t(buf, 8, baseline_a_mm);
+	_mav_put_int32_t(buf, 12, baseline_b_mm);
+	_mav_put_int32_t(buf, 16, baseline_c_mm);
+	_mav_put_uint32_t(buf, 20, accuracy);
+	_mav_put_int32_t(buf, 24, iar_num_hypotheses);
+	_mav_put_uint16_t(buf, 28, wn);
+	_mav_put_uint8_t(buf, 30, rtk_receiver_id);
+	_mav_put_uint8_t(buf, 31, rtk_health);
+	_mav_put_uint8_t(buf, 32, rtk_rate);
+	_mav_put_uint8_t(buf, 33, nsats);
+	_mav_put_uint8_t(buf, 34, baseline_coords_type);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS_RTK_LEN);
+#else
+	mavlink_gps_rtk_t packet;
+	packet.time_last_baseline_ms = time_last_baseline_ms;
+	packet.tow = tow;
+	packet.baseline_a_mm = baseline_a_mm;
+	packet.baseline_b_mm = baseline_b_mm;
+	packet.baseline_c_mm = baseline_c_mm;
+	packet.accuracy = accuracy;
+	packet.iar_num_hypotheses = iar_num_hypotheses;
+	packet.wn = wn;
+	packet.rtk_receiver_id = rtk_receiver_id;
+	packet.rtk_health = rtk_health;
+	packet.rtk_rate = rtk_rate;
+	packet.nsats = nsats;
+	packet.baseline_coords_type = baseline_coords_type;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS_RTK_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_GPS_RTK;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS_RTK_LEN, MAVLINK_MSG_ID_GPS_RTK_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS_RTK_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a gps_rtk message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_last_baseline_ms Time since boot of last baseline message received in ms.
+ * @param rtk_receiver_id Identification of connected RTK receiver.
+ * @param wn GPS Week Number of last baseline
+ * @param tow GPS Time of Week of last baseline
+ * @param rtk_health GPS-specific health report for RTK data.
+ * @param rtk_rate Rate of baseline messages being received by GPS, in HZ
+ * @param nsats Current number of sats used for RTK calculation.
+ * @param baseline_coords_type Coordinate system of baseline. 0 == ECEF, 1 == NED
+ * @param baseline_a_mm Current baseline in ECEF x or NED north component in mm.
+ * @param baseline_b_mm Current baseline in ECEF y or NED east component in mm.
+ * @param baseline_c_mm Current baseline in ECEF z or NED down component in mm.
+ * @param accuracy Current estimate of baseline accuracy.
+ * @param iar_num_hypotheses Current number of integer ambiguity hypotheses.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_gps_rtk_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint32_t time_last_baseline_ms,uint8_t rtk_receiver_id,uint16_t wn,uint32_t tow,uint8_t rtk_health,uint8_t rtk_rate,uint8_t nsats,uint8_t baseline_coords_type,int32_t baseline_a_mm,int32_t baseline_b_mm,int32_t baseline_c_mm,uint32_t accuracy,int32_t iar_num_hypotheses)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_GPS_RTK_LEN];
+	_mav_put_uint32_t(buf, 0, time_last_baseline_ms);
+	_mav_put_uint32_t(buf, 4, tow);
+	_mav_put_int32_t(buf, 8, baseline_a_mm);
+	_mav_put_int32_t(buf, 12, baseline_b_mm);
+	_mav_put_int32_t(buf, 16, baseline_c_mm);
+	_mav_put_uint32_t(buf, 20, accuracy);
+	_mav_put_int32_t(buf, 24, iar_num_hypotheses);
+	_mav_put_uint16_t(buf, 28, wn);
+	_mav_put_uint8_t(buf, 30, rtk_receiver_id);
+	_mav_put_uint8_t(buf, 31, rtk_health);
+	_mav_put_uint8_t(buf, 32, rtk_rate);
+	_mav_put_uint8_t(buf, 33, nsats);
+	_mav_put_uint8_t(buf, 34, baseline_coords_type);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS_RTK_LEN);
+#else
+	mavlink_gps_rtk_t packet;
+	packet.time_last_baseline_ms = time_last_baseline_ms;
+	packet.tow = tow;
+	packet.baseline_a_mm = baseline_a_mm;
+	packet.baseline_b_mm = baseline_b_mm;
+	packet.baseline_c_mm = baseline_c_mm;
+	packet.accuracy = accuracy;
+	packet.iar_num_hypotheses = iar_num_hypotheses;
+	packet.wn = wn;
+	packet.rtk_receiver_id = rtk_receiver_id;
+	packet.rtk_health = rtk_health;
+	packet.rtk_rate = rtk_rate;
+	packet.nsats = nsats;
+	packet.baseline_coords_type = baseline_coords_type;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS_RTK_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_GPS_RTK;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GPS_RTK_LEN, MAVLINK_MSG_ID_GPS_RTK_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GPS_RTK_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a gps_rtk struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param gps_rtk C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_gps_rtk_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_gps_rtk_t* gps_rtk)
+{
+	return mavlink_msg_gps_rtk_pack(system_id, component_id, msg, gps_rtk->time_last_baseline_ms, gps_rtk->rtk_receiver_id, gps_rtk->wn, gps_rtk->tow, gps_rtk->rtk_health, gps_rtk->rtk_rate, gps_rtk->nsats, gps_rtk->baseline_coords_type, gps_rtk->baseline_a_mm, gps_rtk->baseline_b_mm, gps_rtk->baseline_c_mm, gps_rtk->accuracy, gps_rtk->iar_num_hypotheses);
+}
+
+/**
+ * @brief Encode a gps_rtk struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param gps_rtk C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_gps_rtk_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_gps_rtk_t* gps_rtk)
+{
+	return mavlink_msg_gps_rtk_pack_chan(system_id, component_id, chan, msg, gps_rtk->time_last_baseline_ms, gps_rtk->rtk_receiver_id, gps_rtk->wn, gps_rtk->tow, gps_rtk->rtk_health, gps_rtk->rtk_rate, gps_rtk->nsats, gps_rtk->baseline_coords_type, gps_rtk->baseline_a_mm, gps_rtk->baseline_b_mm, gps_rtk->baseline_c_mm, gps_rtk->accuracy, gps_rtk->iar_num_hypotheses);
+}
+
+/**
+ * @brief Send a gps_rtk message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_last_baseline_ms Time since boot of last baseline message received in ms.
+ * @param rtk_receiver_id Identification of connected RTK receiver.
+ * @param wn GPS Week Number of last baseline
+ * @param tow GPS Time of Week of last baseline
+ * @param rtk_health GPS-specific health report for RTK data.
+ * @param rtk_rate Rate of baseline messages being received by GPS, in HZ
+ * @param nsats Current number of sats used for RTK calculation.
+ * @param baseline_coords_type Coordinate system of baseline. 0 == ECEF, 1 == NED
+ * @param baseline_a_mm Current baseline in ECEF x or NED north component in mm.
+ * @param baseline_b_mm Current baseline in ECEF y or NED east component in mm.
+ * @param baseline_c_mm Current baseline in ECEF z or NED down component in mm.
+ * @param accuracy Current estimate of baseline accuracy.
+ * @param iar_num_hypotheses Current number of integer ambiguity hypotheses.
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_gps_rtk_send(mavlink_channel_t chan, uint32_t time_last_baseline_ms, uint8_t rtk_receiver_id, uint16_t wn, uint32_t tow, uint8_t rtk_health, uint8_t rtk_rate, uint8_t nsats, uint8_t baseline_coords_type, int32_t baseline_a_mm, int32_t baseline_b_mm, int32_t baseline_c_mm, uint32_t accuracy, int32_t iar_num_hypotheses)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_GPS_RTK_LEN];
+	_mav_put_uint32_t(buf, 0, time_last_baseline_ms);
+	_mav_put_uint32_t(buf, 4, tow);
+	_mav_put_int32_t(buf, 8, baseline_a_mm);
+	_mav_put_int32_t(buf, 12, baseline_b_mm);
+	_mav_put_int32_t(buf, 16, baseline_c_mm);
+	_mav_put_uint32_t(buf, 20, accuracy);
+	_mav_put_int32_t(buf, 24, iar_num_hypotheses);
+	_mav_put_uint16_t(buf, 28, wn);
+	_mav_put_uint8_t(buf, 30, rtk_receiver_id);
+	_mav_put_uint8_t(buf, 31, rtk_health);
+	_mav_put_uint8_t(buf, 32, rtk_rate);
+	_mav_put_uint8_t(buf, 33, nsats);
+	_mav_put_uint8_t(buf, 34, baseline_coords_type);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RTK, buf, MAVLINK_MSG_ID_GPS_RTK_LEN, MAVLINK_MSG_ID_GPS_RTK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RTK, buf, MAVLINK_MSG_ID_GPS_RTK_LEN);
+#endif
+#else
+	mavlink_gps_rtk_t packet;
+	packet.time_last_baseline_ms = time_last_baseline_ms;
+	packet.tow = tow;
+	packet.baseline_a_mm = baseline_a_mm;
+	packet.baseline_b_mm = baseline_b_mm;
+	packet.baseline_c_mm = baseline_c_mm;
+	packet.accuracy = accuracy;
+	packet.iar_num_hypotheses = iar_num_hypotheses;
+	packet.wn = wn;
+	packet.rtk_receiver_id = rtk_receiver_id;
+	packet.rtk_health = rtk_health;
+	packet.rtk_rate = rtk_rate;
+	packet.nsats = nsats;
+	packet.baseline_coords_type = baseline_coords_type;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RTK, (const char *)&packet, MAVLINK_MSG_ID_GPS_RTK_LEN, MAVLINK_MSG_ID_GPS_RTK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RTK, (const char *)&packet, MAVLINK_MSG_ID_GPS_RTK_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_GPS_RTK_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_gps_rtk_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_last_baseline_ms, uint8_t rtk_receiver_id, uint16_t wn, uint32_t tow, uint8_t rtk_health, uint8_t rtk_rate, uint8_t nsats, uint8_t baseline_coords_type, int32_t baseline_a_mm, int32_t baseline_b_mm, int32_t baseline_c_mm, uint32_t accuracy, int32_t iar_num_hypotheses)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_last_baseline_ms);
+	_mav_put_uint32_t(buf, 4, tow);
+	_mav_put_int32_t(buf, 8, baseline_a_mm);
+	_mav_put_int32_t(buf, 12, baseline_b_mm);
+	_mav_put_int32_t(buf, 16, baseline_c_mm);
+	_mav_put_uint32_t(buf, 20, accuracy);
+	_mav_put_int32_t(buf, 24, iar_num_hypotheses);
+	_mav_put_uint16_t(buf, 28, wn);
+	_mav_put_uint8_t(buf, 30, rtk_receiver_id);
+	_mav_put_uint8_t(buf, 31, rtk_health);
+	_mav_put_uint8_t(buf, 32, rtk_rate);
+	_mav_put_uint8_t(buf, 33, nsats);
+	_mav_put_uint8_t(buf, 34, baseline_coords_type);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RTK, buf, MAVLINK_MSG_ID_GPS_RTK_LEN, MAVLINK_MSG_ID_GPS_RTK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RTK, buf, MAVLINK_MSG_ID_GPS_RTK_LEN);
+#endif
+#else
+	mavlink_gps_rtk_t *packet = (mavlink_gps_rtk_t *)msgbuf;
+	packet->time_last_baseline_ms = time_last_baseline_ms;
+	packet->tow = tow;
+	packet->baseline_a_mm = baseline_a_mm;
+	packet->baseline_b_mm = baseline_b_mm;
+	packet->baseline_c_mm = baseline_c_mm;
+	packet->accuracy = accuracy;
+	packet->iar_num_hypotheses = iar_num_hypotheses;
+	packet->wn = wn;
+	packet->rtk_receiver_id = rtk_receiver_id;
+	packet->rtk_health = rtk_health;
+	packet->rtk_rate = rtk_rate;
+	packet->nsats = nsats;
+	packet->baseline_coords_type = baseline_coords_type;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RTK, (const char *)packet, MAVLINK_MSG_ID_GPS_RTK_LEN, MAVLINK_MSG_ID_GPS_RTK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_RTK, (const char *)packet, MAVLINK_MSG_ID_GPS_RTK_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE GPS_RTK UNPACKING
+
+
+/**
+ * @brief Get field time_last_baseline_ms from gps_rtk message
+ *
+ * @return Time since boot of last baseline message received in ms.
+ */
+static inline uint32_t mavlink_msg_gps_rtk_get_time_last_baseline_ms(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field rtk_receiver_id from gps_rtk message
+ *
+ * @return Identification of connected RTK receiver.
+ */
+static inline uint8_t mavlink_msg_gps_rtk_get_rtk_receiver_id(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  30);
+}
+
+/**
+ * @brief Get field wn from gps_rtk message
+ *
+ * @return GPS Week Number of last baseline
+ */
+static inline uint16_t mavlink_msg_gps_rtk_get_wn(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  28);
+}
+
+/**
+ * @brief Get field tow from gps_rtk message
+ *
+ * @return GPS Time of Week of last baseline
+ */
+static inline uint32_t mavlink_msg_gps_rtk_get_tow(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  4);
+}
+
+/**
+ * @brief Get field rtk_health from gps_rtk message
+ *
+ * @return GPS-specific health report for RTK data.
+ */
+static inline uint8_t mavlink_msg_gps_rtk_get_rtk_health(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  31);
+}
+
+/**
+ * @brief Get field rtk_rate from gps_rtk message
+ *
+ * @return Rate of baseline messages being received by GPS, in HZ
+ */
+static inline uint8_t mavlink_msg_gps_rtk_get_rtk_rate(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  32);
+}
+
+/**
+ * @brief Get field nsats from gps_rtk message
+ *
+ * @return Current number of sats used for RTK calculation.
+ */
+static inline uint8_t mavlink_msg_gps_rtk_get_nsats(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  33);
+}
+
+/**
+ * @brief Get field baseline_coords_type from gps_rtk message
+ *
+ * @return Coordinate system of baseline. 0 == ECEF, 1 == NED
+ */
+static inline uint8_t mavlink_msg_gps_rtk_get_baseline_coords_type(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  34);
+}
+
+/**
+ * @brief Get field baseline_a_mm from gps_rtk message
+ *
+ * @return Current baseline in ECEF x or NED north component in mm.
+ */
+static inline int32_t mavlink_msg_gps_rtk_get_baseline_a_mm(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  8);
+}
+
+/**
+ * @brief Get field baseline_b_mm from gps_rtk message
+ *
+ * @return Current baseline in ECEF y or NED east component in mm.
+ */
+static inline int32_t mavlink_msg_gps_rtk_get_baseline_b_mm(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  12);
+}
+
+/**
+ * @brief Get field baseline_c_mm from gps_rtk message
+ *
+ * @return Current baseline in ECEF z or NED down component in mm.
+ */
+static inline int32_t mavlink_msg_gps_rtk_get_baseline_c_mm(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  16);
+}
+
+/**
+ * @brief Get field accuracy from gps_rtk message
+ *
+ * @return Current estimate of baseline accuracy.
+ */
+static inline uint32_t mavlink_msg_gps_rtk_get_accuracy(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  20);
+}
+
+/**
+ * @brief Get field iar_num_hypotheses from gps_rtk message
+ *
+ * @return Current number of integer ambiguity hypotheses.
+ */
+static inline int32_t mavlink_msg_gps_rtk_get_iar_num_hypotheses(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  24);
+}
+
+/**
+ * @brief Decode a gps_rtk message into a struct
+ *
+ * @param msg The message to decode
+ * @param gps_rtk C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_gps_rtk_decode(const mavlink_message_t* msg, mavlink_gps_rtk_t* gps_rtk)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	gps_rtk->time_last_baseline_ms = mavlink_msg_gps_rtk_get_time_last_baseline_ms(msg);
+	gps_rtk->tow = mavlink_msg_gps_rtk_get_tow(msg);
+	gps_rtk->baseline_a_mm = mavlink_msg_gps_rtk_get_baseline_a_mm(msg);
+	gps_rtk->baseline_b_mm = mavlink_msg_gps_rtk_get_baseline_b_mm(msg);
+	gps_rtk->baseline_c_mm = mavlink_msg_gps_rtk_get_baseline_c_mm(msg);
+	gps_rtk->accuracy = mavlink_msg_gps_rtk_get_accuracy(msg);
+	gps_rtk->iar_num_hypotheses = mavlink_msg_gps_rtk_get_iar_num_hypotheses(msg);
+	gps_rtk->wn = mavlink_msg_gps_rtk_get_wn(msg);
+	gps_rtk->rtk_receiver_id = mavlink_msg_gps_rtk_get_rtk_receiver_id(msg);
+	gps_rtk->rtk_health = mavlink_msg_gps_rtk_get_rtk_health(msg);
+	gps_rtk->rtk_rate = mavlink_msg_gps_rtk_get_rtk_rate(msg);
+	gps_rtk->nsats = mavlink_msg_gps_rtk_get_nsats(msg);
+	gps_rtk->baseline_coords_type = mavlink_msg_gps_rtk_get_baseline_coords_type(msg);
+#else
+	memcpy(gps_rtk, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_GPS_RTK_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_gps_status.h v1.0/common/mavlink_msg_gps_status.h
--- v1.0.old/common/mavlink_msg_gps_status.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_gps_status.h	2015-02-06 11:50:58.000000000 +0500
@@ -15,6 +15,9 @@ typedef struct __mavlink_gps_status_t
 #define MAVLINK_MSG_ID_GPS_STATUS_LEN 101
 #define MAVLINK_MSG_ID_25_LEN 101
 
+#define MAVLINK_MSG_ID_GPS_STATUS_CRC 23
+#define MAVLINK_MSG_ID_25_CRC 23
+
 #define MAVLINK_MSG_GPS_STATUS_FIELD_SATELLITE_PRN_LEN 20
 #define MAVLINK_MSG_GPS_STATUS_FIELD_SATELLITE_USED_LEN 20
 #define MAVLINK_MSG_GPS_STATUS_FIELD_SATELLITE_ELEVATION_LEN 20
@@ -52,14 +55,14 @@ static inline uint16_t mavlink_msg_gps_s
 						       uint8_t satellites_visible, const uint8_t *satellite_prn, const uint8_t *satellite_used, const uint8_t *satellite_elevation, const uint8_t *satellite_azimuth, const uint8_t *satellite_snr)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[101];
+	char buf[MAVLINK_MSG_ID_GPS_STATUS_LEN];
 	_mav_put_uint8_t(buf, 0, satellites_visible);
 	_mav_put_uint8_t_array(buf, 1, satellite_prn, 20);
 	_mav_put_uint8_t_array(buf, 21, satellite_used, 20);
 	_mav_put_uint8_t_array(buf, 41, satellite_elevation, 20);
 	_mav_put_uint8_t_array(buf, 61, satellite_azimuth, 20);
 	_mav_put_uint8_t_array(buf, 81, satellite_snr, 20);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 101);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS_STATUS_LEN);
 #else
 	mavlink_gps_status_t packet;
 	packet.satellites_visible = satellites_visible;
@@ -68,18 +71,22 @@ static inline uint16_t mavlink_msg_gps_s
 	mav_array_memcpy(packet.satellite_elevation, satellite_elevation, sizeof(uint8_t)*20);
 	mav_array_memcpy(packet.satellite_azimuth, satellite_azimuth, sizeof(uint8_t)*20);
 	mav_array_memcpy(packet.satellite_snr, satellite_snr, sizeof(uint8_t)*20);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 101);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS_STATUS_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_GPS_STATUS;
-	return mavlink_finalize_message(msg, system_id, component_id, 101, 23);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS_STATUS_LEN, MAVLINK_MSG_ID_GPS_STATUS_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS_STATUS_LEN);
+#endif
 }
 
 /**
  * @brief Pack a gps_status message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param satellites_visible Number of satellites visible
  * @param satellite_prn Global satellite ID
@@ -94,14 +101,14 @@ static inline uint16_t mavlink_msg_gps_s
 						           uint8_t satellites_visible,const uint8_t *satellite_prn,const uint8_t *satellite_used,const uint8_t *satellite_elevation,const uint8_t *satellite_azimuth,const uint8_t *satellite_snr)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[101];
+	char buf[MAVLINK_MSG_ID_GPS_STATUS_LEN];
 	_mav_put_uint8_t(buf, 0, satellites_visible);
 	_mav_put_uint8_t_array(buf, 1, satellite_prn, 20);
 	_mav_put_uint8_t_array(buf, 21, satellite_used, 20);
 	_mav_put_uint8_t_array(buf, 41, satellite_elevation, 20);
 	_mav_put_uint8_t_array(buf, 61, satellite_azimuth, 20);
 	_mav_put_uint8_t_array(buf, 81, satellite_snr, 20);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 101);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS_STATUS_LEN);
 #else
 	mavlink_gps_status_t packet;
 	packet.satellites_visible = satellites_visible;
@@ -110,15 +117,19 @@ static inline uint16_t mavlink_msg_gps_s
 	mav_array_memcpy(packet.satellite_elevation, satellite_elevation, sizeof(uint8_t)*20);
 	mav_array_memcpy(packet.satellite_azimuth, satellite_azimuth, sizeof(uint8_t)*20);
 	mav_array_memcpy(packet.satellite_snr, satellite_snr, sizeof(uint8_t)*20);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 101);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS_STATUS_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_GPS_STATUS;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 101, 23);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GPS_STATUS_LEN, MAVLINK_MSG_ID_GPS_STATUS_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GPS_STATUS_LEN);
+#endif
 }
 
 /**
- * @brief Encode a gps_status struct into a message
+ * @brief Encode a gps_status struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -131,6 +142,20 @@ static inline uint16_t mavlink_msg_gps_s
 }
 
 /**
+ * @brief Encode a gps_status struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param gps_status C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_gps_status_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_gps_status_t* gps_status)
+{
+	return mavlink_msg_gps_status_pack_chan(system_id, component_id, chan, msg, gps_status->satellites_visible, gps_status->satellite_prn, gps_status->satellite_used, gps_status->satellite_elevation, gps_status->satellite_azimuth, gps_status->satellite_snr);
+}
+
+/**
  * @brief Send a gps_status message
  * @param chan MAVLink channel to send the message
  *
@@ -146,14 +171,18 @@ static inline uint16_t mavlink_msg_gps_s
 static inline void mavlink_msg_gps_status_send(mavlink_channel_t chan, uint8_t satellites_visible, const uint8_t *satellite_prn, const uint8_t *satellite_used, const uint8_t *satellite_elevation, const uint8_t *satellite_azimuth, const uint8_t *satellite_snr)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[101];
+	char buf[MAVLINK_MSG_ID_GPS_STATUS_LEN];
 	_mav_put_uint8_t(buf, 0, satellites_visible);
 	_mav_put_uint8_t_array(buf, 1, satellite_prn, 20);
 	_mav_put_uint8_t_array(buf, 21, satellite_used, 20);
 	_mav_put_uint8_t_array(buf, 41, satellite_elevation, 20);
 	_mav_put_uint8_t_array(buf, 61, satellite_azimuth, 20);
 	_mav_put_uint8_t_array(buf, 81, satellite_snr, 20);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_STATUS, buf, 101, 23);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_STATUS, buf, MAVLINK_MSG_ID_GPS_STATUS_LEN, MAVLINK_MSG_ID_GPS_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_STATUS, buf, MAVLINK_MSG_ID_GPS_STATUS_LEN);
+#endif
 #else
 	mavlink_gps_status_t packet;
 	packet.satellites_visible = satellites_visible;
@@ -162,10 +191,54 @@ static inline void mavlink_msg_gps_statu
 	mav_array_memcpy(packet.satellite_elevation, satellite_elevation, sizeof(uint8_t)*20);
 	mav_array_memcpy(packet.satellite_azimuth, satellite_azimuth, sizeof(uint8_t)*20);
 	mav_array_memcpy(packet.satellite_snr, satellite_snr, sizeof(uint8_t)*20);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_STATUS, (const char *)&packet, 101, 23);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_STATUS, (const char *)&packet, MAVLINK_MSG_ID_GPS_STATUS_LEN, MAVLINK_MSG_ID_GPS_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_STATUS, (const char *)&packet, MAVLINK_MSG_ID_GPS_STATUS_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_GPS_STATUS_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_gps_status_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t satellites_visible, const uint8_t *satellite_prn, const uint8_t *satellite_used, const uint8_t *satellite_elevation, const uint8_t *satellite_azimuth, const uint8_t *satellite_snr)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint8_t(buf, 0, satellites_visible);
+	_mav_put_uint8_t_array(buf, 1, satellite_prn, 20);
+	_mav_put_uint8_t_array(buf, 21, satellite_used, 20);
+	_mav_put_uint8_t_array(buf, 41, satellite_elevation, 20);
+	_mav_put_uint8_t_array(buf, 61, satellite_azimuth, 20);
+	_mav_put_uint8_t_array(buf, 81, satellite_snr, 20);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_STATUS, buf, MAVLINK_MSG_ID_GPS_STATUS_LEN, MAVLINK_MSG_ID_GPS_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_STATUS, buf, MAVLINK_MSG_ID_GPS_STATUS_LEN);
+#endif
+#else
+	mavlink_gps_status_t *packet = (mavlink_gps_status_t *)msgbuf;
+	packet->satellites_visible = satellites_visible;
+	mav_array_memcpy(packet->satellite_prn, satellite_prn, sizeof(uint8_t)*20);
+	mav_array_memcpy(packet->satellite_used, satellite_used, sizeof(uint8_t)*20);
+	mav_array_memcpy(packet->satellite_elevation, satellite_elevation, sizeof(uint8_t)*20);
+	mav_array_memcpy(packet->satellite_azimuth, satellite_azimuth, sizeof(uint8_t)*20);
+	mav_array_memcpy(packet->satellite_snr, satellite_snr, sizeof(uint8_t)*20);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_STATUS, (const char *)packet, MAVLINK_MSG_ID_GPS_STATUS_LEN, MAVLINK_MSG_ID_GPS_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_GPS_STATUS, (const char *)packet, MAVLINK_MSG_ID_GPS_STATUS_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE GPS_STATUS UNPACKING
@@ -247,6 +320,6 @@ static inline void mavlink_msg_gps_statu
 	mavlink_msg_gps_status_get_satellite_azimuth(msg, gps_status->satellite_azimuth);
 	mavlink_msg_gps_status_get_satellite_snr(msg, gps_status->satellite_snr);
 #else
-	memcpy(gps_status, _MAV_PAYLOAD(msg), 101);
+	memcpy(gps_status, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_GPS_STATUS_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_heartbeat.h v1.0/common/mavlink_msg_heartbeat.h
--- v1.0.old/common/mavlink_msg_heartbeat.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_heartbeat.h	2015-02-06 11:50:58.000000000 +0500
@@ -7,7 +7,7 @@ typedef struct __mavlink_heartbeat_t
  uint32_t custom_mode; ///< A bitfield for use for autopilot-specific flags.
  uint8_t type; ///< Type of the MAV (quadrotor, helicopter, etc., up to 15 types, defined in MAV_TYPE ENUM)
  uint8_t autopilot; ///< Autopilot type / class. defined in MAV_AUTOPILOT ENUM
- uint8_t base_mode; ///< System mode bitfield, see MAV_MODE_FLAGS ENUM in mavlink/include/mavlink_types.h
+ uint8_t base_mode; ///< System mode bitfield, see MAV_MODE_FLAG ENUM in mavlink/include/mavlink_types.h
  uint8_t system_status; ///< System status flag, see MAV_STATE ENUM
  uint8_t mavlink_version; ///< MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8_t_mavlink_version
 } mavlink_heartbeat_t;
@@ -15,6 +15,9 @@ typedef struct __mavlink_heartbeat_t
 #define MAVLINK_MSG_ID_HEARTBEAT_LEN 9
 #define MAVLINK_MSG_ID_0_LEN 9
 
+#define MAVLINK_MSG_ID_HEARTBEAT_CRC 50
+#define MAVLINK_MSG_ID_0_CRC 50
+
 
 
 #define MAVLINK_MESSAGE_INFO_HEARTBEAT { \
@@ -38,7 +41,7 @@ typedef struct __mavlink_heartbeat_t
  *
  * @param type Type of the MAV (quadrotor, helicopter, etc., up to 15 types, defined in MAV_TYPE ENUM)
  * @param autopilot Autopilot type / class. defined in MAV_AUTOPILOT ENUM
- * @param base_mode System mode bitfield, see MAV_MODE_FLAGS ENUM in mavlink/include/mavlink_types.h
+ * @param base_mode System mode bitfield, see MAV_MODE_FLAG ENUM in mavlink/include/mavlink_types.h
  * @param custom_mode A bitfield for use for autopilot-specific flags.
  * @param system_status System status flag, see MAV_STATE ENUM
  * @return length of the message in bytes (excluding serial stream start sign)
@@ -47,7 +50,7 @@ static inline uint16_t mavlink_msg_heart
 						       uint8_t type, uint8_t autopilot, uint8_t base_mode, uint32_t custom_mode, uint8_t system_status)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[9];
+	char buf[MAVLINK_MSG_ID_HEARTBEAT_LEN];
 	_mav_put_uint32_t(buf, 0, custom_mode);
 	_mav_put_uint8_t(buf, 4, type);
 	_mav_put_uint8_t(buf, 5, autopilot);
@@ -55,7 +58,7 @@ static inline uint16_t mavlink_msg_heart
 	_mav_put_uint8_t(buf, 7, system_status);
 	_mav_put_uint8_t(buf, 8, 3);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 9);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HEARTBEAT_LEN);
 #else
 	mavlink_heartbeat_t packet;
 	packet.custom_mode = custom_mode;
@@ -65,22 +68,26 @@ static inline uint16_t mavlink_msg_heart
 	packet.system_status = system_status;
 	packet.mavlink_version = 3;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 9);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HEARTBEAT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_HEARTBEAT;
-	return mavlink_finalize_message(msg, system_id, component_id, 9, 50);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HEARTBEAT_LEN, MAVLINK_MSG_ID_HEARTBEAT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HEARTBEAT_LEN);
+#endif
 }
 
 /**
  * @brief Pack a heartbeat message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param type Type of the MAV (quadrotor, helicopter, etc., up to 15 types, defined in MAV_TYPE ENUM)
  * @param autopilot Autopilot type / class. defined in MAV_AUTOPILOT ENUM
- * @param base_mode System mode bitfield, see MAV_MODE_FLAGS ENUM in mavlink/include/mavlink_types.h
+ * @param base_mode System mode bitfield, see MAV_MODE_FLAG ENUM in mavlink/include/mavlink_types.h
  * @param custom_mode A bitfield for use for autopilot-specific flags.
  * @param system_status System status flag, see MAV_STATE ENUM
  * @return length of the message in bytes (excluding serial stream start sign)
@@ -90,7 +97,7 @@ static inline uint16_t mavlink_msg_heart
 						           uint8_t type,uint8_t autopilot,uint8_t base_mode,uint32_t custom_mode,uint8_t system_status)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[9];
+	char buf[MAVLINK_MSG_ID_HEARTBEAT_LEN];
 	_mav_put_uint32_t(buf, 0, custom_mode);
 	_mav_put_uint8_t(buf, 4, type);
 	_mav_put_uint8_t(buf, 5, autopilot);
@@ -98,7 +105,7 @@ static inline uint16_t mavlink_msg_heart
 	_mav_put_uint8_t(buf, 7, system_status);
 	_mav_put_uint8_t(buf, 8, 3);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 9);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HEARTBEAT_LEN);
 #else
 	mavlink_heartbeat_t packet;
 	packet.custom_mode = custom_mode;
@@ -108,15 +115,19 @@ static inline uint16_t mavlink_msg_heart
 	packet.system_status = system_status;
 	packet.mavlink_version = 3;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 9);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HEARTBEAT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_HEARTBEAT;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 9, 50);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HEARTBEAT_LEN, MAVLINK_MSG_ID_HEARTBEAT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HEARTBEAT_LEN);
+#endif
 }
 
 /**
- * @brief Encode a heartbeat struct into a message
+ * @brief Encode a heartbeat struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -129,12 +140,26 @@ static inline uint16_t mavlink_msg_heart
 }
 
 /**
+ * @brief Encode a heartbeat struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param heartbeat C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_heartbeat_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_heartbeat_t* heartbeat)
+{
+	return mavlink_msg_heartbeat_pack_chan(system_id, component_id, chan, msg, heartbeat->type, heartbeat->autopilot, heartbeat->base_mode, heartbeat->custom_mode, heartbeat->system_status);
+}
+
+/**
  * @brief Send a heartbeat message
  * @param chan MAVLink channel to send the message
  *
  * @param type Type of the MAV (quadrotor, helicopter, etc., up to 15 types, defined in MAV_TYPE ENUM)
  * @param autopilot Autopilot type / class. defined in MAV_AUTOPILOT ENUM
- * @param base_mode System mode bitfield, see MAV_MODE_FLAGS ENUM in mavlink/include/mavlink_types.h
+ * @param base_mode System mode bitfield, see MAV_MODE_FLAG ENUM in mavlink/include/mavlink_types.h
  * @param custom_mode A bitfield for use for autopilot-specific flags.
  * @param system_status System status flag, see MAV_STATE ENUM
  */
@@ -143,7 +168,7 @@ static inline uint16_t mavlink_msg_heart
 static inline void mavlink_msg_heartbeat_send(mavlink_channel_t chan, uint8_t type, uint8_t autopilot, uint8_t base_mode, uint32_t custom_mode, uint8_t system_status)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[9];
+	char buf[MAVLINK_MSG_ID_HEARTBEAT_LEN];
 	_mav_put_uint32_t(buf, 0, custom_mode);
 	_mav_put_uint8_t(buf, 4, type);
 	_mav_put_uint8_t(buf, 5, autopilot);
@@ -151,7 +176,11 @@ static inline void mavlink_msg_heartbeat
 	_mav_put_uint8_t(buf, 7, system_status);
 	_mav_put_uint8_t(buf, 8, 3);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HEARTBEAT, buf, 9, 50);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HEARTBEAT, buf, MAVLINK_MSG_ID_HEARTBEAT_LEN, MAVLINK_MSG_ID_HEARTBEAT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HEARTBEAT, buf, MAVLINK_MSG_ID_HEARTBEAT_LEN);
+#endif
 #else
 	mavlink_heartbeat_t packet;
 	packet.custom_mode = custom_mode;
@@ -161,10 +190,56 @@ static inline void mavlink_msg_heartbeat
 	packet.system_status = system_status;
 	packet.mavlink_version = 3;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HEARTBEAT, (const char *)&packet, 9, 50);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HEARTBEAT, (const char *)&packet, MAVLINK_MSG_ID_HEARTBEAT_LEN, MAVLINK_MSG_ID_HEARTBEAT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HEARTBEAT, (const char *)&packet, MAVLINK_MSG_ID_HEARTBEAT_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_HEARTBEAT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_heartbeat_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t type, uint8_t autopilot, uint8_t base_mode, uint32_t custom_mode, uint8_t system_status)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, custom_mode);
+	_mav_put_uint8_t(buf, 4, type);
+	_mav_put_uint8_t(buf, 5, autopilot);
+	_mav_put_uint8_t(buf, 6, base_mode);
+	_mav_put_uint8_t(buf, 7, system_status);
+	_mav_put_uint8_t(buf, 8, 3);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HEARTBEAT, buf, MAVLINK_MSG_ID_HEARTBEAT_LEN, MAVLINK_MSG_ID_HEARTBEAT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HEARTBEAT, buf, MAVLINK_MSG_ID_HEARTBEAT_LEN);
+#endif
+#else
+	mavlink_heartbeat_t *packet = (mavlink_heartbeat_t *)msgbuf;
+	packet->custom_mode = custom_mode;
+	packet->type = type;
+	packet->autopilot = autopilot;
+	packet->base_mode = base_mode;
+	packet->system_status = system_status;
+	packet->mavlink_version = 3;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HEARTBEAT, (const char *)packet, MAVLINK_MSG_ID_HEARTBEAT_LEN, MAVLINK_MSG_ID_HEARTBEAT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HEARTBEAT, (const char *)packet, MAVLINK_MSG_ID_HEARTBEAT_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE HEARTBEAT UNPACKING
@@ -193,7 +268,7 @@ static inline uint8_t mavlink_msg_heartb
 /**
  * @brief Get field base_mode from heartbeat message
  *
- * @return System mode bitfield, see MAV_MODE_FLAGS ENUM in mavlink/include/mavlink_types.h
+ * @return System mode bitfield, see MAV_MODE_FLAG ENUM in mavlink/include/mavlink_types.h
  */
 static inline uint8_t mavlink_msg_heartbeat_get_base_mode(const mavlink_message_t* msg)
 {
@@ -246,6 +321,6 @@ static inline void mavlink_msg_heartbeat
 	heartbeat->system_status = mavlink_msg_heartbeat_get_system_status(msg);
 	heartbeat->mavlink_version = mavlink_msg_heartbeat_get_mavlink_version(msg);
 #else
-	memcpy(heartbeat, _MAV_PAYLOAD(msg), 9);
+	memcpy(heartbeat, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_HEARTBEAT_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_highres_imu.h v1.0/common/mavlink_msg_highres_imu.h
--- v1.0.old/common/mavlink_msg_highres_imu.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_highres_imu.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,545 @@
+// MESSAGE HIGHRES_IMU PACKING
+
+#define MAVLINK_MSG_ID_HIGHRES_IMU 105
+
+typedef struct __mavlink_highres_imu_t
+{
+ uint64_t time_usec; ///< Timestamp (microseconds, synced to UNIX time or since system boot)
+ float xacc; ///< X acceleration (m/s^2)
+ float yacc; ///< Y acceleration (m/s^2)
+ float zacc; ///< Z acceleration (m/s^2)
+ float xgyro; ///< Angular speed around X axis (rad / sec)
+ float ygyro; ///< Angular speed around Y axis (rad / sec)
+ float zgyro; ///< Angular speed around Z axis (rad / sec)
+ float xmag; ///< X Magnetic field (Gauss)
+ float ymag; ///< Y Magnetic field (Gauss)
+ float zmag; ///< Z Magnetic field (Gauss)
+ float abs_pressure; ///< Absolute pressure in millibar
+ float diff_pressure; ///< Differential pressure in millibar
+ float pressure_alt; ///< Altitude calculated from pressure
+ float temperature; ///< Temperature in degrees celsius
+ uint16_t fields_updated; ///< Bitmask for fields that have updated since last message, bit 0 = xacc, bit 12: temperature
+} mavlink_highres_imu_t;
+
+#define MAVLINK_MSG_ID_HIGHRES_IMU_LEN 62
+#define MAVLINK_MSG_ID_105_LEN 62
+
+#define MAVLINK_MSG_ID_HIGHRES_IMU_CRC 93
+#define MAVLINK_MSG_ID_105_CRC 93
+
+
+
+#define MAVLINK_MESSAGE_INFO_HIGHRES_IMU { \
+	"HIGHRES_IMU", \
+	15, \
+	{  { "time_usec", NULL, MAVLINK_TYPE_UINT64_T, 0, 0, offsetof(mavlink_highres_imu_t, time_usec) }, \
+         { "xacc", NULL, MAVLINK_TYPE_FLOAT, 0, 8, offsetof(mavlink_highres_imu_t, xacc) }, \
+         { "yacc", NULL, MAVLINK_TYPE_FLOAT, 0, 12, offsetof(mavlink_highres_imu_t, yacc) }, \
+         { "zacc", NULL, MAVLINK_TYPE_FLOAT, 0, 16, offsetof(mavlink_highres_imu_t, zacc) }, \
+         { "xgyro", NULL, MAVLINK_TYPE_FLOAT, 0, 20, offsetof(mavlink_highres_imu_t, xgyro) }, \
+         { "ygyro", NULL, MAVLINK_TYPE_FLOAT, 0, 24, offsetof(mavlink_highres_imu_t, ygyro) }, \
+         { "zgyro", NULL, MAVLINK_TYPE_FLOAT, 0, 28, offsetof(mavlink_highres_imu_t, zgyro) }, \
+         { "xmag", NULL, MAVLINK_TYPE_FLOAT, 0, 32, offsetof(mavlink_highres_imu_t, xmag) }, \
+         { "ymag", NULL, MAVLINK_TYPE_FLOAT, 0, 36, offsetof(mavlink_highres_imu_t, ymag) }, \
+         { "zmag", NULL, MAVLINK_TYPE_FLOAT, 0, 40, offsetof(mavlink_highres_imu_t, zmag) }, \
+         { "abs_pressure", NULL, MAVLINK_TYPE_FLOAT, 0, 44, offsetof(mavlink_highres_imu_t, abs_pressure) }, \
+         { "diff_pressure", NULL, MAVLINK_TYPE_FLOAT, 0, 48, offsetof(mavlink_highres_imu_t, diff_pressure) }, \
+         { "pressure_alt", NULL, MAVLINK_TYPE_FLOAT, 0, 52, offsetof(mavlink_highres_imu_t, pressure_alt) }, \
+         { "temperature", NULL, MAVLINK_TYPE_FLOAT, 0, 56, offsetof(mavlink_highres_imu_t, temperature) }, \
+         { "fields_updated", NULL, MAVLINK_TYPE_UINT16_T, 0, 60, offsetof(mavlink_highres_imu_t, fields_updated) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a highres_imu message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_usec Timestamp (microseconds, synced to UNIX time or since system boot)
+ * @param xacc X acceleration (m/s^2)
+ * @param yacc Y acceleration (m/s^2)
+ * @param zacc Z acceleration (m/s^2)
+ * @param xgyro Angular speed around X axis (rad / sec)
+ * @param ygyro Angular speed around Y axis (rad / sec)
+ * @param zgyro Angular speed around Z axis (rad / sec)
+ * @param xmag X Magnetic field (Gauss)
+ * @param ymag Y Magnetic field (Gauss)
+ * @param zmag Z Magnetic field (Gauss)
+ * @param abs_pressure Absolute pressure in millibar
+ * @param diff_pressure Differential pressure in millibar
+ * @param pressure_alt Altitude calculated from pressure
+ * @param temperature Temperature in degrees celsius
+ * @param fields_updated Bitmask for fields that have updated since last message, bit 0 = xacc, bit 12: temperature
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_highres_imu_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint64_t time_usec, float xacc, float yacc, float zacc, float xgyro, float ygyro, float zgyro, float xmag, float ymag, float zmag, float abs_pressure, float diff_pressure, float pressure_alt, float temperature, uint16_t fields_updated)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_HIGHRES_IMU_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_float(buf, 8, xacc);
+	_mav_put_float(buf, 12, yacc);
+	_mav_put_float(buf, 16, zacc);
+	_mav_put_float(buf, 20, xgyro);
+	_mav_put_float(buf, 24, ygyro);
+	_mav_put_float(buf, 28, zgyro);
+	_mav_put_float(buf, 32, xmag);
+	_mav_put_float(buf, 36, ymag);
+	_mav_put_float(buf, 40, zmag);
+	_mav_put_float(buf, 44, abs_pressure);
+	_mav_put_float(buf, 48, diff_pressure);
+	_mav_put_float(buf, 52, pressure_alt);
+	_mav_put_float(buf, 56, temperature);
+	_mav_put_uint16_t(buf, 60, fields_updated);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HIGHRES_IMU_LEN);
+#else
+	mavlink_highres_imu_t packet;
+	packet.time_usec = time_usec;
+	packet.xacc = xacc;
+	packet.yacc = yacc;
+	packet.zacc = zacc;
+	packet.xgyro = xgyro;
+	packet.ygyro = ygyro;
+	packet.zgyro = zgyro;
+	packet.xmag = xmag;
+	packet.ymag = ymag;
+	packet.zmag = zmag;
+	packet.abs_pressure = abs_pressure;
+	packet.diff_pressure = diff_pressure;
+	packet.pressure_alt = pressure_alt;
+	packet.temperature = temperature;
+	packet.fields_updated = fields_updated;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HIGHRES_IMU_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_HIGHRES_IMU;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HIGHRES_IMU_LEN, MAVLINK_MSG_ID_HIGHRES_IMU_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HIGHRES_IMU_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a highres_imu message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_usec Timestamp (microseconds, synced to UNIX time or since system boot)
+ * @param xacc X acceleration (m/s^2)
+ * @param yacc Y acceleration (m/s^2)
+ * @param zacc Z acceleration (m/s^2)
+ * @param xgyro Angular speed around X axis (rad / sec)
+ * @param ygyro Angular speed around Y axis (rad / sec)
+ * @param zgyro Angular speed around Z axis (rad / sec)
+ * @param xmag X Magnetic field (Gauss)
+ * @param ymag Y Magnetic field (Gauss)
+ * @param zmag Z Magnetic field (Gauss)
+ * @param abs_pressure Absolute pressure in millibar
+ * @param diff_pressure Differential pressure in millibar
+ * @param pressure_alt Altitude calculated from pressure
+ * @param temperature Temperature in degrees celsius
+ * @param fields_updated Bitmask for fields that have updated since last message, bit 0 = xacc, bit 12: temperature
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_highres_imu_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint64_t time_usec,float xacc,float yacc,float zacc,float xgyro,float ygyro,float zgyro,float xmag,float ymag,float zmag,float abs_pressure,float diff_pressure,float pressure_alt,float temperature,uint16_t fields_updated)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_HIGHRES_IMU_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_float(buf, 8, xacc);
+	_mav_put_float(buf, 12, yacc);
+	_mav_put_float(buf, 16, zacc);
+	_mav_put_float(buf, 20, xgyro);
+	_mav_put_float(buf, 24, ygyro);
+	_mav_put_float(buf, 28, zgyro);
+	_mav_put_float(buf, 32, xmag);
+	_mav_put_float(buf, 36, ymag);
+	_mav_put_float(buf, 40, zmag);
+	_mav_put_float(buf, 44, abs_pressure);
+	_mav_put_float(buf, 48, diff_pressure);
+	_mav_put_float(buf, 52, pressure_alt);
+	_mav_put_float(buf, 56, temperature);
+	_mav_put_uint16_t(buf, 60, fields_updated);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HIGHRES_IMU_LEN);
+#else
+	mavlink_highres_imu_t packet;
+	packet.time_usec = time_usec;
+	packet.xacc = xacc;
+	packet.yacc = yacc;
+	packet.zacc = zacc;
+	packet.xgyro = xgyro;
+	packet.ygyro = ygyro;
+	packet.zgyro = zgyro;
+	packet.xmag = xmag;
+	packet.ymag = ymag;
+	packet.zmag = zmag;
+	packet.abs_pressure = abs_pressure;
+	packet.diff_pressure = diff_pressure;
+	packet.pressure_alt = pressure_alt;
+	packet.temperature = temperature;
+	packet.fields_updated = fields_updated;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HIGHRES_IMU_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_HIGHRES_IMU;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HIGHRES_IMU_LEN, MAVLINK_MSG_ID_HIGHRES_IMU_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HIGHRES_IMU_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a highres_imu struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param highres_imu C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_highres_imu_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_highres_imu_t* highres_imu)
+{
+	return mavlink_msg_highres_imu_pack(system_id, component_id, msg, highres_imu->time_usec, highres_imu->xacc, highres_imu->yacc, highres_imu->zacc, highres_imu->xgyro, highres_imu->ygyro, highres_imu->zgyro, highres_imu->xmag, highres_imu->ymag, highres_imu->zmag, highres_imu->abs_pressure, highres_imu->diff_pressure, highres_imu->pressure_alt, highres_imu->temperature, highres_imu->fields_updated);
+}
+
+/**
+ * @brief Encode a highres_imu struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param highres_imu C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_highres_imu_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_highres_imu_t* highres_imu)
+{
+	return mavlink_msg_highres_imu_pack_chan(system_id, component_id, chan, msg, highres_imu->time_usec, highres_imu->xacc, highres_imu->yacc, highres_imu->zacc, highres_imu->xgyro, highres_imu->ygyro, highres_imu->zgyro, highres_imu->xmag, highres_imu->ymag, highres_imu->zmag, highres_imu->abs_pressure, highres_imu->diff_pressure, highres_imu->pressure_alt, highres_imu->temperature, highres_imu->fields_updated);
+}
+
+/**
+ * @brief Send a highres_imu message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_usec Timestamp (microseconds, synced to UNIX time or since system boot)
+ * @param xacc X acceleration (m/s^2)
+ * @param yacc Y acceleration (m/s^2)
+ * @param zacc Z acceleration (m/s^2)
+ * @param xgyro Angular speed around X axis (rad / sec)
+ * @param ygyro Angular speed around Y axis (rad / sec)
+ * @param zgyro Angular speed around Z axis (rad / sec)
+ * @param xmag X Magnetic field (Gauss)
+ * @param ymag Y Magnetic field (Gauss)
+ * @param zmag Z Magnetic field (Gauss)
+ * @param abs_pressure Absolute pressure in millibar
+ * @param diff_pressure Differential pressure in millibar
+ * @param pressure_alt Altitude calculated from pressure
+ * @param temperature Temperature in degrees celsius
+ * @param fields_updated Bitmask for fields that have updated since last message, bit 0 = xacc, bit 12: temperature
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_highres_imu_send(mavlink_channel_t chan, uint64_t time_usec, float xacc, float yacc, float zacc, float xgyro, float ygyro, float zgyro, float xmag, float ymag, float zmag, float abs_pressure, float diff_pressure, float pressure_alt, float temperature, uint16_t fields_updated)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_HIGHRES_IMU_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_float(buf, 8, xacc);
+	_mav_put_float(buf, 12, yacc);
+	_mav_put_float(buf, 16, zacc);
+	_mav_put_float(buf, 20, xgyro);
+	_mav_put_float(buf, 24, ygyro);
+	_mav_put_float(buf, 28, zgyro);
+	_mav_put_float(buf, 32, xmag);
+	_mav_put_float(buf, 36, ymag);
+	_mav_put_float(buf, 40, zmag);
+	_mav_put_float(buf, 44, abs_pressure);
+	_mav_put_float(buf, 48, diff_pressure);
+	_mav_put_float(buf, 52, pressure_alt);
+	_mav_put_float(buf, 56, temperature);
+	_mav_put_uint16_t(buf, 60, fields_updated);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIGHRES_IMU, buf, MAVLINK_MSG_ID_HIGHRES_IMU_LEN, MAVLINK_MSG_ID_HIGHRES_IMU_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIGHRES_IMU, buf, MAVLINK_MSG_ID_HIGHRES_IMU_LEN);
+#endif
+#else
+	mavlink_highres_imu_t packet;
+	packet.time_usec = time_usec;
+	packet.xacc = xacc;
+	packet.yacc = yacc;
+	packet.zacc = zacc;
+	packet.xgyro = xgyro;
+	packet.ygyro = ygyro;
+	packet.zgyro = zgyro;
+	packet.xmag = xmag;
+	packet.ymag = ymag;
+	packet.zmag = zmag;
+	packet.abs_pressure = abs_pressure;
+	packet.diff_pressure = diff_pressure;
+	packet.pressure_alt = pressure_alt;
+	packet.temperature = temperature;
+	packet.fields_updated = fields_updated;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIGHRES_IMU, (const char *)&packet, MAVLINK_MSG_ID_HIGHRES_IMU_LEN, MAVLINK_MSG_ID_HIGHRES_IMU_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIGHRES_IMU, (const char *)&packet, MAVLINK_MSG_ID_HIGHRES_IMU_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_HIGHRES_IMU_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_highres_imu_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t time_usec, float xacc, float yacc, float zacc, float xgyro, float ygyro, float zgyro, float xmag, float ymag, float zmag, float abs_pressure, float diff_pressure, float pressure_alt, float temperature, uint16_t fields_updated)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_float(buf, 8, xacc);
+	_mav_put_float(buf, 12, yacc);
+	_mav_put_float(buf, 16, zacc);
+	_mav_put_float(buf, 20, xgyro);
+	_mav_put_float(buf, 24, ygyro);
+	_mav_put_float(buf, 28, zgyro);
+	_mav_put_float(buf, 32, xmag);
+	_mav_put_float(buf, 36, ymag);
+	_mav_put_float(buf, 40, zmag);
+	_mav_put_float(buf, 44, abs_pressure);
+	_mav_put_float(buf, 48, diff_pressure);
+	_mav_put_float(buf, 52, pressure_alt);
+	_mav_put_float(buf, 56, temperature);
+	_mav_put_uint16_t(buf, 60, fields_updated);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIGHRES_IMU, buf, MAVLINK_MSG_ID_HIGHRES_IMU_LEN, MAVLINK_MSG_ID_HIGHRES_IMU_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIGHRES_IMU, buf, MAVLINK_MSG_ID_HIGHRES_IMU_LEN);
+#endif
+#else
+	mavlink_highres_imu_t *packet = (mavlink_highres_imu_t *)msgbuf;
+	packet->time_usec = time_usec;
+	packet->xacc = xacc;
+	packet->yacc = yacc;
+	packet->zacc = zacc;
+	packet->xgyro = xgyro;
+	packet->ygyro = ygyro;
+	packet->zgyro = zgyro;
+	packet->xmag = xmag;
+	packet->ymag = ymag;
+	packet->zmag = zmag;
+	packet->abs_pressure = abs_pressure;
+	packet->diff_pressure = diff_pressure;
+	packet->pressure_alt = pressure_alt;
+	packet->temperature = temperature;
+	packet->fields_updated = fields_updated;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIGHRES_IMU, (const char *)packet, MAVLINK_MSG_ID_HIGHRES_IMU_LEN, MAVLINK_MSG_ID_HIGHRES_IMU_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIGHRES_IMU, (const char *)packet, MAVLINK_MSG_ID_HIGHRES_IMU_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE HIGHRES_IMU UNPACKING
+
+
+/**
+ * @brief Get field time_usec from highres_imu message
+ *
+ * @return Timestamp (microseconds, synced to UNIX time or since system boot)
+ */
+static inline uint64_t mavlink_msg_highres_imu_get_time_usec(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint64_t(msg,  0);
+}
+
+/**
+ * @brief Get field xacc from highres_imu message
+ *
+ * @return X acceleration (m/s^2)
+ */
+static inline float mavlink_msg_highres_imu_get_xacc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  8);
+}
+
+/**
+ * @brief Get field yacc from highres_imu message
+ *
+ * @return Y acceleration (m/s^2)
+ */
+static inline float mavlink_msg_highres_imu_get_yacc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  12);
+}
+
+/**
+ * @brief Get field zacc from highres_imu message
+ *
+ * @return Z acceleration (m/s^2)
+ */
+static inline float mavlink_msg_highres_imu_get_zacc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  16);
+}
+
+/**
+ * @brief Get field xgyro from highres_imu message
+ *
+ * @return Angular speed around X axis (rad / sec)
+ */
+static inline float mavlink_msg_highres_imu_get_xgyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  20);
+}
+
+/**
+ * @brief Get field ygyro from highres_imu message
+ *
+ * @return Angular speed around Y axis (rad / sec)
+ */
+static inline float mavlink_msg_highres_imu_get_ygyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  24);
+}
+
+/**
+ * @brief Get field zgyro from highres_imu message
+ *
+ * @return Angular speed around Z axis (rad / sec)
+ */
+static inline float mavlink_msg_highres_imu_get_zgyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  28);
+}
+
+/**
+ * @brief Get field xmag from highres_imu message
+ *
+ * @return X Magnetic field (Gauss)
+ */
+static inline float mavlink_msg_highres_imu_get_xmag(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  32);
+}
+
+/**
+ * @brief Get field ymag from highres_imu message
+ *
+ * @return Y Magnetic field (Gauss)
+ */
+static inline float mavlink_msg_highres_imu_get_ymag(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  36);
+}
+
+/**
+ * @brief Get field zmag from highres_imu message
+ *
+ * @return Z Magnetic field (Gauss)
+ */
+static inline float mavlink_msg_highres_imu_get_zmag(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  40);
+}
+
+/**
+ * @brief Get field abs_pressure from highres_imu message
+ *
+ * @return Absolute pressure in millibar
+ */
+static inline float mavlink_msg_highres_imu_get_abs_pressure(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  44);
+}
+
+/**
+ * @brief Get field diff_pressure from highres_imu message
+ *
+ * @return Differential pressure in millibar
+ */
+static inline float mavlink_msg_highres_imu_get_diff_pressure(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  48);
+}
+
+/**
+ * @brief Get field pressure_alt from highres_imu message
+ *
+ * @return Altitude calculated from pressure
+ */
+static inline float mavlink_msg_highres_imu_get_pressure_alt(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  52);
+}
+
+/**
+ * @brief Get field temperature from highres_imu message
+ *
+ * @return Temperature in degrees celsius
+ */
+static inline float mavlink_msg_highres_imu_get_temperature(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  56);
+}
+
+/**
+ * @brief Get field fields_updated from highres_imu message
+ *
+ * @return Bitmask for fields that have updated since last message, bit 0 = xacc, bit 12: temperature
+ */
+static inline uint16_t mavlink_msg_highres_imu_get_fields_updated(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  60);
+}
+
+/**
+ * @brief Decode a highres_imu message into a struct
+ *
+ * @param msg The message to decode
+ * @param highres_imu C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_highres_imu_decode(const mavlink_message_t* msg, mavlink_highres_imu_t* highres_imu)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	highres_imu->time_usec = mavlink_msg_highres_imu_get_time_usec(msg);
+	highres_imu->xacc = mavlink_msg_highres_imu_get_xacc(msg);
+	highres_imu->yacc = mavlink_msg_highres_imu_get_yacc(msg);
+	highres_imu->zacc = mavlink_msg_highres_imu_get_zacc(msg);
+	highres_imu->xgyro = mavlink_msg_highres_imu_get_xgyro(msg);
+	highres_imu->ygyro = mavlink_msg_highres_imu_get_ygyro(msg);
+	highres_imu->zgyro = mavlink_msg_highres_imu_get_zgyro(msg);
+	highres_imu->xmag = mavlink_msg_highres_imu_get_xmag(msg);
+	highres_imu->ymag = mavlink_msg_highres_imu_get_ymag(msg);
+	highres_imu->zmag = mavlink_msg_highres_imu_get_zmag(msg);
+	highres_imu->abs_pressure = mavlink_msg_highres_imu_get_abs_pressure(msg);
+	highres_imu->diff_pressure = mavlink_msg_highres_imu_get_diff_pressure(msg);
+	highres_imu->pressure_alt = mavlink_msg_highres_imu_get_pressure_alt(msg);
+	highres_imu->temperature = mavlink_msg_highres_imu_get_temperature(msg);
+	highres_imu->fields_updated = mavlink_msg_highres_imu_get_fields_updated(msg);
+#else
+	memcpy(highres_imu, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_HIGHRES_IMU_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_hil_controls.h v1.0/common/mavlink_msg_hil_controls.h
--- v1.0.old/common/mavlink_msg_hil_controls.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_hil_controls.h	2015-02-06 11:50:58.000000000 +0500
@@ -20,6 +20,9 @@ typedef struct __mavlink_hil_controls_t
 #define MAVLINK_MSG_ID_HIL_CONTROLS_LEN 42
 #define MAVLINK_MSG_ID_91_LEN 42
 
+#define MAVLINK_MSG_ID_HIL_CONTROLS_CRC 63
+#define MAVLINK_MSG_ID_91_CRC 63
+
 
 
 #define MAVLINK_MESSAGE_INFO_HIL_CONTROLS { \
@@ -63,7 +66,7 @@ static inline uint16_t mavlink_msg_hil_c
 						       uint64_t time_usec, float roll_ailerons, float pitch_elevator, float yaw_rudder, float throttle, float aux1, float aux2, float aux3, float aux4, uint8_t mode, uint8_t nav_mode)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[42];
+	char buf[MAVLINK_MSG_ID_HIL_CONTROLS_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_float(buf, 8, roll_ailerons);
 	_mav_put_float(buf, 12, pitch_elevator);
@@ -76,7 +79,7 @@ static inline uint16_t mavlink_msg_hil_c
 	_mav_put_uint8_t(buf, 40, mode);
 	_mav_put_uint8_t(buf, 41, nav_mode);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 42);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HIL_CONTROLS_LEN);
 #else
 	mavlink_hil_controls_t packet;
 	packet.time_usec = time_usec;
@@ -91,18 +94,22 @@ static inline uint16_t mavlink_msg_hil_c
 	packet.mode = mode;
 	packet.nav_mode = nav_mode;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 42);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HIL_CONTROLS_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_HIL_CONTROLS;
-	return mavlink_finalize_message(msg, system_id, component_id, 42, 63);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HIL_CONTROLS_LEN, MAVLINK_MSG_ID_HIL_CONTROLS_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HIL_CONTROLS_LEN);
+#endif
 }
 
 /**
  * @brief Pack a hil_controls message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
  * @param roll_ailerons Control output -1 .. 1
@@ -122,7 +129,7 @@ static inline uint16_t mavlink_msg_hil_c
 						           uint64_t time_usec,float roll_ailerons,float pitch_elevator,float yaw_rudder,float throttle,float aux1,float aux2,float aux3,float aux4,uint8_t mode,uint8_t nav_mode)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[42];
+	char buf[MAVLINK_MSG_ID_HIL_CONTROLS_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_float(buf, 8, roll_ailerons);
 	_mav_put_float(buf, 12, pitch_elevator);
@@ -135,7 +142,7 @@ static inline uint16_t mavlink_msg_hil_c
 	_mav_put_uint8_t(buf, 40, mode);
 	_mav_put_uint8_t(buf, 41, nav_mode);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 42);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HIL_CONTROLS_LEN);
 #else
 	mavlink_hil_controls_t packet;
 	packet.time_usec = time_usec;
@@ -150,15 +157,19 @@ static inline uint16_t mavlink_msg_hil_c
 	packet.mode = mode;
 	packet.nav_mode = nav_mode;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 42);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HIL_CONTROLS_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_HIL_CONTROLS;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 42, 63);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HIL_CONTROLS_LEN, MAVLINK_MSG_ID_HIL_CONTROLS_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HIL_CONTROLS_LEN);
+#endif
 }
 
 /**
- * @brief Encode a hil_controls struct into a message
+ * @brief Encode a hil_controls struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -171,6 +182,20 @@ static inline uint16_t mavlink_msg_hil_c
 }
 
 /**
+ * @brief Encode a hil_controls struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param hil_controls C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_hil_controls_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_hil_controls_t* hil_controls)
+{
+	return mavlink_msg_hil_controls_pack_chan(system_id, component_id, chan, msg, hil_controls->time_usec, hil_controls->roll_ailerons, hil_controls->pitch_elevator, hil_controls->yaw_rudder, hil_controls->throttle, hil_controls->aux1, hil_controls->aux2, hil_controls->aux3, hil_controls->aux4, hil_controls->mode, hil_controls->nav_mode);
+}
+
+/**
  * @brief Send a hil_controls message
  * @param chan MAVLink channel to send the message
  *
@@ -191,7 +216,7 @@ static inline uint16_t mavlink_msg_hil_c
 static inline void mavlink_msg_hil_controls_send(mavlink_channel_t chan, uint64_t time_usec, float roll_ailerons, float pitch_elevator, float yaw_rudder, float throttle, float aux1, float aux2, float aux3, float aux4, uint8_t mode, uint8_t nav_mode)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[42];
+	char buf[MAVLINK_MSG_ID_HIL_CONTROLS_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_float(buf, 8, roll_ailerons);
 	_mav_put_float(buf, 12, pitch_elevator);
@@ -204,7 +229,11 @@ static inline void mavlink_msg_hil_contr
 	_mav_put_uint8_t(buf, 40, mode);
 	_mav_put_uint8_t(buf, 41, nav_mode);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_CONTROLS, buf, 42, 63);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_CONTROLS, buf, MAVLINK_MSG_ID_HIL_CONTROLS_LEN, MAVLINK_MSG_ID_HIL_CONTROLS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_CONTROLS, buf, MAVLINK_MSG_ID_HIL_CONTROLS_LEN);
+#endif
 #else
 	mavlink_hil_controls_t packet;
 	packet.time_usec = time_usec;
@@ -219,9 +248,65 @@ static inline void mavlink_msg_hil_contr
 	packet.mode = mode;
 	packet.nav_mode = nav_mode;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_CONTROLS, (const char *)&packet, 42, 63);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_CONTROLS, (const char *)&packet, MAVLINK_MSG_ID_HIL_CONTROLS_LEN, MAVLINK_MSG_ID_HIL_CONTROLS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_CONTROLS, (const char *)&packet, MAVLINK_MSG_ID_HIL_CONTROLS_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_HIL_CONTROLS_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_hil_controls_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t time_usec, float roll_ailerons, float pitch_elevator, float yaw_rudder, float throttle, float aux1, float aux2, float aux3, float aux4, uint8_t mode, uint8_t nav_mode)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_float(buf, 8, roll_ailerons);
+	_mav_put_float(buf, 12, pitch_elevator);
+	_mav_put_float(buf, 16, yaw_rudder);
+	_mav_put_float(buf, 20, throttle);
+	_mav_put_float(buf, 24, aux1);
+	_mav_put_float(buf, 28, aux2);
+	_mav_put_float(buf, 32, aux3);
+	_mav_put_float(buf, 36, aux4);
+	_mav_put_uint8_t(buf, 40, mode);
+	_mav_put_uint8_t(buf, 41, nav_mode);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_CONTROLS, buf, MAVLINK_MSG_ID_HIL_CONTROLS_LEN, MAVLINK_MSG_ID_HIL_CONTROLS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_CONTROLS, buf, MAVLINK_MSG_ID_HIL_CONTROLS_LEN);
+#endif
+#else
+	mavlink_hil_controls_t *packet = (mavlink_hil_controls_t *)msgbuf;
+	packet->time_usec = time_usec;
+	packet->roll_ailerons = roll_ailerons;
+	packet->pitch_elevator = pitch_elevator;
+	packet->yaw_rudder = yaw_rudder;
+	packet->throttle = throttle;
+	packet->aux1 = aux1;
+	packet->aux2 = aux2;
+	packet->aux3 = aux3;
+	packet->aux4 = aux4;
+	packet->mode = mode;
+	packet->nav_mode = nav_mode;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_CONTROLS, (const char *)packet, MAVLINK_MSG_ID_HIL_CONTROLS_LEN, MAVLINK_MSG_ID_HIL_CONTROLS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_CONTROLS, (const char *)packet, MAVLINK_MSG_ID_HIL_CONTROLS_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -359,6 +444,6 @@ static inline void mavlink_msg_hil_contr
 	hil_controls->mode = mavlink_msg_hil_controls_get_mode(msg);
 	hil_controls->nav_mode = mavlink_msg_hil_controls_get_nav_mode(msg);
 #else
-	memcpy(hil_controls, _MAV_PAYLOAD(msg), 42);
+	memcpy(hil_controls, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_HIL_CONTROLS_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_hil_gps.h v1.0/common/mavlink_msg_hil_gps.h
--- v1.0.old/common/mavlink_msg_hil_gps.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_hil_gps.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,497 @@
+// MESSAGE HIL_GPS PACKING
+
+#define MAVLINK_MSG_ID_HIL_GPS 113
+
+typedef struct __mavlink_hil_gps_t
+{
+ uint64_t time_usec; ///< Timestamp (microseconds since UNIX epoch or microseconds since system boot)
+ int32_t lat; ///< Latitude (WGS84), in degrees * 1E7
+ int32_t lon; ///< Longitude (WGS84), in degrees * 1E7
+ int32_t alt; ///< Altitude (AMSL, not WGS84), in meters * 1000 (positive for up)
+ uint16_t eph; ///< GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535
+ uint16_t epv; ///< GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: 65535
+ uint16_t vel; ///< GPS ground speed (m/s * 100). If unknown, set to: 65535
+ int16_t vn; ///< GPS velocity in cm/s in NORTH direction in earth-fixed NED frame
+ int16_t ve; ///< GPS velocity in cm/s in EAST direction in earth-fixed NED frame
+ int16_t vd; ///< GPS velocity in cm/s in DOWN direction in earth-fixed NED frame
+ uint16_t cog; ///< Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535
+ uint8_t fix_type; ///< 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
+ uint8_t satellites_visible; ///< Number of satellites visible. If unknown, set to 255
+} mavlink_hil_gps_t;
+
+#define MAVLINK_MSG_ID_HIL_GPS_LEN 36
+#define MAVLINK_MSG_ID_113_LEN 36
+
+#define MAVLINK_MSG_ID_HIL_GPS_CRC 124
+#define MAVLINK_MSG_ID_113_CRC 124
+
+
+
+#define MAVLINK_MESSAGE_INFO_HIL_GPS { \
+	"HIL_GPS", \
+	13, \
+	{  { "time_usec", NULL, MAVLINK_TYPE_UINT64_T, 0, 0, offsetof(mavlink_hil_gps_t, time_usec) }, \
+         { "lat", NULL, MAVLINK_TYPE_INT32_T, 0, 8, offsetof(mavlink_hil_gps_t, lat) }, \
+         { "lon", NULL, MAVLINK_TYPE_INT32_T, 0, 12, offsetof(mavlink_hil_gps_t, lon) }, \
+         { "alt", NULL, MAVLINK_TYPE_INT32_T, 0, 16, offsetof(mavlink_hil_gps_t, alt) }, \
+         { "eph", NULL, MAVLINK_TYPE_UINT16_T, 0, 20, offsetof(mavlink_hil_gps_t, eph) }, \
+         { "epv", NULL, MAVLINK_TYPE_UINT16_T, 0, 22, offsetof(mavlink_hil_gps_t, epv) }, \
+         { "vel", NULL, MAVLINK_TYPE_UINT16_T, 0, 24, offsetof(mavlink_hil_gps_t, vel) }, \
+         { "vn", NULL, MAVLINK_TYPE_INT16_T, 0, 26, offsetof(mavlink_hil_gps_t, vn) }, \
+         { "ve", NULL, MAVLINK_TYPE_INT16_T, 0, 28, offsetof(mavlink_hil_gps_t, ve) }, \
+         { "vd", NULL, MAVLINK_TYPE_INT16_T, 0, 30, offsetof(mavlink_hil_gps_t, vd) }, \
+         { "cog", NULL, MAVLINK_TYPE_UINT16_T, 0, 32, offsetof(mavlink_hil_gps_t, cog) }, \
+         { "fix_type", NULL, MAVLINK_TYPE_UINT8_T, 0, 34, offsetof(mavlink_hil_gps_t, fix_type) }, \
+         { "satellites_visible", NULL, MAVLINK_TYPE_UINT8_T, 0, 35, offsetof(mavlink_hil_gps_t, satellites_visible) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a hil_gps message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
+ * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
+ * @param lat Latitude (WGS84), in degrees * 1E7
+ * @param lon Longitude (WGS84), in degrees * 1E7
+ * @param alt Altitude (AMSL, not WGS84), in meters * 1000 (positive for up)
+ * @param eph GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535
+ * @param epv GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: 65535
+ * @param vel GPS ground speed (m/s * 100). If unknown, set to: 65535
+ * @param vn GPS velocity in cm/s in NORTH direction in earth-fixed NED frame
+ * @param ve GPS velocity in cm/s in EAST direction in earth-fixed NED frame
+ * @param vd GPS velocity in cm/s in DOWN direction in earth-fixed NED frame
+ * @param cog Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535
+ * @param satellites_visible Number of satellites visible. If unknown, set to 255
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_hil_gps_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint64_t time_usec, uint8_t fix_type, int32_t lat, int32_t lon, int32_t alt, uint16_t eph, uint16_t epv, uint16_t vel, int16_t vn, int16_t ve, int16_t vd, uint16_t cog, uint8_t satellites_visible)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_HIL_GPS_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_int32_t(buf, 8, lat);
+	_mav_put_int32_t(buf, 12, lon);
+	_mav_put_int32_t(buf, 16, alt);
+	_mav_put_uint16_t(buf, 20, eph);
+	_mav_put_uint16_t(buf, 22, epv);
+	_mav_put_uint16_t(buf, 24, vel);
+	_mav_put_int16_t(buf, 26, vn);
+	_mav_put_int16_t(buf, 28, ve);
+	_mav_put_int16_t(buf, 30, vd);
+	_mav_put_uint16_t(buf, 32, cog);
+	_mav_put_uint8_t(buf, 34, fix_type);
+	_mav_put_uint8_t(buf, 35, satellites_visible);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HIL_GPS_LEN);
+#else
+	mavlink_hil_gps_t packet;
+	packet.time_usec = time_usec;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.alt = alt;
+	packet.eph = eph;
+	packet.epv = epv;
+	packet.vel = vel;
+	packet.vn = vn;
+	packet.ve = ve;
+	packet.vd = vd;
+	packet.cog = cog;
+	packet.fix_type = fix_type;
+	packet.satellites_visible = satellites_visible;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HIL_GPS_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_HIL_GPS;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HIL_GPS_LEN, MAVLINK_MSG_ID_HIL_GPS_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HIL_GPS_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a hil_gps message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
+ * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
+ * @param lat Latitude (WGS84), in degrees * 1E7
+ * @param lon Longitude (WGS84), in degrees * 1E7
+ * @param alt Altitude (AMSL, not WGS84), in meters * 1000 (positive for up)
+ * @param eph GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535
+ * @param epv GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: 65535
+ * @param vel GPS ground speed (m/s * 100). If unknown, set to: 65535
+ * @param vn GPS velocity in cm/s in NORTH direction in earth-fixed NED frame
+ * @param ve GPS velocity in cm/s in EAST direction in earth-fixed NED frame
+ * @param vd GPS velocity in cm/s in DOWN direction in earth-fixed NED frame
+ * @param cog Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535
+ * @param satellites_visible Number of satellites visible. If unknown, set to 255
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_hil_gps_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint64_t time_usec,uint8_t fix_type,int32_t lat,int32_t lon,int32_t alt,uint16_t eph,uint16_t epv,uint16_t vel,int16_t vn,int16_t ve,int16_t vd,uint16_t cog,uint8_t satellites_visible)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_HIL_GPS_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_int32_t(buf, 8, lat);
+	_mav_put_int32_t(buf, 12, lon);
+	_mav_put_int32_t(buf, 16, alt);
+	_mav_put_uint16_t(buf, 20, eph);
+	_mav_put_uint16_t(buf, 22, epv);
+	_mav_put_uint16_t(buf, 24, vel);
+	_mav_put_int16_t(buf, 26, vn);
+	_mav_put_int16_t(buf, 28, ve);
+	_mav_put_int16_t(buf, 30, vd);
+	_mav_put_uint16_t(buf, 32, cog);
+	_mav_put_uint8_t(buf, 34, fix_type);
+	_mav_put_uint8_t(buf, 35, satellites_visible);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HIL_GPS_LEN);
+#else
+	mavlink_hil_gps_t packet;
+	packet.time_usec = time_usec;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.alt = alt;
+	packet.eph = eph;
+	packet.epv = epv;
+	packet.vel = vel;
+	packet.vn = vn;
+	packet.ve = ve;
+	packet.vd = vd;
+	packet.cog = cog;
+	packet.fix_type = fix_type;
+	packet.satellites_visible = satellites_visible;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HIL_GPS_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_HIL_GPS;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HIL_GPS_LEN, MAVLINK_MSG_ID_HIL_GPS_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HIL_GPS_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a hil_gps struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param hil_gps C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_hil_gps_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_hil_gps_t* hil_gps)
+{
+	return mavlink_msg_hil_gps_pack(system_id, component_id, msg, hil_gps->time_usec, hil_gps->fix_type, hil_gps->lat, hil_gps->lon, hil_gps->alt, hil_gps->eph, hil_gps->epv, hil_gps->vel, hil_gps->vn, hil_gps->ve, hil_gps->vd, hil_gps->cog, hil_gps->satellites_visible);
+}
+
+/**
+ * @brief Encode a hil_gps struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param hil_gps C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_hil_gps_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_hil_gps_t* hil_gps)
+{
+	return mavlink_msg_hil_gps_pack_chan(system_id, component_id, chan, msg, hil_gps->time_usec, hil_gps->fix_type, hil_gps->lat, hil_gps->lon, hil_gps->alt, hil_gps->eph, hil_gps->epv, hil_gps->vel, hil_gps->vn, hil_gps->ve, hil_gps->vd, hil_gps->cog, hil_gps->satellites_visible);
+}
+
+/**
+ * @brief Send a hil_gps message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
+ * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
+ * @param lat Latitude (WGS84), in degrees * 1E7
+ * @param lon Longitude (WGS84), in degrees * 1E7
+ * @param alt Altitude (AMSL, not WGS84), in meters * 1000 (positive for up)
+ * @param eph GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535
+ * @param epv GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: 65535
+ * @param vel GPS ground speed (m/s * 100). If unknown, set to: 65535
+ * @param vn GPS velocity in cm/s in NORTH direction in earth-fixed NED frame
+ * @param ve GPS velocity in cm/s in EAST direction in earth-fixed NED frame
+ * @param vd GPS velocity in cm/s in DOWN direction in earth-fixed NED frame
+ * @param cog Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535
+ * @param satellites_visible Number of satellites visible. If unknown, set to 255
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_hil_gps_send(mavlink_channel_t chan, uint64_t time_usec, uint8_t fix_type, int32_t lat, int32_t lon, int32_t alt, uint16_t eph, uint16_t epv, uint16_t vel, int16_t vn, int16_t ve, int16_t vd, uint16_t cog, uint8_t satellites_visible)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_HIL_GPS_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_int32_t(buf, 8, lat);
+	_mav_put_int32_t(buf, 12, lon);
+	_mav_put_int32_t(buf, 16, alt);
+	_mav_put_uint16_t(buf, 20, eph);
+	_mav_put_uint16_t(buf, 22, epv);
+	_mav_put_uint16_t(buf, 24, vel);
+	_mav_put_int16_t(buf, 26, vn);
+	_mav_put_int16_t(buf, 28, ve);
+	_mav_put_int16_t(buf, 30, vd);
+	_mav_put_uint16_t(buf, 32, cog);
+	_mav_put_uint8_t(buf, 34, fix_type);
+	_mav_put_uint8_t(buf, 35, satellites_visible);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_GPS, buf, MAVLINK_MSG_ID_HIL_GPS_LEN, MAVLINK_MSG_ID_HIL_GPS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_GPS, buf, MAVLINK_MSG_ID_HIL_GPS_LEN);
+#endif
+#else
+	mavlink_hil_gps_t packet;
+	packet.time_usec = time_usec;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.alt = alt;
+	packet.eph = eph;
+	packet.epv = epv;
+	packet.vel = vel;
+	packet.vn = vn;
+	packet.ve = ve;
+	packet.vd = vd;
+	packet.cog = cog;
+	packet.fix_type = fix_type;
+	packet.satellites_visible = satellites_visible;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_GPS, (const char *)&packet, MAVLINK_MSG_ID_HIL_GPS_LEN, MAVLINK_MSG_ID_HIL_GPS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_GPS, (const char *)&packet, MAVLINK_MSG_ID_HIL_GPS_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_HIL_GPS_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_hil_gps_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t time_usec, uint8_t fix_type, int32_t lat, int32_t lon, int32_t alt, uint16_t eph, uint16_t epv, uint16_t vel, int16_t vn, int16_t ve, int16_t vd, uint16_t cog, uint8_t satellites_visible)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_int32_t(buf, 8, lat);
+	_mav_put_int32_t(buf, 12, lon);
+	_mav_put_int32_t(buf, 16, alt);
+	_mav_put_uint16_t(buf, 20, eph);
+	_mav_put_uint16_t(buf, 22, epv);
+	_mav_put_uint16_t(buf, 24, vel);
+	_mav_put_int16_t(buf, 26, vn);
+	_mav_put_int16_t(buf, 28, ve);
+	_mav_put_int16_t(buf, 30, vd);
+	_mav_put_uint16_t(buf, 32, cog);
+	_mav_put_uint8_t(buf, 34, fix_type);
+	_mav_put_uint8_t(buf, 35, satellites_visible);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_GPS, buf, MAVLINK_MSG_ID_HIL_GPS_LEN, MAVLINK_MSG_ID_HIL_GPS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_GPS, buf, MAVLINK_MSG_ID_HIL_GPS_LEN);
+#endif
+#else
+	mavlink_hil_gps_t *packet = (mavlink_hil_gps_t *)msgbuf;
+	packet->time_usec = time_usec;
+	packet->lat = lat;
+	packet->lon = lon;
+	packet->alt = alt;
+	packet->eph = eph;
+	packet->epv = epv;
+	packet->vel = vel;
+	packet->vn = vn;
+	packet->ve = ve;
+	packet->vd = vd;
+	packet->cog = cog;
+	packet->fix_type = fix_type;
+	packet->satellites_visible = satellites_visible;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_GPS, (const char *)packet, MAVLINK_MSG_ID_HIL_GPS_LEN, MAVLINK_MSG_ID_HIL_GPS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_GPS, (const char *)packet, MAVLINK_MSG_ID_HIL_GPS_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE HIL_GPS UNPACKING
+
+
+/**
+ * @brief Get field time_usec from hil_gps message
+ *
+ * @return Timestamp (microseconds since UNIX epoch or microseconds since system boot)
+ */
+static inline uint64_t mavlink_msg_hil_gps_get_time_usec(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint64_t(msg,  0);
+}
+
+/**
+ * @brief Get field fix_type from hil_gps message
+ *
+ * @return 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
+ */
+static inline uint8_t mavlink_msg_hil_gps_get_fix_type(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  34);
+}
+
+/**
+ * @brief Get field lat from hil_gps message
+ *
+ * @return Latitude (WGS84), in degrees * 1E7
+ */
+static inline int32_t mavlink_msg_hil_gps_get_lat(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  8);
+}
+
+/**
+ * @brief Get field lon from hil_gps message
+ *
+ * @return Longitude (WGS84), in degrees * 1E7
+ */
+static inline int32_t mavlink_msg_hil_gps_get_lon(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  12);
+}
+
+/**
+ * @brief Get field alt from hil_gps message
+ *
+ * @return Altitude (AMSL, not WGS84), in meters * 1000 (positive for up)
+ */
+static inline int32_t mavlink_msg_hil_gps_get_alt(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  16);
+}
+
+/**
+ * @brief Get field eph from hil_gps message
+ *
+ * @return GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535
+ */
+static inline uint16_t mavlink_msg_hil_gps_get_eph(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  20);
+}
+
+/**
+ * @brief Get field epv from hil_gps message
+ *
+ * @return GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: 65535
+ */
+static inline uint16_t mavlink_msg_hil_gps_get_epv(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  22);
+}
+
+/**
+ * @brief Get field vel from hil_gps message
+ *
+ * @return GPS ground speed (m/s * 100). If unknown, set to: 65535
+ */
+static inline uint16_t mavlink_msg_hil_gps_get_vel(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  24);
+}
+
+/**
+ * @brief Get field vn from hil_gps message
+ *
+ * @return GPS velocity in cm/s in NORTH direction in earth-fixed NED frame
+ */
+static inline int16_t mavlink_msg_hil_gps_get_vn(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  26);
+}
+
+/**
+ * @brief Get field ve from hil_gps message
+ *
+ * @return GPS velocity in cm/s in EAST direction in earth-fixed NED frame
+ */
+static inline int16_t mavlink_msg_hil_gps_get_ve(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  28);
+}
+
+/**
+ * @brief Get field vd from hil_gps message
+ *
+ * @return GPS velocity in cm/s in DOWN direction in earth-fixed NED frame
+ */
+static inline int16_t mavlink_msg_hil_gps_get_vd(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  30);
+}
+
+/**
+ * @brief Get field cog from hil_gps message
+ *
+ * @return Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535
+ */
+static inline uint16_t mavlink_msg_hil_gps_get_cog(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  32);
+}
+
+/**
+ * @brief Get field satellites_visible from hil_gps message
+ *
+ * @return Number of satellites visible. If unknown, set to 255
+ */
+static inline uint8_t mavlink_msg_hil_gps_get_satellites_visible(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  35);
+}
+
+/**
+ * @brief Decode a hil_gps message into a struct
+ *
+ * @param msg The message to decode
+ * @param hil_gps C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_hil_gps_decode(const mavlink_message_t* msg, mavlink_hil_gps_t* hil_gps)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	hil_gps->time_usec = mavlink_msg_hil_gps_get_time_usec(msg);
+	hil_gps->lat = mavlink_msg_hil_gps_get_lat(msg);
+	hil_gps->lon = mavlink_msg_hil_gps_get_lon(msg);
+	hil_gps->alt = mavlink_msg_hil_gps_get_alt(msg);
+	hil_gps->eph = mavlink_msg_hil_gps_get_eph(msg);
+	hil_gps->epv = mavlink_msg_hil_gps_get_epv(msg);
+	hil_gps->vel = mavlink_msg_hil_gps_get_vel(msg);
+	hil_gps->vn = mavlink_msg_hil_gps_get_vn(msg);
+	hil_gps->ve = mavlink_msg_hil_gps_get_ve(msg);
+	hil_gps->vd = mavlink_msg_hil_gps_get_vd(msg);
+	hil_gps->cog = mavlink_msg_hil_gps_get_cog(msg);
+	hil_gps->fix_type = mavlink_msg_hil_gps_get_fix_type(msg);
+	hil_gps->satellites_visible = mavlink_msg_hil_gps_get_satellites_visible(msg);
+#else
+	memcpy(hil_gps, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_HIL_GPS_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_hil_optical_flow.h v1.0/common/mavlink_msg_hil_optical_flow.h
--- v1.0.old/common/mavlink_msg_hil_optical_flow.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_hil_optical_flow.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,473 @@
+// MESSAGE HIL_OPTICAL_FLOW PACKING
+
+#define MAVLINK_MSG_ID_HIL_OPTICAL_FLOW 114
+
+typedef struct __mavlink_hil_optical_flow_t
+{
+ uint64_t time_usec; ///< Timestamp (microseconds, synced to UNIX time or since system boot)
+ uint32_t integration_time_us; ///< Integration time in microseconds. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
+ float integrated_x; ///< Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
+ float integrated_y; ///< Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
+ float integrated_xgyro; ///< RH rotation around X axis (rad)
+ float integrated_ygyro; ///< RH rotation around Y axis (rad)
+ float integrated_zgyro; ///< RH rotation around Z axis (rad)
+ uint32_t time_delta_distance_us; ///< Time in microseconds since the distance was sampled.
+ float distance; ///< Distance to the center of the flow field in meters. Positive value (including zero): distance known. Negative value: Unknown distance.
+ int16_t temperature; ///< Temperature * 100 in centi-degrees Celsius
+ uint8_t sensor_id; ///< Sensor ID
+ uint8_t quality; ///< Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
+} mavlink_hil_optical_flow_t;
+
+#define MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN 44
+#define MAVLINK_MSG_ID_114_LEN 44
+
+#define MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_CRC 237
+#define MAVLINK_MSG_ID_114_CRC 237
+
+
+
+#define MAVLINK_MESSAGE_INFO_HIL_OPTICAL_FLOW { \
+	"HIL_OPTICAL_FLOW", \
+	12, \
+	{  { "time_usec", NULL, MAVLINK_TYPE_UINT64_T, 0, 0, offsetof(mavlink_hil_optical_flow_t, time_usec) }, \
+         { "integration_time_us", NULL, MAVLINK_TYPE_UINT32_T, 0, 8, offsetof(mavlink_hil_optical_flow_t, integration_time_us) }, \
+         { "integrated_x", NULL, MAVLINK_TYPE_FLOAT, 0, 12, offsetof(mavlink_hil_optical_flow_t, integrated_x) }, \
+         { "integrated_y", NULL, MAVLINK_TYPE_FLOAT, 0, 16, offsetof(mavlink_hil_optical_flow_t, integrated_y) }, \
+         { "integrated_xgyro", NULL, MAVLINK_TYPE_FLOAT, 0, 20, offsetof(mavlink_hil_optical_flow_t, integrated_xgyro) }, \
+         { "integrated_ygyro", NULL, MAVLINK_TYPE_FLOAT, 0, 24, offsetof(mavlink_hil_optical_flow_t, integrated_ygyro) }, \
+         { "integrated_zgyro", NULL, MAVLINK_TYPE_FLOAT, 0, 28, offsetof(mavlink_hil_optical_flow_t, integrated_zgyro) }, \
+         { "time_delta_distance_us", NULL, MAVLINK_TYPE_UINT32_T, 0, 32, offsetof(mavlink_hil_optical_flow_t, time_delta_distance_us) }, \
+         { "distance", NULL, MAVLINK_TYPE_FLOAT, 0, 36, offsetof(mavlink_hil_optical_flow_t, distance) }, \
+         { "temperature", NULL, MAVLINK_TYPE_INT16_T, 0, 40, offsetof(mavlink_hil_optical_flow_t, temperature) }, \
+         { "sensor_id", NULL, MAVLINK_TYPE_UINT8_T, 0, 42, offsetof(mavlink_hil_optical_flow_t, sensor_id) }, \
+         { "quality", NULL, MAVLINK_TYPE_UINT8_T, 0, 43, offsetof(mavlink_hil_optical_flow_t, quality) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a hil_optical_flow message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_usec Timestamp (microseconds, synced to UNIX time or since system boot)
+ * @param sensor_id Sensor ID
+ * @param integration_time_us Integration time in microseconds. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
+ * @param integrated_x Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
+ * @param integrated_y Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
+ * @param integrated_xgyro RH rotation around X axis (rad)
+ * @param integrated_ygyro RH rotation around Y axis (rad)
+ * @param integrated_zgyro RH rotation around Z axis (rad)
+ * @param temperature Temperature * 100 in centi-degrees Celsius
+ * @param quality Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
+ * @param time_delta_distance_us Time in microseconds since the distance was sampled.
+ * @param distance Distance to the center of the flow field in meters. Positive value (including zero): distance known. Negative value: Unknown distance.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_hil_optical_flow_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint64_t time_usec, uint8_t sensor_id, uint32_t integration_time_us, float integrated_x, float integrated_y, float integrated_xgyro, float integrated_ygyro, float integrated_zgyro, int16_t temperature, uint8_t quality, uint32_t time_delta_distance_us, float distance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_uint32_t(buf, 8, integration_time_us);
+	_mav_put_float(buf, 12, integrated_x);
+	_mav_put_float(buf, 16, integrated_y);
+	_mav_put_float(buf, 20, integrated_xgyro);
+	_mav_put_float(buf, 24, integrated_ygyro);
+	_mav_put_float(buf, 28, integrated_zgyro);
+	_mav_put_uint32_t(buf, 32, time_delta_distance_us);
+	_mav_put_float(buf, 36, distance);
+	_mav_put_int16_t(buf, 40, temperature);
+	_mav_put_uint8_t(buf, 42, sensor_id);
+	_mav_put_uint8_t(buf, 43, quality);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN);
+#else
+	mavlink_hil_optical_flow_t packet;
+	packet.time_usec = time_usec;
+	packet.integration_time_us = integration_time_us;
+	packet.integrated_x = integrated_x;
+	packet.integrated_y = integrated_y;
+	packet.integrated_xgyro = integrated_xgyro;
+	packet.integrated_ygyro = integrated_ygyro;
+	packet.integrated_zgyro = integrated_zgyro;
+	packet.time_delta_distance_us = time_delta_distance_us;
+	packet.distance = distance;
+	packet.temperature = temperature;
+	packet.sensor_id = sensor_id;
+	packet.quality = quality;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_HIL_OPTICAL_FLOW;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a hil_optical_flow message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_usec Timestamp (microseconds, synced to UNIX time or since system boot)
+ * @param sensor_id Sensor ID
+ * @param integration_time_us Integration time in microseconds. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
+ * @param integrated_x Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
+ * @param integrated_y Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
+ * @param integrated_xgyro RH rotation around X axis (rad)
+ * @param integrated_ygyro RH rotation around Y axis (rad)
+ * @param integrated_zgyro RH rotation around Z axis (rad)
+ * @param temperature Temperature * 100 in centi-degrees Celsius
+ * @param quality Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
+ * @param time_delta_distance_us Time in microseconds since the distance was sampled.
+ * @param distance Distance to the center of the flow field in meters. Positive value (including zero): distance known. Negative value: Unknown distance.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_hil_optical_flow_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint64_t time_usec,uint8_t sensor_id,uint32_t integration_time_us,float integrated_x,float integrated_y,float integrated_xgyro,float integrated_ygyro,float integrated_zgyro,int16_t temperature,uint8_t quality,uint32_t time_delta_distance_us,float distance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_uint32_t(buf, 8, integration_time_us);
+	_mav_put_float(buf, 12, integrated_x);
+	_mav_put_float(buf, 16, integrated_y);
+	_mav_put_float(buf, 20, integrated_xgyro);
+	_mav_put_float(buf, 24, integrated_ygyro);
+	_mav_put_float(buf, 28, integrated_zgyro);
+	_mav_put_uint32_t(buf, 32, time_delta_distance_us);
+	_mav_put_float(buf, 36, distance);
+	_mav_put_int16_t(buf, 40, temperature);
+	_mav_put_uint8_t(buf, 42, sensor_id);
+	_mav_put_uint8_t(buf, 43, quality);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN);
+#else
+	mavlink_hil_optical_flow_t packet;
+	packet.time_usec = time_usec;
+	packet.integration_time_us = integration_time_us;
+	packet.integrated_x = integrated_x;
+	packet.integrated_y = integrated_y;
+	packet.integrated_xgyro = integrated_xgyro;
+	packet.integrated_ygyro = integrated_ygyro;
+	packet.integrated_zgyro = integrated_zgyro;
+	packet.time_delta_distance_us = time_delta_distance_us;
+	packet.distance = distance;
+	packet.temperature = temperature;
+	packet.sensor_id = sensor_id;
+	packet.quality = quality;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_HIL_OPTICAL_FLOW;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a hil_optical_flow struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param hil_optical_flow C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_hil_optical_flow_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_hil_optical_flow_t* hil_optical_flow)
+{
+	return mavlink_msg_hil_optical_flow_pack(system_id, component_id, msg, hil_optical_flow->time_usec, hil_optical_flow->sensor_id, hil_optical_flow->integration_time_us, hil_optical_flow->integrated_x, hil_optical_flow->integrated_y, hil_optical_flow->integrated_xgyro, hil_optical_flow->integrated_ygyro, hil_optical_flow->integrated_zgyro, hil_optical_flow->temperature, hil_optical_flow->quality, hil_optical_flow->time_delta_distance_us, hil_optical_flow->distance);
+}
+
+/**
+ * @brief Encode a hil_optical_flow struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param hil_optical_flow C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_hil_optical_flow_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_hil_optical_flow_t* hil_optical_flow)
+{
+	return mavlink_msg_hil_optical_flow_pack_chan(system_id, component_id, chan, msg, hil_optical_flow->time_usec, hil_optical_flow->sensor_id, hil_optical_flow->integration_time_us, hil_optical_flow->integrated_x, hil_optical_flow->integrated_y, hil_optical_flow->integrated_xgyro, hil_optical_flow->integrated_ygyro, hil_optical_flow->integrated_zgyro, hil_optical_flow->temperature, hil_optical_flow->quality, hil_optical_flow->time_delta_distance_us, hil_optical_flow->distance);
+}
+
+/**
+ * @brief Send a hil_optical_flow message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_usec Timestamp (microseconds, synced to UNIX time or since system boot)
+ * @param sensor_id Sensor ID
+ * @param integration_time_us Integration time in microseconds. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
+ * @param integrated_x Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
+ * @param integrated_y Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
+ * @param integrated_xgyro RH rotation around X axis (rad)
+ * @param integrated_ygyro RH rotation around Y axis (rad)
+ * @param integrated_zgyro RH rotation around Z axis (rad)
+ * @param temperature Temperature * 100 in centi-degrees Celsius
+ * @param quality Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
+ * @param time_delta_distance_us Time in microseconds since the distance was sampled.
+ * @param distance Distance to the center of the flow field in meters. Positive value (including zero): distance known. Negative value: Unknown distance.
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_hil_optical_flow_send(mavlink_channel_t chan, uint64_t time_usec, uint8_t sensor_id, uint32_t integration_time_us, float integrated_x, float integrated_y, float integrated_xgyro, float integrated_ygyro, float integrated_zgyro, int16_t temperature, uint8_t quality, uint32_t time_delta_distance_us, float distance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_uint32_t(buf, 8, integration_time_us);
+	_mav_put_float(buf, 12, integrated_x);
+	_mav_put_float(buf, 16, integrated_y);
+	_mav_put_float(buf, 20, integrated_xgyro);
+	_mav_put_float(buf, 24, integrated_ygyro);
+	_mav_put_float(buf, 28, integrated_zgyro);
+	_mav_put_uint32_t(buf, 32, time_delta_distance_us);
+	_mav_put_float(buf, 36, distance);
+	_mav_put_int16_t(buf, 40, temperature);
+	_mav_put_uint8_t(buf, 42, sensor_id);
+	_mav_put_uint8_t(buf, 43, quality);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW, buf, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW, buf, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN);
+#endif
+#else
+	mavlink_hil_optical_flow_t packet;
+	packet.time_usec = time_usec;
+	packet.integration_time_us = integration_time_us;
+	packet.integrated_x = integrated_x;
+	packet.integrated_y = integrated_y;
+	packet.integrated_xgyro = integrated_xgyro;
+	packet.integrated_ygyro = integrated_ygyro;
+	packet.integrated_zgyro = integrated_zgyro;
+	packet.time_delta_distance_us = time_delta_distance_us;
+	packet.distance = distance;
+	packet.temperature = temperature;
+	packet.sensor_id = sensor_id;
+	packet.quality = quality;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW, (const char *)&packet, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW, (const char *)&packet, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_hil_optical_flow_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t time_usec, uint8_t sensor_id, uint32_t integration_time_us, float integrated_x, float integrated_y, float integrated_xgyro, float integrated_ygyro, float integrated_zgyro, int16_t temperature, uint8_t quality, uint32_t time_delta_distance_us, float distance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_uint32_t(buf, 8, integration_time_us);
+	_mav_put_float(buf, 12, integrated_x);
+	_mav_put_float(buf, 16, integrated_y);
+	_mav_put_float(buf, 20, integrated_xgyro);
+	_mav_put_float(buf, 24, integrated_ygyro);
+	_mav_put_float(buf, 28, integrated_zgyro);
+	_mav_put_uint32_t(buf, 32, time_delta_distance_us);
+	_mav_put_float(buf, 36, distance);
+	_mav_put_int16_t(buf, 40, temperature);
+	_mav_put_uint8_t(buf, 42, sensor_id);
+	_mav_put_uint8_t(buf, 43, quality);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW, buf, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW, buf, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN);
+#endif
+#else
+	mavlink_hil_optical_flow_t *packet = (mavlink_hil_optical_flow_t *)msgbuf;
+	packet->time_usec = time_usec;
+	packet->integration_time_us = integration_time_us;
+	packet->integrated_x = integrated_x;
+	packet->integrated_y = integrated_y;
+	packet->integrated_xgyro = integrated_xgyro;
+	packet->integrated_ygyro = integrated_ygyro;
+	packet->integrated_zgyro = integrated_zgyro;
+	packet->time_delta_distance_us = time_delta_distance_us;
+	packet->distance = distance;
+	packet->temperature = temperature;
+	packet->sensor_id = sensor_id;
+	packet->quality = quality;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW, (const char *)packet, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW, (const char *)packet, MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE HIL_OPTICAL_FLOW UNPACKING
+
+
+/**
+ * @brief Get field time_usec from hil_optical_flow message
+ *
+ * @return Timestamp (microseconds, synced to UNIX time or since system boot)
+ */
+static inline uint64_t mavlink_msg_hil_optical_flow_get_time_usec(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint64_t(msg,  0);
+}
+
+/**
+ * @brief Get field sensor_id from hil_optical_flow message
+ *
+ * @return Sensor ID
+ */
+static inline uint8_t mavlink_msg_hil_optical_flow_get_sensor_id(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  42);
+}
+
+/**
+ * @brief Get field integration_time_us from hil_optical_flow message
+ *
+ * @return Integration time in microseconds. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
+ */
+static inline uint32_t mavlink_msg_hil_optical_flow_get_integration_time_us(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  8);
+}
+
+/**
+ * @brief Get field integrated_x from hil_optical_flow message
+ *
+ * @return Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
+ */
+static inline float mavlink_msg_hil_optical_flow_get_integrated_x(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  12);
+}
+
+/**
+ * @brief Get field integrated_y from hil_optical_flow message
+ *
+ * @return Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
+ */
+static inline float mavlink_msg_hil_optical_flow_get_integrated_y(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  16);
+}
+
+/**
+ * @brief Get field integrated_xgyro from hil_optical_flow message
+ *
+ * @return RH rotation around X axis (rad)
+ */
+static inline float mavlink_msg_hil_optical_flow_get_integrated_xgyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  20);
+}
+
+/**
+ * @brief Get field integrated_ygyro from hil_optical_flow message
+ *
+ * @return RH rotation around Y axis (rad)
+ */
+static inline float mavlink_msg_hil_optical_flow_get_integrated_ygyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  24);
+}
+
+/**
+ * @brief Get field integrated_zgyro from hil_optical_flow message
+ *
+ * @return RH rotation around Z axis (rad)
+ */
+static inline float mavlink_msg_hil_optical_flow_get_integrated_zgyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  28);
+}
+
+/**
+ * @brief Get field temperature from hil_optical_flow message
+ *
+ * @return Temperature * 100 in centi-degrees Celsius
+ */
+static inline int16_t mavlink_msg_hil_optical_flow_get_temperature(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  40);
+}
+
+/**
+ * @brief Get field quality from hil_optical_flow message
+ *
+ * @return Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
+ */
+static inline uint8_t mavlink_msg_hil_optical_flow_get_quality(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  43);
+}
+
+/**
+ * @brief Get field time_delta_distance_us from hil_optical_flow message
+ *
+ * @return Time in microseconds since the distance was sampled.
+ */
+static inline uint32_t mavlink_msg_hil_optical_flow_get_time_delta_distance_us(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  32);
+}
+
+/**
+ * @brief Get field distance from hil_optical_flow message
+ *
+ * @return Distance to the center of the flow field in meters. Positive value (including zero): distance known. Negative value: Unknown distance.
+ */
+static inline float mavlink_msg_hil_optical_flow_get_distance(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  36);
+}
+
+/**
+ * @brief Decode a hil_optical_flow message into a struct
+ *
+ * @param msg The message to decode
+ * @param hil_optical_flow C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_hil_optical_flow_decode(const mavlink_message_t* msg, mavlink_hil_optical_flow_t* hil_optical_flow)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	hil_optical_flow->time_usec = mavlink_msg_hil_optical_flow_get_time_usec(msg);
+	hil_optical_flow->integration_time_us = mavlink_msg_hil_optical_flow_get_integration_time_us(msg);
+	hil_optical_flow->integrated_x = mavlink_msg_hil_optical_flow_get_integrated_x(msg);
+	hil_optical_flow->integrated_y = mavlink_msg_hil_optical_flow_get_integrated_y(msg);
+	hil_optical_flow->integrated_xgyro = mavlink_msg_hil_optical_flow_get_integrated_xgyro(msg);
+	hil_optical_flow->integrated_ygyro = mavlink_msg_hil_optical_flow_get_integrated_ygyro(msg);
+	hil_optical_flow->integrated_zgyro = mavlink_msg_hil_optical_flow_get_integrated_zgyro(msg);
+	hil_optical_flow->time_delta_distance_us = mavlink_msg_hil_optical_flow_get_time_delta_distance_us(msg);
+	hil_optical_flow->distance = mavlink_msg_hil_optical_flow_get_distance(msg);
+	hil_optical_flow->temperature = mavlink_msg_hil_optical_flow_get_temperature(msg);
+	hil_optical_flow->sensor_id = mavlink_msg_hil_optical_flow_get_sensor_id(msg);
+	hil_optical_flow->quality = mavlink_msg_hil_optical_flow_get_quality(msg);
+#else
+	memcpy(hil_optical_flow, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_HIL_OPTICAL_FLOW_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_hil_rc_inputs_raw.h v1.0/common/mavlink_msg_hil_rc_inputs_raw.h
--- v1.0.old/common/mavlink_msg_hil_rc_inputs_raw.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_hil_rc_inputs_raw.h	2015-02-06 11:50:58.000000000 +0500
@@ -23,6 +23,9 @@ typedef struct __mavlink_hil_rc_inputs_r
 #define MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN 33
 #define MAVLINK_MSG_ID_92_LEN 33
 
+#define MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_CRC 54
+#define MAVLINK_MSG_ID_92_CRC 54
+
 
 
 #define MAVLINK_MESSAGE_INFO_HIL_RC_INPUTS_RAW { \
@@ -72,7 +75,7 @@ static inline uint16_t mavlink_msg_hil_r
 						       uint64_t time_usec, uint16_t chan1_raw, uint16_t chan2_raw, uint16_t chan3_raw, uint16_t chan4_raw, uint16_t chan5_raw, uint16_t chan6_raw, uint16_t chan7_raw, uint16_t chan8_raw, uint16_t chan9_raw, uint16_t chan10_raw, uint16_t chan11_raw, uint16_t chan12_raw, uint8_t rssi)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[33];
+	char buf[MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_uint16_t(buf, 8, chan1_raw);
 	_mav_put_uint16_t(buf, 10, chan2_raw);
@@ -88,7 +91,7 @@ static inline uint16_t mavlink_msg_hil_r
 	_mav_put_uint16_t(buf, 30, chan12_raw);
 	_mav_put_uint8_t(buf, 32, rssi);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 33);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN);
 #else
 	mavlink_hil_rc_inputs_raw_t packet;
 	packet.time_usec = time_usec;
@@ -106,18 +109,22 @@ static inline uint16_t mavlink_msg_hil_r
 	packet.chan12_raw = chan12_raw;
 	packet.rssi = rssi;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 33);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW;
-	return mavlink_finalize_message(msg, system_id, component_id, 33, 54);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN);
+#endif
 }
 
 /**
  * @brief Pack a hil_rc_inputs_raw message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
  * @param chan1_raw RC channel 1 value, in microseconds
@@ -140,7 +147,7 @@ static inline uint16_t mavlink_msg_hil_r
 						           uint64_t time_usec,uint16_t chan1_raw,uint16_t chan2_raw,uint16_t chan3_raw,uint16_t chan4_raw,uint16_t chan5_raw,uint16_t chan6_raw,uint16_t chan7_raw,uint16_t chan8_raw,uint16_t chan9_raw,uint16_t chan10_raw,uint16_t chan11_raw,uint16_t chan12_raw,uint8_t rssi)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[33];
+	char buf[MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_uint16_t(buf, 8, chan1_raw);
 	_mav_put_uint16_t(buf, 10, chan2_raw);
@@ -156,7 +163,7 @@ static inline uint16_t mavlink_msg_hil_r
 	_mav_put_uint16_t(buf, 30, chan12_raw);
 	_mav_put_uint8_t(buf, 32, rssi);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 33);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN);
 #else
 	mavlink_hil_rc_inputs_raw_t packet;
 	packet.time_usec = time_usec;
@@ -174,15 +181,19 @@ static inline uint16_t mavlink_msg_hil_r
 	packet.chan12_raw = chan12_raw;
 	packet.rssi = rssi;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 33);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 33, 54);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN);
+#endif
 }
 
 /**
- * @brief Encode a hil_rc_inputs_raw struct into a message
+ * @brief Encode a hil_rc_inputs_raw struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -195,6 +206,20 @@ static inline uint16_t mavlink_msg_hil_r
 }
 
 /**
+ * @brief Encode a hil_rc_inputs_raw struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param hil_rc_inputs_raw C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_hil_rc_inputs_raw_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_hil_rc_inputs_raw_t* hil_rc_inputs_raw)
+{
+	return mavlink_msg_hil_rc_inputs_raw_pack_chan(system_id, component_id, chan, msg, hil_rc_inputs_raw->time_usec, hil_rc_inputs_raw->chan1_raw, hil_rc_inputs_raw->chan2_raw, hil_rc_inputs_raw->chan3_raw, hil_rc_inputs_raw->chan4_raw, hil_rc_inputs_raw->chan5_raw, hil_rc_inputs_raw->chan6_raw, hil_rc_inputs_raw->chan7_raw, hil_rc_inputs_raw->chan8_raw, hil_rc_inputs_raw->chan9_raw, hil_rc_inputs_raw->chan10_raw, hil_rc_inputs_raw->chan11_raw, hil_rc_inputs_raw->chan12_raw, hil_rc_inputs_raw->rssi);
+}
+
+/**
  * @brief Send a hil_rc_inputs_raw message
  * @param chan MAVLink channel to send the message
  *
@@ -218,7 +243,7 @@ static inline uint16_t mavlink_msg_hil_r
 static inline void mavlink_msg_hil_rc_inputs_raw_send(mavlink_channel_t chan, uint64_t time_usec, uint16_t chan1_raw, uint16_t chan2_raw, uint16_t chan3_raw, uint16_t chan4_raw, uint16_t chan5_raw, uint16_t chan6_raw, uint16_t chan7_raw, uint16_t chan8_raw, uint16_t chan9_raw, uint16_t chan10_raw, uint16_t chan11_raw, uint16_t chan12_raw, uint8_t rssi)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[33];
+	char buf[MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_uint16_t(buf, 8, chan1_raw);
 	_mav_put_uint16_t(buf, 10, chan2_raw);
@@ -234,7 +259,11 @@ static inline void mavlink_msg_hil_rc_in
 	_mav_put_uint16_t(buf, 30, chan12_raw);
 	_mav_put_uint8_t(buf, 32, rssi);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW, buf, 33, 54);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW, buf, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW, buf, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN);
+#endif
 #else
 	mavlink_hil_rc_inputs_raw_t packet;
 	packet.time_usec = time_usec;
@@ -252,10 +281,72 @@ static inline void mavlink_msg_hil_rc_in
 	packet.chan12_raw = chan12_raw;
 	packet.rssi = rssi;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW, (const char *)&packet, 33, 54);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW, (const char *)&packet, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW, (const char *)&packet, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_hil_rc_inputs_raw_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t time_usec, uint16_t chan1_raw, uint16_t chan2_raw, uint16_t chan3_raw, uint16_t chan4_raw, uint16_t chan5_raw, uint16_t chan6_raw, uint16_t chan7_raw, uint16_t chan8_raw, uint16_t chan9_raw, uint16_t chan10_raw, uint16_t chan11_raw, uint16_t chan12_raw, uint8_t rssi)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_uint16_t(buf, 8, chan1_raw);
+	_mav_put_uint16_t(buf, 10, chan2_raw);
+	_mav_put_uint16_t(buf, 12, chan3_raw);
+	_mav_put_uint16_t(buf, 14, chan4_raw);
+	_mav_put_uint16_t(buf, 16, chan5_raw);
+	_mav_put_uint16_t(buf, 18, chan6_raw);
+	_mav_put_uint16_t(buf, 20, chan7_raw);
+	_mav_put_uint16_t(buf, 22, chan8_raw);
+	_mav_put_uint16_t(buf, 24, chan9_raw);
+	_mav_put_uint16_t(buf, 26, chan10_raw);
+	_mav_put_uint16_t(buf, 28, chan11_raw);
+	_mav_put_uint16_t(buf, 30, chan12_raw);
+	_mav_put_uint8_t(buf, 32, rssi);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW, buf, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW, buf, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN);
+#endif
+#else
+	mavlink_hil_rc_inputs_raw_t *packet = (mavlink_hil_rc_inputs_raw_t *)msgbuf;
+	packet->time_usec = time_usec;
+	packet->chan1_raw = chan1_raw;
+	packet->chan2_raw = chan2_raw;
+	packet->chan3_raw = chan3_raw;
+	packet->chan4_raw = chan4_raw;
+	packet->chan5_raw = chan5_raw;
+	packet->chan6_raw = chan6_raw;
+	packet->chan7_raw = chan7_raw;
+	packet->chan8_raw = chan8_raw;
+	packet->chan9_raw = chan9_raw;
+	packet->chan10_raw = chan10_raw;
+	packet->chan11_raw = chan11_raw;
+	packet->chan12_raw = chan12_raw;
+	packet->rssi = rssi;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW, (const char *)packet, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW, (const char *)packet, MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE HIL_RC_INPUTS_RAW UNPACKING
@@ -425,6 +516,6 @@ static inline void mavlink_msg_hil_rc_in
 	hil_rc_inputs_raw->chan12_raw = mavlink_msg_hil_rc_inputs_raw_get_chan12_raw(msg);
 	hil_rc_inputs_raw->rssi = mavlink_msg_hil_rc_inputs_raw_get_rssi(msg);
 #else
-	memcpy(hil_rc_inputs_raw, _MAV_PAYLOAD(msg), 33);
+	memcpy(hil_rc_inputs_raw, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_hil_sensor.h v1.0/common/mavlink_msg_hil_sensor.h
--- v1.0.old/common/mavlink_msg_hil_sensor.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_hil_sensor.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,545 @@
+// MESSAGE HIL_SENSOR PACKING
+
+#define MAVLINK_MSG_ID_HIL_SENSOR 107
+
+typedef struct __mavlink_hil_sensor_t
+{
+ uint64_t time_usec; ///< Timestamp (microseconds, synced to UNIX time or since system boot)
+ float xacc; ///< X acceleration (m/s^2)
+ float yacc; ///< Y acceleration (m/s^2)
+ float zacc; ///< Z acceleration (m/s^2)
+ float xgyro; ///< Angular speed around X axis in body frame (rad / sec)
+ float ygyro; ///< Angular speed around Y axis in body frame (rad / sec)
+ float zgyro; ///< Angular speed around Z axis in body frame (rad / sec)
+ float xmag; ///< X Magnetic field (Gauss)
+ float ymag; ///< Y Magnetic field (Gauss)
+ float zmag; ///< Z Magnetic field (Gauss)
+ float abs_pressure; ///< Absolute pressure in millibar
+ float diff_pressure; ///< Differential pressure (airspeed) in millibar
+ float pressure_alt; ///< Altitude calculated from pressure
+ float temperature; ///< Temperature in degrees celsius
+ uint32_t fields_updated; ///< Bitmask for fields that have updated since last message, bit 0 = xacc, bit 12: temperature
+} mavlink_hil_sensor_t;
+
+#define MAVLINK_MSG_ID_HIL_SENSOR_LEN 64
+#define MAVLINK_MSG_ID_107_LEN 64
+
+#define MAVLINK_MSG_ID_HIL_SENSOR_CRC 108
+#define MAVLINK_MSG_ID_107_CRC 108
+
+
+
+#define MAVLINK_MESSAGE_INFO_HIL_SENSOR { \
+	"HIL_SENSOR", \
+	15, \
+	{  { "time_usec", NULL, MAVLINK_TYPE_UINT64_T, 0, 0, offsetof(mavlink_hil_sensor_t, time_usec) }, \
+         { "xacc", NULL, MAVLINK_TYPE_FLOAT, 0, 8, offsetof(mavlink_hil_sensor_t, xacc) }, \
+         { "yacc", NULL, MAVLINK_TYPE_FLOAT, 0, 12, offsetof(mavlink_hil_sensor_t, yacc) }, \
+         { "zacc", NULL, MAVLINK_TYPE_FLOAT, 0, 16, offsetof(mavlink_hil_sensor_t, zacc) }, \
+         { "xgyro", NULL, MAVLINK_TYPE_FLOAT, 0, 20, offsetof(mavlink_hil_sensor_t, xgyro) }, \
+         { "ygyro", NULL, MAVLINK_TYPE_FLOAT, 0, 24, offsetof(mavlink_hil_sensor_t, ygyro) }, \
+         { "zgyro", NULL, MAVLINK_TYPE_FLOAT, 0, 28, offsetof(mavlink_hil_sensor_t, zgyro) }, \
+         { "xmag", NULL, MAVLINK_TYPE_FLOAT, 0, 32, offsetof(mavlink_hil_sensor_t, xmag) }, \
+         { "ymag", NULL, MAVLINK_TYPE_FLOAT, 0, 36, offsetof(mavlink_hil_sensor_t, ymag) }, \
+         { "zmag", NULL, MAVLINK_TYPE_FLOAT, 0, 40, offsetof(mavlink_hil_sensor_t, zmag) }, \
+         { "abs_pressure", NULL, MAVLINK_TYPE_FLOAT, 0, 44, offsetof(mavlink_hil_sensor_t, abs_pressure) }, \
+         { "diff_pressure", NULL, MAVLINK_TYPE_FLOAT, 0, 48, offsetof(mavlink_hil_sensor_t, diff_pressure) }, \
+         { "pressure_alt", NULL, MAVLINK_TYPE_FLOAT, 0, 52, offsetof(mavlink_hil_sensor_t, pressure_alt) }, \
+         { "temperature", NULL, MAVLINK_TYPE_FLOAT, 0, 56, offsetof(mavlink_hil_sensor_t, temperature) }, \
+         { "fields_updated", NULL, MAVLINK_TYPE_UINT32_T, 0, 60, offsetof(mavlink_hil_sensor_t, fields_updated) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a hil_sensor message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_usec Timestamp (microseconds, synced to UNIX time or since system boot)
+ * @param xacc X acceleration (m/s^2)
+ * @param yacc Y acceleration (m/s^2)
+ * @param zacc Z acceleration (m/s^2)
+ * @param xgyro Angular speed around X axis in body frame (rad / sec)
+ * @param ygyro Angular speed around Y axis in body frame (rad / sec)
+ * @param zgyro Angular speed around Z axis in body frame (rad / sec)
+ * @param xmag X Magnetic field (Gauss)
+ * @param ymag Y Magnetic field (Gauss)
+ * @param zmag Z Magnetic field (Gauss)
+ * @param abs_pressure Absolute pressure in millibar
+ * @param diff_pressure Differential pressure (airspeed) in millibar
+ * @param pressure_alt Altitude calculated from pressure
+ * @param temperature Temperature in degrees celsius
+ * @param fields_updated Bitmask for fields that have updated since last message, bit 0 = xacc, bit 12: temperature
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_hil_sensor_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint64_t time_usec, float xacc, float yacc, float zacc, float xgyro, float ygyro, float zgyro, float xmag, float ymag, float zmag, float abs_pressure, float diff_pressure, float pressure_alt, float temperature, uint32_t fields_updated)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_HIL_SENSOR_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_float(buf, 8, xacc);
+	_mav_put_float(buf, 12, yacc);
+	_mav_put_float(buf, 16, zacc);
+	_mav_put_float(buf, 20, xgyro);
+	_mav_put_float(buf, 24, ygyro);
+	_mav_put_float(buf, 28, zgyro);
+	_mav_put_float(buf, 32, xmag);
+	_mav_put_float(buf, 36, ymag);
+	_mav_put_float(buf, 40, zmag);
+	_mav_put_float(buf, 44, abs_pressure);
+	_mav_put_float(buf, 48, diff_pressure);
+	_mav_put_float(buf, 52, pressure_alt);
+	_mav_put_float(buf, 56, temperature);
+	_mav_put_uint32_t(buf, 60, fields_updated);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HIL_SENSOR_LEN);
+#else
+	mavlink_hil_sensor_t packet;
+	packet.time_usec = time_usec;
+	packet.xacc = xacc;
+	packet.yacc = yacc;
+	packet.zacc = zacc;
+	packet.xgyro = xgyro;
+	packet.ygyro = ygyro;
+	packet.zgyro = zgyro;
+	packet.xmag = xmag;
+	packet.ymag = ymag;
+	packet.zmag = zmag;
+	packet.abs_pressure = abs_pressure;
+	packet.diff_pressure = diff_pressure;
+	packet.pressure_alt = pressure_alt;
+	packet.temperature = temperature;
+	packet.fields_updated = fields_updated;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HIL_SENSOR_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_HIL_SENSOR;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HIL_SENSOR_LEN, MAVLINK_MSG_ID_HIL_SENSOR_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HIL_SENSOR_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a hil_sensor message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_usec Timestamp (microseconds, synced to UNIX time or since system boot)
+ * @param xacc X acceleration (m/s^2)
+ * @param yacc Y acceleration (m/s^2)
+ * @param zacc Z acceleration (m/s^2)
+ * @param xgyro Angular speed around X axis in body frame (rad / sec)
+ * @param ygyro Angular speed around Y axis in body frame (rad / sec)
+ * @param zgyro Angular speed around Z axis in body frame (rad / sec)
+ * @param xmag X Magnetic field (Gauss)
+ * @param ymag Y Magnetic field (Gauss)
+ * @param zmag Z Magnetic field (Gauss)
+ * @param abs_pressure Absolute pressure in millibar
+ * @param diff_pressure Differential pressure (airspeed) in millibar
+ * @param pressure_alt Altitude calculated from pressure
+ * @param temperature Temperature in degrees celsius
+ * @param fields_updated Bitmask for fields that have updated since last message, bit 0 = xacc, bit 12: temperature
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_hil_sensor_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint64_t time_usec,float xacc,float yacc,float zacc,float xgyro,float ygyro,float zgyro,float xmag,float ymag,float zmag,float abs_pressure,float diff_pressure,float pressure_alt,float temperature,uint32_t fields_updated)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_HIL_SENSOR_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_float(buf, 8, xacc);
+	_mav_put_float(buf, 12, yacc);
+	_mav_put_float(buf, 16, zacc);
+	_mav_put_float(buf, 20, xgyro);
+	_mav_put_float(buf, 24, ygyro);
+	_mav_put_float(buf, 28, zgyro);
+	_mav_put_float(buf, 32, xmag);
+	_mav_put_float(buf, 36, ymag);
+	_mav_put_float(buf, 40, zmag);
+	_mav_put_float(buf, 44, abs_pressure);
+	_mav_put_float(buf, 48, diff_pressure);
+	_mav_put_float(buf, 52, pressure_alt);
+	_mav_put_float(buf, 56, temperature);
+	_mav_put_uint32_t(buf, 60, fields_updated);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HIL_SENSOR_LEN);
+#else
+	mavlink_hil_sensor_t packet;
+	packet.time_usec = time_usec;
+	packet.xacc = xacc;
+	packet.yacc = yacc;
+	packet.zacc = zacc;
+	packet.xgyro = xgyro;
+	packet.ygyro = ygyro;
+	packet.zgyro = zgyro;
+	packet.xmag = xmag;
+	packet.ymag = ymag;
+	packet.zmag = zmag;
+	packet.abs_pressure = abs_pressure;
+	packet.diff_pressure = diff_pressure;
+	packet.pressure_alt = pressure_alt;
+	packet.temperature = temperature;
+	packet.fields_updated = fields_updated;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HIL_SENSOR_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_HIL_SENSOR;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HIL_SENSOR_LEN, MAVLINK_MSG_ID_HIL_SENSOR_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HIL_SENSOR_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a hil_sensor struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param hil_sensor C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_hil_sensor_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_hil_sensor_t* hil_sensor)
+{
+	return mavlink_msg_hil_sensor_pack(system_id, component_id, msg, hil_sensor->time_usec, hil_sensor->xacc, hil_sensor->yacc, hil_sensor->zacc, hil_sensor->xgyro, hil_sensor->ygyro, hil_sensor->zgyro, hil_sensor->xmag, hil_sensor->ymag, hil_sensor->zmag, hil_sensor->abs_pressure, hil_sensor->diff_pressure, hil_sensor->pressure_alt, hil_sensor->temperature, hil_sensor->fields_updated);
+}
+
+/**
+ * @brief Encode a hil_sensor struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param hil_sensor C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_hil_sensor_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_hil_sensor_t* hil_sensor)
+{
+	return mavlink_msg_hil_sensor_pack_chan(system_id, component_id, chan, msg, hil_sensor->time_usec, hil_sensor->xacc, hil_sensor->yacc, hil_sensor->zacc, hil_sensor->xgyro, hil_sensor->ygyro, hil_sensor->zgyro, hil_sensor->xmag, hil_sensor->ymag, hil_sensor->zmag, hil_sensor->abs_pressure, hil_sensor->diff_pressure, hil_sensor->pressure_alt, hil_sensor->temperature, hil_sensor->fields_updated);
+}
+
+/**
+ * @brief Send a hil_sensor message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_usec Timestamp (microseconds, synced to UNIX time or since system boot)
+ * @param xacc X acceleration (m/s^2)
+ * @param yacc Y acceleration (m/s^2)
+ * @param zacc Z acceleration (m/s^2)
+ * @param xgyro Angular speed around X axis in body frame (rad / sec)
+ * @param ygyro Angular speed around Y axis in body frame (rad / sec)
+ * @param zgyro Angular speed around Z axis in body frame (rad / sec)
+ * @param xmag X Magnetic field (Gauss)
+ * @param ymag Y Magnetic field (Gauss)
+ * @param zmag Z Magnetic field (Gauss)
+ * @param abs_pressure Absolute pressure in millibar
+ * @param diff_pressure Differential pressure (airspeed) in millibar
+ * @param pressure_alt Altitude calculated from pressure
+ * @param temperature Temperature in degrees celsius
+ * @param fields_updated Bitmask for fields that have updated since last message, bit 0 = xacc, bit 12: temperature
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_hil_sensor_send(mavlink_channel_t chan, uint64_t time_usec, float xacc, float yacc, float zacc, float xgyro, float ygyro, float zgyro, float xmag, float ymag, float zmag, float abs_pressure, float diff_pressure, float pressure_alt, float temperature, uint32_t fields_updated)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_HIL_SENSOR_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_float(buf, 8, xacc);
+	_mav_put_float(buf, 12, yacc);
+	_mav_put_float(buf, 16, zacc);
+	_mav_put_float(buf, 20, xgyro);
+	_mav_put_float(buf, 24, ygyro);
+	_mav_put_float(buf, 28, zgyro);
+	_mav_put_float(buf, 32, xmag);
+	_mav_put_float(buf, 36, ymag);
+	_mav_put_float(buf, 40, zmag);
+	_mav_put_float(buf, 44, abs_pressure);
+	_mav_put_float(buf, 48, diff_pressure);
+	_mav_put_float(buf, 52, pressure_alt);
+	_mav_put_float(buf, 56, temperature);
+	_mav_put_uint32_t(buf, 60, fields_updated);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_SENSOR, buf, MAVLINK_MSG_ID_HIL_SENSOR_LEN, MAVLINK_MSG_ID_HIL_SENSOR_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_SENSOR, buf, MAVLINK_MSG_ID_HIL_SENSOR_LEN);
+#endif
+#else
+	mavlink_hil_sensor_t packet;
+	packet.time_usec = time_usec;
+	packet.xacc = xacc;
+	packet.yacc = yacc;
+	packet.zacc = zacc;
+	packet.xgyro = xgyro;
+	packet.ygyro = ygyro;
+	packet.zgyro = zgyro;
+	packet.xmag = xmag;
+	packet.ymag = ymag;
+	packet.zmag = zmag;
+	packet.abs_pressure = abs_pressure;
+	packet.diff_pressure = diff_pressure;
+	packet.pressure_alt = pressure_alt;
+	packet.temperature = temperature;
+	packet.fields_updated = fields_updated;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_SENSOR, (const char *)&packet, MAVLINK_MSG_ID_HIL_SENSOR_LEN, MAVLINK_MSG_ID_HIL_SENSOR_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_SENSOR, (const char *)&packet, MAVLINK_MSG_ID_HIL_SENSOR_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_HIL_SENSOR_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_hil_sensor_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t time_usec, float xacc, float yacc, float zacc, float xgyro, float ygyro, float zgyro, float xmag, float ymag, float zmag, float abs_pressure, float diff_pressure, float pressure_alt, float temperature, uint32_t fields_updated)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_float(buf, 8, xacc);
+	_mav_put_float(buf, 12, yacc);
+	_mav_put_float(buf, 16, zacc);
+	_mav_put_float(buf, 20, xgyro);
+	_mav_put_float(buf, 24, ygyro);
+	_mav_put_float(buf, 28, zgyro);
+	_mav_put_float(buf, 32, xmag);
+	_mav_put_float(buf, 36, ymag);
+	_mav_put_float(buf, 40, zmag);
+	_mav_put_float(buf, 44, abs_pressure);
+	_mav_put_float(buf, 48, diff_pressure);
+	_mav_put_float(buf, 52, pressure_alt);
+	_mav_put_float(buf, 56, temperature);
+	_mav_put_uint32_t(buf, 60, fields_updated);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_SENSOR, buf, MAVLINK_MSG_ID_HIL_SENSOR_LEN, MAVLINK_MSG_ID_HIL_SENSOR_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_SENSOR, buf, MAVLINK_MSG_ID_HIL_SENSOR_LEN);
+#endif
+#else
+	mavlink_hil_sensor_t *packet = (mavlink_hil_sensor_t *)msgbuf;
+	packet->time_usec = time_usec;
+	packet->xacc = xacc;
+	packet->yacc = yacc;
+	packet->zacc = zacc;
+	packet->xgyro = xgyro;
+	packet->ygyro = ygyro;
+	packet->zgyro = zgyro;
+	packet->xmag = xmag;
+	packet->ymag = ymag;
+	packet->zmag = zmag;
+	packet->abs_pressure = abs_pressure;
+	packet->diff_pressure = diff_pressure;
+	packet->pressure_alt = pressure_alt;
+	packet->temperature = temperature;
+	packet->fields_updated = fields_updated;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_SENSOR, (const char *)packet, MAVLINK_MSG_ID_HIL_SENSOR_LEN, MAVLINK_MSG_ID_HIL_SENSOR_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_SENSOR, (const char *)packet, MAVLINK_MSG_ID_HIL_SENSOR_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE HIL_SENSOR UNPACKING
+
+
+/**
+ * @brief Get field time_usec from hil_sensor message
+ *
+ * @return Timestamp (microseconds, synced to UNIX time or since system boot)
+ */
+static inline uint64_t mavlink_msg_hil_sensor_get_time_usec(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint64_t(msg,  0);
+}
+
+/**
+ * @brief Get field xacc from hil_sensor message
+ *
+ * @return X acceleration (m/s^2)
+ */
+static inline float mavlink_msg_hil_sensor_get_xacc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  8);
+}
+
+/**
+ * @brief Get field yacc from hil_sensor message
+ *
+ * @return Y acceleration (m/s^2)
+ */
+static inline float mavlink_msg_hil_sensor_get_yacc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  12);
+}
+
+/**
+ * @brief Get field zacc from hil_sensor message
+ *
+ * @return Z acceleration (m/s^2)
+ */
+static inline float mavlink_msg_hil_sensor_get_zacc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  16);
+}
+
+/**
+ * @brief Get field xgyro from hil_sensor message
+ *
+ * @return Angular speed around X axis in body frame (rad / sec)
+ */
+static inline float mavlink_msg_hil_sensor_get_xgyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  20);
+}
+
+/**
+ * @brief Get field ygyro from hil_sensor message
+ *
+ * @return Angular speed around Y axis in body frame (rad / sec)
+ */
+static inline float mavlink_msg_hil_sensor_get_ygyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  24);
+}
+
+/**
+ * @brief Get field zgyro from hil_sensor message
+ *
+ * @return Angular speed around Z axis in body frame (rad / sec)
+ */
+static inline float mavlink_msg_hil_sensor_get_zgyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  28);
+}
+
+/**
+ * @brief Get field xmag from hil_sensor message
+ *
+ * @return X Magnetic field (Gauss)
+ */
+static inline float mavlink_msg_hil_sensor_get_xmag(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  32);
+}
+
+/**
+ * @brief Get field ymag from hil_sensor message
+ *
+ * @return Y Magnetic field (Gauss)
+ */
+static inline float mavlink_msg_hil_sensor_get_ymag(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  36);
+}
+
+/**
+ * @brief Get field zmag from hil_sensor message
+ *
+ * @return Z Magnetic field (Gauss)
+ */
+static inline float mavlink_msg_hil_sensor_get_zmag(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  40);
+}
+
+/**
+ * @brief Get field abs_pressure from hil_sensor message
+ *
+ * @return Absolute pressure in millibar
+ */
+static inline float mavlink_msg_hil_sensor_get_abs_pressure(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  44);
+}
+
+/**
+ * @brief Get field diff_pressure from hil_sensor message
+ *
+ * @return Differential pressure (airspeed) in millibar
+ */
+static inline float mavlink_msg_hil_sensor_get_diff_pressure(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  48);
+}
+
+/**
+ * @brief Get field pressure_alt from hil_sensor message
+ *
+ * @return Altitude calculated from pressure
+ */
+static inline float mavlink_msg_hil_sensor_get_pressure_alt(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  52);
+}
+
+/**
+ * @brief Get field temperature from hil_sensor message
+ *
+ * @return Temperature in degrees celsius
+ */
+static inline float mavlink_msg_hil_sensor_get_temperature(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  56);
+}
+
+/**
+ * @brief Get field fields_updated from hil_sensor message
+ *
+ * @return Bitmask for fields that have updated since last message, bit 0 = xacc, bit 12: temperature
+ */
+static inline uint32_t mavlink_msg_hil_sensor_get_fields_updated(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  60);
+}
+
+/**
+ * @brief Decode a hil_sensor message into a struct
+ *
+ * @param msg The message to decode
+ * @param hil_sensor C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_hil_sensor_decode(const mavlink_message_t* msg, mavlink_hil_sensor_t* hil_sensor)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	hil_sensor->time_usec = mavlink_msg_hil_sensor_get_time_usec(msg);
+	hil_sensor->xacc = mavlink_msg_hil_sensor_get_xacc(msg);
+	hil_sensor->yacc = mavlink_msg_hil_sensor_get_yacc(msg);
+	hil_sensor->zacc = mavlink_msg_hil_sensor_get_zacc(msg);
+	hil_sensor->xgyro = mavlink_msg_hil_sensor_get_xgyro(msg);
+	hil_sensor->ygyro = mavlink_msg_hil_sensor_get_ygyro(msg);
+	hil_sensor->zgyro = mavlink_msg_hil_sensor_get_zgyro(msg);
+	hil_sensor->xmag = mavlink_msg_hil_sensor_get_xmag(msg);
+	hil_sensor->ymag = mavlink_msg_hil_sensor_get_ymag(msg);
+	hil_sensor->zmag = mavlink_msg_hil_sensor_get_zmag(msg);
+	hil_sensor->abs_pressure = mavlink_msg_hil_sensor_get_abs_pressure(msg);
+	hil_sensor->diff_pressure = mavlink_msg_hil_sensor_get_diff_pressure(msg);
+	hil_sensor->pressure_alt = mavlink_msg_hil_sensor_get_pressure_alt(msg);
+	hil_sensor->temperature = mavlink_msg_hil_sensor_get_temperature(msg);
+	hil_sensor->fields_updated = mavlink_msg_hil_sensor_get_fields_updated(msg);
+#else
+	memcpy(hil_sensor, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_HIL_SENSOR_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_hil_state.h v1.0/common/mavlink_msg_hil_state.h
--- v1.0.old/common/mavlink_msg_hil_state.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_hil_state.h	2015-02-06 11:50:58.000000000 +0500
@@ -8,9 +8,9 @@ typedef struct __mavlink_hil_state_t
  float roll; ///< Roll angle (rad)
  float pitch; ///< Pitch angle (rad)
  float yaw; ///< Yaw angle (rad)
- float rollspeed; ///< Roll angular speed (rad/s)
- float pitchspeed; ///< Pitch angular speed (rad/s)
- float yawspeed; ///< Yaw angular speed (rad/s)
+ float rollspeed; ///< Body frame roll / phi angular speed (rad/s)
+ float pitchspeed; ///< Body frame pitch / theta angular speed (rad/s)
+ float yawspeed; ///< Body frame yaw / psi angular speed (rad/s)
  int32_t lat; ///< Latitude, expressed as * 1E7
  int32_t lon; ///< Longitude, expressed as * 1E7
  int32_t alt; ///< Altitude in meters, expressed as * 1000 (millimeters)
@@ -25,6 +25,9 @@ typedef struct __mavlink_hil_state_t
 #define MAVLINK_MSG_ID_HIL_STATE_LEN 56
 #define MAVLINK_MSG_ID_90_LEN 56
 
+#define MAVLINK_MSG_ID_HIL_STATE_CRC 183
+#define MAVLINK_MSG_ID_90_CRC 183
+
 
 
 #define MAVLINK_MESSAGE_INFO_HIL_STATE { \
@@ -60,9 +63,9 @@ typedef struct __mavlink_hil_state_t
  * @param roll Roll angle (rad)
  * @param pitch Pitch angle (rad)
  * @param yaw Yaw angle (rad)
- * @param rollspeed Roll angular speed (rad/s)
- * @param pitchspeed Pitch angular speed (rad/s)
- * @param yawspeed Yaw angular speed (rad/s)
+ * @param rollspeed Body frame roll / phi angular speed (rad/s)
+ * @param pitchspeed Body frame pitch / theta angular speed (rad/s)
+ * @param yawspeed Body frame yaw / psi angular speed (rad/s)
  * @param lat Latitude, expressed as * 1E7
  * @param lon Longitude, expressed as * 1E7
  * @param alt Altitude in meters, expressed as * 1000 (millimeters)
@@ -78,7 +81,7 @@ static inline uint16_t mavlink_msg_hil_s
 						       uint64_t time_usec, float roll, float pitch, float yaw, float rollspeed, float pitchspeed, float yawspeed, int32_t lat, int32_t lon, int32_t alt, int16_t vx, int16_t vy, int16_t vz, int16_t xacc, int16_t yacc, int16_t zacc)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[56];
+	char buf[MAVLINK_MSG_ID_HIL_STATE_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_float(buf, 8, roll);
 	_mav_put_float(buf, 12, pitch);
@@ -96,7 +99,7 @@ static inline uint16_t mavlink_msg_hil_s
 	_mav_put_int16_t(buf, 52, yacc);
 	_mav_put_int16_t(buf, 54, zacc);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 56);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HIL_STATE_LEN);
 #else
 	mavlink_hil_state_t packet;
 	packet.time_usec = time_usec;
@@ -116,26 +119,30 @@ static inline uint16_t mavlink_msg_hil_s
 	packet.yacc = yacc;
 	packet.zacc = zacc;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 56);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HIL_STATE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_HIL_STATE;
-	return mavlink_finalize_message(msg, system_id, component_id, 56, 183);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HIL_STATE_LEN, MAVLINK_MSG_ID_HIL_STATE_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HIL_STATE_LEN);
+#endif
 }
 
 /**
  * @brief Pack a hil_state message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
  * @param roll Roll angle (rad)
  * @param pitch Pitch angle (rad)
  * @param yaw Yaw angle (rad)
- * @param rollspeed Roll angular speed (rad/s)
- * @param pitchspeed Pitch angular speed (rad/s)
- * @param yawspeed Yaw angular speed (rad/s)
+ * @param rollspeed Body frame roll / phi angular speed (rad/s)
+ * @param pitchspeed Body frame pitch / theta angular speed (rad/s)
+ * @param yawspeed Body frame yaw / psi angular speed (rad/s)
  * @param lat Latitude, expressed as * 1E7
  * @param lon Longitude, expressed as * 1E7
  * @param alt Altitude in meters, expressed as * 1000 (millimeters)
@@ -152,7 +159,7 @@ static inline uint16_t mavlink_msg_hil_s
 						           uint64_t time_usec,float roll,float pitch,float yaw,float rollspeed,float pitchspeed,float yawspeed,int32_t lat,int32_t lon,int32_t alt,int16_t vx,int16_t vy,int16_t vz,int16_t xacc,int16_t yacc,int16_t zacc)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[56];
+	char buf[MAVLINK_MSG_ID_HIL_STATE_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_float(buf, 8, roll);
 	_mav_put_float(buf, 12, pitch);
@@ -170,7 +177,7 @@ static inline uint16_t mavlink_msg_hil_s
 	_mav_put_int16_t(buf, 52, yacc);
 	_mav_put_int16_t(buf, 54, zacc);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 56);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HIL_STATE_LEN);
 #else
 	mavlink_hil_state_t packet;
 	packet.time_usec = time_usec;
@@ -190,15 +197,19 @@ static inline uint16_t mavlink_msg_hil_s
 	packet.yacc = yacc;
 	packet.zacc = zacc;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 56);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HIL_STATE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_HIL_STATE;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 56, 183);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HIL_STATE_LEN, MAVLINK_MSG_ID_HIL_STATE_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HIL_STATE_LEN);
+#endif
 }
 
 /**
- * @brief Encode a hil_state struct into a message
+ * @brief Encode a hil_state struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -211,6 +222,20 @@ static inline uint16_t mavlink_msg_hil_s
 }
 
 /**
+ * @brief Encode a hil_state struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param hil_state C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_hil_state_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_hil_state_t* hil_state)
+{
+	return mavlink_msg_hil_state_pack_chan(system_id, component_id, chan, msg, hil_state->time_usec, hil_state->roll, hil_state->pitch, hil_state->yaw, hil_state->rollspeed, hil_state->pitchspeed, hil_state->yawspeed, hil_state->lat, hil_state->lon, hil_state->alt, hil_state->vx, hil_state->vy, hil_state->vz, hil_state->xacc, hil_state->yacc, hil_state->zacc);
+}
+
+/**
  * @brief Send a hil_state message
  * @param chan MAVLink channel to send the message
  *
@@ -218,9 +243,9 @@ static inline uint16_t mavlink_msg_hil_s
  * @param roll Roll angle (rad)
  * @param pitch Pitch angle (rad)
  * @param yaw Yaw angle (rad)
- * @param rollspeed Roll angular speed (rad/s)
- * @param pitchspeed Pitch angular speed (rad/s)
- * @param yawspeed Yaw angular speed (rad/s)
+ * @param rollspeed Body frame roll / phi angular speed (rad/s)
+ * @param pitchspeed Body frame pitch / theta angular speed (rad/s)
+ * @param yawspeed Body frame yaw / psi angular speed (rad/s)
  * @param lat Latitude, expressed as * 1E7
  * @param lon Longitude, expressed as * 1E7
  * @param alt Altitude in meters, expressed as * 1000 (millimeters)
@@ -236,7 +261,7 @@ static inline uint16_t mavlink_msg_hil_s
 static inline void mavlink_msg_hil_state_send(mavlink_channel_t chan, uint64_t time_usec, float roll, float pitch, float yaw, float rollspeed, float pitchspeed, float yawspeed, int32_t lat, int32_t lon, int32_t alt, int16_t vx, int16_t vy, int16_t vz, int16_t xacc, int16_t yacc, int16_t zacc)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[56];
+	char buf[MAVLINK_MSG_ID_HIL_STATE_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_float(buf, 8, roll);
 	_mav_put_float(buf, 12, pitch);
@@ -254,7 +279,11 @@ static inline void mavlink_msg_hil_state
 	_mav_put_int16_t(buf, 52, yacc);
 	_mav_put_int16_t(buf, 54, zacc);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE, buf, 56, 183);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE, buf, MAVLINK_MSG_ID_HIL_STATE_LEN, MAVLINK_MSG_ID_HIL_STATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE, buf, MAVLINK_MSG_ID_HIL_STATE_LEN);
+#endif
 #else
 	mavlink_hil_state_t packet;
 	packet.time_usec = time_usec;
@@ -274,10 +303,76 @@ static inline void mavlink_msg_hil_state
 	packet.yacc = yacc;
 	packet.zacc = zacc;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE, (const char *)&packet, 56, 183);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE, (const char *)&packet, MAVLINK_MSG_ID_HIL_STATE_LEN, MAVLINK_MSG_ID_HIL_STATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE, (const char *)&packet, MAVLINK_MSG_ID_HIL_STATE_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_HIL_STATE_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_hil_state_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t time_usec, float roll, float pitch, float yaw, float rollspeed, float pitchspeed, float yawspeed, int32_t lat, int32_t lon, int32_t alt, int16_t vx, int16_t vy, int16_t vz, int16_t xacc, int16_t yacc, int16_t zacc)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_float(buf, 8, roll);
+	_mav_put_float(buf, 12, pitch);
+	_mav_put_float(buf, 16, yaw);
+	_mav_put_float(buf, 20, rollspeed);
+	_mav_put_float(buf, 24, pitchspeed);
+	_mav_put_float(buf, 28, yawspeed);
+	_mav_put_int32_t(buf, 32, lat);
+	_mav_put_int32_t(buf, 36, lon);
+	_mav_put_int32_t(buf, 40, alt);
+	_mav_put_int16_t(buf, 44, vx);
+	_mav_put_int16_t(buf, 46, vy);
+	_mav_put_int16_t(buf, 48, vz);
+	_mav_put_int16_t(buf, 50, xacc);
+	_mav_put_int16_t(buf, 52, yacc);
+	_mav_put_int16_t(buf, 54, zacc);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE, buf, MAVLINK_MSG_ID_HIL_STATE_LEN, MAVLINK_MSG_ID_HIL_STATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE, buf, MAVLINK_MSG_ID_HIL_STATE_LEN);
+#endif
+#else
+	mavlink_hil_state_t *packet = (mavlink_hil_state_t *)msgbuf;
+	packet->time_usec = time_usec;
+	packet->roll = roll;
+	packet->pitch = pitch;
+	packet->yaw = yaw;
+	packet->rollspeed = rollspeed;
+	packet->pitchspeed = pitchspeed;
+	packet->yawspeed = yawspeed;
+	packet->lat = lat;
+	packet->lon = lon;
+	packet->alt = alt;
+	packet->vx = vx;
+	packet->vy = vy;
+	packet->vz = vz;
+	packet->xacc = xacc;
+	packet->yacc = yacc;
+	packet->zacc = zacc;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE, (const char *)packet, MAVLINK_MSG_ID_HIL_STATE_LEN, MAVLINK_MSG_ID_HIL_STATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE, (const char *)packet, MAVLINK_MSG_ID_HIL_STATE_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE HIL_STATE UNPACKING
@@ -326,7 +421,7 @@ static inline float mavlink_msg_hil_stat
 /**
  * @brief Get field rollspeed from hil_state message
  *
- * @return Roll angular speed (rad/s)
+ * @return Body frame roll / phi angular speed (rad/s)
  */
 static inline float mavlink_msg_hil_state_get_rollspeed(const mavlink_message_t* msg)
 {
@@ -336,7 +431,7 @@ static inline float mavlink_msg_hil_stat
 /**
  * @brief Get field pitchspeed from hil_state message
  *
- * @return Pitch angular speed (rad/s)
+ * @return Body frame pitch / theta angular speed (rad/s)
  */
 static inline float mavlink_msg_hil_state_get_pitchspeed(const mavlink_message_t* msg)
 {
@@ -346,7 +441,7 @@ static inline float mavlink_msg_hil_stat
 /**
  * @brief Get field yawspeed from hil_state message
  *
- * @return Yaw angular speed (rad/s)
+ * @return Body frame yaw / psi angular speed (rad/s)
  */
 static inline float mavlink_msg_hil_state_get_yawspeed(const mavlink_message_t* msg)
 {
@@ -469,6 +564,6 @@ static inline void mavlink_msg_hil_state
 	hil_state->yacc = mavlink_msg_hil_state_get_yacc(msg);
 	hil_state->zacc = mavlink_msg_hil_state_get_zacc(msg);
 #else
-	memcpy(hil_state, _MAV_PAYLOAD(msg), 56);
+	memcpy(hil_state, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_HIL_STATE_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_hil_state_quaternion.h v1.0/common/mavlink_msg_hil_state_quaternion.h
--- v1.0.old/common/mavlink_msg_hil_state_quaternion.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_hil_state_quaternion.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,561 @@
+// MESSAGE HIL_STATE_QUATERNION PACKING
+
+#define MAVLINK_MSG_ID_HIL_STATE_QUATERNION 115
+
+typedef struct __mavlink_hil_state_quaternion_t
+{
+ uint64_t time_usec; ///< Timestamp (microseconds since UNIX epoch or microseconds since system boot)
+ float attitude_quaternion[4]; ///< Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation)
+ float rollspeed; ///< Body frame roll / phi angular speed (rad/s)
+ float pitchspeed; ///< Body frame pitch / theta angular speed (rad/s)
+ float yawspeed; ///< Body frame yaw / psi angular speed (rad/s)
+ int32_t lat; ///< Latitude, expressed as * 1E7
+ int32_t lon; ///< Longitude, expressed as * 1E7
+ int32_t alt; ///< Altitude in meters, expressed as * 1000 (millimeters)
+ int16_t vx; ///< Ground X Speed (Latitude), expressed as m/s * 100
+ int16_t vy; ///< Ground Y Speed (Longitude), expressed as m/s * 100
+ int16_t vz; ///< Ground Z Speed (Altitude), expressed as m/s * 100
+ uint16_t ind_airspeed; ///< Indicated airspeed, expressed as m/s * 100
+ uint16_t true_airspeed; ///< True airspeed, expressed as m/s * 100
+ int16_t xacc; ///< X acceleration (mg)
+ int16_t yacc; ///< Y acceleration (mg)
+ int16_t zacc; ///< Z acceleration (mg)
+} mavlink_hil_state_quaternion_t;
+
+#define MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN 64
+#define MAVLINK_MSG_ID_115_LEN 64
+
+#define MAVLINK_MSG_ID_HIL_STATE_QUATERNION_CRC 4
+#define MAVLINK_MSG_ID_115_CRC 4
+
+#define MAVLINK_MSG_HIL_STATE_QUATERNION_FIELD_ATTITUDE_QUATERNION_LEN 4
+
+#define MAVLINK_MESSAGE_INFO_HIL_STATE_QUATERNION { \
+	"HIL_STATE_QUATERNION", \
+	16, \
+	{  { "time_usec", NULL, MAVLINK_TYPE_UINT64_T, 0, 0, offsetof(mavlink_hil_state_quaternion_t, time_usec) }, \
+         { "attitude_quaternion", NULL, MAVLINK_TYPE_FLOAT, 4, 8, offsetof(mavlink_hil_state_quaternion_t, attitude_quaternion) }, \
+         { "rollspeed", NULL, MAVLINK_TYPE_FLOAT, 0, 24, offsetof(mavlink_hil_state_quaternion_t, rollspeed) }, \
+         { "pitchspeed", NULL, MAVLINK_TYPE_FLOAT, 0, 28, offsetof(mavlink_hil_state_quaternion_t, pitchspeed) }, \
+         { "yawspeed", NULL, MAVLINK_TYPE_FLOAT, 0, 32, offsetof(mavlink_hil_state_quaternion_t, yawspeed) }, \
+         { "lat", NULL, MAVLINK_TYPE_INT32_T, 0, 36, offsetof(mavlink_hil_state_quaternion_t, lat) }, \
+         { "lon", NULL, MAVLINK_TYPE_INT32_T, 0, 40, offsetof(mavlink_hil_state_quaternion_t, lon) }, \
+         { "alt", NULL, MAVLINK_TYPE_INT32_T, 0, 44, offsetof(mavlink_hil_state_quaternion_t, alt) }, \
+         { "vx", NULL, MAVLINK_TYPE_INT16_T, 0, 48, offsetof(mavlink_hil_state_quaternion_t, vx) }, \
+         { "vy", NULL, MAVLINK_TYPE_INT16_T, 0, 50, offsetof(mavlink_hil_state_quaternion_t, vy) }, \
+         { "vz", NULL, MAVLINK_TYPE_INT16_T, 0, 52, offsetof(mavlink_hil_state_quaternion_t, vz) }, \
+         { "ind_airspeed", NULL, MAVLINK_TYPE_UINT16_T, 0, 54, offsetof(mavlink_hil_state_quaternion_t, ind_airspeed) }, \
+         { "true_airspeed", NULL, MAVLINK_TYPE_UINT16_T, 0, 56, offsetof(mavlink_hil_state_quaternion_t, true_airspeed) }, \
+         { "xacc", NULL, MAVLINK_TYPE_INT16_T, 0, 58, offsetof(mavlink_hil_state_quaternion_t, xacc) }, \
+         { "yacc", NULL, MAVLINK_TYPE_INT16_T, 0, 60, offsetof(mavlink_hil_state_quaternion_t, yacc) }, \
+         { "zacc", NULL, MAVLINK_TYPE_INT16_T, 0, 62, offsetof(mavlink_hil_state_quaternion_t, zacc) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a hil_state_quaternion message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
+ * @param attitude_quaternion Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation)
+ * @param rollspeed Body frame roll / phi angular speed (rad/s)
+ * @param pitchspeed Body frame pitch / theta angular speed (rad/s)
+ * @param yawspeed Body frame yaw / psi angular speed (rad/s)
+ * @param lat Latitude, expressed as * 1E7
+ * @param lon Longitude, expressed as * 1E7
+ * @param alt Altitude in meters, expressed as * 1000 (millimeters)
+ * @param vx Ground X Speed (Latitude), expressed as m/s * 100
+ * @param vy Ground Y Speed (Longitude), expressed as m/s * 100
+ * @param vz Ground Z Speed (Altitude), expressed as m/s * 100
+ * @param ind_airspeed Indicated airspeed, expressed as m/s * 100
+ * @param true_airspeed True airspeed, expressed as m/s * 100
+ * @param xacc X acceleration (mg)
+ * @param yacc Y acceleration (mg)
+ * @param zacc Z acceleration (mg)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_hil_state_quaternion_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint64_t time_usec, const float *attitude_quaternion, float rollspeed, float pitchspeed, float yawspeed, int32_t lat, int32_t lon, int32_t alt, int16_t vx, int16_t vy, int16_t vz, uint16_t ind_airspeed, uint16_t true_airspeed, int16_t xacc, int16_t yacc, int16_t zacc)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_float(buf, 24, rollspeed);
+	_mav_put_float(buf, 28, pitchspeed);
+	_mav_put_float(buf, 32, yawspeed);
+	_mav_put_int32_t(buf, 36, lat);
+	_mav_put_int32_t(buf, 40, lon);
+	_mav_put_int32_t(buf, 44, alt);
+	_mav_put_int16_t(buf, 48, vx);
+	_mav_put_int16_t(buf, 50, vy);
+	_mav_put_int16_t(buf, 52, vz);
+	_mav_put_uint16_t(buf, 54, ind_airspeed);
+	_mav_put_uint16_t(buf, 56, true_airspeed);
+	_mav_put_int16_t(buf, 58, xacc);
+	_mav_put_int16_t(buf, 60, yacc);
+	_mav_put_int16_t(buf, 62, zacc);
+	_mav_put_float_array(buf, 8, attitude_quaternion, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN);
+#else
+	mavlink_hil_state_quaternion_t packet;
+	packet.time_usec = time_usec;
+	packet.rollspeed = rollspeed;
+	packet.pitchspeed = pitchspeed;
+	packet.yawspeed = yawspeed;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.alt = alt;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.ind_airspeed = ind_airspeed;
+	packet.true_airspeed = true_airspeed;
+	packet.xacc = xacc;
+	packet.yacc = yacc;
+	packet.zacc = zacc;
+	mav_array_memcpy(packet.attitude_quaternion, attitude_quaternion, sizeof(float)*4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_HIL_STATE_QUATERNION;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a hil_state_quaternion message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
+ * @param attitude_quaternion Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation)
+ * @param rollspeed Body frame roll / phi angular speed (rad/s)
+ * @param pitchspeed Body frame pitch / theta angular speed (rad/s)
+ * @param yawspeed Body frame yaw / psi angular speed (rad/s)
+ * @param lat Latitude, expressed as * 1E7
+ * @param lon Longitude, expressed as * 1E7
+ * @param alt Altitude in meters, expressed as * 1000 (millimeters)
+ * @param vx Ground X Speed (Latitude), expressed as m/s * 100
+ * @param vy Ground Y Speed (Longitude), expressed as m/s * 100
+ * @param vz Ground Z Speed (Altitude), expressed as m/s * 100
+ * @param ind_airspeed Indicated airspeed, expressed as m/s * 100
+ * @param true_airspeed True airspeed, expressed as m/s * 100
+ * @param xacc X acceleration (mg)
+ * @param yacc Y acceleration (mg)
+ * @param zacc Z acceleration (mg)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_hil_state_quaternion_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint64_t time_usec,const float *attitude_quaternion,float rollspeed,float pitchspeed,float yawspeed,int32_t lat,int32_t lon,int32_t alt,int16_t vx,int16_t vy,int16_t vz,uint16_t ind_airspeed,uint16_t true_airspeed,int16_t xacc,int16_t yacc,int16_t zacc)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_float(buf, 24, rollspeed);
+	_mav_put_float(buf, 28, pitchspeed);
+	_mav_put_float(buf, 32, yawspeed);
+	_mav_put_int32_t(buf, 36, lat);
+	_mav_put_int32_t(buf, 40, lon);
+	_mav_put_int32_t(buf, 44, alt);
+	_mav_put_int16_t(buf, 48, vx);
+	_mav_put_int16_t(buf, 50, vy);
+	_mav_put_int16_t(buf, 52, vz);
+	_mav_put_uint16_t(buf, 54, ind_airspeed);
+	_mav_put_uint16_t(buf, 56, true_airspeed);
+	_mav_put_int16_t(buf, 58, xacc);
+	_mav_put_int16_t(buf, 60, yacc);
+	_mav_put_int16_t(buf, 62, zacc);
+	_mav_put_float_array(buf, 8, attitude_quaternion, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN);
+#else
+	mavlink_hil_state_quaternion_t packet;
+	packet.time_usec = time_usec;
+	packet.rollspeed = rollspeed;
+	packet.pitchspeed = pitchspeed;
+	packet.yawspeed = yawspeed;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.alt = alt;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.ind_airspeed = ind_airspeed;
+	packet.true_airspeed = true_airspeed;
+	packet.xacc = xacc;
+	packet.yacc = yacc;
+	packet.zacc = zacc;
+	mav_array_memcpy(packet.attitude_quaternion, attitude_quaternion, sizeof(float)*4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_HIL_STATE_QUATERNION;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a hil_state_quaternion struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param hil_state_quaternion C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_hil_state_quaternion_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_hil_state_quaternion_t* hil_state_quaternion)
+{
+	return mavlink_msg_hil_state_quaternion_pack(system_id, component_id, msg, hil_state_quaternion->time_usec, hil_state_quaternion->attitude_quaternion, hil_state_quaternion->rollspeed, hil_state_quaternion->pitchspeed, hil_state_quaternion->yawspeed, hil_state_quaternion->lat, hil_state_quaternion->lon, hil_state_quaternion->alt, hil_state_quaternion->vx, hil_state_quaternion->vy, hil_state_quaternion->vz, hil_state_quaternion->ind_airspeed, hil_state_quaternion->true_airspeed, hil_state_quaternion->xacc, hil_state_quaternion->yacc, hil_state_quaternion->zacc);
+}
+
+/**
+ * @brief Encode a hil_state_quaternion struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param hil_state_quaternion C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_hil_state_quaternion_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_hil_state_quaternion_t* hil_state_quaternion)
+{
+	return mavlink_msg_hil_state_quaternion_pack_chan(system_id, component_id, chan, msg, hil_state_quaternion->time_usec, hil_state_quaternion->attitude_quaternion, hil_state_quaternion->rollspeed, hil_state_quaternion->pitchspeed, hil_state_quaternion->yawspeed, hil_state_quaternion->lat, hil_state_quaternion->lon, hil_state_quaternion->alt, hil_state_quaternion->vx, hil_state_quaternion->vy, hil_state_quaternion->vz, hil_state_quaternion->ind_airspeed, hil_state_quaternion->true_airspeed, hil_state_quaternion->xacc, hil_state_quaternion->yacc, hil_state_quaternion->zacc);
+}
+
+/**
+ * @brief Send a hil_state_quaternion message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
+ * @param attitude_quaternion Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation)
+ * @param rollspeed Body frame roll / phi angular speed (rad/s)
+ * @param pitchspeed Body frame pitch / theta angular speed (rad/s)
+ * @param yawspeed Body frame yaw / psi angular speed (rad/s)
+ * @param lat Latitude, expressed as * 1E7
+ * @param lon Longitude, expressed as * 1E7
+ * @param alt Altitude in meters, expressed as * 1000 (millimeters)
+ * @param vx Ground X Speed (Latitude), expressed as m/s * 100
+ * @param vy Ground Y Speed (Longitude), expressed as m/s * 100
+ * @param vz Ground Z Speed (Altitude), expressed as m/s * 100
+ * @param ind_airspeed Indicated airspeed, expressed as m/s * 100
+ * @param true_airspeed True airspeed, expressed as m/s * 100
+ * @param xacc X acceleration (mg)
+ * @param yacc Y acceleration (mg)
+ * @param zacc Z acceleration (mg)
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_hil_state_quaternion_send(mavlink_channel_t chan, uint64_t time_usec, const float *attitude_quaternion, float rollspeed, float pitchspeed, float yawspeed, int32_t lat, int32_t lon, int32_t alt, int16_t vx, int16_t vy, int16_t vz, uint16_t ind_airspeed, uint16_t true_airspeed, int16_t xacc, int16_t yacc, int16_t zacc)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_float(buf, 24, rollspeed);
+	_mav_put_float(buf, 28, pitchspeed);
+	_mav_put_float(buf, 32, yawspeed);
+	_mav_put_int32_t(buf, 36, lat);
+	_mav_put_int32_t(buf, 40, lon);
+	_mav_put_int32_t(buf, 44, alt);
+	_mav_put_int16_t(buf, 48, vx);
+	_mav_put_int16_t(buf, 50, vy);
+	_mav_put_int16_t(buf, 52, vz);
+	_mav_put_uint16_t(buf, 54, ind_airspeed);
+	_mav_put_uint16_t(buf, 56, true_airspeed);
+	_mav_put_int16_t(buf, 58, xacc);
+	_mav_put_int16_t(buf, 60, yacc);
+	_mav_put_int16_t(buf, 62, zacc);
+	_mav_put_float_array(buf, 8, attitude_quaternion, 4);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE_QUATERNION, buf, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE_QUATERNION, buf, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN);
+#endif
+#else
+	mavlink_hil_state_quaternion_t packet;
+	packet.time_usec = time_usec;
+	packet.rollspeed = rollspeed;
+	packet.pitchspeed = pitchspeed;
+	packet.yawspeed = yawspeed;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.alt = alt;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.ind_airspeed = ind_airspeed;
+	packet.true_airspeed = true_airspeed;
+	packet.xacc = xacc;
+	packet.yacc = yacc;
+	packet.zacc = zacc;
+	mav_array_memcpy(packet.attitude_quaternion, attitude_quaternion, sizeof(float)*4);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE_QUATERNION, (const char *)&packet, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE_QUATERNION, (const char *)&packet, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_hil_state_quaternion_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t time_usec, const float *attitude_quaternion, float rollspeed, float pitchspeed, float yawspeed, int32_t lat, int32_t lon, int32_t alt, int16_t vx, int16_t vy, int16_t vz, uint16_t ind_airspeed, uint16_t true_airspeed, int16_t xacc, int16_t yacc, int16_t zacc)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_float(buf, 24, rollspeed);
+	_mav_put_float(buf, 28, pitchspeed);
+	_mav_put_float(buf, 32, yawspeed);
+	_mav_put_int32_t(buf, 36, lat);
+	_mav_put_int32_t(buf, 40, lon);
+	_mav_put_int32_t(buf, 44, alt);
+	_mav_put_int16_t(buf, 48, vx);
+	_mav_put_int16_t(buf, 50, vy);
+	_mav_put_int16_t(buf, 52, vz);
+	_mav_put_uint16_t(buf, 54, ind_airspeed);
+	_mav_put_uint16_t(buf, 56, true_airspeed);
+	_mav_put_int16_t(buf, 58, xacc);
+	_mav_put_int16_t(buf, 60, yacc);
+	_mav_put_int16_t(buf, 62, zacc);
+	_mav_put_float_array(buf, 8, attitude_quaternion, 4);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE_QUATERNION, buf, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE_QUATERNION, buf, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN);
+#endif
+#else
+	mavlink_hil_state_quaternion_t *packet = (mavlink_hil_state_quaternion_t *)msgbuf;
+	packet->time_usec = time_usec;
+	packet->rollspeed = rollspeed;
+	packet->pitchspeed = pitchspeed;
+	packet->yawspeed = yawspeed;
+	packet->lat = lat;
+	packet->lon = lon;
+	packet->alt = alt;
+	packet->vx = vx;
+	packet->vy = vy;
+	packet->vz = vz;
+	packet->ind_airspeed = ind_airspeed;
+	packet->true_airspeed = true_airspeed;
+	packet->xacc = xacc;
+	packet->yacc = yacc;
+	packet->zacc = zacc;
+	mav_array_memcpy(packet->attitude_quaternion, attitude_quaternion, sizeof(float)*4);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE_QUATERNION, (const char *)packet, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HIL_STATE_QUATERNION, (const char *)packet, MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE HIL_STATE_QUATERNION UNPACKING
+
+
+/**
+ * @brief Get field time_usec from hil_state_quaternion message
+ *
+ * @return Timestamp (microseconds since UNIX epoch or microseconds since system boot)
+ */
+static inline uint64_t mavlink_msg_hil_state_quaternion_get_time_usec(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint64_t(msg,  0);
+}
+
+/**
+ * @brief Get field attitude_quaternion from hil_state_quaternion message
+ *
+ * @return Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation)
+ */
+static inline uint16_t mavlink_msg_hil_state_quaternion_get_attitude_quaternion(const mavlink_message_t* msg, float *attitude_quaternion)
+{
+	return _MAV_RETURN_float_array(msg, attitude_quaternion, 4,  8);
+}
+
+/**
+ * @brief Get field rollspeed from hil_state_quaternion message
+ *
+ * @return Body frame roll / phi angular speed (rad/s)
+ */
+static inline float mavlink_msg_hil_state_quaternion_get_rollspeed(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  24);
+}
+
+/**
+ * @brief Get field pitchspeed from hil_state_quaternion message
+ *
+ * @return Body frame pitch / theta angular speed (rad/s)
+ */
+static inline float mavlink_msg_hil_state_quaternion_get_pitchspeed(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  28);
+}
+
+/**
+ * @brief Get field yawspeed from hil_state_quaternion message
+ *
+ * @return Body frame yaw / psi angular speed (rad/s)
+ */
+static inline float mavlink_msg_hil_state_quaternion_get_yawspeed(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  32);
+}
+
+/**
+ * @brief Get field lat from hil_state_quaternion message
+ *
+ * @return Latitude, expressed as * 1E7
+ */
+static inline int32_t mavlink_msg_hil_state_quaternion_get_lat(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  36);
+}
+
+/**
+ * @brief Get field lon from hil_state_quaternion message
+ *
+ * @return Longitude, expressed as * 1E7
+ */
+static inline int32_t mavlink_msg_hil_state_quaternion_get_lon(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  40);
+}
+
+/**
+ * @brief Get field alt from hil_state_quaternion message
+ *
+ * @return Altitude in meters, expressed as * 1000 (millimeters)
+ */
+static inline int32_t mavlink_msg_hil_state_quaternion_get_alt(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  44);
+}
+
+/**
+ * @brief Get field vx from hil_state_quaternion message
+ *
+ * @return Ground X Speed (Latitude), expressed as m/s * 100
+ */
+static inline int16_t mavlink_msg_hil_state_quaternion_get_vx(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  48);
+}
+
+/**
+ * @brief Get field vy from hil_state_quaternion message
+ *
+ * @return Ground Y Speed (Longitude), expressed as m/s * 100
+ */
+static inline int16_t mavlink_msg_hil_state_quaternion_get_vy(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  50);
+}
+
+/**
+ * @brief Get field vz from hil_state_quaternion message
+ *
+ * @return Ground Z Speed (Altitude), expressed as m/s * 100
+ */
+static inline int16_t mavlink_msg_hil_state_quaternion_get_vz(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  52);
+}
+
+/**
+ * @brief Get field ind_airspeed from hil_state_quaternion message
+ *
+ * @return Indicated airspeed, expressed as m/s * 100
+ */
+static inline uint16_t mavlink_msg_hil_state_quaternion_get_ind_airspeed(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  54);
+}
+
+/**
+ * @brief Get field true_airspeed from hil_state_quaternion message
+ *
+ * @return True airspeed, expressed as m/s * 100
+ */
+static inline uint16_t mavlink_msg_hil_state_quaternion_get_true_airspeed(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  56);
+}
+
+/**
+ * @brief Get field xacc from hil_state_quaternion message
+ *
+ * @return X acceleration (mg)
+ */
+static inline int16_t mavlink_msg_hil_state_quaternion_get_xacc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  58);
+}
+
+/**
+ * @brief Get field yacc from hil_state_quaternion message
+ *
+ * @return Y acceleration (mg)
+ */
+static inline int16_t mavlink_msg_hil_state_quaternion_get_yacc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  60);
+}
+
+/**
+ * @brief Get field zacc from hil_state_quaternion message
+ *
+ * @return Z acceleration (mg)
+ */
+static inline int16_t mavlink_msg_hil_state_quaternion_get_zacc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  62);
+}
+
+/**
+ * @brief Decode a hil_state_quaternion message into a struct
+ *
+ * @param msg The message to decode
+ * @param hil_state_quaternion C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_hil_state_quaternion_decode(const mavlink_message_t* msg, mavlink_hil_state_quaternion_t* hil_state_quaternion)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	hil_state_quaternion->time_usec = mavlink_msg_hil_state_quaternion_get_time_usec(msg);
+	mavlink_msg_hil_state_quaternion_get_attitude_quaternion(msg, hil_state_quaternion->attitude_quaternion);
+	hil_state_quaternion->rollspeed = mavlink_msg_hil_state_quaternion_get_rollspeed(msg);
+	hil_state_quaternion->pitchspeed = mavlink_msg_hil_state_quaternion_get_pitchspeed(msg);
+	hil_state_quaternion->yawspeed = mavlink_msg_hil_state_quaternion_get_yawspeed(msg);
+	hil_state_quaternion->lat = mavlink_msg_hil_state_quaternion_get_lat(msg);
+	hil_state_quaternion->lon = mavlink_msg_hil_state_quaternion_get_lon(msg);
+	hil_state_quaternion->alt = mavlink_msg_hil_state_quaternion_get_alt(msg);
+	hil_state_quaternion->vx = mavlink_msg_hil_state_quaternion_get_vx(msg);
+	hil_state_quaternion->vy = mavlink_msg_hil_state_quaternion_get_vy(msg);
+	hil_state_quaternion->vz = mavlink_msg_hil_state_quaternion_get_vz(msg);
+	hil_state_quaternion->ind_airspeed = mavlink_msg_hil_state_quaternion_get_ind_airspeed(msg);
+	hil_state_quaternion->true_airspeed = mavlink_msg_hil_state_quaternion_get_true_airspeed(msg);
+	hil_state_quaternion->xacc = mavlink_msg_hil_state_quaternion_get_xacc(msg);
+	hil_state_quaternion->yacc = mavlink_msg_hil_state_quaternion_get_yacc(msg);
+	hil_state_quaternion->zacc = mavlink_msg_hil_state_quaternion_get_zacc(msg);
+#else
+	memcpy(hil_state_quaternion, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_local_position_ned_cov.h v1.0/common/mavlink_msg_local_position_ned_cov.h
--- v1.0.old/common/mavlink_msg_local_position_ned_cov.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_local_position_ned_cov.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,417 @@
+// MESSAGE LOCAL_POSITION_NED_COV PACKING
+
+#define MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV 64
+
+typedef struct __mavlink_local_position_ned_cov_t
+{
+ uint64_t time_utc; ///< Timestamp (microseconds since UNIX epoch) in UTC. 0 for unknown. Commonly filled by the precision time source of a GPS receiver.
+ uint32_t time_boot_ms; ///< Timestamp (milliseconds since system boot)
+ float x; ///< X Position
+ float y; ///< Y Position
+ float z; ///< Z Position
+ float vx; ///< X Speed
+ float vy; ///< Y Speed
+ float vz; ///< Z Speed
+ float covariance[36]; ///< Covariance matrix (first six entries are the first ROW, next six entries are the second row, etc.)
+ uint8_t estimator_type; ///< Class id of the estimator this estimate originated from.
+} mavlink_local_position_ned_cov_t;
+
+#define MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN 181
+#define MAVLINK_MSG_ID_64_LEN 181
+
+#define MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_CRC 82
+#define MAVLINK_MSG_ID_64_CRC 82
+
+#define MAVLINK_MSG_LOCAL_POSITION_NED_COV_FIELD_COVARIANCE_LEN 36
+
+#define MAVLINK_MESSAGE_INFO_LOCAL_POSITION_NED_COV { \
+	"LOCAL_POSITION_NED_COV", \
+	10, \
+	{  { "time_utc", NULL, MAVLINK_TYPE_UINT64_T, 0, 0, offsetof(mavlink_local_position_ned_cov_t, time_utc) }, \
+         { "time_boot_ms", NULL, MAVLINK_TYPE_UINT32_T, 0, 8, offsetof(mavlink_local_position_ned_cov_t, time_boot_ms) }, \
+         { "x", NULL, MAVLINK_TYPE_FLOAT, 0, 12, offsetof(mavlink_local_position_ned_cov_t, x) }, \
+         { "y", NULL, MAVLINK_TYPE_FLOAT, 0, 16, offsetof(mavlink_local_position_ned_cov_t, y) }, \
+         { "z", NULL, MAVLINK_TYPE_FLOAT, 0, 20, offsetof(mavlink_local_position_ned_cov_t, z) }, \
+         { "vx", NULL, MAVLINK_TYPE_FLOAT, 0, 24, offsetof(mavlink_local_position_ned_cov_t, vx) }, \
+         { "vy", NULL, MAVLINK_TYPE_FLOAT, 0, 28, offsetof(mavlink_local_position_ned_cov_t, vy) }, \
+         { "vz", NULL, MAVLINK_TYPE_FLOAT, 0, 32, offsetof(mavlink_local_position_ned_cov_t, vz) }, \
+         { "covariance", NULL, MAVLINK_TYPE_FLOAT, 36, 36, offsetof(mavlink_local_position_ned_cov_t, covariance) }, \
+         { "estimator_type", NULL, MAVLINK_TYPE_UINT8_T, 0, 180, offsetof(mavlink_local_position_ned_cov_t, estimator_type) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a local_position_ned_cov message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param time_utc Timestamp (microseconds since UNIX epoch) in UTC. 0 for unknown. Commonly filled by the precision time source of a GPS receiver.
+ * @param estimator_type Class id of the estimator this estimate originated from.
+ * @param x X Position
+ * @param y Y Position
+ * @param z Z Position
+ * @param vx X Speed
+ * @param vy Y Speed
+ * @param vz Z Speed
+ * @param covariance Covariance matrix (first six entries are the first ROW, next six entries are the second row, etc.)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_local_position_ned_cov_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint32_t time_boot_ms, uint64_t time_utc, uint8_t estimator_type, float x, float y, float z, float vx, float vy, float vz, const float *covariance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN];
+	_mav_put_uint64_t(buf, 0, time_utc);
+	_mav_put_uint32_t(buf, 8, time_boot_ms);
+	_mav_put_float(buf, 12, x);
+	_mav_put_float(buf, 16, y);
+	_mav_put_float(buf, 20, z);
+	_mav_put_float(buf, 24, vx);
+	_mav_put_float(buf, 28, vy);
+	_mav_put_float(buf, 32, vz);
+	_mav_put_uint8_t(buf, 180, estimator_type);
+	_mav_put_float_array(buf, 36, covariance, 36);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN);
+#else
+	mavlink_local_position_ned_cov_t packet;
+	packet.time_utc = time_utc;
+	packet.time_boot_ms = time_boot_ms;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.estimator_type = estimator_type;
+	mav_array_memcpy(packet.covariance, covariance, sizeof(float)*36);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a local_position_ned_cov message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param time_utc Timestamp (microseconds since UNIX epoch) in UTC. 0 for unknown. Commonly filled by the precision time source of a GPS receiver.
+ * @param estimator_type Class id of the estimator this estimate originated from.
+ * @param x X Position
+ * @param y Y Position
+ * @param z Z Position
+ * @param vx X Speed
+ * @param vy Y Speed
+ * @param vz Z Speed
+ * @param covariance Covariance matrix (first six entries are the first ROW, next six entries are the second row, etc.)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_local_position_ned_cov_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint32_t time_boot_ms,uint64_t time_utc,uint8_t estimator_type,float x,float y,float z,float vx,float vy,float vz,const float *covariance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN];
+	_mav_put_uint64_t(buf, 0, time_utc);
+	_mav_put_uint32_t(buf, 8, time_boot_ms);
+	_mav_put_float(buf, 12, x);
+	_mav_put_float(buf, 16, y);
+	_mav_put_float(buf, 20, z);
+	_mav_put_float(buf, 24, vx);
+	_mav_put_float(buf, 28, vy);
+	_mav_put_float(buf, 32, vz);
+	_mav_put_uint8_t(buf, 180, estimator_type);
+	_mav_put_float_array(buf, 36, covariance, 36);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN);
+#else
+	mavlink_local_position_ned_cov_t packet;
+	packet.time_utc = time_utc;
+	packet.time_boot_ms = time_boot_ms;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.estimator_type = estimator_type;
+	mav_array_memcpy(packet.covariance, covariance, sizeof(float)*36);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a local_position_ned_cov struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param local_position_ned_cov C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_local_position_ned_cov_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_local_position_ned_cov_t* local_position_ned_cov)
+{
+	return mavlink_msg_local_position_ned_cov_pack(system_id, component_id, msg, local_position_ned_cov->time_boot_ms, local_position_ned_cov->time_utc, local_position_ned_cov->estimator_type, local_position_ned_cov->x, local_position_ned_cov->y, local_position_ned_cov->z, local_position_ned_cov->vx, local_position_ned_cov->vy, local_position_ned_cov->vz, local_position_ned_cov->covariance);
+}
+
+/**
+ * @brief Encode a local_position_ned_cov struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param local_position_ned_cov C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_local_position_ned_cov_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_local_position_ned_cov_t* local_position_ned_cov)
+{
+	return mavlink_msg_local_position_ned_cov_pack_chan(system_id, component_id, chan, msg, local_position_ned_cov->time_boot_ms, local_position_ned_cov->time_utc, local_position_ned_cov->estimator_type, local_position_ned_cov->x, local_position_ned_cov->y, local_position_ned_cov->z, local_position_ned_cov->vx, local_position_ned_cov->vy, local_position_ned_cov->vz, local_position_ned_cov->covariance);
+}
+
+/**
+ * @brief Send a local_position_ned_cov message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param time_utc Timestamp (microseconds since UNIX epoch) in UTC. 0 for unknown. Commonly filled by the precision time source of a GPS receiver.
+ * @param estimator_type Class id of the estimator this estimate originated from.
+ * @param x X Position
+ * @param y Y Position
+ * @param z Z Position
+ * @param vx X Speed
+ * @param vy Y Speed
+ * @param vz Z Speed
+ * @param covariance Covariance matrix (first six entries are the first ROW, next six entries are the second row, etc.)
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_local_position_ned_cov_send(mavlink_channel_t chan, uint32_t time_boot_ms, uint64_t time_utc, uint8_t estimator_type, float x, float y, float z, float vx, float vy, float vz, const float *covariance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN];
+	_mav_put_uint64_t(buf, 0, time_utc);
+	_mav_put_uint32_t(buf, 8, time_boot_ms);
+	_mav_put_float(buf, 12, x);
+	_mav_put_float(buf, 16, y);
+	_mav_put_float(buf, 20, z);
+	_mav_put_float(buf, 24, vx);
+	_mav_put_float(buf, 28, vy);
+	_mav_put_float(buf, 32, vz);
+	_mav_put_uint8_t(buf, 180, estimator_type);
+	_mav_put_float_array(buf, 36, covariance, 36);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV, buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV, buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN);
+#endif
+#else
+	mavlink_local_position_ned_cov_t packet;
+	packet.time_utc = time_utc;
+	packet.time_boot_ms = time_boot_ms;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.estimator_type = estimator_type;
+	mav_array_memcpy(packet.covariance, covariance, sizeof(float)*36);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV, (const char *)&packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV, (const char *)&packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_local_position_ned_cov_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, uint64_t time_utc, uint8_t estimator_type, float x, float y, float z, float vx, float vy, float vz, const float *covariance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_utc);
+	_mav_put_uint32_t(buf, 8, time_boot_ms);
+	_mav_put_float(buf, 12, x);
+	_mav_put_float(buf, 16, y);
+	_mav_put_float(buf, 20, z);
+	_mav_put_float(buf, 24, vx);
+	_mav_put_float(buf, 28, vy);
+	_mav_put_float(buf, 32, vz);
+	_mav_put_uint8_t(buf, 180, estimator_type);
+	_mav_put_float_array(buf, 36, covariance, 36);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV, buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV, buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN);
+#endif
+#else
+	mavlink_local_position_ned_cov_t *packet = (mavlink_local_position_ned_cov_t *)msgbuf;
+	packet->time_utc = time_utc;
+	packet->time_boot_ms = time_boot_ms;
+	packet->x = x;
+	packet->y = y;
+	packet->z = z;
+	packet->vx = vx;
+	packet->vy = vy;
+	packet->vz = vz;
+	packet->estimator_type = estimator_type;
+	mav_array_memcpy(packet->covariance, covariance, sizeof(float)*36);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV, (const char *)packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV, (const char *)packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE LOCAL_POSITION_NED_COV UNPACKING
+
+
+/**
+ * @brief Get field time_boot_ms from local_position_ned_cov message
+ *
+ * @return Timestamp (milliseconds since system boot)
+ */
+static inline uint32_t mavlink_msg_local_position_ned_cov_get_time_boot_ms(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  8);
+}
+
+/**
+ * @brief Get field time_utc from local_position_ned_cov message
+ *
+ * @return Timestamp (microseconds since UNIX epoch) in UTC. 0 for unknown. Commonly filled by the precision time source of a GPS receiver.
+ */
+static inline uint64_t mavlink_msg_local_position_ned_cov_get_time_utc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint64_t(msg,  0);
+}
+
+/**
+ * @brief Get field estimator_type from local_position_ned_cov message
+ *
+ * @return Class id of the estimator this estimate originated from.
+ */
+static inline uint8_t mavlink_msg_local_position_ned_cov_get_estimator_type(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  180);
+}
+
+/**
+ * @brief Get field x from local_position_ned_cov message
+ *
+ * @return X Position
+ */
+static inline float mavlink_msg_local_position_ned_cov_get_x(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  12);
+}
+
+/**
+ * @brief Get field y from local_position_ned_cov message
+ *
+ * @return Y Position
+ */
+static inline float mavlink_msg_local_position_ned_cov_get_y(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  16);
+}
+
+/**
+ * @brief Get field z from local_position_ned_cov message
+ *
+ * @return Z Position
+ */
+static inline float mavlink_msg_local_position_ned_cov_get_z(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  20);
+}
+
+/**
+ * @brief Get field vx from local_position_ned_cov message
+ *
+ * @return X Speed
+ */
+static inline float mavlink_msg_local_position_ned_cov_get_vx(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  24);
+}
+
+/**
+ * @brief Get field vy from local_position_ned_cov message
+ *
+ * @return Y Speed
+ */
+static inline float mavlink_msg_local_position_ned_cov_get_vy(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  28);
+}
+
+/**
+ * @brief Get field vz from local_position_ned_cov message
+ *
+ * @return Z Speed
+ */
+static inline float mavlink_msg_local_position_ned_cov_get_vz(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  32);
+}
+
+/**
+ * @brief Get field covariance from local_position_ned_cov message
+ *
+ * @return Covariance matrix (first six entries are the first ROW, next six entries are the second row, etc.)
+ */
+static inline uint16_t mavlink_msg_local_position_ned_cov_get_covariance(const mavlink_message_t* msg, float *covariance)
+{
+	return _MAV_RETURN_float_array(msg, covariance, 36,  36);
+}
+
+/**
+ * @brief Decode a local_position_ned_cov message into a struct
+ *
+ * @param msg The message to decode
+ * @param local_position_ned_cov C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_local_position_ned_cov_decode(const mavlink_message_t* msg, mavlink_local_position_ned_cov_t* local_position_ned_cov)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	local_position_ned_cov->time_utc = mavlink_msg_local_position_ned_cov_get_time_utc(msg);
+	local_position_ned_cov->time_boot_ms = mavlink_msg_local_position_ned_cov_get_time_boot_ms(msg);
+	local_position_ned_cov->x = mavlink_msg_local_position_ned_cov_get_x(msg);
+	local_position_ned_cov->y = mavlink_msg_local_position_ned_cov_get_y(msg);
+	local_position_ned_cov->z = mavlink_msg_local_position_ned_cov_get_z(msg);
+	local_position_ned_cov->vx = mavlink_msg_local_position_ned_cov_get_vx(msg);
+	local_position_ned_cov->vy = mavlink_msg_local_position_ned_cov_get_vy(msg);
+	local_position_ned_cov->vz = mavlink_msg_local_position_ned_cov_get_vz(msg);
+	mavlink_msg_local_position_ned_cov_get_covariance(msg, local_position_ned_cov->covariance);
+	local_position_ned_cov->estimator_type = mavlink_msg_local_position_ned_cov_get_estimator_type(msg);
+#else
+	memcpy(local_position_ned_cov, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_local_position_ned.h v1.0/common/mavlink_msg_local_position_ned.h
--- v1.0.old/common/mavlink_msg_local_position_ned.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_local_position_ned.h	2015-02-06 11:50:58.000000000 +0500
@@ -16,6 +16,9 @@ typedef struct __mavlink_local_position_
 #define MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN 28
 #define MAVLINK_MSG_ID_32_LEN 28
 
+#define MAVLINK_MSG_ID_LOCAL_POSITION_NED_CRC 185
+#define MAVLINK_MSG_ID_32_CRC 185
+
 
 
 #define MAVLINK_MESSAGE_INFO_LOCAL_POSITION_NED { \
@@ -51,7 +54,7 @@ static inline uint16_t mavlink_msg_local
 						       uint32_t time_boot_ms, float x, float y, float z, float vx, float vy, float vz)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[28];
+	char buf[MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, x);
 	_mav_put_float(buf, 8, y);
@@ -60,7 +63,7 @@ static inline uint16_t mavlink_msg_local
 	_mav_put_float(buf, 20, vy);
 	_mav_put_float(buf, 24, vz);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
 #else
 	mavlink_local_position_ned_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -71,18 +74,22 @@ static inline uint16_t mavlink_msg_local
 	packet.vy = vy;
 	packet.vz = vz;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_LOCAL_POSITION_NED;
-	return mavlink_finalize_message(msg, system_id, component_id, 28, 185);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
+#endif
 }
 
 /**
  * @brief Pack a local_position_ned message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_boot_ms Timestamp (milliseconds since system boot)
  * @param x X Position
@@ -98,7 +105,7 @@ static inline uint16_t mavlink_msg_local
 						           uint32_t time_boot_ms,float x,float y,float z,float vx,float vy,float vz)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[28];
+	char buf[MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, x);
 	_mav_put_float(buf, 8, y);
@@ -107,7 +114,7 @@ static inline uint16_t mavlink_msg_local
 	_mav_put_float(buf, 20, vy);
 	_mav_put_float(buf, 24, vz);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
 #else
 	mavlink_local_position_ned_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -118,15 +125,19 @@ static inline uint16_t mavlink_msg_local
 	packet.vy = vy;
 	packet.vz = vz;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_LOCAL_POSITION_NED;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 28, 185);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
+#endif
 }
 
 /**
- * @brief Encode a local_position_ned struct into a message
+ * @brief Encode a local_position_ned struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -139,6 +150,20 @@ static inline uint16_t mavlink_msg_local
 }
 
 /**
+ * @brief Encode a local_position_ned struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param local_position_ned C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_local_position_ned_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_local_position_ned_t* local_position_ned)
+{
+	return mavlink_msg_local_position_ned_pack_chan(system_id, component_id, chan, msg, local_position_ned->time_boot_ms, local_position_ned->x, local_position_ned->y, local_position_ned->z, local_position_ned->vx, local_position_ned->vy, local_position_ned->vz);
+}
+
+/**
  * @brief Send a local_position_ned message
  * @param chan MAVLink channel to send the message
  *
@@ -155,7 +180,7 @@ static inline uint16_t mavlink_msg_local
 static inline void mavlink_msg_local_position_ned_send(mavlink_channel_t chan, uint32_t time_boot_ms, float x, float y, float z, float vx, float vy, float vz)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[28];
+	char buf[MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, x);
 	_mav_put_float(buf, 8, y);
@@ -164,7 +189,11 @@ static inline void mavlink_msg_local_pos
 	_mav_put_float(buf, 20, vy);
 	_mav_put_float(buf, 24, vz);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED, buf, 28, 185);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED, buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED, buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
+#endif
 #else
 	mavlink_local_position_ned_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -175,9 +204,57 @@ static inline void mavlink_msg_local_pos
 	packet.vy = vy;
 	packet.vz = vz;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED, (const char *)&packet, 28, 185);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED, (const char *)&packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED, (const char *)&packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_local_position_ned_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, float x, float y, float z, float vx, float vy, float vz)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, x);
+	_mav_put_float(buf, 8, y);
+	_mav_put_float(buf, 12, z);
+	_mav_put_float(buf, 16, vx);
+	_mav_put_float(buf, 20, vy);
+	_mav_put_float(buf, 24, vz);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED, buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED, buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
+#endif
+#else
+	mavlink_local_position_ned_t *packet = (mavlink_local_position_ned_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->x = x;
+	packet->y = y;
+	packet->z = z;
+	packet->vx = vx;
+	packet->vy = vy;
+	packet->vz = vz;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED, (const char *)packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED, (const char *)packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -271,6 +348,6 @@ static inline void mavlink_msg_local_pos
 	local_position_ned->vy = mavlink_msg_local_position_ned_get_vy(msg);
 	local_position_ned->vz = mavlink_msg_local_position_ned_get_vz(msg);
 #else
-	memcpy(local_position_ned, _MAV_PAYLOAD(msg), 28);
+	memcpy(local_position_ned, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_local_position_ned_system_global_offset.h v1.0/common/mavlink_msg_local_position_ned_system_global_offset.h
--- v1.0.old/common/mavlink_msg_local_position_ned_system_global_offset.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_local_position_ned_system_global_offset.h	2015-02-06 11:50:58.000000000 +0500
@@ -16,6 +16,9 @@ typedef struct __mavlink_local_position_
 #define MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN 28
 #define MAVLINK_MSG_ID_89_LEN 28
 
+#define MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_CRC 231
+#define MAVLINK_MSG_ID_89_CRC 231
+
 
 
 #define MAVLINK_MESSAGE_INFO_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET { \
@@ -51,7 +54,7 @@ static inline uint16_t mavlink_msg_local
 						       uint32_t time_boot_ms, float x, float y, float z, float roll, float pitch, float yaw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[28];
+	char buf[MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, x);
 	_mav_put_float(buf, 8, y);
@@ -60,7 +63,7 @@ static inline uint16_t mavlink_msg_local
 	_mav_put_float(buf, 20, pitch);
 	_mav_put_float(buf, 24, yaw);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN);
 #else
 	mavlink_local_position_ned_system_global_offset_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -71,18 +74,22 @@ static inline uint16_t mavlink_msg_local
 	packet.pitch = pitch;
 	packet.yaw = yaw;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET;
-	return mavlink_finalize_message(msg, system_id, component_id, 28, 231);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN);
+#endif
 }
 
 /**
  * @brief Pack a local_position_ned_system_global_offset message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_boot_ms Timestamp (milliseconds since system boot)
  * @param x X Position
@@ -98,7 +105,7 @@ static inline uint16_t mavlink_msg_local
 						           uint32_t time_boot_ms,float x,float y,float z,float roll,float pitch,float yaw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[28];
+	char buf[MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, x);
 	_mav_put_float(buf, 8, y);
@@ -107,7 +114,7 @@ static inline uint16_t mavlink_msg_local
 	_mav_put_float(buf, 20, pitch);
 	_mav_put_float(buf, 24, yaw);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN);
 #else
 	mavlink_local_position_ned_system_global_offset_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -118,15 +125,19 @@ static inline uint16_t mavlink_msg_local
 	packet.pitch = pitch;
 	packet.yaw = yaw;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 28);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 28, 231);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN);
+#endif
 }
 
 /**
- * @brief Encode a local_position_ned_system_global_offset struct into a message
+ * @brief Encode a local_position_ned_system_global_offset struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -139,6 +150,20 @@ static inline uint16_t mavlink_msg_local
 }
 
 /**
+ * @brief Encode a local_position_ned_system_global_offset struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param local_position_ned_system_global_offset C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_local_position_ned_system_global_offset_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_local_position_ned_system_global_offset_t* local_position_ned_system_global_offset)
+{
+	return mavlink_msg_local_position_ned_system_global_offset_pack_chan(system_id, component_id, chan, msg, local_position_ned_system_global_offset->time_boot_ms, local_position_ned_system_global_offset->x, local_position_ned_system_global_offset->y, local_position_ned_system_global_offset->z, local_position_ned_system_global_offset->roll, local_position_ned_system_global_offset->pitch, local_position_ned_system_global_offset->yaw);
+}
+
+/**
  * @brief Send a local_position_ned_system_global_offset message
  * @param chan MAVLink channel to send the message
  *
@@ -155,7 +180,7 @@ static inline uint16_t mavlink_msg_local
 static inline void mavlink_msg_local_position_ned_system_global_offset_send(mavlink_channel_t chan, uint32_t time_boot_ms, float x, float y, float z, float roll, float pitch, float yaw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[28];
+	char buf[MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, x);
 	_mav_put_float(buf, 8, y);
@@ -164,7 +189,11 @@ static inline void mavlink_msg_local_pos
 	_mav_put_float(buf, 20, pitch);
 	_mav_put_float(buf, 24, yaw);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET, buf, 28, 231);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET, buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET, buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN);
+#endif
 #else
 	mavlink_local_position_ned_system_global_offset_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -175,9 +204,57 @@ static inline void mavlink_msg_local_pos
 	packet.pitch = pitch;
 	packet.yaw = yaw;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET, (const char *)&packet, 28, 231);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET, (const char *)&packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET, (const char *)&packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_local_position_ned_system_global_offset_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, float x, float y, float z, float roll, float pitch, float yaw)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, x);
+	_mav_put_float(buf, 8, y);
+	_mav_put_float(buf, 12, z);
+	_mav_put_float(buf, 16, roll);
+	_mav_put_float(buf, 20, pitch);
+	_mav_put_float(buf, 24, yaw);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET, buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET, buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN);
+#endif
+#else
+	mavlink_local_position_ned_system_global_offset_t *packet = (mavlink_local_position_ned_system_global_offset_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->x = x;
+	packet->y = y;
+	packet->z = z;
+	packet->roll = roll;
+	packet->pitch = pitch;
+	packet->yaw = yaw;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET, (const char *)packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET, (const char *)packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -271,6 +348,6 @@ static inline void mavlink_msg_local_pos
 	local_position_ned_system_global_offset->pitch = mavlink_msg_local_position_ned_system_global_offset_get_pitch(msg);
 	local_position_ned_system_global_offset->yaw = mavlink_msg_local_position_ned_system_global_offset_get_yaw(msg);
 #else
-	memcpy(local_position_ned_system_global_offset, _MAV_PAYLOAD(msg), 28);
+	memcpy(local_position_ned_system_global_offset, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_log_data.h v1.0/common/mavlink_msg_log_data.h
--- v1.0.old/common/mavlink_msg_log_data.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_log_data.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,273 @@
+// MESSAGE LOG_DATA PACKING
+
+#define MAVLINK_MSG_ID_LOG_DATA 120
+
+typedef struct __mavlink_log_data_t
+{
+ uint32_t ofs; ///< Offset into the log
+ uint16_t id; ///< Log id (from LOG_ENTRY reply)
+ uint8_t count; ///< Number of bytes (zero for end of log)
+ uint8_t data[90]; ///< log data
+} mavlink_log_data_t;
+
+#define MAVLINK_MSG_ID_LOG_DATA_LEN 97
+#define MAVLINK_MSG_ID_120_LEN 97
+
+#define MAVLINK_MSG_ID_LOG_DATA_CRC 134
+#define MAVLINK_MSG_ID_120_CRC 134
+
+#define MAVLINK_MSG_LOG_DATA_FIELD_DATA_LEN 90
+
+#define MAVLINK_MESSAGE_INFO_LOG_DATA { \
+	"LOG_DATA", \
+	4, \
+	{  { "ofs", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_log_data_t, ofs) }, \
+         { "id", NULL, MAVLINK_TYPE_UINT16_T, 0, 4, offsetof(mavlink_log_data_t, id) }, \
+         { "count", NULL, MAVLINK_TYPE_UINT8_T, 0, 6, offsetof(mavlink_log_data_t, count) }, \
+         { "data", NULL, MAVLINK_TYPE_UINT8_T, 90, 7, offsetof(mavlink_log_data_t, data) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a log_data message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param id Log id (from LOG_ENTRY reply)
+ * @param ofs Offset into the log
+ * @param count Number of bytes (zero for end of log)
+ * @param data log data
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_log_data_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint16_t id, uint32_t ofs, uint8_t count, const uint8_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_DATA_LEN];
+	_mav_put_uint32_t(buf, 0, ofs);
+	_mav_put_uint16_t(buf, 4, id);
+	_mav_put_uint8_t(buf, 6, count);
+	_mav_put_uint8_t_array(buf, 7, data, 90);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOG_DATA_LEN);
+#else
+	mavlink_log_data_t packet;
+	packet.ofs = ofs;
+	packet.id = id;
+	packet.count = count;
+	mav_array_memcpy(packet.data, data, sizeof(uint8_t)*90);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOG_DATA_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_LOG_DATA;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOG_DATA_LEN, MAVLINK_MSG_ID_LOG_DATA_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOG_DATA_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a log_data message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param id Log id (from LOG_ENTRY reply)
+ * @param ofs Offset into the log
+ * @param count Number of bytes (zero for end of log)
+ * @param data log data
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_log_data_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint16_t id,uint32_t ofs,uint8_t count,const uint8_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_DATA_LEN];
+	_mav_put_uint32_t(buf, 0, ofs);
+	_mav_put_uint16_t(buf, 4, id);
+	_mav_put_uint8_t(buf, 6, count);
+	_mav_put_uint8_t_array(buf, 7, data, 90);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOG_DATA_LEN);
+#else
+	mavlink_log_data_t packet;
+	packet.ofs = ofs;
+	packet.id = id;
+	packet.count = count;
+	mav_array_memcpy(packet.data, data, sizeof(uint8_t)*90);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOG_DATA_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_LOG_DATA;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOG_DATA_LEN, MAVLINK_MSG_ID_LOG_DATA_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOG_DATA_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a log_data struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param log_data C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_log_data_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_log_data_t* log_data)
+{
+	return mavlink_msg_log_data_pack(system_id, component_id, msg, log_data->id, log_data->ofs, log_data->count, log_data->data);
+}
+
+/**
+ * @brief Encode a log_data struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param log_data C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_log_data_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_log_data_t* log_data)
+{
+	return mavlink_msg_log_data_pack_chan(system_id, component_id, chan, msg, log_data->id, log_data->ofs, log_data->count, log_data->data);
+}
+
+/**
+ * @brief Send a log_data message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param id Log id (from LOG_ENTRY reply)
+ * @param ofs Offset into the log
+ * @param count Number of bytes (zero for end of log)
+ * @param data log data
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_log_data_send(mavlink_channel_t chan, uint16_t id, uint32_t ofs, uint8_t count, const uint8_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_DATA_LEN];
+	_mav_put_uint32_t(buf, 0, ofs);
+	_mav_put_uint16_t(buf, 4, id);
+	_mav_put_uint8_t(buf, 6, count);
+	_mav_put_uint8_t_array(buf, 7, data, 90);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_DATA, buf, MAVLINK_MSG_ID_LOG_DATA_LEN, MAVLINK_MSG_ID_LOG_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_DATA, buf, MAVLINK_MSG_ID_LOG_DATA_LEN);
+#endif
+#else
+	mavlink_log_data_t packet;
+	packet.ofs = ofs;
+	packet.id = id;
+	packet.count = count;
+	mav_array_memcpy(packet.data, data, sizeof(uint8_t)*90);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_DATA, (const char *)&packet, MAVLINK_MSG_ID_LOG_DATA_LEN, MAVLINK_MSG_ID_LOG_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_DATA, (const char *)&packet, MAVLINK_MSG_ID_LOG_DATA_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_LOG_DATA_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_log_data_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint16_t id, uint32_t ofs, uint8_t count, const uint8_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, ofs);
+	_mav_put_uint16_t(buf, 4, id);
+	_mav_put_uint8_t(buf, 6, count);
+	_mav_put_uint8_t_array(buf, 7, data, 90);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_DATA, buf, MAVLINK_MSG_ID_LOG_DATA_LEN, MAVLINK_MSG_ID_LOG_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_DATA, buf, MAVLINK_MSG_ID_LOG_DATA_LEN);
+#endif
+#else
+	mavlink_log_data_t *packet = (mavlink_log_data_t *)msgbuf;
+	packet->ofs = ofs;
+	packet->id = id;
+	packet->count = count;
+	mav_array_memcpy(packet->data, data, sizeof(uint8_t)*90);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_DATA, (const char *)packet, MAVLINK_MSG_ID_LOG_DATA_LEN, MAVLINK_MSG_ID_LOG_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_DATA, (const char *)packet, MAVLINK_MSG_ID_LOG_DATA_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE LOG_DATA UNPACKING
+
+
+/**
+ * @brief Get field id from log_data message
+ *
+ * @return Log id (from LOG_ENTRY reply)
+ */
+static inline uint16_t mavlink_msg_log_data_get_id(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  4);
+}
+
+/**
+ * @brief Get field ofs from log_data message
+ *
+ * @return Offset into the log
+ */
+static inline uint32_t mavlink_msg_log_data_get_ofs(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field count from log_data message
+ *
+ * @return Number of bytes (zero for end of log)
+ */
+static inline uint8_t mavlink_msg_log_data_get_count(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  6);
+}
+
+/**
+ * @brief Get field data from log_data message
+ *
+ * @return log data
+ */
+static inline uint16_t mavlink_msg_log_data_get_data(const mavlink_message_t* msg, uint8_t *data)
+{
+	return _MAV_RETURN_uint8_t_array(msg, data, 90,  7);
+}
+
+/**
+ * @brief Decode a log_data message into a struct
+ *
+ * @param msg The message to decode
+ * @param log_data C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_log_data_decode(const mavlink_message_t* msg, mavlink_log_data_t* log_data)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	log_data->ofs = mavlink_msg_log_data_get_ofs(msg);
+	log_data->id = mavlink_msg_log_data_get_id(msg);
+	log_data->count = mavlink_msg_log_data_get_count(msg);
+	mavlink_msg_log_data_get_data(msg, log_data->data);
+#else
+	memcpy(log_data, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_LOG_DATA_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_log_entry.h v1.0/common/mavlink_msg_log_entry.h
--- v1.0.old/common/mavlink_msg_log_entry.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_log_entry.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,305 @@
+// MESSAGE LOG_ENTRY PACKING
+
+#define MAVLINK_MSG_ID_LOG_ENTRY 118
+
+typedef struct __mavlink_log_entry_t
+{
+ uint32_t time_utc; ///< UTC timestamp of log in seconds since 1970, or 0 if not available
+ uint32_t size; ///< Size of the log (may be approximate) in bytes
+ uint16_t id; ///< Log id
+ uint16_t num_logs; ///< Total number of logs
+ uint16_t last_log_num; ///< High log number
+} mavlink_log_entry_t;
+
+#define MAVLINK_MSG_ID_LOG_ENTRY_LEN 14
+#define MAVLINK_MSG_ID_118_LEN 14
+
+#define MAVLINK_MSG_ID_LOG_ENTRY_CRC 56
+#define MAVLINK_MSG_ID_118_CRC 56
+
+
+
+#define MAVLINK_MESSAGE_INFO_LOG_ENTRY { \
+	"LOG_ENTRY", \
+	5, \
+	{  { "time_utc", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_log_entry_t, time_utc) }, \
+         { "size", NULL, MAVLINK_TYPE_UINT32_T, 0, 4, offsetof(mavlink_log_entry_t, size) }, \
+         { "id", NULL, MAVLINK_TYPE_UINT16_T, 0, 8, offsetof(mavlink_log_entry_t, id) }, \
+         { "num_logs", NULL, MAVLINK_TYPE_UINT16_T, 0, 10, offsetof(mavlink_log_entry_t, num_logs) }, \
+         { "last_log_num", NULL, MAVLINK_TYPE_UINT16_T, 0, 12, offsetof(mavlink_log_entry_t, last_log_num) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a log_entry message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param id Log id
+ * @param num_logs Total number of logs
+ * @param last_log_num High log number
+ * @param time_utc UTC timestamp of log in seconds since 1970, or 0 if not available
+ * @param size Size of the log (may be approximate) in bytes
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_log_entry_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint16_t id, uint16_t num_logs, uint16_t last_log_num, uint32_t time_utc, uint32_t size)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_ENTRY_LEN];
+	_mav_put_uint32_t(buf, 0, time_utc);
+	_mav_put_uint32_t(buf, 4, size);
+	_mav_put_uint16_t(buf, 8, id);
+	_mav_put_uint16_t(buf, 10, num_logs);
+	_mav_put_uint16_t(buf, 12, last_log_num);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOG_ENTRY_LEN);
+#else
+	mavlink_log_entry_t packet;
+	packet.time_utc = time_utc;
+	packet.size = size;
+	packet.id = id;
+	packet.num_logs = num_logs;
+	packet.last_log_num = last_log_num;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOG_ENTRY_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_LOG_ENTRY;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOG_ENTRY_LEN, MAVLINK_MSG_ID_LOG_ENTRY_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOG_ENTRY_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a log_entry message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param id Log id
+ * @param num_logs Total number of logs
+ * @param last_log_num High log number
+ * @param time_utc UTC timestamp of log in seconds since 1970, or 0 if not available
+ * @param size Size of the log (may be approximate) in bytes
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_log_entry_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint16_t id,uint16_t num_logs,uint16_t last_log_num,uint32_t time_utc,uint32_t size)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_ENTRY_LEN];
+	_mav_put_uint32_t(buf, 0, time_utc);
+	_mav_put_uint32_t(buf, 4, size);
+	_mav_put_uint16_t(buf, 8, id);
+	_mav_put_uint16_t(buf, 10, num_logs);
+	_mav_put_uint16_t(buf, 12, last_log_num);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOG_ENTRY_LEN);
+#else
+	mavlink_log_entry_t packet;
+	packet.time_utc = time_utc;
+	packet.size = size;
+	packet.id = id;
+	packet.num_logs = num_logs;
+	packet.last_log_num = last_log_num;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOG_ENTRY_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_LOG_ENTRY;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOG_ENTRY_LEN, MAVLINK_MSG_ID_LOG_ENTRY_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOG_ENTRY_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a log_entry struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param log_entry C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_log_entry_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_log_entry_t* log_entry)
+{
+	return mavlink_msg_log_entry_pack(system_id, component_id, msg, log_entry->id, log_entry->num_logs, log_entry->last_log_num, log_entry->time_utc, log_entry->size);
+}
+
+/**
+ * @brief Encode a log_entry struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param log_entry C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_log_entry_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_log_entry_t* log_entry)
+{
+	return mavlink_msg_log_entry_pack_chan(system_id, component_id, chan, msg, log_entry->id, log_entry->num_logs, log_entry->last_log_num, log_entry->time_utc, log_entry->size);
+}
+
+/**
+ * @brief Send a log_entry message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param id Log id
+ * @param num_logs Total number of logs
+ * @param last_log_num High log number
+ * @param time_utc UTC timestamp of log in seconds since 1970, or 0 if not available
+ * @param size Size of the log (may be approximate) in bytes
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_log_entry_send(mavlink_channel_t chan, uint16_t id, uint16_t num_logs, uint16_t last_log_num, uint32_t time_utc, uint32_t size)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_ENTRY_LEN];
+	_mav_put_uint32_t(buf, 0, time_utc);
+	_mav_put_uint32_t(buf, 4, size);
+	_mav_put_uint16_t(buf, 8, id);
+	_mav_put_uint16_t(buf, 10, num_logs);
+	_mav_put_uint16_t(buf, 12, last_log_num);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_ENTRY, buf, MAVLINK_MSG_ID_LOG_ENTRY_LEN, MAVLINK_MSG_ID_LOG_ENTRY_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_ENTRY, buf, MAVLINK_MSG_ID_LOG_ENTRY_LEN);
+#endif
+#else
+	mavlink_log_entry_t packet;
+	packet.time_utc = time_utc;
+	packet.size = size;
+	packet.id = id;
+	packet.num_logs = num_logs;
+	packet.last_log_num = last_log_num;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_ENTRY, (const char *)&packet, MAVLINK_MSG_ID_LOG_ENTRY_LEN, MAVLINK_MSG_ID_LOG_ENTRY_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_ENTRY, (const char *)&packet, MAVLINK_MSG_ID_LOG_ENTRY_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_LOG_ENTRY_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_log_entry_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint16_t id, uint16_t num_logs, uint16_t last_log_num, uint32_t time_utc, uint32_t size)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_utc);
+	_mav_put_uint32_t(buf, 4, size);
+	_mav_put_uint16_t(buf, 8, id);
+	_mav_put_uint16_t(buf, 10, num_logs);
+	_mav_put_uint16_t(buf, 12, last_log_num);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_ENTRY, buf, MAVLINK_MSG_ID_LOG_ENTRY_LEN, MAVLINK_MSG_ID_LOG_ENTRY_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_ENTRY, buf, MAVLINK_MSG_ID_LOG_ENTRY_LEN);
+#endif
+#else
+	mavlink_log_entry_t *packet = (mavlink_log_entry_t *)msgbuf;
+	packet->time_utc = time_utc;
+	packet->size = size;
+	packet->id = id;
+	packet->num_logs = num_logs;
+	packet->last_log_num = last_log_num;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_ENTRY, (const char *)packet, MAVLINK_MSG_ID_LOG_ENTRY_LEN, MAVLINK_MSG_ID_LOG_ENTRY_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_ENTRY, (const char *)packet, MAVLINK_MSG_ID_LOG_ENTRY_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE LOG_ENTRY UNPACKING
+
+
+/**
+ * @brief Get field id from log_entry message
+ *
+ * @return Log id
+ */
+static inline uint16_t mavlink_msg_log_entry_get_id(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  8);
+}
+
+/**
+ * @brief Get field num_logs from log_entry message
+ *
+ * @return Total number of logs
+ */
+static inline uint16_t mavlink_msg_log_entry_get_num_logs(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  10);
+}
+
+/**
+ * @brief Get field last_log_num from log_entry message
+ *
+ * @return High log number
+ */
+static inline uint16_t mavlink_msg_log_entry_get_last_log_num(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  12);
+}
+
+/**
+ * @brief Get field time_utc from log_entry message
+ *
+ * @return UTC timestamp of log in seconds since 1970, or 0 if not available
+ */
+static inline uint32_t mavlink_msg_log_entry_get_time_utc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field size from log_entry message
+ *
+ * @return Size of the log (may be approximate) in bytes
+ */
+static inline uint32_t mavlink_msg_log_entry_get_size(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  4);
+}
+
+/**
+ * @brief Decode a log_entry message into a struct
+ *
+ * @param msg The message to decode
+ * @param log_entry C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_log_entry_decode(const mavlink_message_t* msg, mavlink_log_entry_t* log_entry)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	log_entry->time_utc = mavlink_msg_log_entry_get_time_utc(msg);
+	log_entry->size = mavlink_msg_log_entry_get_size(msg);
+	log_entry->id = mavlink_msg_log_entry_get_id(msg);
+	log_entry->num_logs = mavlink_msg_log_entry_get_num_logs(msg);
+	log_entry->last_log_num = mavlink_msg_log_entry_get_last_log_num(msg);
+#else
+	memcpy(log_entry, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_LOG_ENTRY_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_log_erase.h v1.0/common/mavlink_msg_log_erase.h
--- v1.0.old/common/mavlink_msg_log_erase.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_log_erase.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,233 @@
+// MESSAGE LOG_ERASE PACKING
+
+#define MAVLINK_MSG_ID_LOG_ERASE 121
+
+typedef struct __mavlink_log_erase_t
+{
+ uint8_t target_system; ///< System ID
+ uint8_t target_component; ///< Component ID
+} mavlink_log_erase_t;
+
+#define MAVLINK_MSG_ID_LOG_ERASE_LEN 2
+#define MAVLINK_MSG_ID_121_LEN 2
+
+#define MAVLINK_MSG_ID_LOG_ERASE_CRC 237
+#define MAVLINK_MSG_ID_121_CRC 237
+
+
+
+#define MAVLINK_MESSAGE_INFO_LOG_ERASE { \
+	"LOG_ERASE", \
+	2, \
+	{  { "target_system", NULL, MAVLINK_TYPE_UINT8_T, 0, 0, offsetof(mavlink_log_erase_t, target_system) }, \
+         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_log_erase_t, target_component) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a log_erase message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_log_erase_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint8_t target_system, uint8_t target_component)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_ERASE_LEN];
+	_mav_put_uint8_t(buf, 0, target_system);
+	_mav_put_uint8_t(buf, 1, target_component);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOG_ERASE_LEN);
+#else
+	mavlink_log_erase_t packet;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOG_ERASE_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_LOG_ERASE;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOG_ERASE_LEN, MAVLINK_MSG_ID_LOG_ERASE_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOG_ERASE_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a log_erase message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_log_erase_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint8_t target_system,uint8_t target_component)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_ERASE_LEN];
+	_mav_put_uint8_t(buf, 0, target_system);
+	_mav_put_uint8_t(buf, 1, target_component);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOG_ERASE_LEN);
+#else
+	mavlink_log_erase_t packet;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOG_ERASE_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_LOG_ERASE;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOG_ERASE_LEN, MAVLINK_MSG_ID_LOG_ERASE_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOG_ERASE_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a log_erase struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param log_erase C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_log_erase_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_log_erase_t* log_erase)
+{
+	return mavlink_msg_log_erase_pack(system_id, component_id, msg, log_erase->target_system, log_erase->target_component);
+}
+
+/**
+ * @brief Encode a log_erase struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param log_erase C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_log_erase_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_log_erase_t* log_erase)
+{
+	return mavlink_msg_log_erase_pack_chan(system_id, component_id, chan, msg, log_erase->target_system, log_erase->target_component);
+}
+
+/**
+ * @brief Send a log_erase message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param target_system System ID
+ * @param target_component Component ID
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_log_erase_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_ERASE_LEN];
+	_mav_put_uint8_t(buf, 0, target_system);
+	_mav_put_uint8_t(buf, 1, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_ERASE, buf, MAVLINK_MSG_ID_LOG_ERASE_LEN, MAVLINK_MSG_ID_LOG_ERASE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_ERASE, buf, MAVLINK_MSG_ID_LOG_ERASE_LEN);
+#endif
+#else
+	mavlink_log_erase_t packet;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_ERASE, (const char *)&packet, MAVLINK_MSG_ID_LOG_ERASE_LEN, MAVLINK_MSG_ID_LOG_ERASE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_ERASE, (const char *)&packet, MAVLINK_MSG_ID_LOG_ERASE_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_LOG_ERASE_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_log_erase_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint8_t(buf, 0, target_system);
+	_mav_put_uint8_t(buf, 1, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_ERASE, buf, MAVLINK_MSG_ID_LOG_ERASE_LEN, MAVLINK_MSG_ID_LOG_ERASE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_ERASE, buf, MAVLINK_MSG_ID_LOG_ERASE_LEN);
+#endif
+#else
+	mavlink_log_erase_t *packet = (mavlink_log_erase_t *)msgbuf;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_ERASE, (const char *)packet, MAVLINK_MSG_ID_LOG_ERASE_LEN, MAVLINK_MSG_ID_LOG_ERASE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_ERASE, (const char *)packet, MAVLINK_MSG_ID_LOG_ERASE_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE LOG_ERASE UNPACKING
+
+
+/**
+ * @brief Get field target_system from log_erase message
+ *
+ * @return System ID
+ */
+static inline uint8_t mavlink_msg_log_erase_get_target_system(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  0);
+}
+
+/**
+ * @brief Get field target_component from log_erase message
+ *
+ * @return Component ID
+ */
+static inline uint8_t mavlink_msg_log_erase_get_target_component(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  1);
+}
+
+/**
+ * @brief Decode a log_erase message into a struct
+ *
+ * @param msg The message to decode
+ * @param log_erase C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_log_erase_decode(const mavlink_message_t* msg, mavlink_log_erase_t* log_erase)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	log_erase->target_system = mavlink_msg_log_erase_get_target_system(msg);
+	log_erase->target_component = mavlink_msg_log_erase_get_target_component(msg);
+#else
+	memcpy(log_erase, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_LOG_ERASE_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_log_request_data.h v1.0/common/mavlink_msg_log_request_data.h
--- v1.0.old/common/mavlink_msg_log_request_data.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_log_request_data.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,305 @@
+// MESSAGE LOG_REQUEST_DATA PACKING
+
+#define MAVLINK_MSG_ID_LOG_REQUEST_DATA 119
+
+typedef struct __mavlink_log_request_data_t
+{
+ uint32_t ofs; ///< Offset into the log
+ uint32_t count; ///< Number of bytes
+ uint16_t id; ///< Log id (from LOG_ENTRY reply)
+ uint8_t target_system; ///< System ID
+ uint8_t target_component; ///< Component ID
+} mavlink_log_request_data_t;
+
+#define MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN 12
+#define MAVLINK_MSG_ID_119_LEN 12
+
+#define MAVLINK_MSG_ID_LOG_REQUEST_DATA_CRC 116
+#define MAVLINK_MSG_ID_119_CRC 116
+
+
+
+#define MAVLINK_MESSAGE_INFO_LOG_REQUEST_DATA { \
+	"LOG_REQUEST_DATA", \
+	5, \
+	{  { "ofs", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_log_request_data_t, ofs) }, \
+         { "count", NULL, MAVLINK_TYPE_UINT32_T, 0, 4, offsetof(mavlink_log_request_data_t, count) }, \
+         { "id", NULL, MAVLINK_TYPE_UINT16_T, 0, 8, offsetof(mavlink_log_request_data_t, id) }, \
+         { "target_system", NULL, MAVLINK_TYPE_UINT8_T, 0, 10, offsetof(mavlink_log_request_data_t, target_system) }, \
+         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 11, offsetof(mavlink_log_request_data_t, target_component) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a log_request_data message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param id Log id (from LOG_ENTRY reply)
+ * @param ofs Offset into the log
+ * @param count Number of bytes
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_log_request_data_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint8_t target_system, uint8_t target_component, uint16_t id, uint32_t ofs, uint32_t count)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN];
+	_mav_put_uint32_t(buf, 0, ofs);
+	_mav_put_uint32_t(buf, 4, count);
+	_mav_put_uint16_t(buf, 8, id);
+	_mav_put_uint8_t(buf, 10, target_system);
+	_mav_put_uint8_t(buf, 11, target_component);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN);
+#else
+	mavlink_log_request_data_t packet;
+	packet.ofs = ofs;
+	packet.count = count;
+	packet.id = id;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_LOG_REQUEST_DATA;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN, MAVLINK_MSG_ID_LOG_REQUEST_DATA_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a log_request_data message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param id Log id (from LOG_ENTRY reply)
+ * @param ofs Offset into the log
+ * @param count Number of bytes
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_log_request_data_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint8_t target_system,uint8_t target_component,uint16_t id,uint32_t ofs,uint32_t count)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN];
+	_mav_put_uint32_t(buf, 0, ofs);
+	_mav_put_uint32_t(buf, 4, count);
+	_mav_put_uint16_t(buf, 8, id);
+	_mav_put_uint8_t(buf, 10, target_system);
+	_mav_put_uint8_t(buf, 11, target_component);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN);
+#else
+	mavlink_log_request_data_t packet;
+	packet.ofs = ofs;
+	packet.count = count;
+	packet.id = id;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_LOG_REQUEST_DATA;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN, MAVLINK_MSG_ID_LOG_REQUEST_DATA_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a log_request_data struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param log_request_data C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_log_request_data_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_log_request_data_t* log_request_data)
+{
+	return mavlink_msg_log_request_data_pack(system_id, component_id, msg, log_request_data->target_system, log_request_data->target_component, log_request_data->id, log_request_data->ofs, log_request_data->count);
+}
+
+/**
+ * @brief Encode a log_request_data struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param log_request_data C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_log_request_data_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_log_request_data_t* log_request_data)
+{
+	return mavlink_msg_log_request_data_pack_chan(system_id, component_id, chan, msg, log_request_data->target_system, log_request_data->target_component, log_request_data->id, log_request_data->ofs, log_request_data->count);
+}
+
+/**
+ * @brief Send a log_request_data message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param id Log id (from LOG_ENTRY reply)
+ * @param ofs Offset into the log
+ * @param count Number of bytes
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_log_request_data_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, uint16_t id, uint32_t ofs, uint32_t count)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN];
+	_mav_put_uint32_t(buf, 0, ofs);
+	_mav_put_uint32_t(buf, 4, count);
+	_mav_put_uint16_t(buf, 8, id);
+	_mav_put_uint8_t(buf, 10, target_system);
+	_mav_put_uint8_t(buf, 11, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_DATA, buf, MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN, MAVLINK_MSG_ID_LOG_REQUEST_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_DATA, buf, MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN);
+#endif
+#else
+	mavlink_log_request_data_t packet;
+	packet.ofs = ofs;
+	packet.count = count;
+	packet.id = id;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_DATA, (const char *)&packet, MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN, MAVLINK_MSG_ID_LOG_REQUEST_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_DATA, (const char *)&packet, MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_log_request_data_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, uint16_t id, uint32_t ofs, uint32_t count)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, ofs);
+	_mav_put_uint32_t(buf, 4, count);
+	_mav_put_uint16_t(buf, 8, id);
+	_mav_put_uint8_t(buf, 10, target_system);
+	_mav_put_uint8_t(buf, 11, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_DATA, buf, MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN, MAVLINK_MSG_ID_LOG_REQUEST_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_DATA, buf, MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN);
+#endif
+#else
+	mavlink_log_request_data_t *packet = (mavlink_log_request_data_t *)msgbuf;
+	packet->ofs = ofs;
+	packet->count = count;
+	packet->id = id;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_DATA, (const char *)packet, MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN, MAVLINK_MSG_ID_LOG_REQUEST_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_DATA, (const char *)packet, MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE LOG_REQUEST_DATA UNPACKING
+
+
+/**
+ * @brief Get field target_system from log_request_data message
+ *
+ * @return System ID
+ */
+static inline uint8_t mavlink_msg_log_request_data_get_target_system(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  10);
+}
+
+/**
+ * @brief Get field target_component from log_request_data message
+ *
+ * @return Component ID
+ */
+static inline uint8_t mavlink_msg_log_request_data_get_target_component(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  11);
+}
+
+/**
+ * @brief Get field id from log_request_data message
+ *
+ * @return Log id (from LOG_ENTRY reply)
+ */
+static inline uint16_t mavlink_msg_log_request_data_get_id(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  8);
+}
+
+/**
+ * @brief Get field ofs from log_request_data message
+ *
+ * @return Offset into the log
+ */
+static inline uint32_t mavlink_msg_log_request_data_get_ofs(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field count from log_request_data message
+ *
+ * @return Number of bytes
+ */
+static inline uint32_t mavlink_msg_log_request_data_get_count(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  4);
+}
+
+/**
+ * @brief Decode a log_request_data message into a struct
+ *
+ * @param msg The message to decode
+ * @param log_request_data C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_log_request_data_decode(const mavlink_message_t* msg, mavlink_log_request_data_t* log_request_data)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	log_request_data->ofs = mavlink_msg_log_request_data_get_ofs(msg);
+	log_request_data->count = mavlink_msg_log_request_data_get_count(msg);
+	log_request_data->id = mavlink_msg_log_request_data_get_id(msg);
+	log_request_data->target_system = mavlink_msg_log_request_data_get_target_system(msg);
+	log_request_data->target_component = mavlink_msg_log_request_data_get_target_component(msg);
+#else
+	memcpy(log_request_data, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_LOG_REQUEST_DATA_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_log_request_end.h v1.0/common/mavlink_msg_log_request_end.h
--- v1.0.old/common/mavlink_msg_log_request_end.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_log_request_end.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,233 @@
+// MESSAGE LOG_REQUEST_END PACKING
+
+#define MAVLINK_MSG_ID_LOG_REQUEST_END 122
+
+typedef struct __mavlink_log_request_end_t
+{
+ uint8_t target_system; ///< System ID
+ uint8_t target_component; ///< Component ID
+} mavlink_log_request_end_t;
+
+#define MAVLINK_MSG_ID_LOG_REQUEST_END_LEN 2
+#define MAVLINK_MSG_ID_122_LEN 2
+
+#define MAVLINK_MSG_ID_LOG_REQUEST_END_CRC 203
+#define MAVLINK_MSG_ID_122_CRC 203
+
+
+
+#define MAVLINK_MESSAGE_INFO_LOG_REQUEST_END { \
+	"LOG_REQUEST_END", \
+	2, \
+	{  { "target_system", NULL, MAVLINK_TYPE_UINT8_T, 0, 0, offsetof(mavlink_log_request_end_t, target_system) }, \
+         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_log_request_end_t, target_component) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a log_request_end message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_log_request_end_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint8_t target_system, uint8_t target_component)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_REQUEST_END_LEN];
+	_mav_put_uint8_t(buf, 0, target_system);
+	_mav_put_uint8_t(buf, 1, target_component);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOG_REQUEST_END_LEN);
+#else
+	mavlink_log_request_end_t packet;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOG_REQUEST_END_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_LOG_REQUEST_END;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOG_REQUEST_END_LEN, MAVLINK_MSG_ID_LOG_REQUEST_END_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOG_REQUEST_END_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a log_request_end message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_log_request_end_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint8_t target_system,uint8_t target_component)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_REQUEST_END_LEN];
+	_mav_put_uint8_t(buf, 0, target_system);
+	_mav_put_uint8_t(buf, 1, target_component);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOG_REQUEST_END_LEN);
+#else
+	mavlink_log_request_end_t packet;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOG_REQUEST_END_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_LOG_REQUEST_END;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOG_REQUEST_END_LEN, MAVLINK_MSG_ID_LOG_REQUEST_END_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOG_REQUEST_END_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a log_request_end struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param log_request_end C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_log_request_end_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_log_request_end_t* log_request_end)
+{
+	return mavlink_msg_log_request_end_pack(system_id, component_id, msg, log_request_end->target_system, log_request_end->target_component);
+}
+
+/**
+ * @brief Encode a log_request_end struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param log_request_end C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_log_request_end_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_log_request_end_t* log_request_end)
+{
+	return mavlink_msg_log_request_end_pack_chan(system_id, component_id, chan, msg, log_request_end->target_system, log_request_end->target_component);
+}
+
+/**
+ * @brief Send a log_request_end message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param target_system System ID
+ * @param target_component Component ID
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_log_request_end_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_REQUEST_END_LEN];
+	_mav_put_uint8_t(buf, 0, target_system);
+	_mav_put_uint8_t(buf, 1, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_END, buf, MAVLINK_MSG_ID_LOG_REQUEST_END_LEN, MAVLINK_MSG_ID_LOG_REQUEST_END_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_END, buf, MAVLINK_MSG_ID_LOG_REQUEST_END_LEN);
+#endif
+#else
+	mavlink_log_request_end_t packet;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_END, (const char *)&packet, MAVLINK_MSG_ID_LOG_REQUEST_END_LEN, MAVLINK_MSG_ID_LOG_REQUEST_END_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_END, (const char *)&packet, MAVLINK_MSG_ID_LOG_REQUEST_END_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_LOG_REQUEST_END_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_log_request_end_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint8_t(buf, 0, target_system);
+	_mav_put_uint8_t(buf, 1, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_END, buf, MAVLINK_MSG_ID_LOG_REQUEST_END_LEN, MAVLINK_MSG_ID_LOG_REQUEST_END_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_END, buf, MAVLINK_MSG_ID_LOG_REQUEST_END_LEN);
+#endif
+#else
+	mavlink_log_request_end_t *packet = (mavlink_log_request_end_t *)msgbuf;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_END, (const char *)packet, MAVLINK_MSG_ID_LOG_REQUEST_END_LEN, MAVLINK_MSG_ID_LOG_REQUEST_END_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_END, (const char *)packet, MAVLINK_MSG_ID_LOG_REQUEST_END_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE LOG_REQUEST_END UNPACKING
+
+
+/**
+ * @brief Get field target_system from log_request_end message
+ *
+ * @return System ID
+ */
+static inline uint8_t mavlink_msg_log_request_end_get_target_system(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  0);
+}
+
+/**
+ * @brief Get field target_component from log_request_end message
+ *
+ * @return Component ID
+ */
+static inline uint8_t mavlink_msg_log_request_end_get_target_component(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  1);
+}
+
+/**
+ * @brief Decode a log_request_end message into a struct
+ *
+ * @param msg The message to decode
+ * @param log_request_end C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_log_request_end_decode(const mavlink_message_t* msg, mavlink_log_request_end_t* log_request_end)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	log_request_end->target_system = mavlink_msg_log_request_end_get_target_system(msg);
+	log_request_end->target_component = mavlink_msg_log_request_end_get_target_component(msg);
+#else
+	memcpy(log_request_end, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_LOG_REQUEST_END_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_log_request_list.h v1.0/common/mavlink_msg_log_request_list.h
--- v1.0.old/common/mavlink_msg_log_request_list.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_log_request_list.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,281 @@
+// MESSAGE LOG_REQUEST_LIST PACKING
+
+#define MAVLINK_MSG_ID_LOG_REQUEST_LIST 117
+
+typedef struct __mavlink_log_request_list_t
+{
+ uint16_t start; ///< First log id (0 for first available)
+ uint16_t end; ///< Last log id (0xffff for last available)
+ uint8_t target_system; ///< System ID
+ uint8_t target_component; ///< Component ID
+} mavlink_log_request_list_t;
+
+#define MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN 6
+#define MAVLINK_MSG_ID_117_LEN 6
+
+#define MAVLINK_MSG_ID_LOG_REQUEST_LIST_CRC 128
+#define MAVLINK_MSG_ID_117_CRC 128
+
+
+
+#define MAVLINK_MESSAGE_INFO_LOG_REQUEST_LIST { \
+	"LOG_REQUEST_LIST", \
+	4, \
+	{  { "start", NULL, MAVLINK_TYPE_UINT16_T, 0, 0, offsetof(mavlink_log_request_list_t, start) }, \
+         { "end", NULL, MAVLINK_TYPE_UINT16_T, 0, 2, offsetof(mavlink_log_request_list_t, end) }, \
+         { "target_system", NULL, MAVLINK_TYPE_UINT8_T, 0, 4, offsetof(mavlink_log_request_list_t, target_system) }, \
+         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 5, offsetof(mavlink_log_request_list_t, target_component) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a log_request_list message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param start First log id (0 for first available)
+ * @param end Last log id (0xffff for last available)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_log_request_list_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint8_t target_system, uint8_t target_component, uint16_t start, uint16_t end)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN];
+	_mav_put_uint16_t(buf, 0, start);
+	_mav_put_uint16_t(buf, 2, end);
+	_mav_put_uint8_t(buf, 4, target_system);
+	_mav_put_uint8_t(buf, 5, target_component);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN);
+#else
+	mavlink_log_request_list_t packet;
+	packet.start = start;
+	packet.end = end;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_LOG_REQUEST_LIST;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN, MAVLINK_MSG_ID_LOG_REQUEST_LIST_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a log_request_list message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param start First log id (0 for first available)
+ * @param end Last log id (0xffff for last available)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_log_request_list_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint8_t target_system,uint8_t target_component,uint16_t start,uint16_t end)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN];
+	_mav_put_uint16_t(buf, 0, start);
+	_mav_put_uint16_t(buf, 2, end);
+	_mav_put_uint8_t(buf, 4, target_system);
+	_mav_put_uint8_t(buf, 5, target_component);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN);
+#else
+	mavlink_log_request_list_t packet;
+	packet.start = start;
+	packet.end = end;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_LOG_REQUEST_LIST;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN, MAVLINK_MSG_ID_LOG_REQUEST_LIST_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a log_request_list struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param log_request_list C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_log_request_list_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_log_request_list_t* log_request_list)
+{
+	return mavlink_msg_log_request_list_pack(system_id, component_id, msg, log_request_list->target_system, log_request_list->target_component, log_request_list->start, log_request_list->end);
+}
+
+/**
+ * @brief Encode a log_request_list struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param log_request_list C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_log_request_list_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_log_request_list_t* log_request_list)
+{
+	return mavlink_msg_log_request_list_pack_chan(system_id, component_id, chan, msg, log_request_list->target_system, log_request_list->target_component, log_request_list->start, log_request_list->end);
+}
+
+/**
+ * @brief Send a log_request_list message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param start First log id (0 for first available)
+ * @param end Last log id (0xffff for last available)
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_log_request_list_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, uint16_t start, uint16_t end)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN];
+	_mav_put_uint16_t(buf, 0, start);
+	_mav_put_uint16_t(buf, 2, end);
+	_mav_put_uint8_t(buf, 4, target_system);
+	_mav_put_uint8_t(buf, 5, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_LIST, buf, MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN, MAVLINK_MSG_ID_LOG_REQUEST_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_LIST, buf, MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN);
+#endif
+#else
+	mavlink_log_request_list_t packet;
+	packet.start = start;
+	packet.end = end;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_LIST, (const char *)&packet, MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN, MAVLINK_MSG_ID_LOG_REQUEST_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_LIST, (const char *)&packet, MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_log_request_list_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, uint16_t start, uint16_t end)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint16_t(buf, 0, start);
+	_mav_put_uint16_t(buf, 2, end);
+	_mav_put_uint8_t(buf, 4, target_system);
+	_mav_put_uint8_t(buf, 5, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_LIST, buf, MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN, MAVLINK_MSG_ID_LOG_REQUEST_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_LIST, buf, MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN);
+#endif
+#else
+	mavlink_log_request_list_t *packet = (mavlink_log_request_list_t *)msgbuf;
+	packet->start = start;
+	packet->end = end;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_LIST, (const char *)packet, MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN, MAVLINK_MSG_ID_LOG_REQUEST_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_LOG_REQUEST_LIST, (const char *)packet, MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE LOG_REQUEST_LIST UNPACKING
+
+
+/**
+ * @brief Get field target_system from log_request_list message
+ *
+ * @return System ID
+ */
+static inline uint8_t mavlink_msg_log_request_list_get_target_system(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  4);
+}
+
+/**
+ * @brief Get field target_component from log_request_list message
+ *
+ * @return Component ID
+ */
+static inline uint8_t mavlink_msg_log_request_list_get_target_component(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  5);
+}
+
+/**
+ * @brief Get field start from log_request_list message
+ *
+ * @return First log id (0 for first available)
+ */
+static inline uint16_t mavlink_msg_log_request_list_get_start(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  0);
+}
+
+/**
+ * @brief Get field end from log_request_list message
+ *
+ * @return Last log id (0xffff for last available)
+ */
+static inline uint16_t mavlink_msg_log_request_list_get_end(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  2);
+}
+
+/**
+ * @brief Decode a log_request_list message into a struct
+ *
+ * @param msg The message to decode
+ * @param log_request_list C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_log_request_list_decode(const mavlink_message_t* msg, mavlink_log_request_list_t* log_request_list)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	log_request_list->start = mavlink_msg_log_request_list_get_start(msg);
+	log_request_list->end = mavlink_msg_log_request_list_get_end(msg);
+	log_request_list->target_system = mavlink_msg_log_request_list_get_target_system(msg);
+	log_request_list->target_component = mavlink_msg_log_request_list_get_target_component(msg);
+#else
+	memcpy(log_request_list, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_LOG_REQUEST_LIST_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_manual_control.h v1.0/common/mavlink_msg_manual_control.h
--- v1.0.old/common/mavlink_msg_manual_control.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_manual_control.h	2015-02-06 11:50:58.000000000 +0500
@@ -4,34 +4,31 @@
 
 typedef struct __mavlink_manual_control_t
 {
- float roll; ///< roll
- float pitch; ///< pitch
- float yaw; ///< yaw
- float thrust; ///< thrust
- uint8_t target; ///< The system to be controlled
- uint8_t roll_manual; ///< roll control enabled auto:0, manual:1
- uint8_t pitch_manual; ///< pitch auto:0, manual:1
- uint8_t yaw_manual; ///< yaw auto:0, manual:1
- uint8_t thrust_manual; ///< thrust auto:0, manual:1
+ int16_t x; ///< X-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to forward(1000)-backward(-1000) movement on a joystick and the pitch of a vehicle.
+ int16_t y; ///< Y-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to left(-1000)-right(1000) movement on a joystick and the roll of a vehicle.
+ int16_t z; ///< Z-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a separate slider movement with maximum being 1000 and minimum being -1000 on a joystick and the thrust of a vehicle.
+ int16_t r; ///< R-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a twisting of the joystick, with counter-clockwise being 1000 and clockwise being -1000, and the yaw of a vehicle.
+ uint16_t buttons; ///< A bitfield corresponding to the joystick buttons' current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1.
+ uint8_t target; ///< The system to be controlled.
 } mavlink_manual_control_t;
 
-#define MAVLINK_MSG_ID_MANUAL_CONTROL_LEN 21
-#define MAVLINK_MSG_ID_69_LEN 21
+#define MAVLINK_MSG_ID_MANUAL_CONTROL_LEN 11
+#define MAVLINK_MSG_ID_69_LEN 11
+
+#define MAVLINK_MSG_ID_MANUAL_CONTROL_CRC 243
+#define MAVLINK_MSG_ID_69_CRC 243
 
 
 
 #define MAVLINK_MESSAGE_INFO_MANUAL_CONTROL { \
 	"MANUAL_CONTROL", \
-	9, \
-	{  { "roll", NULL, MAVLINK_TYPE_FLOAT, 0, 0, offsetof(mavlink_manual_control_t, roll) }, \
-         { "pitch", NULL, MAVLINK_TYPE_FLOAT, 0, 4, offsetof(mavlink_manual_control_t, pitch) }, \
-         { "yaw", NULL, MAVLINK_TYPE_FLOAT, 0, 8, offsetof(mavlink_manual_control_t, yaw) }, \
-         { "thrust", NULL, MAVLINK_TYPE_FLOAT, 0, 12, offsetof(mavlink_manual_control_t, thrust) }, \
-         { "target", NULL, MAVLINK_TYPE_UINT8_T, 0, 16, offsetof(mavlink_manual_control_t, target) }, \
-         { "roll_manual", NULL, MAVLINK_TYPE_UINT8_T, 0, 17, offsetof(mavlink_manual_control_t, roll_manual) }, \
-         { "pitch_manual", NULL, MAVLINK_TYPE_UINT8_T, 0, 18, offsetof(mavlink_manual_control_t, pitch_manual) }, \
-         { "yaw_manual", NULL, MAVLINK_TYPE_UINT8_T, 0, 19, offsetof(mavlink_manual_control_t, yaw_manual) }, \
-         { "thrust_manual", NULL, MAVLINK_TYPE_UINT8_T, 0, 20, offsetof(mavlink_manual_control_t, thrust_manual) }, \
+	6, \
+	{  { "x", NULL, MAVLINK_TYPE_INT16_T, 0, 0, offsetof(mavlink_manual_control_t, x) }, \
+         { "y", NULL, MAVLINK_TYPE_INT16_T, 0, 2, offsetof(mavlink_manual_control_t, y) }, \
+         { "z", NULL, MAVLINK_TYPE_INT16_T, 0, 4, offsetof(mavlink_manual_control_t, z) }, \
+         { "r", NULL, MAVLINK_TYPE_INT16_T, 0, 6, offsetof(mavlink_manual_control_t, r) }, \
+         { "buttons", NULL, MAVLINK_TYPE_UINT16_T, 0, 8, offsetof(mavlink_manual_control_t, buttons) }, \
+         { "target", NULL, MAVLINK_TYPE_UINT8_T, 0, 10, offsetof(mavlink_manual_control_t, target) }, \
          } \
 }
 
@@ -42,107 +39,97 @@ typedef struct __mavlink_manual_control_
  * @param component_id ID of this component (e.g. 200 for IMU)
  * @param msg The MAVLink message to compress the data into
  *
- * @param target The system to be controlled
- * @param roll roll
- * @param pitch pitch
- * @param yaw yaw
- * @param thrust thrust
- * @param roll_manual roll control enabled auto:0, manual:1
- * @param pitch_manual pitch auto:0, manual:1
- * @param yaw_manual yaw auto:0, manual:1
- * @param thrust_manual thrust auto:0, manual:1
+ * @param target The system to be controlled.
+ * @param x X-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to forward(1000)-backward(-1000) movement on a joystick and the pitch of a vehicle.
+ * @param y Y-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to left(-1000)-right(1000) movement on a joystick and the roll of a vehicle.
+ * @param z Z-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a separate slider movement with maximum being 1000 and minimum being -1000 on a joystick and the thrust of a vehicle.
+ * @param r R-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a twisting of the joystick, with counter-clockwise being 1000 and clockwise being -1000, and the yaw of a vehicle.
+ * @param buttons A bitfield corresponding to the joystick buttons' current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1.
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_manual_control_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
-						       uint8_t target, float roll, float pitch, float yaw, float thrust, uint8_t roll_manual, uint8_t pitch_manual, uint8_t yaw_manual, uint8_t thrust_manual)
+						       uint8_t target, int16_t x, int16_t y, int16_t z, int16_t r, uint16_t buttons)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[21];
-	_mav_put_float(buf, 0, roll);
-	_mav_put_float(buf, 4, pitch);
-	_mav_put_float(buf, 8, yaw);
-	_mav_put_float(buf, 12, thrust);
-	_mav_put_uint8_t(buf, 16, target);
-	_mav_put_uint8_t(buf, 17, roll_manual);
-	_mav_put_uint8_t(buf, 18, pitch_manual);
-	_mav_put_uint8_t(buf, 19, yaw_manual);
-	_mav_put_uint8_t(buf, 20, thrust_manual);
+	char buf[MAVLINK_MSG_ID_MANUAL_CONTROL_LEN];
+	_mav_put_int16_t(buf, 0, x);
+	_mav_put_int16_t(buf, 2, y);
+	_mav_put_int16_t(buf, 4, z);
+	_mav_put_int16_t(buf, 6, r);
+	_mav_put_uint16_t(buf, 8, buttons);
+	_mav_put_uint8_t(buf, 10, target);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 21);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MANUAL_CONTROL_LEN);
 #else
 	mavlink_manual_control_t packet;
-	packet.roll = roll;
-	packet.pitch = pitch;
-	packet.yaw = yaw;
-	packet.thrust = thrust;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.r = r;
+	packet.buttons = buttons;
 	packet.target = target;
-	packet.roll_manual = roll_manual;
-	packet.pitch_manual = pitch_manual;
-	packet.yaw_manual = yaw_manual;
-	packet.thrust_manual = thrust_manual;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 21);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MANUAL_CONTROL_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MANUAL_CONTROL;
-	return mavlink_finalize_message(msg, system_id, component_id, 21, 52);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MANUAL_CONTROL_LEN, MAVLINK_MSG_ID_MANUAL_CONTROL_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MANUAL_CONTROL_LEN);
+#endif
 }
 
 /**
  * @brief Pack a manual_control message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
- * @param target The system to be controlled
- * @param roll roll
- * @param pitch pitch
- * @param yaw yaw
- * @param thrust thrust
- * @param roll_manual roll control enabled auto:0, manual:1
- * @param pitch_manual pitch auto:0, manual:1
- * @param yaw_manual yaw auto:0, manual:1
- * @param thrust_manual thrust auto:0, manual:1
+ * @param target The system to be controlled.
+ * @param x X-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to forward(1000)-backward(-1000) movement on a joystick and the pitch of a vehicle.
+ * @param y Y-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to left(-1000)-right(1000) movement on a joystick and the roll of a vehicle.
+ * @param z Z-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a separate slider movement with maximum being 1000 and minimum being -1000 on a joystick and the thrust of a vehicle.
+ * @param r R-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a twisting of the joystick, with counter-clockwise being 1000 and clockwise being -1000, and the yaw of a vehicle.
+ * @param buttons A bitfield corresponding to the joystick buttons' current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1.
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_manual_control_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
 							   mavlink_message_t* msg,
-						           uint8_t target,float roll,float pitch,float yaw,float thrust,uint8_t roll_manual,uint8_t pitch_manual,uint8_t yaw_manual,uint8_t thrust_manual)
+						           uint8_t target,int16_t x,int16_t y,int16_t z,int16_t r,uint16_t buttons)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[21];
-	_mav_put_float(buf, 0, roll);
-	_mav_put_float(buf, 4, pitch);
-	_mav_put_float(buf, 8, yaw);
-	_mav_put_float(buf, 12, thrust);
-	_mav_put_uint8_t(buf, 16, target);
-	_mav_put_uint8_t(buf, 17, roll_manual);
-	_mav_put_uint8_t(buf, 18, pitch_manual);
-	_mav_put_uint8_t(buf, 19, yaw_manual);
-	_mav_put_uint8_t(buf, 20, thrust_manual);
+	char buf[MAVLINK_MSG_ID_MANUAL_CONTROL_LEN];
+	_mav_put_int16_t(buf, 0, x);
+	_mav_put_int16_t(buf, 2, y);
+	_mav_put_int16_t(buf, 4, z);
+	_mav_put_int16_t(buf, 6, r);
+	_mav_put_uint16_t(buf, 8, buttons);
+	_mav_put_uint8_t(buf, 10, target);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 21);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MANUAL_CONTROL_LEN);
 #else
 	mavlink_manual_control_t packet;
-	packet.roll = roll;
-	packet.pitch = pitch;
-	packet.yaw = yaw;
-	packet.thrust = thrust;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.r = r;
+	packet.buttons = buttons;
 	packet.target = target;
-	packet.roll_manual = roll_manual;
-	packet.pitch_manual = pitch_manual;
-	packet.yaw_manual = yaw_manual;
-	packet.thrust_manual = thrust_manual;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 21);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MANUAL_CONTROL_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MANUAL_CONTROL;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 21, 52);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MANUAL_CONTROL_LEN, MAVLINK_MSG_ID_MANUAL_CONTROL_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MANUAL_CONTROL_LEN);
+#endif
 }
 
 /**
- * @brief Encode a manual_control struct into a message
+ * @brief Encode a manual_control struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -151,56 +138,111 @@ static inline uint16_t mavlink_msg_manua
  */
 static inline uint16_t mavlink_msg_manual_control_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_manual_control_t* manual_control)
 {
-	return mavlink_msg_manual_control_pack(system_id, component_id, msg, manual_control->target, manual_control->roll, manual_control->pitch, manual_control->yaw, manual_control->thrust, manual_control->roll_manual, manual_control->pitch_manual, manual_control->yaw_manual, manual_control->thrust_manual);
+	return mavlink_msg_manual_control_pack(system_id, component_id, msg, manual_control->target, manual_control->x, manual_control->y, manual_control->z, manual_control->r, manual_control->buttons);
+}
+
+/**
+ * @brief Encode a manual_control struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param manual_control C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_manual_control_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_manual_control_t* manual_control)
+{
+	return mavlink_msg_manual_control_pack_chan(system_id, component_id, chan, msg, manual_control->target, manual_control->x, manual_control->y, manual_control->z, manual_control->r, manual_control->buttons);
 }
 
 /**
  * @brief Send a manual_control message
  * @param chan MAVLink channel to send the message
  *
- * @param target The system to be controlled
- * @param roll roll
- * @param pitch pitch
- * @param yaw yaw
- * @param thrust thrust
- * @param roll_manual roll control enabled auto:0, manual:1
- * @param pitch_manual pitch auto:0, manual:1
- * @param yaw_manual yaw auto:0, manual:1
- * @param thrust_manual thrust auto:0, manual:1
+ * @param target The system to be controlled.
+ * @param x X-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to forward(1000)-backward(-1000) movement on a joystick and the pitch of a vehicle.
+ * @param y Y-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to left(-1000)-right(1000) movement on a joystick and the roll of a vehicle.
+ * @param z Z-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a separate slider movement with maximum being 1000 and minimum being -1000 on a joystick and the thrust of a vehicle.
+ * @param r R-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a twisting of the joystick, with counter-clockwise being 1000 and clockwise being -1000, and the yaw of a vehicle.
+ * @param buttons A bitfield corresponding to the joystick buttons' current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1.
  */
 #ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
 
-static inline void mavlink_msg_manual_control_send(mavlink_channel_t chan, uint8_t target, float roll, float pitch, float yaw, float thrust, uint8_t roll_manual, uint8_t pitch_manual, uint8_t yaw_manual, uint8_t thrust_manual)
+static inline void mavlink_msg_manual_control_send(mavlink_channel_t chan, uint8_t target, int16_t x, int16_t y, int16_t z, int16_t r, uint16_t buttons)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[21];
-	_mav_put_float(buf, 0, roll);
-	_mav_put_float(buf, 4, pitch);
-	_mav_put_float(buf, 8, yaw);
-	_mav_put_float(buf, 12, thrust);
-	_mav_put_uint8_t(buf, 16, target);
-	_mav_put_uint8_t(buf, 17, roll_manual);
-	_mav_put_uint8_t(buf, 18, pitch_manual);
-	_mav_put_uint8_t(buf, 19, yaw_manual);
-	_mav_put_uint8_t(buf, 20, thrust_manual);
+	char buf[MAVLINK_MSG_ID_MANUAL_CONTROL_LEN];
+	_mav_put_int16_t(buf, 0, x);
+	_mav_put_int16_t(buf, 2, y);
+	_mav_put_int16_t(buf, 4, z);
+	_mav_put_int16_t(buf, 6, r);
+	_mav_put_uint16_t(buf, 8, buttons);
+	_mav_put_uint8_t(buf, 10, target);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_CONTROL, buf, 21, 52);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_CONTROL, buf, MAVLINK_MSG_ID_MANUAL_CONTROL_LEN, MAVLINK_MSG_ID_MANUAL_CONTROL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_CONTROL, buf, MAVLINK_MSG_ID_MANUAL_CONTROL_LEN);
+#endif
 #else
 	mavlink_manual_control_t packet;
-	packet.roll = roll;
-	packet.pitch = pitch;
-	packet.yaw = yaw;
-	packet.thrust = thrust;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.r = r;
+	packet.buttons = buttons;
 	packet.target = target;
-	packet.roll_manual = roll_manual;
-	packet.pitch_manual = pitch_manual;
-	packet.yaw_manual = yaw_manual;
-	packet.thrust_manual = thrust_manual;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_CONTROL, (const char *)&packet, 21, 52);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_CONTROL, (const char *)&packet, MAVLINK_MSG_ID_MANUAL_CONTROL_LEN, MAVLINK_MSG_ID_MANUAL_CONTROL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_CONTROL, (const char *)&packet, MAVLINK_MSG_ID_MANUAL_CONTROL_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_MANUAL_CONTROL_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_manual_control_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target, int16_t x, int16_t y, int16_t z, int16_t r, uint16_t buttons)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_int16_t(buf, 0, x);
+	_mav_put_int16_t(buf, 2, y);
+	_mav_put_int16_t(buf, 4, z);
+	_mav_put_int16_t(buf, 6, r);
+	_mav_put_uint16_t(buf, 8, buttons);
+	_mav_put_uint8_t(buf, 10, target);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_CONTROL, buf, MAVLINK_MSG_ID_MANUAL_CONTROL_LEN, MAVLINK_MSG_ID_MANUAL_CONTROL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_CONTROL, buf, MAVLINK_MSG_ID_MANUAL_CONTROL_LEN);
+#endif
+#else
+	mavlink_manual_control_t *packet = (mavlink_manual_control_t *)msgbuf;
+	packet->x = x;
+	packet->y = y;
+	packet->z = z;
+	packet->r = r;
+	packet->buttons = buttons;
+	packet->target = target;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_CONTROL, (const char *)packet, MAVLINK_MSG_ID_MANUAL_CONTROL_LEN, MAVLINK_MSG_ID_MANUAL_CONTROL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_CONTROL, (const char *)packet, MAVLINK_MSG_ID_MANUAL_CONTROL_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE MANUAL_CONTROL UNPACKING
@@ -209,91 +251,61 @@ static inline void mavlink_msg_manual_co
 /**
  * @brief Get field target from manual_control message
  *
- * @return The system to be controlled
+ * @return The system to be controlled.
  */
 static inline uint8_t mavlink_msg_manual_control_get_target(const mavlink_message_t* msg)
 {
-	return _MAV_RETURN_uint8_t(msg,  16);
-}
-
-/**
- * @brief Get field roll from manual_control message
- *
- * @return roll
- */
-static inline float mavlink_msg_manual_control_get_roll(const mavlink_message_t* msg)
-{
-	return _MAV_RETURN_float(msg,  0);
-}
-
-/**
- * @brief Get field pitch from manual_control message
- *
- * @return pitch
- */
-static inline float mavlink_msg_manual_control_get_pitch(const mavlink_message_t* msg)
-{
-	return _MAV_RETURN_float(msg,  4);
-}
-
-/**
- * @brief Get field yaw from manual_control message
- *
- * @return yaw
- */
-static inline float mavlink_msg_manual_control_get_yaw(const mavlink_message_t* msg)
-{
-	return _MAV_RETURN_float(msg,  8);
+	return _MAV_RETURN_uint8_t(msg,  10);
 }
 
 /**
- * @brief Get field thrust from manual_control message
+ * @brief Get field x from manual_control message
  *
- * @return thrust
+ * @return X-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to forward(1000)-backward(-1000) movement on a joystick and the pitch of a vehicle.
  */
-static inline float mavlink_msg_manual_control_get_thrust(const mavlink_message_t* msg)
+static inline int16_t mavlink_msg_manual_control_get_x(const mavlink_message_t* msg)
 {
-	return _MAV_RETURN_float(msg,  12);
+	return _MAV_RETURN_int16_t(msg,  0);
 }
 
 /**
- * @brief Get field roll_manual from manual_control message
+ * @brief Get field y from manual_control message
  *
- * @return roll control enabled auto:0, manual:1
+ * @return Y-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to left(-1000)-right(1000) movement on a joystick and the roll of a vehicle.
  */
-static inline uint8_t mavlink_msg_manual_control_get_roll_manual(const mavlink_message_t* msg)
+static inline int16_t mavlink_msg_manual_control_get_y(const mavlink_message_t* msg)
 {
-	return _MAV_RETURN_uint8_t(msg,  17);
+	return _MAV_RETURN_int16_t(msg,  2);
 }
 
 /**
- * @brief Get field pitch_manual from manual_control message
+ * @brief Get field z from manual_control message
  *
- * @return pitch auto:0, manual:1
+ * @return Z-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a separate slider movement with maximum being 1000 and minimum being -1000 on a joystick and the thrust of a vehicle.
  */
-static inline uint8_t mavlink_msg_manual_control_get_pitch_manual(const mavlink_message_t* msg)
+static inline int16_t mavlink_msg_manual_control_get_z(const mavlink_message_t* msg)
 {
-	return _MAV_RETURN_uint8_t(msg,  18);
+	return _MAV_RETURN_int16_t(msg,  4);
 }
 
 /**
- * @brief Get field yaw_manual from manual_control message
+ * @brief Get field r from manual_control message
  *
- * @return yaw auto:0, manual:1
+ * @return R-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a twisting of the joystick, with counter-clockwise being 1000 and clockwise being -1000, and the yaw of a vehicle.
  */
-static inline uint8_t mavlink_msg_manual_control_get_yaw_manual(const mavlink_message_t* msg)
+static inline int16_t mavlink_msg_manual_control_get_r(const mavlink_message_t* msg)
 {
-	return _MAV_RETURN_uint8_t(msg,  19);
+	return _MAV_RETURN_int16_t(msg,  6);
 }
 
 /**
- * @brief Get field thrust_manual from manual_control message
+ * @brief Get field buttons from manual_control message
  *
- * @return thrust auto:0, manual:1
+ * @return A bitfield corresponding to the joystick buttons' current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1.
  */
-static inline uint8_t mavlink_msg_manual_control_get_thrust_manual(const mavlink_message_t* msg)
+static inline uint16_t mavlink_msg_manual_control_get_buttons(const mavlink_message_t* msg)
 {
-	return _MAV_RETURN_uint8_t(msg,  20);
+	return _MAV_RETURN_uint16_t(msg,  8);
 }
 
 /**
@@ -305,16 +317,13 @@ static inline uint8_t mavlink_msg_manual
 static inline void mavlink_msg_manual_control_decode(const mavlink_message_t* msg, mavlink_manual_control_t* manual_control)
 {
 #if MAVLINK_NEED_BYTE_SWAP
-	manual_control->roll = mavlink_msg_manual_control_get_roll(msg);
-	manual_control->pitch = mavlink_msg_manual_control_get_pitch(msg);
-	manual_control->yaw = mavlink_msg_manual_control_get_yaw(msg);
-	manual_control->thrust = mavlink_msg_manual_control_get_thrust(msg);
+	manual_control->x = mavlink_msg_manual_control_get_x(msg);
+	manual_control->y = mavlink_msg_manual_control_get_y(msg);
+	manual_control->z = mavlink_msg_manual_control_get_z(msg);
+	manual_control->r = mavlink_msg_manual_control_get_r(msg);
+	manual_control->buttons = mavlink_msg_manual_control_get_buttons(msg);
 	manual_control->target = mavlink_msg_manual_control_get_target(msg);
-	manual_control->roll_manual = mavlink_msg_manual_control_get_roll_manual(msg);
-	manual_control->pitch_manual = mavlink_msg_manual_control_get_pitch_manual(msg);
-	manual_control->yaw_manual = mavlink_msg_manual_control_get_yaw_manual(msg);
-	manual_control->thrust_manual = mavlink_msg_manual_control_get_thrust_manual(msg);
 #else
-	memcpy(manual_control, _MAV_PAYLOAD(msg), 21);
+	memcpy(manual_control, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MANUAL_CONTROL_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_manual_setpoint.h v1.0/common/mavlink_msg_manual_setpoint.h
--- v1.0.old/common/mavlink_msg_manual_setpoint.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_manual_setpoint.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,353 @@
+// MESSAGE MANUAL_SETPOINT PACKING
+
+#define MAVLINK_MSG_ID_MANUAL_SETPOINT 81
+
+typedef struct __mavlink_manual_setpoint_t
+{
+ uint32_t time_boot_ms; ///< Timestamp in milliseconds since system boot
+ float roll; ///< Desired roll rate in radians per second
+ float pitch; ///< Desired pitch rate in radians per second
+ float yaw; ///< Desired yaw rate in radians per second
+ float thrust; ///< Collective thrust, normalized to 0 .. 1
+ uint8_t mode_switch; ///< Flight mode switch position, 0.. 255
+ uint8_t manual_override_switch; ///< Override mode switch position, 0.. 255
+} mavlink_manual_setpoint_t;
+
+#define MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN 22
+#define MAVLINK_MSG_ID_81_LEN 22
+
+#define MAVLINK_MSG_ID_MANUAL_SETPOINT_CRC 106
+#define MAVLINK_MSG_ID_81_CRC 106
+
+
+
+#define MAVLINK_MESSAGE_INFO_MANUAL_SETPOINT { \
+	"MANUAL_SETPOINT", \
+	7, \
+	{  { "time_boot_ms", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_manual_setpoint_t, time_boot_ms) }, \
+         { "roll", NULL, MAVLINK_TYPE_FLOAT, 0, 4, offsetof(mavlink_manual_setpoint_t, roll) }, \
+         { "pitch", NULL, MAVLINK_TYPE_FLOAT, 0, 8, offsetof(mavlink_manual_setpoint_t, pitch) }, \
+         { "yaw", NULL, MAVLINK_TYPE_FLOAT, 0, 12, offsetof(mavlink_manual_setpoint_t, yaw) }, \
+         { "thrust", NULL, MAVLINK_TYPE_FLOAT, 0, 16, offsetof(mavlink_manual_setpoint_t, thrust) }, \
+         { "mode_switch", NULL, MAVLINK_TYPE_UINT8_T, 0, 20, offsetof(mavlink_manual_setpoint_t, mode_switch) }, \
+         { "manual_override_switch", NULL, MAVLINK_TYPE_UINT8_T, 0, 21, offsetof(mavlink_manual_setpoint_t, manual_override_switch) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a manual_setpoint message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_boot_ms Timestamp in milliseconds since system boot
+ * @param roll Desired roll rate in radians per second
+ * @param pitch Desired pitch rate in radians per second
+ * @param yaw Desired yaw rate in radians per second
+ * @param thrust Collective thrust, normalized to 0 .. 1
+ * @param mode_switch Flight mode switch position, 0.. 255
+ * @param manual_override_switch Override mode switch position, 0.. 255
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_manual_setpoint_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint32_t time_boot_ms, float roll, float pitch, float yaw, float thrust, uint8_t mode_switch, uint8_t manual_override_switch)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, roll);
+	_mav_put_float(buf, 8, pitch);
+	_mav_put_float(buf, 12, yaw);
+	_mav_put_float(buf, 16, thrust);
+	_mav_put_uint8_t(buf, 20, mode_switch);
+	_mav_put_uint8_t(buf, 21, manual_override_switch);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN);
+#else
+	mavlink_manual_setpoint_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.roll = roll;
+	packet.pitch = pitch;
+	packet.yaw = yaw;
+	packet.thrust = thrust;
+	packet.mode_switch = mode_switch;
+	packet.manual_override_switch = manual_override_switch;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_MANUAL_SETPOINT;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN, MAVLINK_MSG_ID_MANUAL_SETPOINT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a manual_setpoint message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_boot_ms Timestamp in milliseconds since system boot
+ * @param roll Desired roll rate in radians per second
+ * @param pitch Desired pitch rate in radians per second
+ * @param yaw Desired yaw rate in radians per second
+ * @param thrust Collective thrust, normalized to 0 .. 1
+ * @param mode_switch Flight mode switch position, 0.. 255
+ * @param manual_override_switch Override mode switch position, 0.. 255
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_manual_setpoint_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint32_t time_boot_ms,float roll,float pitch,float yaw,float thrust,uint8_t mode_switch,uint8_t manual_override_switch)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, roll);
+	_mav_put_float(buf, 8, pitch);
+	_mav_put_float(buf, 12, yaw);
+	_mav_put_float(buf, 16, thrust);
+	_mav_put_uint8_t(buf, 20, mode_switch);
+	_mav_put_uint8_t(buf, 21, manual_override_switch);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN);
+#else
+	mavlink_manual_setpoint_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.roll = roll;
+	packet.pitch = pitch;
+	packet.yaw = yaw;
+	packet.thrust = thrust;
+	packet.mode_switch = mode_switch;
+	packet.manual_override_switch = manual_override_switch;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_MANUAL_SETPOINT;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN, MAVLINK_MSG_ID_MANUAL_SETPOINT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a manual_setpoint struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param manual_setpoint C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_manual_setpoint_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_manual_setpoint_t* manual_setpoint)
+{
+	return mavlink_msg_manual_setpoint_pack(system_id, component_id, msg, manual_setpoint->time_boot_ms, manual_setpoint->roll, manual_setpoint->pitch, manual_setpoint->yaw, manual_setpoint->thrust, manual_setpoint->mode_switch, manual_setpoint->manual_override_switch);
+}
+
+/**
+ * @brief Encode a manual_setpoint struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param manual_setpoint C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_manual_setpoint_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_manual_setpoint_t* manual_setpoint)
+{
+	return mavlink_msg_manual_setpoint_pack_chan(system_id, component_id, chan, msg, manual_setpoint->time_boot_ms, manual_setpoint->roll, manual_setpoint->pitch, manual_setpoint->yaw, manual_setpoint->thrust, manual_setpoint->mode_switch, manual_setpoint->manual_override_switch);
+}
+
+/**
+ * @brief Send a manual_setpoint message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_boot_ms Timestamp in milliseconds since system boot
+ * @param roll Desired roll rate in radians per second
+ * @param pitch Desired pitch rate in radians per second
+ * @param yaw Desired yaw rate in radians per second
+ * @param thrust Collective thrust, normalized to 0 .. 1
+ * @param mode_switch Flight mode switch position, 0.. 255
+ * @param manual_override_switch Override mode switch position, 0.. 255
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_manual_setpoint_send(mavlink_channel_t chan, uint32_t time_boot_ms, float roll, float pitch, float yaw, float thrust, uint8_t mode_switch, uint8_t manual_override_switch)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, roll);
+	_mav_put_float(buf, 8, pitch);
+	_mav_put_float(buf, 12, yaw);
+	_mav_put_float(buf, 16, thrust);
+	_mav_put_uint8_t(buf, 20, mode_switch);
+	_mav_put_uint8_t(buf, 21, manual_override_switch);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_SETPOINT, buf, MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN, MAVLINK_MSG_ID_MANUAL_SETPOINT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_SETPOINT, buf, MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN);
+#endif
+#else
+	mavlink_manual_setpoint_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.roll = roll;
+	packet.pitch = pitch;
+	packet.yaw = yaw;
+	packet.thrust = thrust;
+	packet.mode_switch = mode_switch;
+	packet.manual_override_switch = manual_override_switch;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_SETPOINT, (const char *)&packet, MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN, MAVLINK_MSG_ID_MANUAL_SETPOINT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_SETPOINT, (const char *)&packet, MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_manual_setpoint_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, float roll, float pitch, float yaw, float thrust, uint8_t mode_switch, uint8_t manual_override_switch)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, roll);
+	_mav_put_float(buf, 8, pitch);
+	_mav_put_float(buf, 12, yaw);
+	_mav_put_float(buf, 16, thrust);
+	_mav_put_uint8_t(buf, 20, mode_switch);
+	_mav_put_uint8_t(buf, 21, manual_override_switch);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_SETPOINT, buf, MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN, MAVLINK_MSG_ID_MANUAL_SETPOINT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_SETPOINT, buf, MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN);
+#endif
+#else
+	mavlink_manual_setpoint_t *packet = (mavlink_manual_setpoint_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->roll = roll;
+	packet->pitch = pitch;
+	packet->yaw = yaw;
+	packet->thrust = thrust;
+	packet->mode_switch = mode_switch;
+	packet->manual_override_switch = manual_override_switch;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_SETPOINT, (const char *)packet, MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN, MAVLINK_MSG_ID_MANUAL_SETPOINT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MANUAL_SETPOINT, (const char *)packet, MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE MANUAL_SETPOINT UNPACKING
+
+
+/**
+ * @brief Get field time_boot_ms from manual_setpoint message
+ *
+ * @return Timestamp in milliseconds since system boot
+ */
+static inline uint32_t mavlink_msg_manual_setpoint_get_time_boot_ms(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field roll from manual_setpoint message
+ *
+ * @return Desired roll rate in radians per second
+ */
+static inline float mavlink_msg_manual_setpoint_get_roll(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  4);
+}
+
+/**
+ * @brief Get field pitch from manual_setpoint message
+ *
+ * @return Desired pitch rate in radians per second
+ */
+static inline float mavlink_msg_manual_setpoint_get_pitch(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  8);
+}
+
+/**
+ * @brief Get field yaw from manual_setpoint message
+ *
+ * @return Desired yaw rate in radians per second
+ */
+static inline float mavlink_msg_manual_setpoint_get_yaw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  12);
+}
+
+/**
+ * @brief Get field thrust from manual_setpoint message
+ *
+ * @return Collective thrust, normalized to 0 .. 1
+ */
+static inline float mavlink_msg_manual_setpoint_get_thrust(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  16);
+}
+
+/**
+ * @brief Get field mode_switch from manual_setpoint message
+ *
+ * @return Flight mode switch position, 0.. 255
+ */
+static inline uint8_t mavlink_msg_manual_setpoint_get_mode_switch(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  20);
+}
+
+/**
+ * @brief Get field manual_override_switch from manual_setpoint message
+ *
+ * @return Override mode switch position, 0.. 255
+ */
+static inline uint8_t mavlink_msg_manual_setpoint_get_manual_override_switch(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  21);
+}
+
+/**
+ * @brief Decode a manual_setpoint message into a struct
+ *
+ * @param msg The message to decode
+ * @param manual_setpoint C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_manual_setpoint_decode(const mavlink_message_t* msg, mavlink_manual_setpoint_t* manual_setpoint)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	manual_setpoint->time_boot_ms = mavlink_msg_manual_setpoint_get_time_boot_ms(msg);
+	manual_setpoint->roll = mavlink_msg_manual_setpoint_get_roll(msg);
+	manual_setpoint->pitch = mavlink_msg_manual_setpoint_get_pitch(msg);
+	manual_setpoint->yaw = mavlink_msg_manual_setpoint_get_yaw(msg);
+	manual_setpoint->thrust = mavlink_msg_manual_setpoint_get_thrust(msg);
+	manual_setpoint->mode_switch = mavlink_msg_manual_setpoint_get_mode_switch(msg);
+	manual_setpoint->manual_override_switch = mavlink_msg_manual_setpoint_get_manual_override_switch(msg);
+#else
+	memcpy(manual_setpoint, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MANUAL_SETPOINT_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_memory_vect.h v1.0/common/mavlink_msg_memory_vect.h
--- v1.0.old/common/mavlink_msg_memory_vect.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_memory_vect.h	2015-02-06 11:50:58.000000000 +0500
@@ -13,6 +13,9 @@ typedef struct __mavlink_memory_vect_t
 #define MAVLINK_MSG_ID_MEMORY_VECT_LEN 36
 #define MAVLINK_MSG_ID_249_LEN 36
 
+#define MAVLINK_MSG_ID_MEMORY_VECT_CRC 204
+#define MAVLINK_MSG_ID_249_CRC 204
+
 #define MAVLINK_MSG_MEMORY_VECT_FIELD_VALUE_LEN 32
 
 #define MAVLINK_MESSAGE_INFO_MEMORY_VECT { \
@@ -42,30 +45,34 @@ static inline uint16_t mavlink_msg_memor
 						       uint16_t address, uint8_t ver, uint8_t type, const int8_t *value)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[36];
+	char buf[MAVLINK_MSG_ID_MEMORY_VECT_LEN];
 	_mav_put_uint16_t(buf, 0, address);
 	_mav_put_uint8_t(buf, 2, ver);
 	_mav_put_uint8_t(buf, 3, type);
 	_mav_put_int8_t_array(buf, 4, value, 32);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 36);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MEMORY_VECT_LEN);
 #else
 	mavlink_memory_vect_t packet;
 	packet.address = address;
 	packet.ver = ver;
 	packet.type = type;
 	mav_array_memcpy(packet.value, value, sizeof(int8_t)*32);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 36);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MEMORY_VECT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MEMORY_VECT;
-	return mavlink_finalize_message(msg, system_id, component_id, 36, 204);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MEMORY_VECT_LEN, MAVLINK_MSG_ID_MEMORY_VECT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MEMORY_VECT_LEN);
+#endif
 }
 
 /**
  * @brief Pack a memory_vect message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param address Starting address of the debug variables
  * @param ver Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below
@@ -78,27 +85,31 @@ static inline uint16_t mavlink_msg_memor
 						           uint16_t address,uint8_t ver,uint8_t type,const int8_t *value)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[36];
+	char buf[MAVLINK_MSG_ID_MEMORY_VECT_LEN];
 	_mav_put_uint16_t(buf, 0, address);
 	_mav_put_uint8_t(buf, 2, ver);
 	_mav_put_uint8_t(buf, 3, type);
 	_mav_put_int8_t_array(buf, 4, value, 32);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 36);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MEMORY_VECT_LEN);
 #else
 	mavlink_memory_vect_t packet;
 	packet.address = address;
 	packet.ver = ver;
 	packet.type = type;
 	mav_array_memcpy(packet.value, value, sizeof(int8_t)*32);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 36);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MEMORY_VECT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MEMORY_VECT;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 36, 204);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MEMORY_VECT_LEN, MAVLINK_MSG_ID_MEMORY_VECT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MEMORY_VECT_LEN);
+#endif
 }
 
 /**
- * @brief Encode a memory_vect struct into a message
+ * @brief Encode a memory_vect struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -111,6 +122,20 @@ static inline uint16_t mavlink_msg_memor
 }
 
 /**
+ * @brief Encode a memory_vect struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param memory_vect C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_memory_vect_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_memory_vect_t* memory_vect)
+{
+	return mavlink_msg_memory_vect_pack_chan(system_id, component_id, chan, msg, memory_vect->address, memory_vect->ver, memory_vect->type, memory_vect->value);
+}
+
+/**
  * @brief Send a memory_vect message
  * @param chan MAVLink channel to send the message
  *
@@ -124,22 +149,66 @@ static inline uint16_t mavlink_msg_memor
 static inline void mavlink_msg_memory_vect_send(mavlink_channel_t chan, uint16_t address, uint8_t ver, uint8_t type, const int8_t *value)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[36];
+	char buf[MAVLINK_MSG_ID_MEMORY_VECT_LEN];
 	_mav_put_uint16_t(buf, 0, address);
 	_mav_put_uint8_t(buf, 2, ver);
 	_mav_put_uint8_t(buf, 3, type);
 	_mav_put_int8_t_array(buf, 4, value, 32);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MEMORY_VECT, buf, 36, 204);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MEMORY_VECT, buf, MAVLINK_MSG_ID_MEMORY_VECT_LEN, MAVLINK_MSG_ID_MEMORY_VECT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MEMORY_VECT, buf, MAVLINK_MSG_ID_MEMORY_VECT_LEN);
+#endif
 #else
 	mavlink_memory_vect_t packet;
 	packet.address = address;
 	packet.ver = ver;
 	packet.type = type;
 	mav_array_memcpy(packet.value, value, sizeof(int8_t)*32);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MEMORY_VECT, (const char *)&packet, 36, 204);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MEMORY_VECT, (const char *)&packet, MAVLINK_MSG_ID_MEMORY_VECT_LEN, MAVLINK_MSG_ID_MEMORY_VECT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MEMORY_VECT, (const char *)&packet, MAVLINK_MSG_ID_MEMORY_VECT_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_MEMORY_VECT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_memory_vect_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint16_t address, uint8_t ver, uint8_t type, const int8_t *value)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint16_t(buf, 0, address);
+	_mav_put_uint8_t(buf, 2, ver);
+	_mav_put_uint8_t(buf, 3, type);
+	_mav_put_int8_t_array(buf, 4, value, 32);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MEMORY_VECT, buf, MAVLINK_MSG_ID_MEMORY_VECT_LEN, MAVLINK_MSG_ID_MEMORY_VECT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MEMORY_VECT, buf, MAVLINK_MSG_ID_MEMORY_VECT_LEN);
+#endif
+#else
+	mavlink_memory_vect_t *packet = (mavlink_memory_vect_t *)msgbuf;
+	packet->address = address;
+	packet->ver = ver;
+	packet->type = type;
+	mav_array_memcpy(packet->value, value, sizeof(int8_t)*32);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MEMORY_VECT, (const char *)packet, MAVLINK_MSG_ID_MEMORY_VECT_LEN, MAVLINK_MSG_ID_MEMORY_VECT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MEMORY_VECT, (const char *)packet, MAVLINK_MSG_ID_MEMORY_VECT_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE MEMORY_VECT UNPACKING
@@ -199,6 +268,6 @@ static inline void mavlink_msg_memory_ve
 	memory_vect->type = mavlink_msg_memory_vect_get_type(msg);
 	mavlink_msg_memory_vect_get_value(msg, memory_vect->value);
 #else
-	memcpy(memory_vect, _MAV_PAYLOAD(msg), 36);
+	memcpy(memory_vect, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MEMORY_VECT_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_mission_ack.h v1.0/common/mavlink_msg_mission_ack.h
--- v1.0.old/common/mavlink_msg_mission_ack.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_mission_ack.h	2015-02-06 11:50:58.000000000 +0500
@@ -12,6 +12,9 @@ typedef struct __mavlink_mission_ack_t
 #define MAVLINK_MSG_ID_MISSION_ACK_LEN 3
 #define MAVLINK_MSG_ID_47_LEN 3
 
+#define MAVLINK_MSG_ID_MISSION_ACK_CRC 153
+#define MAVLINK_MSG_ID_47_CRC 153
+
 
 
 #define MAVLINK_MESSAGE_INFO_MISSION_ACK { \
@@ -39,30 +42,34 @@ static inline uint16_t mavlink_msg_missi
 						       uint8_t target_system, uint8_t target_component, uint8_t type)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[3];
+	char buf[MAVLINK_MSG_ID_MISSION_ACK_LEN];
 	_mav_put_uint8_t(buf, 0, target_system);
 	_mav_put_uint8_t(buf, 1, target_component);
 	_mav_put_uint8_t(buf, 2, type);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 3);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_ACK_LEN);
 #else
 	mavlink_mission_ack_t packet;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 	packet.type = type;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 3);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_ACK_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_ACK;
-	return mavlink_finalize_message(msg, system_id, component_id, 3, 153);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_ACK_LEN, MAVLINK_MSG_ID_MISSION_ACK_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_ACK_LEN);
+#endif
 }
 
 /**
  * @brief Pack a mission_ack message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system System ID
  * @param target_component Component ID
@@ -74,27 +81,31 @@ static inline uint16_t mavlink_msg_missi
 						           uint8_t target_system,uint8_t target_component,uint8_t type)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[3];
+	char buf[MAVLINK_MSG_ID_MISSION_ACK_LEN];
 	_mav_put_uint8_t(buf, 0, target_system);
 	_mav_put_uint8_t(buf, 1, target_component);
 	_mav_put_uint8_t(buf, 2, type);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 3);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_ACK_LEN);
 #else
 	mavlink_mission_ack_t packet;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 	packet.type = type;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 3);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_ACK_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_ACK;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 3, 153);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_ACK_LEN, MAVLINK_MSG_ID_MISSION_ACK_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_ACK_LEN);
+#endif
 }
 
 /**
- * @brief Encode a mission_ack struct into a message
+ * @brief Encode a mission_ack struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -107,6 +118,20 @@ static inline uint16_t mavlink_msg_missi
 }
 
 /**
+ * @brief Encode a mission_ack struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param mission_ack C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_mission_ack_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_mission_ack_t* mission_ack)
+{
+	return mavlink_msg_mission_ack_pack_chan(system_id, component_id, chan, msg, mission_ack->target_system, mission_ack->target_component, mission_ack->type);
+}
+
+/**
  * @brief Send a mission_ack message
  * @param chan MAVLink channel to send the message
  *
@@ -119,21 +144,65 @@ static inline uint16_t mavlink_msg_missi
 static inline void mavlink_msg_mission_ack_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, uint8_t type)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[3];
+	char buf[MAVLINK_MSG_ID_MISSION_ACK_LEN];
 	_mav_put_uint8_t(buf, 0, target_system);
 	_mav_put_uint8_t(buf, 1, target_component);
 	_mav_put_uint8_t(buf, 2, type);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ACK, buf, 3, 153);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ACK, buf, MAVLINK_MSG_ID_MISSION_ACK_LEN, MAVLINK_MSG_ID_MISSION_ACK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ACK, buf, MAVLINK_MSG_ID_MISSION_ACK_LEN);
+#endif
 #else
 	mavlink_mission_ack_t packet;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 	packet.type = type;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ACK, (const char *)&packet, 3, 153);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ACK, (const char *)&packet, MAVLINK_MSG_ID_MISSION_ACK_LEN, MAVLINK_MSG_ID_MISSION_ACK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ACK, (const char *)&packet, MAVLINK_MSG_ID_MISSION_ACK_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_MISSION_ACK_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_mission_ack_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, uint8_t type)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint8_t(buf, 0, target_system);
+	_mav_put_uint8_t(buf, 1, target_component);
+	_mav_put_uint8_t(buf, 2, type);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ACK, buf, MAVLINK_MSG_ID_MISSION_ACK_LEN, MAVLINK_MSG_ID_MISSION_ACK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ACK, buf, MAVLINK_MSG_ID_MISSION_ACK_LEN);
+#endif
+#else
+	mavlink_mission_ack_t *packet = (mavlink_mission_ack_t *)msgbuf;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+	packet->type = type;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ACK, (const char *)packet, MAVLINK_MSG_ID_MISSION_ACK_LEN, MAVLINK_MSG_ID_MISSION_ACK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ACK, (const char *)packet, MAVLINK_MSG_ID_MISSION_ACK_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -183,6 +252,6 @@ static inline void mavlink_msg_mission_a
 	mission_ack->target_component = mavlink_msg_mission_ack_get_target_component(msg);
 	mission_ack->type = mavlink_msg_mission_ack_get_type(msg);
 #else
-	memcpy(mission_ack, _MAV_PAYLOAD(msg), 3);
+	memcpy(mission_ack, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MISSION_ACK_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_mission_clear_all.h v1.0/common/mavlink_msg_mission_clear_all.h
--- v1.0.old/common/mavlink_msg_mission_clear_all.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_mission_clear_all.h	2015-02-06 11:50:58.000000000 +0500
@@ -11,6 +11,9 @@ typedef struct __mavlink_mission_clear_a
 #define MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN 2
 #define MAVLINK_MSG_ID_45_LEN 2
 
+#define MAVLINK_MSG_ID_MISSION_CLEAR_ALL_CRC 232
+#define MAVLINK_MSG_ID_45_CRC 232
+
 
 
 #define MAVLINK_MESSAGE_INFO_MISSION_CLEAR_ALL { \
@@ -36,28 +39,32 @@ static inline uint16_t mavlink_msg_missi
 						       uint8_t target_system, uint8_t target_component)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[2];
+	char buf[MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN];
 	_mav_put_uint8_t(buf, 0, target_system);
 	_mav_put_uint8_t(buf, 1, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN);
 #else
 	mavlink_mission_clear_all_t packet;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_CLEAR_ALL;
-	return mavlink_finalize_message(msg, system_id, component_id, 2, 232);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN);
+#endif
 }
 
 /**
  * @brief Pack a mission_clear_all message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system System ID
  * @param target_component Component ID
@@ -68,25 +75,29 @@ static inline uint16_t mavlink_msg_missi
 						           uint8_t target_system,uint8_t target_component)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[2];
+	char buf[MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN];
 	_mav_put_uint8_t(buf, 0, target_system);
 	_mav_put_uint8_t(buf, 1, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN);
 #else
 	mavlink_mission_clear_all_t packet;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_CLEAR_ALL;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 2, 232);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN);
+#endif
 }
 
 /**
- * @brief Encode a mission_clear_all struct into a message
+ * @brief Encode a mission_clear_all struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -99,6 +110,20 @@ static inline uint16_t mavlink_msg_missi
 }
 
 /**
+ * @brief Encode a mission_clear_all struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param mission_clear_all C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_mission_clear_all_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_mission_clear_all_t* mission_clear_all)
+{
+	return mavlink_msg_mission_clear_all_pack_chan(system_id, component_id, chan, msg, mission_clear_all->target_system, mission_clear_all->target_component);
+}
+
+/**
  * @brief Send a mission_clear_all message
  * @param chan MAVLink channel to send the message
  *
@@ -110,20 +135,62 @@ static inline uint16_t mavlink_msg_missi
 static inline void mavlink_msg_mission_clear_all_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[2];
+	char buf[MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN];
 	_mav_put_uint8_t(buf, 0, target_system);
 	_mav_put_uint8_t(buf, 1, target_component);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CLEAR_ALL, buf, 2, 232);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CLEAR_ALL, buf, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CLEAR_ALL, buf, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN);
+#endif
 #else
 	mavlink_mission_clear_all_t packet;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CLEAR_ALL, (const char *)&packet, 2, 232);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CLEAR_ALL, (const char *)&packet, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CLEAR_ALL, (const char *)&packet, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_mission_clear_all_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint8_t(buf, 0, target_system);
+	_mav_put_uint8_t(buf, 1, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CLEAR_ALL, buf, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CLEAR_ALL, buf, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN);
+#endif
+#else
+	mavlink_mission_clear_all_t *packet = (mavlink_mission_clear_all_t *)msgbuf;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CLEAR_ALL, (const char *)packet, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CLEAR_ALL, (const char *)packet, MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE MISSION_CLEAR_ALL UNPACKING
@@ -161,6 +228,6 @@ static inline void mavlink_msg_mission_c
 	mission_clear_all->target_system = mavlink_msg_mission_clear_all_get_target_system(msg);
 	mission_clear_all->target_component = mavlink_msg_mission_clear_all_get_target_component(msg);
 #else
-	memcpy(mission_clear_all, _MAV_PAYLOAD(msg), 2);
+	memcpy(mission_clear_all, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MISSION_CLEAR_ALL_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_mission_count.h v1.0/common/mavlink_msg_mission_count.h
--- v1.0.old/common/mavlink_msg_mission_count.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_mission_count.h	2015-02-06 11:50:58.000000000 +0500
@@ -12,6 +12,9 @@ typedef struct __mavlink_mission_count_t
 #define MAVLINK_MSG_ID_MISSION_COUNT_LEN 4
 #define MAVLINK_MSG_ID_44_LEN 4
 
+#define MAVLINK_MSG_ID_MISSION_COUNT_CRC 221
+#define MAVLINK_MSG_ID_44_CRC 221
+
 
 
 #define MAVLINK_MESSAGE_INFO_MISSION_COUNT { \
@@ -39,30 +42,34 @@ static inline uint16_t mavlink_msg_missi
 						       uint8_t target_system, uint8_t target_component, uint16_t count)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[4];
+	char buf[MAVLINK_MSG_ID_MISSION_COUNT_LEN];
 	_mav_put_uint16_t(buf, 0, count);
 	_mav_put_uint8_t(buf, 2, target_system);
 	_mav_put_uint8_t(buf, 3, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_COUNT_LEN);
 #else
 	mavlink_mission_count_t packet;
 	packet.count = count;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_COUNT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_COUNT;
-	return mavlink_finalize_message(msg, system_id, component_id, 4, 221);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_COUNT_LEN, MAVLINK_MSG_ID_MISSION_COUNT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_COUNT_LEN);
+#endif
 }
 
 /**
  * @brief Pack a mission_count message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system System ID
  * @param target_component Component ID
@@ -74,27 +81,31 @@ static inline uint16_t mavlink_msg_missi
 						           uint8_t target_system,uint8_t target_component,uint16_t count)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[4];
+	char buf[MAVLINK_MSG_ID_MISSION_COUNT_LEN];
 	_mav_put_uint16_t(buf, 0, count);
 	_mav_put_uint8_t(buf, 2, target_system);
 	_mav_put_uint8_t(buf, 3, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_COUNT_LEN);
 #else
 	mavlink_mission_count_t packet;
 	packet.count = count;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_COUNT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_COUNT;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 4, 221);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_COUNT_LEN, MAVLINK_MSG_ID_MISSION_COUNT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_COUNT_LEN);
+#endif
 }
 
 /**
- * @brief Encode a mission_count struct into a message
+ * @brief Encode a mission_count struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -107,6 +118,20 @@ static inline uint16_t mavlink_msg_missi
 }
 
 /**
+ * @brief Encode a mission_count struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param mission_count C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_mission_count_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_mission_count_t* mission_count)
+{
+	return mavlink_msg_mission_count_pack_chan(system_id, component_id, chan, msg, mission_count->target_system, mission_count->target_component, mission_count->count);
+}
+
+/**
  * @brief Send a mission_count message
  * @param chan MAVLink channel to send the message
  *
@@ -119,21 +144,65 @@ static inline uint16_t mavlink_msg_missi
 static inline void mavlink_msg_mission_count_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, uint16_t count)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[4];
+	char buf[MAVLINK_MSG_ID_MISSION_COUNT_LEN];
 	_mav_put_uint16_t(buf, 0, count);
 	_mav_put_uint8_t(buf, 2, target_system);
 	_mav_put_uint8_t(buf, 3, target_component);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_COUNT, buf, 4, 221);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_COUNT, buf, MAVLINK_MSG_ID_MISSION_COUNT_LEN, MAVLINK_MSG_ID_MISSION_COUNT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_COUNT, buf, MAVLINK_MSG_ID_MISSION_COUNT_LEN);
+#endif
 #else
 	mavlink_mission_count_t packet;
 	packet.count = count;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_COUNT, (const char *)&packet, 4, 221);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_COUNT, (const char *)&packet, MAVLINK_MSG_ID_MISSION_COUNT_LEN, MAVLINK_MSG_ID_MISSION_COUNT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_COUNT, (const char *)&packet, MAVLINK_MSG_ID_MISSION_COUNT_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_MISSION_COUNT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_mission_count_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, uint16_t count)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint16_t(buf, 0, count);
+	_mav_put_uint8_t(buf, 2, target_system);
+	_mav_put_uint8_t(buf, 3, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_COUNT, buf, MAVLINK_MSG_ID_MISSION_COUNT_LEN, MAVLINK_MSG_ID_MISSION_COUNT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_COUNT, buf, MAVLINK_MSG_ID_MISSION_COUNT_LEN);
+#endif
+#else
+	mavlink_mission_count_t *packet = (mavlink_mission_count_t *)msgbuf;
+	packet->count = count;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_COUNT, (const char *)packet, MAVLINK_MSG_ID_MISSION_COUNT_LEN, MAVLINK_MSG_ID_MISSION_COUNT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_COUNT, (const char *)packet, MAVLINK_MSG_ID_MISSION_COUNT_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -183,6 +252,6 @@ static inline void mavlink_msg_mission_c
 	mission_count->target_system = mavlink_msg_mission_count_get_target_system(msg);
 	mission_count->target_component = mavlink_msg_mission_count_get_target_component(msg);
 #else
-	memcpy(mission_count, _MAV_PAYLOAD(msg), 4);
+	memcpy(mission_count, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MISSION_COUNT_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_mission_current.h v1.0/common/mavlink_msg_mission_current.h
--- v1.0.old/common/mavlink_msg_mission_current.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_mission_current.h	2015-02-06 11:50:58.000000000 +0500
@@ -10,6 +10,9 @@ typedef struct __mavlink_mission_current
 #define MAVLINK_MSG_ID_MISSION_CURRENT_LEN 2
 #define MAVLINK_MSG_ID_42_LEN 2
 
+#define MAVLINK_MSG_ID_MISSION_CURRENT_CRC 28
+#define MAVLINK_MSG_ID_42_CRC 28
+
 
 
 #define MAVLINK_MESSAGE_INFO_MISSION_CURRENT { \
@@ -33,26 +36,30 @@ static inline uint16_t mavlink_msg_missi
 						       uint16_t seq)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[2];
+	char buf[MAVLINK_MSG_ID_MISSION_CURRENT_LEN];
 	_mav_put_uint16_t(buf, 0, seq);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_CURRENT_LEN);
 #else
 	mavlink_mission_current_t packet;
 	packet.seq = seq;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_CURRENT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_CURRENT;
-	return mavlink_finalize_message(msg, system_id, component_id, 2, 28);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_CURRENT_LEN, MAVLINK_MSG_ID_MISSION_CURRENT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_CURRENT_LEN);
+#endif
 }
 
 /**
  * @brief Pack a mission_current message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param seq Sequence
  * @return length of the message in bytes (excluding serial stream start sign)
@@ -62,23 +69,27 @@ static inline uint16_t mavlink_msg_missi
 						           uint16_t seq)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[2];
+	char buf[MAVLINK_MSG_ID_MISSION_CURRENT_LEN];
 	_mav_put_uint16_t(buf, 0, seq);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_CURRENT_LEN);
 #else
 	mavlink_mission_current_t packet;
 	packet.seq = seq;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_CURRENT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_CURRENT;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 2, 28);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_CURRENT_LEN, MAVLINK_MSG_ID_MISSION_CURRENT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_CURRENT_LEN);
+#endif
 }
 
 /**
- * @brief Encode a mission_current struct into a message
+ * @brief Encode a mission_current struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -91,6 +102,20 @@ static inline uint16_t mavlink_msg_missi
 }
 
 /**
+ * @brief Encode a mission_current struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param mission_current C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_mission_current_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_mission_current_t* mission_current)
+{
+	return mavlink_msg_mission_current_pack_chan(system_id, component_id, chan, msg, mission_current->seq);
+}
+
+/**
  * @brief Send a mission_current message
  * @param chan MAVLink channel to send the message
  *
@@ -101,18 +126,58 @@ static inline uint16_t mavlink_msg_missi
 static inline void mavlink_msg_mission_current_send(mavlink_channel_t chan, uint16_t seq)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[2];
+	char buf[MAVLINK_MSG_ID_MISSION_CURRENT_LEN];
 	_mav_put_uint16_t(buf, 0, seq);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CURRENT, buf, 2, 28);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CURRENT, buf, MAVLINK_MSG_ID_MISSION_CURRENT_LEN, MAVLINK_MSG_ID_MISSION_CURRENT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CURRENT, buf, MAVLINK_MSG_ID_MISSION_CURRENT_LEN);
+#endif
 #else
 	mavlink_mission_current_t packet;
 	packet.seq = seq;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CURRENT, (const char *)&packet, 2, 28);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CURRENT, (const char *)&packet, MAVLINK_MSG_ID_MISSION_CURRENT_LEN, MAVLINK_MSG_ID_MISSION_CURRENT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CURRENT, (const char *)&packet, MAVLINK_MSG_ID_MISSION_CURRENT_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_MISSION_CURRENT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_mission_current_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint16_t seq)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint16_t(buf, 0, seq);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CURRENT, buf, MAVLINK_MSG_ID_MISSION_CURRENT_LEN, MAVLINK_MSG_ID_MISSION_CURRENT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CURRENT, buf, MAVLINK_MSG_ID_MISSION_CURRENT_LEN);
+#endif
+#else
+	mavlink_mission_current_t *packet = (mavlink_mission_current_t *)msgbuf;
+	packet->seq = seq;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CURRENT, (const char *)packet, MAVLINK_MSG_ID_MISSION_CURRENT_LEN, MAVLINK_MSG_ID_MISSION_CURRENT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_CURRENT, (const char *)packet, MAVLINK_MSG_ID_MISSION_CURRENT_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE MISSION_CURRENT UNPACKING
@@ -139,6 +204,6 @@ static inline void mavlink_msg_mission_c
 #if MAVLINK_NEED_BYTE_SWAP
 	mission_current->seq = mavlink_msg_mission_current_get_seq(msg);
 #else
-	memcpy(mission_current, _MAV_PAYLOAD(msg), 2);
+	memcpy(mission_current, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MISSION_CURRENT_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_mission_item.h v1.0/common/mavlink_msg_mission_item.h
--- v1.0.old/common/mavlink_msg_mission_item.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_mission_item.h	2015-02-06 11:50:58.000000000 +0500
@@ -4,13 +4,13 @@
 
 typedef struct __mavlink_mission_item_t
 {
- float param1; ///< PARAM1 / For NAV command MISSIONs: Radius in which the MISSION is accepted as reached, in meters
- float param2; ///< PARAM2 / For NAV command MISSIONs: Time that the MAV should stay inside the PARAM1 radius before advancing, in milliseconds
- float param3; ///< PARAM3 / For LOITER command MISSIONs: Orbit to circle around the MISSION, in meters. If positive the orbit direction should be clockwise, if negative the orbit direction should be counter-clockwise.
- float param4; ///< PARAM4 / For NAV and LOITER command MISSIONs: Yaw orientation in degrees, [0..360] 0 = NORTH
+ float param1; ///< PARAM1, see MAV_CMD enum
+ float param2; ///< PARAM2, see MAV_CMD enum
+ float param3; ///< PARAM3, see MAV_CMD enum
+ float param4; ///< PARAM4, see MAV_CMD enum
  float x; ///< PARAM5 / local: x position, global: latitude
  float y; ///< PARAM6 / y position: global: longitude
- float z; ///< PARAM7 / z position: global: altitude
+ float z; ///< PARAM7 / z position: global: altitude (relative or absolute, depending on frame.
  uint16_t seq; ///< Sequence
  uint16_t command; ///< The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs
  uint8_t target_system; ///< System ID
@@ -23,6 +23,9 @@ typedef struct __mavlink_mission_item_t
 #define MAVLINK_MSG_ID_MISSION_ITEM_LEN 37
 #define MAVLINK_MSG_ID_39_LEN 37
 
+#define MAVLINK_MSG_ID_MISSION_ITEM_CRC 254
+#define MAVLINK_MSG_ID_39_CRC 254
+
 
 
 #define MAVLINK_MESSAGE_INFO_MISSION_ITEM { \
@@ -59,20 +62,20 @@ typedef struct __mavlink_mission_item_t
  * @param command The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs
  * @param current false:0, true:1
  * @param autocontinue autocontinue to next wp
- * @param param1 PARAM1 / For NAV command MISSIONs: Radius in which the MISSION is accepted as reached, in meters
- * @param param2 PARAM2 / For NAV command MISSIONs: Time that the MAV should stay inside the PARAM1 radius before advancing, in milliseconds
- * @param param3 PARAM3 / For LOITER command MISSIONs: Orbit to circle around the MISSION, in meters. If positive the orbit direction should be clockwise, if negative the orbit direction should be counter-clockwise.
- * @param param4 PARAM4 / For NAV and LOITER command MISSIONs: Yaw orientation in degrees, [0..360] 0 = NORTH
+ * @param param1 PARAM1, see MAV_CMD enum
+ * @param param2 PARAM2, see MAV_CMD enum
+ * @param param3 PARAM3, see MAV_CMD enum
+ * @param param4 PARAM4, see MAV_CMD enum
  * @param x PARAM5 / local: x position, global: latitude
  * @param y PARAM6 / y position: global: longitude
- * @param z PARAM7 / z position: global: altitude
+ * @param z PARAM7 / z position: global: altitude (relative or absolute, depending on frame.
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_mission_item_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
 						       uint8_t target_system, uint8_t target_component, uint16_t seq, uint8_t frame, uint16_t command, uint8_t current, uint8_t autocontinue, float param1, float param2, float param3, float param4, float x, float y, float z)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[37];
+	char buf[MAVLINK_MSG_ID_MISSION_ITEM_LEN];
 	_mav_put_float(buf, 0, param1);
 	_mav_put_float(buf, 4, param2);
 	_mav_put_float(buf, 8, param3);
@@ -88,7 +91,7 @@ static inline uint16_t mavlink_msg_missi
 	_mav_put_uint8_t(buf, 35, current);
 	_mav_put_uint8_t(buf, 36, autocontinue);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 37);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_ITEM_LEN);
 #else
 	mavlink_mission_item_t packet;
 	packet.param1 = param1;
@@ -106,18 +109,22 @@ static inline uint16_t mavlink_msg_missi
 	packet.current = current;
 	packet.autocontinue = autocontinue;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 37);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_ITEM_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_ITEM;
-	return mavlink_finalize_message(msg, system_id, component_id, 37, 254);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_ITEM_LEN, MAVLINK_MSG_ID_MISSION_ITEM_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_ITEM_LEN);
+#endif
 }
 
 /**
  * @brief Pack a mission_item message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system System ID
  * @param target_component Component ID
@@ -126,13 +133,13 @@ static inline uint16_t mavlink_msg_missi
  * @param command The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs
  * @param current false:0, true:1
  * @param autocontinue autocontinue to next wp
- * @param param1 PARAM1 / For NAV command MISSIONs: Radius in which the MISSION is accepted as reached, in meters
- * @param param2 PARAM2 / For NAV command MISSIONs: Time that the MAV should stay inside the PARAM1 radius before advancing, in milliseconds
- * @param param3 PARAM3 / For LOITER command MISSIONs: Orbit to circle around the MISSION, in meters. If positive the orbit direction should be clockwise, if negative the orbit direction should be counter-clockwise.
- * @param param4 PARAM4 / For NAV and LOITER command MISSIONs: Yaw orientation in degrees, [0..360] 0 = NORTH
+ * @param param1 PARAM1, see MAV_CMD enum
+ * @param param2 PARAM2, see MAV_CMD enum
+ * @param param3 PARAM3, see MAV_CMD enum
+ * @param param4 PARAM4, see MAV_CMD enum
  * @param x PARAM5 / local: x position, global: latitude
  * @param y PARAM6 / y position: global: longitude
- * @param z PARAM7 / z position: global: altitude
+ * @param z PARAM7 / z position: global: altitude (relative or absolute, depending on frame.
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_mission_item_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
@@ -140,7 +147,7 @@ static inline uint16_t mavlink_msg_missi
 						           uint8_t target_system,uint8_t target_component,uint16_t seq,uint8_t frame,uint16_t command,uint8_t current,uint8_t autocontinue,float param1,float param2,float param3,float param4,float x,float y,float z)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[37];
+	char buf[MAVLINK_MSG_ID_MISSION_ITEM_LEN];
 	_mav_put_float(buf, 0, param1);
 	_mav_put_float(buf, 4, param2);
 	_mav_put_float(buf, 8, param3);
@@ -156,7 +163,7 @@ static inline uint16_t mavlink_msg_missi
 	_mav_put_uint8_t(buf, 35, current);
 	_mav_put_uint8_t(buf, 36, autocontinue);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 37);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_ITEM_LEN);
 #else
 	mavlink_mission_item_t packet;
 	packet.param1 = param1;
@@ -174,15 +181,19 @@ static inline uint16_t mavlink_msg_missi
 	packet.current = current;
 	packet.autocontinue = autocontinue;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 37);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_ITEM_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_ITEM;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 37, 254);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_ITEM_LEN, MAVLINK_MSG_ID_MISSION_ITEM_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_ITEM_LEN);
+#endif
 }
 
 /**
- * @brief Encode a mission_item struct into a message
+ * @brief Encode a mission_item struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -195,6 +206,20 @@ static inline uint16_t mavlink_msg_missi
 }
 
 /**
+ * @brief Encode a mission_item struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param mission_item C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_mission_item_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_mission_item_t* mission_item)
+{
+	return mavlink_msg_mission_item_pack_chan(system_id, component_id, chan, msg, mission_item->target_system, mission_item->target_component, mission_item->seq, mission_item->frame, mission_item->command, mission_item->current, mission_item->autocontinue, mission_item->param1, mission_item->param2, mission_item->param3, mission_item->param4, mission_item->x, mission_item->y, mission_item->z);
+}
+
+/**
  * @brief Send a mission_item message
  * @param chan MAVLink channel to send the message
  *
@@ -205,20 +230,20 @@ static inline uint16_t mavlink_msg_missi
  * @param command The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs
  * @param current false:0, true:1
  * @param autocontinue autocontinue to next wp
- * @param param1 PARAM1 / For NAV command MISSIONs: Radius in which the MISSION is accepted as reached, in meters
- * @param param2 PARAM2 / For NAV command MISSIONs: Time that the MAV should stay inside the PARAM1 radius before advancing, in milliseconds
- * @param param3 PARAM3 / For LOITER command MISSIONs: Orbit to circle around the MISSION, in meters. If positive the orbit direction should be clockwise, if negative the orbit direction should be counter-clockwise.
- * @param param4 PARAM4 / For NAV and LOITER command MISSIONs: Yaw orientation in degrees, [0..360] 0 = NORTH
+ * @param param1 PARAM1, see MAV_CMD enum
+ * @param param2 PARAM2, see MAV_CMD enum
+ * @param param3 PARAM3, see MAV_CMD enum
+ * @param param4 PARAM4, see MAV_CMD enum
  * @param x PARAM5 / local: x position, global: latitude
  * @param y PARAM6 / y position: global: longitude
- * @param z PARAM7 / z position: global: altitude
+ * @param z PARAM7 / z position: global: altitude (relative or absolute, depending on frame.
  */
 #ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
 
 static inline void mavlink_msg_mission_item_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, uint16_t seq, uint8_t frame, uint16_t command, uint8_t current, uint8_t autocontinue, float param1, float param2, float param3, float param4, float x, float y, float z)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[37];
+	char buf[MAVLINK_MSG_ID_MISSION_ITEM_LEN];
 	_mav_put_float(buf, 0, param1);
 	_mav_put_float(buf, 4, param2);
 	_mav_put_float(buf, 8, param3);
@@ -234,7 +259,11 @@ static inline void mavlink_msg_mission_i
 	_mav_put_uint8_t(buf, 35, current);
 	_mav_put_uint8_t(buf, 36, autocontinue);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM, buf, 37, 254);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM, buf, MAVLINK_MSG_ID_MISSION_ITEM_LEN, MAVLINK_MSG_ID_MISSION_ITEM_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM, buf, MAVLINK_MSG_ID_MISSION_ITEM_LEN);
+#endif
 #else
 	mavlink_mission_item_t packet;
 	packet.param1 = param1;
@@ -252,10 +281,72 @@ static inline void mavlink_msg_mission_i
 	packet.current = current;
 	packet.autocontinue = autocontinue;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM, (const char *)&packet, 37, 254);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM, (const char *)&packet, MAVLINK_MSG_ID_MISSION_ITEM_LEN, MAVLINK_MSG_ID_MISSION_ITEM_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM, (const char *)&packet, MAVLINK_MSG_ID_MISSION_ITEM_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_MISSION_ITEM_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_mission_item_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, uint16_t seq, uint8_t frame, uint16_t command, uint8_t current, uint8_t autocontinue, float param1, float param2, float param3, float param4, float x, float y, float z)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_float(buf, 0, param1);
+	_mav_put_float(buf, 4, param2);
+	_mav_put_float(buf, 8, param3);
+	_mav_put_float(buf, 12, param4);
+	_mav_put_float(buf, 16, x);
+	_mav_put_float(buf, 20, y);
+	_mav_put_float(buf, 24, z);
+	_mav_put_uint16_t(buf, 28, seq);
+	_mav_put_uint16_t(buf, 30, command);
+	_mav_put_uint8_t(buf, 32, target_system);
+	_mav_put_uint8_t(buf, 33, target_component);
+	_mav_put_uint8_t(buf, 34, frame);
+	_mav_put_uint8_t(buf, 35, current);
+	_mav_put_uint8_t(buf, 36, autocontinue);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM, buf, MAVLINK_MSG_ID_MISSION_ITEM_LEN, MAVLINK_MSG_ID_MISSION_ITEM_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM, buf, MAVLINK_MSG_ID_MISSION_ITEM_LEN);
+#endif
+#else
+	mavlink_mission_item_t *packet = (mavlink_mission_item_t *)msgbuf;
+	packet->param1 = param1;
+	packet->param2 = param2;
+	packet->param3 = param3;
+	packet->param4 = param4;
+	packet->x = x;
+	packet->y = y;
+	packet->z = z;
+	packet->seq = seq;
+	packet->command = command;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+	packet->frame = frame;
+	packet->current = current;
+	packet->autocontinue = autocontinue;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM, (const char *)packet, MAVLINK_MSG_ID_MISSION_ITEM_LEN, MAVLINK_MSG_ID_MISSION_ITEM_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM, (const char *)packet, MAVLINK_MSG_ID_MISSION_ITEM_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE MISSION_ITEM UNPACKING
@@ -334,7 +425,7 @@ static inline uint8_t mavlink_msg_missio
 /**
  * @brief Get field param1 from mission_item message
  *
- * @return PARAM1 / For NAV command MISSIONs: Radius in which the MISSION is accepted as reached, in meters
+ * @return PARAM1, see MAV_CMD enum
  */
 static inline float mavlink_msg_mission_item_get_param1(const mavlink_message_t* msg)
 {
@@ -344,7 +435,7 @@ static inline float mavlink_msg_mission_
 /**
  * @brief Get field param2 from mission_item message
  *
- * @return PARAM2 / For NAV command MISSIONs: Time that the MAV should stay inside the PARAM1 radius before advancing, in milliseconds
+ * @return PARAM2, see MAV_CMD enum
  */
 static inline float mavlink_msg_mission_item_get_param2(const mavlink_message_t* msg)
 {
@@ -354,7 +445,7 @@ static inline float mavlink_msg_mission_
 /**
  * @brief Get field param3 from mission_item message
  *
- * @return PARAM3 / For LOITER command MISSIONs: Orbit to circle around the MISSION, in meters. If positive the orbit direction should be clockwise, if negative the orbit direction should be counter-clockwise.
+ * @return PARAM3, see MAV_CMD enum
  */
 static inline float mavlink_msg_mission_item_get_param3(const mavlink_message_t* msg)
 {
@@ -364,7 +455,7 @@ static inline float mavlink_msg_mission_
 /**
  * @brief Get field param4 from mission_item message
  *
- * @return PARAM4 / For NAV and LOITER command MISSIONs: Yaw orientation in degrees, [0..360] 0 = NORTH
+ * @return PARAM4, see MAV_CMD enum
  */
 static inline float mavlink_msg_mission_item_get_param4(const mavlink_message_t* msg)
 {
@@ -394,7 +485,7 @@ static inline float mavlink_msg_mission_
 /**
  * @brief Get field z from mission_item message
  *
- * @return PARAM7 / z position: global: altitude
+ * @return PARAM7 / z position: global: altitude (relative or absolute, depending on frame.
  */
 static inline float mavlink_msg_mission_item_get_z(const mavlink_message_t* msg)
 {
@@ -425,6 +516,6 @@ static inline void mavlink_msg_mission_i
 	mission_item->current = mavlink_msg_mission_item_get_current(msg);
 	mission_item->autocontinue = mavlink_msg_mission_item_get_autocontinue(msg);
 #else
-	memcpy(mission_item, _MAV_PAYLOAD(msg), 37);
+	memcpy(mission_item, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MISSION_ITEM_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_mission_item_int.h v1.0/common/mavlink_msg_mission_item_int.h
--- v1.0.old/common/mavlink_msg_mission_item_int.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_mission_item_int.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,521 @@
+// MESSAGE MISSION_ITEM_INT PACKING
+
+#define MAVLINK_MSG_ID_MISSION_ITEM_INT 73
+
+typedef struct __mavlink_mission_item_int_t
+{
+ float param1; ///< PARAM1, see MAV_CMD enum
+ float param2; ///< PARAM2, see MAV_CMD enum
+ float param3; ///< PARAM3, see MAV_CMD enum
+ float param4; ///< PARAM4, see MAV_CMD enum
+ int32_t x; ///< PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
+ int32_t y; ///< PARAM6 / y position: local: x position in meters * 1e4, global: longitude in degrees *10^7
+ float z; ///< PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.
+ uint16_t seq; ///< Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4).
+ uint16_t command; ///< The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs
+ uint8_t target_system; ///< System ID
+ uint8_t target_component; ///< Component ID
+ uint8_t frame; ///< The coordinate system of the MISSION. see MAV_FRAME in mavlink_types.h
+ uint8_t current; ///< false:0, true:1
+ uint8_t autocontinue; ///< autocontinue to next wp
+} mavlink_mission_item_int_t;
+
+#define MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN 37
+#define MAVLINK_MSG_ID_73_LEN 37
+
+#define MAVLINK_MSG_ID_MISSION_ITEM_INT_CRC 38
+#define MAVLINK_MSG_ID_73_CRC 38
+
+
+
+#define MAVLINK_MESSAGE_INFO_MISSION_ITEM_INT { \
+	"MISSION_ITEM_INT", \
+	14, \
+	{  { "param1", NULL, MAVLINK_TYPE_FLOAT, 0, 0, offsetof(mavlink_mission_item_int_t, param1) }, \
+         { "param2", NULL, MAVLINK_TYPE_FLOAT, 0, 4, offsetof(mavlink_mission_item_int_t, param2) }, \
+         { "param3", NULL, MAVLINK_TYPE_FLOAT, 0, 8, offsetof(mavlink_mission_item_int_t, param3) }, \
+         { "param4", NULL, MAVLINK_TYPE_FLOAT, 0, 12, offsetof(mavlink_mission_item_int_t, param4) }, \
+         { "x", NULL, MAVLINK_TYPE_INT32_T, 0, 16, offsetof(mavlink_mission_item_int_t, x) }, \
+         { "y", NULL, MAVLINK_TYPE_INT32_T, 0, 20, offsetof(mavlink_mission_item_int_t, y) }, \
+         { "z", NULL, MAVLINK_TYPE_FLOAT, 0, 24, offsetof(mavlink_mission_item_int_t, z) }, \
+         { "seq", NULL, MAVLINK_TYPE_UINT16_T, 0, 28, offsetof(mavlink_mission_item_int_t, seq) }, \
+         { "command", NULL, MAVLINK_TYPE_UINT16_T, 0, 30, offsetof(mavlink_mission_item_int_t, command) }, \
+         { "target_system", NULL, MAVLINK_TYPE_UINT8_T, 0, 32, offsetof(mavlink_mission_item_int_t, target_system) }, \
+         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 33, offsetof(mavlink_mission_item_int_t, target_component) }, \
+         { "frame", NULL, MAVLINK_TYPE_UINT8_T, 0, 34, offsetof(mavlink_mission_item_int_t, frame) }, \
+         { "current", NULL, MAVLINK_TYPE_UINT8_T, 0, 35, offsetof(mavlink_mission_item_int_t, current) }, \
+         { "autocontinue", NULL, MAVLINK_TYPE_UINT8_T, 0, 36, offsetof(mavlink_mission_item_int_t, autocontinue) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a mission_item_int message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param seq Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4).
+ * @param frame The coordinate system of the MISSION. see MAV_FRAME in mavlink_types.h
+ * @param command The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs
+ * @param current false:0, true:1
+ * @param autocontinue autocontinue to next wp
+ * @param param1 PARAM1, see MAV_CMD enum
+ * @param param2 PARAM2, see MAV_CMD enum
+ * @param param3 PARAM3, see MAV_CMD enum
+ * @param param4 PARAM4, see MAV_CMD enum
+ * @param x PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
+ * @param y PARAM6 / y position: local: x position in meters * 1e4, global: longitude in degrees *10^7
+ * @param z PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_mission_item_int_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint8_t target_system, uint8_t target_component, uint16_t seq, uint8_t frame, uint16_t command, uint8_t current, uint8_t autocontinue, float param1, float param2, float param3, float param4, int32_t x, int32_t y, float z)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN];
+	_mav_put_float(buf, 0, param1);
+	_mav_put_float(buf, 4, param2);
+	_mav_put_float(buf, 8, param3);
+	_mav_put_float(buf, 12, param4);
+	_mav_put_int32_t(buf, 16, x);
+	_mav_put_int32_t(buf, 20, y);
+	_mav_put_float(buf, 24, z);
+	_mav_put_uint16_t(buf, 28, seq);
+	_mav_put_uint16_t(buf, 30, command);
+	_mav_put_uint8_t(buf, 32, target_system);
+	_mav_put_uint8_t(buf, 33, target_component);
+	_mav_put_uint8_t(buf, 34, frame);
+	_mav_put_uint8_t(buf, 35, current);
+	_mav_put_uint8_t(buf, 36, autocontinue);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN);
+#else
+	mavlink_mission_item_int_t packet;
+	packet.param1 = param1;
+	packet.param2 = param2;
+	packet.param3 = param3;
+	packet.param4 = param4;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.seq = seq;
+	packet.command = command;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.frame = frame;
+	packet.current = current;
+	packet.autocontinue = autocontinue;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_MISSION_ITEM_INT;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN, MAVLINK_MSG_ID_MISSION_ITEM_INT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a mission_item_int message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param seq Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4).
+ * @param frame The coordinate system of the MISSION. see MAV_FRAME in mavlink_types.h
+ * @param command The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs
+ * @param current false:0, true:1
+ * @param autocontinue autocontinue to next wp
+ * @param param1 PARAM1, see MAV_CMD enum
+ * @param param2 PARAM2, see MAV_CMD enum
+ * @param param3 PARAM3, see MAV_CMD enum
+ * @param param4 PARAM4, see MAV_CMD enum
+ * @param x PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
+ * @param y PARAM6 / y position: local: x position in meters * 1e4, global: longitude in degrees *10^7
+ * @param z PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_mission_item_int_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint8_t target_system,uint8_t target_component,uint16_t seq,uint8_t frame,uint16_t command,uint8_t current,uint8_t autocontinue,float param1,float param2,float param3,float param4,int32_t x,int32_t y,float z)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN];
+	_mav_put_float(buf, 0, param1);
+	_mav_put_float(buf, 4, param2);
+	_mav_put_float(buf, 8, param3);
+	_mav_put_float(buf, 12, param4);
+	_mav_put_int32_t(buf, 16, x);
+	_mav_put_int32_t(buf, 20, y);
+	_mav_put_float(buf, 24, z);
+	_mav_put_uint16_t(buf, 28, seq);
+	_mav_put_uint16_t(buf, 30, command);
+	_mav_put_uint8_t(buf, 32, target_system);
+	_mav_put_uint8_t(buf, 33, target_component);
+	_mav_put_uint8_t(buf, 34, frame);
+	_mav_put_uint8_t(buf, 35, current);
+	_mav_put_uint8_t(buf, 36, autocontinue);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN);
+#else
+	mavlink_mission_item_int_t packet;
+	packet.param1 = param1;
+	packet.param2 = param2;
+	packet.param3 = param3;
+	packet.param4 = param4;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.seq = seq;
+	packet.command = command;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.frame = frame;
+	packet.current = current;
+	packet.autocontinue = autocontinue;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_MISSION_ITEM_INT;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN, MAVLINK_MSG_ID_MISSION_ITEM_INT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a mission_item_int struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param mission_item_int C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_mission_item_int_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_mission_item_int_t* mission_item_int)
+{
+	return mavlink_msg_mission_item_int_pack(system_id, component_id, msg, mission_item_int->target_system, mission_item_int->target_component, mission_item_int->seq, mission_item_int->frame, mission_item_int->command, mission_item_int->current, mission_item_int->autocontinue, mission_item_int->param1, mission_item_int->param2, mission_item_int->param3, mission_item_int->param4, mission_item_int->x, mission_item_int->y, mission_item_int->z);
+}
+
+/**
+ * @brief Encode a mission_item_int struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param mission_item_int C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_mission_item_int_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_mission_item_int_t* mission_item_int)
+{
+	return mavlink_msg_mission_item_int_pack_chan(system_id, component_id, chan, msg, mission_item_int->target_system, mission_item_int->target_component, mission_item_int->seq, mission_item_int->frame, mission_item_int->command, mission_item_int->current, mission_item_int->autocontinue, mission_item_int->param1, mission_item_int->param2, mission_item_int->param3, mission_item_int->param4, mission_item_int->x, mission_item_int->y, mission_item_int->z);
+}
+
+/**
+ * @brief Send a mission_item_int message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param seq Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4).
+ * @param frame The coordinate system of the MISSION. see MAV_FRAME in mavlink_types.h
+ * @param command The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs
+ * @param current false:0, true:1
+ * @param autocontinue autocontinue to next wp
+ * @param param1 PARAM1, see MAV_CMD enum
+ * @param param2 PARAM2, see MAV_CMD enum
+ * @param param3 PARAM3, see MAV_CMD enum
+ * @param param4 PARAM4, see MAV_CMD enum
+ * @param x PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
+ * @param y PARAM6 / y position: local: x position in meters * 1e4, global: longitude in degrees *10^7
+ * @param z PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_mission_item_int_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, uint16_t seq, uint8_t frame, uint16_t command, uint8_t current, uint8_t autocontinue, float param1, float param2, float param3, float param4, int32_t x, int32_t y, float z)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN];
+	_mav_put_float(buf, 0, param1);
+	_mav_put_float(buf, 4, param2);
+	_mav_put_float(buf, 8, param3);
+	_mav_put_float(buf, 12, param4);
+	_mav_put_int32_t(buf, 16, x);
+	_mav_put_int32_t(buf, 20, y);
+	_mav_put_float(buf, 24, z);
+	_mav_put_uint16_t(buf, 28, seq);
+	_mav_put_uint16_t(buf, 30, command);
+	_mav_put_uint8_t(buf, 32, target_system);
+	_mav_put_uint8_t(buf, 33, target_component);
+	_mav_put_uint8_t(buf, 34, frame);
+	_mav_put_uint8_t(buf, 35, current);
+	_mav_put_uint8_t(buf, 36, autocontinue);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_INT, buf, MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN, MAVLINK_MSG_ID_MISSION_ITEM_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_INT, buf, MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN);
+#endif
+#else
+	mavlink_mission_item_int_t packet;
+	packet.param1 = param1;
+	packet.param2 = param2;
+	packet.param3 = param3;
+	packet.param4 = param4;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.seq = seq;
+	packet.command = command;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.frame = frame;
+	packet.current = current;
+	packet.autocontinue = autocontinue;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_INT, (const char *)&packet, MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN, MAVLINK_MSG_ID_MISSION_ITEM_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_INT, (const char *)&packet, MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_mission_item_int_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, uint16_t seq, uint8_t frame, uint16_t command, uint8_t current, uint8_t autocontinue, float param1, float param2, float param3, float param4, int32_t x, int32_t y, float z)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_float(buf, 0, param1);
+	_mav_put_float(buf, 4, param2);
+	_mav_put_float(buf, 8, param3);
+	_mav_put_float(buf, 12, param4);
+	_mav_put_int32_t(buf, 16, x);
+	_mav_put_int32_t(buf, 20, y);
+	_mav_put_float(buf, 24, z);
+	_mav_put_uint16_t(buf, 28, seq);
+	_mav_put_uint16_t(buf, 30, command);
+	_mav_put_uint8_t(buf, 32, target_system);
+	_mav_put_uint8_t(buf, 33, target_component);
+	_mav_put_uint8_t(buf, 34, frame);
+	_mav_put_uint8_t(buf, 35, current);
+	_mav_put_uint8_t(buf, 36, autocontinue);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_INT, buf, MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN, MAVLINK_MSG_ID_MISSION_ITEM_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_INT, buf, MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN);
+#endif
+#else
+	mavlink_mission_item_int_t *packet = (mavlink_mission_item_int_t *)msgbuf;
+	packet->param1 = param1;
+	packet->param2 = param2;
+	packet->param3 = param3;
+	packet->param4 = param4;
+	packet->x = x;
+	packet->y = y;
+	packet->z = z;
+	packet->seq = seq;
+	packet->command = command;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+	packet->frame = frame;
+	packet->current = current;
+	packet->autocontinue = autocontinue;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_INT, (const char *)packet, MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN, MAVLINK_MSG_ID_MISSION_ITEM_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_INT, (const char *)packet, MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE MISSION_ITEM_INT UNPACKING
+
+
+/**
+ * @brief Get field target_system from mission_item_int message
+ *
+ * @return System ID
+ */
+static inline uint8_t mavlink_msg_mission_item_int_get_target_system(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  32);
+}
+
+/**
+ * @brief Get field target_component from mission_item_int message
+ *
+ * @return Component ID
+ */
+static inline uint8_t mavlink_msg_mission_item_int_get_target_component(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  33);
+}
+
+/**
+ * @brief Get field seq from mission_item_int message
+ *
+ * @return Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4).
+ */
+static inline uint16_t mavlink_msg_mission_item_int_get_seq(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  28);
+}
+
+/**
+ * @brief Get field frame from mission_item_int message
+ *
+ * @return The coordinate system of the MISSION. see MAV_FRAME in mavlink_types.h
+ */
+static inline uint8_t mavlink_msg_mission_item_int_get_frame(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  34);
+}
+
+/**
+ * @brief Get field command from mission_item_int message
+ *
+ * @return The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs
+ */
+static inline uint16_t mavlink_msg_mission_item_int_get_command(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  30);
+}
+
+/**
+ * @brief Get field current from mission_item_int message
+ *
+ * @return false:0, true:1
+ */
+static inline uint8_t mavlink_msg_mission_item_int_get_current(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  35);
+}
+
+/**
+ * @brief Get field autocontinue from mission_item_int message
+ *
+ * @return autocontinue to next wp
+ */
+static inline uint8_t mavlink_msg_mission_item_int_get_autocontinue(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  36);
+}
+
+/**
+ * @brief Get field param1 from mission_item_int message
+ *
+ * @return PARAM1, see MAV_CMD enum
+ */
+static inline float mavlink_msg_mission_item_int_get_param1(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  0);
+}
+
+/**
+ * @brief Get field param2 from mission_item_int message
+ *
+ * @return PARAM2, see MAV_CMD enum
+ */
+static inline float mavlink_msg_mission_item_int_get_param2(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  4);
+}
+
+/**
+ * @brief Get field param3 from mission_item_int message
+ *
+ * @return PARAM3, see MAV_CMD enum
+ */
+static inline float mavlink_msg_mission_item_int_get_param3(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  8);
+}
+
+/**
+ * @brief Get field param4 from mission_item_int message
+ *
+ * @return PARAM4, see MAV_CMD enum
+ */
+static inline float mavlink_msg_mission_item_int_get_param4(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  12);
+}
+
+/**
+ * @brief Get field x from mission_item_int message
+ *
+ * @return PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
+ */
+static inline int32_t mavlink_msg_mission_item_int_get_x(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  16);
+}
+
+/**
+ * @brief Get field y from mission_item_int message
+ *
+ * @return PARAM6 / y position: local: x position in meters * 1e4, global: longitude in degrees *10^7
+ */
+static inline int32_t mavlink_msg_mission_item_int_get_y(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  20);
+}
+
+/**
+ * @brief Get field z from mission_item_int message
+ *
+ * @return PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.
+ */
+static inline float mavlink_msg_mission_item_int_get_z(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  24);
+}
+
+/**
+ * @brief Decode a mission_item_int message into a struct
+ *
+ * @param msg The message to decode
+ * @param mission_item_int C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_mission_item_int_decode(const mavlink_message_t* msg, mavlink_mission_item_int_t* mission_item_int)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	mission_item_int->param1 = mavlink_msg_mission_item_int_get_param1(msg);
+	mission_item_int->param2 = mavlink_msg_mission_item_int_get_param2(msg);
+	mission_item_int->param3 = mavlink_msg_mission_item_int_get_param3(msg);
+	mission_item_int->param4 = mavlink_msg_mission_item_int_get_param4(msg);
+	mission_item_int->x = mavlink_msg_mission_item_int_get_x(msg);
+	mission_item_int->y = mavlink_msg_mission_item_int_get_y(msg);
+	mission_item_int->z = mavlink_msg_mission_item_int_get_z(msg);
+	mission_item_int->seq = mavlink_msg_mission_item_int_get_seq(msg);
+	mission_item_int->command = mavlink_msg_mission_item_int_get_command(msg);
+	mission_item_int->target_system = mavlink_msg_mission_item_int_get_target_system(msg);
+	mission_item_int->target_component = mavlink_msg_mission_item_int_get_target_component(msg);
+	mission_item_int->frame = mavlink_msg_mission_item_int_get_frame(msg);
+	mission_item_int->current = mavlink_msg_mission_item_int_get_current(msg);
+	mission_item_int->autocontinue = mavlink_msg_mission_item_int_get_autocontinue(msg);
+#else
+	memcpy(mission_item_int, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MISSION_ITEM_INT_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_mission_item_reached.h v1.0/common/mavlink_msg_mission_item_reached.h
--- v1.0.old/common/mavlink_msg_mission_item_reached.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_mission_item_reached.h	2015-02-06 11:50:58.000000000 +0500
@@ -10,6 +10,9 @@ typedef struct __mavlink_mission_item_re
 #define MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN 2
 #define MAVLINK_MSG_ID_46_LEN 2
 
+#define MAVLINK_MSG_ID_MISSION_ITEM_REACHED_CRC 11
+#define MAVLINK_MSG_ID_46_CRC 11
+
 
 
 #define MAVLINK_MESSAGE_INFO_MISSION_ITEM_REACHED { \
@@ -33,26 +36,30 @@ static inline uint16_t mavlink_msg_missi
 						       uint16_t seq)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[2];
+	char buf[MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN];
 	_mav_put_uint16_t(buf, 0, seq);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN);
 #else
 	mavlink_mission_item_reached_t packet;
 	packet.seq = seq;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_ITEM_REACHED;
-	return mavlink_finalize_message(msg, system_id, component_id, 2, 11);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN);
+#endif
 }
 
 /**
  * @brief Pack a mission_item_reached message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param seq Sequence
  * @return length of the message in bytes (excluding serial stream start sign)
@@ -62,23 +69,27 @@ static inline uint16_t mavlink_msg_missi
 						           uint16_t seq)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[2];
+	char buf[MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN];
 	_mav_put_uint16_t(buf, 0, seq);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN);
 #else
 	mavlink_mission_item_reached_t packet;
 	packet.seq = seq;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_ITEM_REACHED;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 2, 11);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN);
+#endif
 }
 
 /**
- * @brief Encode a mission_item_reached struct into a message
+ * @brief Encode a mission_item_reached struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -91,6 +102,20 @@ static inline uint16_t mavlink_msg_missi
 }
 
 /**
+ * @brief Encode a mission_item_reached struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param mission_item_reached C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_mission_item_reached_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_mission_item_reached_t* mission_item_reached)
+{
+	return mavlink_msg_mission_item_reached_pack_chan(system_id, component_id, chan, msg, mission_item_reached->seq);
+}
+
+/**
  * @brief Send a mission_item_reached message
  * @param chan MAVLink channel to send the message
  *
@@ -101,18 +126,58 @@ static inline uint16_t mavlink_msg_missi
 static inline void mavlink_msg_mission_item_reached_send(mavlink_channel_t chan, uint16_t seq)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[2];
+	char buf[MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN];
 	_mav_put_uint16_t(buf, 0, seq);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_REACHED, buf, 2, 11);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_REACHED, buf, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_REACHED, buf, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN);
+#endif
 #else
 	mavlink_mission_item_reached_t packet;
 	packet.seq = seq;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_REACHED, (const char *)&packet, 2, 11);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_REACHED, (const char *)&packet, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_REACHED, (const char *)&packet, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_mission_item_reached_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint16_t seq)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint16_t(buf, 0, seq);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_REACHED, buf, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_REACHED, buf, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN);
+#endif
+#else
+	mavlink_mission_item_reached_t *packet = (mavlink_mission_item_reached_t *)msgbuf;
+	packet->seq = seq;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_REACHED, (const char *)packet, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_ITEM_REACHED, (const char *)packet, MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE MISSION_ITEM_REACHED UNPACKING
@@ -139,6 +204,6 @@ static inline void mavlink_msg_mission_i
 #if MAVLINK_NEED_BYTE_SWAP
 	mission_item_reached->seq = mavlink_msg_mission_item_reached_get_seq(msg);
 #else
-	memcpy(mission_item_reached, _MAV_PAYLOAD(msg), 2);
+	memcpy(mission_item_reached, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MISSION_ITEM_REACHED_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_mission_request.h v1.0/common/mavlink_msg_mission_request.h
--- v1.0.old/common/mavlink_msg_mission_request.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_mission_request.h	2015-02-06 11:50:58.000000000 +0500
@@ -12,6 +12,9 @@ typedef struct __mavlink_mission_request
 #define MAVLINK_MSG_ID_MISSION_REQUEST_LEN 4
 #define MAVLINK_MSG_ID_40_LEN 4
 
+#define MAVLINK_MSG_ID_MISSION_REQUEST_CRC 230
+#define MAVLINK_MSG_ID_40_CRC 230
+
 
 
 #define MAVLINK_MESSAGE_INFO_MISSION_REQUEST { \
@@ -39,30 +42,34 @@ static inline uint16_t mavlink_msg_missi
 						       uint8_t target_system, uint8_t target_component, uint16_t seq)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[4];
+	char buf[MAVLINK_MSG_ID_MISSION_REQUEST_LEN];
 	_mav_put_uint16_t(buf, 0, seq);
 	_mav_put_uint8_t(buf, 2, target_system);
 	_mav_put_uint8_t(buf, 3, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
 #else
 	mavlink_mission_request_t packet;
 	packet.seq = seq;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_REQUEST;
-	return mavlink_finalize_message(msg, system_id, component_id, 4, 230);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_REQUEST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
+#endif
 }
 
 /**
  * @brief Pack a mission_request message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system System ID
  * @param target_component Component ID
@@ -74,27 +81,31 @@ static inline uint16_t mavlink_msg_missi
 						           uint8_t target_system,uint8_t target_component,uint16_t seq)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[4];
+	char buf[MAVLINK_MSG_ID_MISSION_REQUEST_LEN];
 	_mav_put_uint16_t(buf, 0, seq);
 	_mav_put_uint8_t(buf, 2, target_system);
 	_mav_put_uint8_t(buf, 3, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
 #else
 	mavlink_mission_request_t packet;
 	packet.seq = seq;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_REQUEST;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 4, 230);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_REQUEST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
+#endif
 }
 
 /**
- * @brief Encode a mission_request struct into a message
+ * @brief Encode a mission_request struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -107,6 +118,20 @@ static inline uint16_t mavlink_msg_missi
 }
 
 /**
+ * @brief Encode a mission_request struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param mission_request C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_mission_request_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_mission_request_t* mission_request)
+{
+	return mavlink_msg_mission_request_pack_chan(system_id, component_id, chan, msg, mission_request->target_system, mission_request->target_component, mission_request->seq);
+}
+
+/**
  * @brief Send a mission_request message
  * @param chan MAVLink channel to send the message
  *
@@ -119,21 +144,65 @@ static inline uint16_t mavlink_msg_missi
 static inline void mavlink_msg_mission_request_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, uint16_t seq)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[4];
+	char buf[MAVLINK_MSG_ID_MISSION_REQUEST_LEN];
 	_mav_put_uint16_t(buf, 0, seq);
 	_mav_put_uint8_t(buf, 2, target_system);
 	_mav_put_uint8_t(buf, 3, target_component);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST, buf, 4, 230);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST, buf, MAVLINK_MSG_ID_MISSION_REQUEST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST, buf, MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
+#endif
 #else
 	mavlink_mission_request_t packet;
 	packet.seq = seq;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST, (const char *)&packet, 4, 230);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST, (const char *)&packet, MAVLINK_MSG_ID_MISSION_REQUEST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST, (const char *)&packet, MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_MISSION_REQUEST_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_mission_request_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, uint16_t seq)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint16_t(buf, 0, seq);
+	_mav_put_uint8_t(buf, 2, target_system);
+	_mav_put_uint8_t(buf, 3, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST, buf, MAVLINK_MSG_ID_MISSION_REQUEST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST, buf, MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
+#endif
+#else
+	mavlink_mission_request_t *packet = (mavlink_mission_request_t *)msgbuf;
+	packet->seq = seq;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST, (const char *)packet, MAVLINK_MSG_ID_MISSION_REQUEST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST, (const char *)packet, MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -183,6 +252,6 @@ static inline void mavlink_msg_mission_r
 	mission_request->target_system = mavlink_msg_mission_request_get_target_system(msg);
 	mission_request->target_component = mavlink_msg_mission_request_get_target_component(msg);
 #else
-	memcpy(mission_request, _MAV_PAYLOAD(msg), 4);
+	memcpy(mission_request, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_mission_request_list.h v1.0/common/mavlink_msg_mission_request_list.h
--- v1.0.old/common/mavlink_msg_mission_request_list.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_mission_request_list.h	2015-02-06 11:50:58.000000000 +0500
@@ -11,6 +11,9 @@ typedef struct __mavlink_mission_request
 #define MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN 2
 #define MAVLINK_MSG_ID_43_LEN 2
 
+#define MAVLINK_MSG_ID_MISSION_REQUEST_LIST_CRC 132
+#define MAVLINK_MSG_ID_43_CRC 132
+
 
 
 #define MAVLINK_MESSAGE_INFO_MISSION_REQUEST_LIST { \
@@ -36,28 +39,32 @@ static inline uint16_t mavlink_msg_missi
 						       uint8_t target_system, uint8_t target_component)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[2];
+	char buf[MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN];
 	_mav_put_uint8_t(buf, 0, target_system);
 	_mav_put_uint8_t(buf, 1, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN);
 #else
 	mavlink_mission_request_list_t packet;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_REQUEST_LIST;
-	return mavlink_finalize_message(msg, system_id, component_id, 2, 132);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN);
+#endif
 }
 
 /**
  * @brief Pack a mission_request_list message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system System ID
  * @param target_component Component ID
@@ -68,25 +75,29 @@ static inline uint16_t mavlink_msg_missi
 						           uint8_t target_system,uint8_t target_component)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[2];
+	char buf[MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN];
 	_mav_put_uint8_t(buf, 0, target_system);
 	_mav_put_uint8_t(buf, 1, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN);
 #else
 	mavlink_mission_request_list_t packet;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_REQUEST_LIST;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 2, 132);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN);
+#endif
 }
 
 /**
- * @brief Encode a mission_request_list struct into a message
+ * @brief Encode a mission_request_list struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -99,6 +110,20 @@ static inline uint16_t mavlink_msg_missi
 }
 
 /**
+ * @brief Encode a mission_request_list struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param mission_request_list C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_mission_request_list_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_mission_request_list_t* mission_request_list)
+{
+	return mavlink_msg_mission_request_list_pack_chan(system_id, component_id, chan, msg, mission_request_list->target_system, mission_request_list->target_component);
+}
+
+/**
  * @brief Send a mission_request_list message
  * @param chan MAVLink channel to send the message
  *
@@ -110,20 +135,62 @@ static inline uint16_t mavlink_msg_missi
 static inline void mavlink_msg_mission_request_list_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[2];
+	char buf[MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN];
 	_mav_put_uint8_t(buf, 0, target_system);
 	_mav_put_uint8_t(buf, 1, target_component);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_LIST, buf, 2, 132);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_LIST, buf, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_LIST, buf, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN);
+#endif
 #else
 	mavlink_mission_request_list_t packet;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_LIST, (const char *)&packet, 2, 132);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_LIST, (const char *)&packet, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_LIST, (const char *)&packet, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_mission_request_list_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint8_t(buf, 0, target_system);
+	_mav_put_uint8_t(buf, 1, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_LIST, buf, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_LIST, buf, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN);
+#endif
+#else
+	mavlink_mission_request_list_t *packet = (mavlink_mission_request_list_t *)msgbuf;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_LIST, (const char *)packet, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_LIST, (const char *)packet, MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE MISSION_REQUEST_LIST UNPACKING
@@ -161,6 +228,6 @@ static inline void mavlink_msg_mission_r
 	mission_request_list->target_system = mavlink_msg_mission_request_list_get_target_system(msg);
 	mission_request_list->target_component = mavlink_msg_mission_request_list_get_target_component(msg);
 #else
-	memcpy(mission_request_list, _MAV_PAYLOAD(msg), 2);
+	memcpy(mission_request_list, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MISSION_REQUEST_LIST_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_mission_request_partial_list.h v1.0/common/mavlink_msg_mission_request_partial_list.h
--- v1.0.old/common/mavlink_msg_mission_request_partial_list.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_mission_request_partial_list.h	2015-02-06 11:50:58.000000000 +0500
@@ -13,6 +13,9 @@ typedef struct __mavlink_mission_request
 #define MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN 6
 #define MAVLINK_MSG_ID_37_LEN 6
 
+#define MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_CRC 212
+#define MAVLINK_MSG_ID_37_CRC 212
+
 
 
 #define MAVLINK_MESSAGE_INFO_MISSION_REQUEST_PARTIAL_LIST { \
@@ -42,13 +45,13 @@ static inline uint16_t mavlink_msg_missi
 						       uint8_t target_system, uint8_t target_component, int16_t start_index, int16_t end_index)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[6];
+	char buf[MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN];
 	_mav_put_int16_t(buf, 0, start_index);
 	_mav_put_int16_t(buf, 2, end_index);
 	_mav_put_uint8_t(buf, 4, target_system);
 	_mav_put_uint8_t(buf, 5, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 6);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN);
 #else
 	mavlink_mission_request_partial_list_t packet;
 	packet.start_index = start_index;
@@ -56,18 +59,22 @@ static inline uint16_t mavlink_msg_missi
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 6);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST;
-	return mavlink_finalize_message(msg, system_id, component_id, 6, 212);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN);
+#endif
 }
 
 /**
  * @brief Pack a mission_request_partial_list message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system System ID
  * @param target_component Component ID
@@ -80,13 +87,13 @@ static inline uint16_t mavlink_msg_missi
 						           uint8_t target_system,uint8_t target_component,int16_t start_index,int16_t end_index)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[6];
+	char buf[MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN];
 	_mav_put_int16_t(buf, 0, start_index);
 	_mav_put_int16_t(buf, 2, end_index);
 	_mav_put_uint8_t(buf, 4, target_system);
 	_mav_put_uint8_t(buf, 5, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 6);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN);
 #else
 	mavlink_mission_request_partial_list_t packet;
 	packet.start_index = start_index;
@@ -94,15 +101,19 @@ static inline uint16_t mavlink_msg_missi
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 6);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 6, 212);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN);
+#endif
 }
 
 /**
- * @brief Encode a mission_request_partial_list struct into a message
+ * @brief Encode a mission_request_partial_list struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -115,6 +126,20 @@ static inline uint16_t mavlink_msg_missi
 }
 
 /**
+ * @brief Encode a mission_request_partial_list struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param mission_request_partial_list C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_mission_request_partial_list_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_mission_request_partial_list_t* mission_request_partial_list)
+{
+	return mavlink_msg_mission_request_partial_list_pack_chan(system_id, component_id, chan, msg, mission_request_partial_list->target_system, mission_request_partial_list->target_component, mission_request_partial_list->start_index, mission_request_partial_list->end_index);
+}
+
+/**
  * @brief Send a mission_request_partial_list message
  * @param chan MAVLink channel to send the message
  *
@@ -128,13 +153,17 @@ static inline uint16_t mavlink_msg_missi
 static inline void mavlink_msg_mission_request_partial_list_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, int16_t start_index, int16_t end_index)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[6];
+	char buf[MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN];
 	_mav_put_int16_t(buf, 0, start_index);
 	_mav_put_int16_t(buf, 2, end_index);
 	_mav_put_uint8_t(buf, 4, target_system);
 	_mav_put_uint8_t(buf, 5, target_component);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST, buf, 6, 212);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST, buf, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST, buf, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN);
+#endif
 #else
 	mavlink_mission_request_partial_list_t packet;
 	packet.start_index = start_index;
@@ -142,10 +171,52 @@ static inline void mavlink_msg_mission_r
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST, (const char *)&packet, 6, 212);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST, (const char *)&packet, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST, (const char *)&packet, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_mission_request_partial_list_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, int16_t start_index, int16_t end_index)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_int16_t(buf, 0, start_index);
+	_mav_put_int16_t(buf, 2, end_index);
+	_mav_put_uint8_t(buf, 4, target_system);
+	_mav_put_uint8_t(buf, 5, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST, buf, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST, buf, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN);
+#endif
+#else
+	mavlink_mission_request_partial_list_t *packet = (mavlink_mission_request_partial_list_t *)msgbuf;
+	packet->start_index = start_index;
+	packet->end_index = end_index;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST, (const char *)packet, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST, (const char *)packet, MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE MISSION_REQUEST_PARTIAL_LIST UNPACKING
@@ -205,6 +276,6 @@ static inline void mavlink_msg_mission_r
 	mission_request_partial_list->target_system = mavlink_msg_mission_request_partial_list_get_target_system(msg);
 	mission_request_partial_list->target_component = mavlink_msg_mission_request_partial_list_get_target_component(msg);
 #else
-	memcpy(mission_request_partial_list, _MAV_PAYLOAD(msg), 6);
+	memcpy(mission_request_partial_list, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_mission_set_current.h v1.0/common/mavlink_msg_mission_set_current.h
--- v1.0.old/common/mavlink_msg_mission_set_current.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_mission_set_current.h	2015-02-06 11:50:58.000000000 +0500
@@ -12,6 +12,9 @@ typedef struct __mavlink_mission_set_cur
 #define MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN 4
 #define MAVLINK_MSG_ID_41_LEN 4
 
+#define MAVLINK_MSG_ID_MISSION_SET_CURRENT_CRC 28
+#define MAVLINK_MSG_ID_41_CRC 28
+
 
 
 #define MAVLINK_MESSAGE_INFO_MISSION_SET_CURRENT { \
@@ -39,30 +42,34 @@ static inline uint16_t mavlink_msg_missi
 						       uint8_t target_system, uint8_t target_component, uint16_t seq)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[4];
+	char buf[MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN];
 	_mav_put_uint16_t(buf, 0, seq);
 	_mav_put_uint8_t(buf, 2, target_system);
 	_mav_put_uint8_t(buf, 3, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN);
 #else
 	mavlink_mission_set_current_t packet;
 	packet.seq = seq;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_SET_CURRENT;
-	return mavlink_finalize_message(msg, system_id, component_id, 4, 28);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN, MAVLINK_MSG_ID_MISSION_SET_CURRENT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN);
+#endif
 }
 
 /**
  * @brief Pack a mission_set_current message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system System ID
  * @param target_component Component ID
@@ -74,27 +81,31 @@ static inline uint16_t mavlink_msg_missi
 						           uint8_t target_system,uint8_t target_component,uint16_t seq)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[4];
+	char buf[MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN];
 	_mav_put_uint16_t(buf, 0, seq);
 	_mav_put_uint8_t(buf, 2, target_system);
 	_mav_put_uint8_t(buf, 3, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN);
 #else
 	mavlink_mission_set_current_t packet;
 	packet.seq = seq;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_SET_CURRENT;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 4, 28);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN, MAVLINK_MSG_ID_MISSION_SET_CURRENT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN);
+#endif
 }
 
 /**
- * @brief Encode a mission_set_current struct into a message
+ * @brief Encode a mission_set_current struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -107,6 +118,20 @@ static inline uint16_t mavlink_msg_missi
 }
 
 /**
+ * @brief Encode a mission_set_current struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param mission_set_current C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_mission_set_current_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_mission_set_current_t* mission_set_current)
+{
+	return mavlink_msg_mission_set_current_pack_chan(system_id, component_id, chan, msg, mission_set_current->target_system, mission_set_current->target_component, mission_set_current->seq);
+}
+
+/**
  * @brief Send a mission_set_current message
  * @param chan MAVLink channel to send the message
  *
@@ -119,21 +144,65 @@ static inline uint16_t mavlink_msg_missi
 static inline void mavlink_msg_mission_set_current_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, uint16_t seq)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[4];
+	char buf[MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN];
 	_mav_put_uint16_t(buf, 0, seq);
 	_mav_put_uint8_t(buf, 2, target_system);
 	_mav_put_uint8_t(buf, 3, target_component);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_SET_CURRENT, buf, 4, 28);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_SET_CURRENT, buf, MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN, MAVLINK_MSG_ID_MISSION_SET_CURRENT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_SET_CURRENT, buf, MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN);
+#endif
 #else
 	mavlink_mission_set_current_t packet;
 	packet.seq = seq;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_SET_CURRENT, (const char *)&packet, 4, 28);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_SET_CURRENT, (const char *)&packet, MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN, MAVLINK_MSG_ID_MISSION_SET_CURRENT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_SET_CURRENT, (const char *)&packet, MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_mission_set_current_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, uint16_t seq)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint16_t(buf, 0, seq);
+	_mav_put_uint8_t(buf, 2, target_system);
+	_mav_put_uint8_t(buf, 3, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_SET_CURRENT, buf, MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN, MAVLINK_MSG_ID_MISSION_SET_CURRENT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_SET_CURRENT, buf, MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN);
+#endif
+#else
+	mavlink_mission_set_current_t *packet = (mavlink_mission_set_current_t *)msgbuf;
+	packet->seq = seq;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_SET_CURRENT, (const char *)packet, MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN, MAVLINK_MSG_ID_MISSION_SET_CURRENT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_SET_CURRENT, (const char *)packet, MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -183,6 +252,6 @@ static inline void mavlink_msg_mission_s
 	mission_set_current->target_system = mavlink_msg_mission_set_current_get_target_system(msg);
 	mission_set_current->target_component = mavlink_msg_mission_set_current_get_target_component(msg);
 #else
-	memcpy(mission_set_current, _MAV_PAYLOAD(msg), 4);
+	memcpy(mission_set_current, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MISSION_SET_CURRENT_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_mission_write_partial_list.h v1.0/common/mavlink_msg_mission_write_partial_list.h
--- v1.0.old/common/mavlink_msg_mission_write_partial_list.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_mission_write_partial_list.h	2015-02-06 11:50:58.000000000 +0500
@@ -13,6 +13,9 @@ typedef struct __mavlink_mission_write_p
 #define MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN 6
 #define MAVLINK_MSG_ID_38_LEN 6
 
+#define MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_CRC 9
+#define MAVLINK_MSG_ID_38_CRC 9
+
 
 
 #define MAVLINK_MESSAGE_INFO_MISSION_WRITE_PARTIAL_LIST { \
@@ -42,13 +45,13 @@ static inline uint16_t mavlink_msg_missi
 						       uint8_t target_system, uint8_t target_component, int16_t start_index, int16_t end_index)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[6];
+	char buf[MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN];
 	_mav_put_int16_t(buf, 0, start_index);
 	_mav_put_int16_t(buf, 2, end_index);
 	_mav_put_uint8_t(buf, 4, target_system);
 	_mav_put_uint8_t(buf, 5, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 6);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN);
 #else
 	mavlink_mission_write_partial_list_t packet;
 	packet.start_index = start_index;
@@ -56,18 +59,22 @@ static inline uint16_t mavlink_msg_missi
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 6);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST;
-	return mavlink_finalize_message(msg, system_id, component_id, 6, 9);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN);
+#endif
 }
 
 /**
  * @brief Pack a mission_write_partial_list message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system System ID
  * @param target_component Component ID
@@ -80,13 +87,13 @@ static inline uint16_t mavlink_msg_missi
 						           uint8_t target_system,uint8_t target_component,int16_t start_index,int16_t end_index)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[6];
+	char buf[MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN];
 	_mav_put_int16_t(buf, 0, start_index);
 	_mav_put_int16_t(buf, 2, end_index);
 	_mav_put_uint8_t(buf, 4, target_system);
 	_mav_put_uint8_t(buf, 5, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 6);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN);
 #else
 	mavlink_mission_write_partial_list_t packet;
 	packet.start_index = start_index;
@@ -94,15 +101,19 @@ static inline uint16_t mavlink_msg_missi
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 6);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 6, 9);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN);
+#endif
 }
 
 /**
- * @brief Encode a mission_write_partial_list struct into a message
+ * @brief Encode a mission_write_partial_list struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -115,6 +126,20 @@ static inline uint16_t mavlink_msg_missi
 }
 
 /**
+ * @brief Encode a mission_write_partial_list struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param mission_write_partial_list C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_mission_write_partial_list_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_mission_write_partial_list_t* mission_write_partial_list)
+{
+	return mavlink_msg_mission_write_partial_list_pack_chan(system_id, component_id, chan, msg, mission_write_partial_list->target_system, mission_write_partial_list->target_component, mission_write_partial_list->start_index, mission_write_partial_list->end_index);
+}
+
+/**
  * @brief Send a mission_write_partial_list message
  * @param chan MAVLink channel to send the message
  *
@@ -128,13 +153,17 @@ static inline uint16_t mavlink_msg_missi
 static inline void mavlink_msg_mission_write_partial_list_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, int16_t start_index, int16_t end_index)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[6];
+	char buf[MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN];
 	_mav_put_int16_t(buf, 0, start_index);
 	_mav_put_int16_t(buf, 2, end_index);
 	_mav_put_uint8_t(buf, 4, target_system);
 	_mav_put_uint8_t(buf, 5, target_component);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST, buf, 6, 9);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST, buf, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST, buf, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN);
+#endif
 #else
 	mavlink_mission_write_partial_list_t packet;
 	packet.start_index = start_index;
@@ -142,10 +171,52 @@ static inline void mavlink_msg_mission_w
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST, (const char *)&packet, 6, 9);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST, (const char *)&packet, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST, (const char *)&packet, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_mission_write_partial_list_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, int16_t start_index, int16_t end_index)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_int16_t(buf, 0, start_index);
+	_mav_put_int16_t(buf, 2, end_index);
+	_mav_put_uint8_t(buf, 4, target_system);
+	_mav_put_uint8_t(buf, 5, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST, buf, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST, buf, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN);
+#endif
+#else
+	mavlink_mission_write_partial_list_t *packet = (mavlink_mission_write_partial_list_t *)msgbuf;
+	packet->start_index = start_index;
+	packet->end_index = end_index;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST, (const char *)packet, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST, (const char *)packet, MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE MISSION_WRITE_PARTIAL_LIST UNPACKING
@@ -205,6 +276,6 @@ static inline void mavlink_msg_mission_w
 	mission_write_partial_list->target_system = mavlink_msg_mission_write_partial_list_get_target_system(msg);
 	mission_write_partial_list->target_component = mavlink_msg_mission_write_partial_list_get_target_component(msg);
 #else
-	memcpy(mission_write_partial_list, _MAV_PAYLOAD(msg), 6);
+	memcpy(mission_write_partial_list, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_named_value_float.h v1.0/common/mavlink_msg_named_value_float.h
--- v1.0.old/common/mavlink_msg_named_value_float.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_named_value_float.h	2015-02-06 11:50:58.000000000 +0500
@@ -12,6 +12,9 @@ typedef struct __mavlink_named_value_flo
 #define MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN 18
 #define MAVLINK_MSG_ID_251_LEN 18
 
+#define MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_CRC 170
+#define MAVLINK_MSG_ID_251_CRC 170
+
 #define MAVLINK_MSG_NAMED_VALUE_FLOAT_FIELD_NAME_LEN 10
 
 #define MAVLINK_MESSAGE_INFO_NAMED_VALUE_FLOAT { \
@@ -39,28 +42,32 @@ static inline uint16_t mavlink_msg_named
 						       uint32_t time_boot_ms, const char *name, float value)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[18];
+	char buf[MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, value);
 	_mav_put_char_array(buf, 8, name, 10);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 18);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN);
 #else
 	mavlink_named_value_float_t packet;
 	packet.time_boot_ms = time_boot_ms;
 	packet.value = value;
 	mav_array_memcpy(packet.name, name, sizeof(char)*10);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 18);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_NAMED_VALUE_FLOAT;
-	return mavlink_finalize_message(msg, system_id, component_id, 18, 170);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN);
+#endif
 }
 
 /**
  * @brief Pack a named_value_float message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_boot_ms Timestamp (milliseconds since system boot)
  * @param name Name of the debug variable
@@ -72,25 +79,29 @@ static inline uint16_t mavlink_msg_named
 						           uint32_t time_boot_ms,const char *name,float value)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[18];
+	char buf[MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, value);
 	_mav_put_char_array(buf, 8, name, 10);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 18);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN);
 #else
 	mavlink_named_value_float_t packet;
 	packet.time_boot_ms = time_boot_ms;
 	packet.value = value;
 	mav_array_memcpy(packet.name, name, sizeof(char)*10);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 18);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_NAMED_VALUE_FLOAT;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 18, 170);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN);
+#endif
 }
 
 /**
- * @brief Encode a named_value_float struct into a message
+ * @brief Encode a named_value_float struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -103,6 +114,20 @@ static inline uint16_t mavlink_msg_named
 }
 
 /**
+ * @brief Encode a named_value_float struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param named_value_float C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_named_value_float_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_named_value_float_t* named_value_float)
+{
+	return mavlink_msg_named_value_float_pack_chan(system_id, component_id, chan, msg, named_value_float->time_boot_ms, named_value_float->name, named_value_float->value);
+}
+
+/**
  * @brief Send a named_value_float message
  * @param chan MAVLink channel to send the message
  *
@@ -115,20 +140,62 @@ static inline uint16_t mavlink_msg_named
 static inline void mavlink_msg_named_value_float_send(mavlink_channel_t chan, uint32_t time_boot_ms, const char *name, float value)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[18];
+	char buf[MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, value);
 	_mav_put_char_array(buf, 8, name, 10);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT, buf, 18, 170);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT, buf, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT, buf, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN);
+#endif
 #else
 	mavlink_named_value_float_t packet;
 	packet.time_boot_ms = time_boot_ms;
 	packet.value = value;
 	mav_array_memcpy(packet.name, name, sizeof(char)*10);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT, (const char *)&packet, 18, 170);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT, (const char *)&packet, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT, (const char *)&packet, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_named_value_float_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, const char *name, float value)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, value);
+	_mav_put_char_array(buf, 8, name, 10);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT, buf, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT, buf, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN);
+#endif
+#else
+	mavlink_named_value_float_t *packet = (mavlink_named_value_float_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->value = value;
+	mav_array_memcpy(packet->name, name, sizeof(char)*10);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT, (const char *)packet, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT, (const char *)packet, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE NAMED_VALUE_FLOAT UNPACKING
@@ -177,6 +244,6 @@ static inline void mavlink_msg_named_val
 	named_value_float->value = mavlink_msg_named_value_float_get_value(msg);
 	mavlink_msg_named_value_float_get_name(msg, named_value_float->name);
 #else
-	memcpy(named_value_float, _MAV_PAYLOAD(msg), 18);
+	memcpy(named_value_float, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_NAMED_VALUE_FLOAT_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_named_value_int.h v1.0/common/mavlink_msg_named_value_int.h
--- v1.0.old/common/mavlink_msg_named_value_int.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_named_value_int.h	2015-02-06 11:50:58.000000000 +0500
@@ -12,6 +12,9 @@ typedef struct __mavlink_named_value_int
 #define MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN 18
 #define MAVLINK_MSG_ID_252_LEN 18
 
+#define MAVLINK_MSG_ID_NAMED_VALUE_INT_CRC 44
+#define MAVLINK_MSG_ID_252_CRC 44
+
 #define MAVLINK_MSG_NAMED_VALUE_INT_FIELD_NAME_LEN 10
 
 #define MAVLINK_MESSAGE_INFO_NAMED_VALUE_INT { \
@@ -39,28 +42,32 @@ static inline uint16_t mavlink_msg_named
 						       uint32_t time_boot_ms, const char *name, int32_t value)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[18];
+	char buf[MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_int32_t(buf, 4, value);
 	_mav_put_char_array(buf, 8, name, 10);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 18);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN);
 #else
 	mavlink_named_value_int_t packet;
 	packet.time_boot_ms = time_boot_ms;
 	packet.value = value;
 	mav_array_memcpy(packet.name, name, sizeof(char)*10);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 18);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_NAMED_VALUE_INT;
-	return mavlink_finalize_message(msg, system_id, component_id, 18, 44);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN, MAVLINK_MSG_ID_NAMED_VALUE_INT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN);
+#endif
 }
 
 /**
  * @brief Pack a named_value_int message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_boot_ms Timestamp (milliseconds since system boot)
  * @param name Name of the debug variable
@@ -72,25 +79,29 @@ static inline uint16_t mavlink_msg_named
 						           uint32_t time_boot_ms,const char *name,int32_t value)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[18];
+	char buf[MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_int32_t(buf, 4, value);
 	_mav_put_char_array(buf, 8, name, 10);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 18);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN);
 #else
 	mavlink_named_value_int_t packet;
 	packet.time_boot_ms = time_boot_ms;
 	packet.value = value;
 	mav_array_memcpy(packet.name, name, sizeof(char)*10);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 18);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_NAMED_VALUE_INT;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 18, 44);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN, MAVLINK_MSG_ID_NAMED_VALUE_INT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN);
+#endif
 }
 
 /**
- * @brief Encode a named_value_int struct into a message
+ * @brief Encode a named_value_int struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -103,6 +114,20 @@ static inline uint16_t mavlink_msg_named
 }
 
 /**
+ * @brief Encode a named_value_int struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param named_value_int C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_named_value_int_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_named_value_int_t* named_value_int)
+{
+	return mavlink_msg_named_value_int_pack_chan(system_id, component_id, chan, msg, named_value_int->time_boot_ms, named_value_int->name, named_value_int->value);
+}
+
+/**
  * @brief Send a named_value_int message
  * @param chan MAVLink channel to send the message
  *
@@ -115,20 +140,62 @@ static inline uint16_t mavlink_msg_named
 static inline void mavlink_msg_named_value_int_send(mavlink_channel_t chan, uint32_t time_boot_ms, const char *name, int32_t value)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[18];
+	char buf[MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_int32_t(buf, 4, value);
 	_mav_put_char_array(buf, 8, name, 10);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_INT, buf, 18, 44);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_INT, buf, MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN, MAVLINK_MSG_ID_NAMED_VALUE_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_INT, buf, MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN);
+#endif
 #else
 	mavlink_named_value_int_t packet;
 	packet.time_boot_ms = time_boot_ms;
 	packet.value = value;
 	mav_array_memcpy(packet.name, name, sizeof(char)*10);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_INT, (const char *)&packet, 18, 44);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_INT, (const char *)&packet, MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN, MAVLINK_MSG_ID_NAMED_VALUE_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_INT, (const char *)&packet, MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_named_value_int_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, const char *name, int32_t value)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_int32_t(buf, 4, value);
+	_mav_put_char_array(buf, 8, name, 10);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_INT, buf, MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN, MAVLINK_MSG_ID_NAMED_VALUE_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_INT, buf, MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN);
+#endif
+#else
+	mavlink_named_value_int_t *packet = (mavlink_named_value_int_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->value = value;
+	mav_array_memcpy(packet->name, name, sizeof(char)*10);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_INT, (const char *)packet, MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN, MAVLINK_MSG_ID_NAMED_VALUE_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAMED_VALUE_INT, (const char *)packet, MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE NAMED_VALUE_INT UNPACKING
@@ -177,6 +244,6 @@ static inline void mavlink_msg_named_val
 	named_value_int->value = mavlink_msg_named_value_int_get_value(msg);
 	mavlink_msg_named_value_int_get_name(msg, named_value_int->name);
 #else
-	memcpy(named_value_int, _MAV_PAYLOAD(msg), 18);
+	memcpy(named_value_int, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_NAMED_VALUE_INT_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_nav_controller_output.h v1.0/common/mavlink_msg_nav_controller_output.h
--- v1.0.old/common/mavlink_msg_nav_controller_output.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_nav_controller_output.h	2015-02-06 11:50:58.000000000 +0500
@@ -17,6 +17,9 @@ typedef struct __mavlink_nav_controller_
 #define MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN 26
 #define MAVLINK_MSG_ID_62_LEN 26
 
+#define MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_CRC 183
+#define MAVLINK_MSG_ID_62_CRC 183
+
 
 
 #define MAVLINK_MESSAGE_INFO_NAV_CONTROLLER_OUTPUT { \
@@ -54,7 +57,7 @@ static inline uint16_t mavlink_msg_nav_c
 						       float nav_roll, float nav_pitch, int16_t nav_bearing, int16_t target_bearing, uint16_t wp_dist, float alt_error, float aspd_error, float xtrack_error)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[26];
+	char buf[MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN];
 	_mav_put_float(buf, 0, nav_roll);
 	_mav_put_float(buf, 4, nav_pitch);
 	_mav_put_float(buf, 8, alt_error);
@@ -64,7 +67,7 @@ static inline uint16_t mavlink_msg_nav_c
 	_mav_put_int16_t(buf, 22, target_bearing);
 	_mav_put_uint16_t(buf, 24, wp_dist);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 26);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN);
 #else
 	mavlink_nav_controller_output_t packet;
 	packet.nav_roll = nav_roll;
@@ -76,18 +79,22 @@ static inline uint16_t mavlink_msg_nav_c
 	packet.target_bearing = target_bearing;
 	packet.wp_dist = wp_dist;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 26);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT;
-	return mavlink_finalize_message(msg, system_id, component_id, 26, 183);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN);
+#endif
 }
 
 /**
  * @brief Pack a nav_controller_output message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param nav_roll Current desired roll in degrees
  * @param nav_pitch Current desired pitch in degrees
@@ -104,7 +111,7 @@ static inline uint16_t mavlink_msg_nav_c
 						           float nav_roll,float nav_pitch,int16_t nav_bearing,int16_t target_bearing,uint16_t wp_dist,float alt_error,float aspd_error,float xtrack_error)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[26];
+	char buf[MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN];
 	_mav_put_float(buf, 0, nav_roll);
 	_mav_put_float(buf, 4, nav_pitch);
 	_mav_put_float(buf, 8, alt_error);
@@ -114,7 +121,7 @@ static inline uint16_t mavlink_msg_nav_c
 	_mav_put_int16_t(buf, 22, target_bearing);
 	_mav_put_uint16_t(buf, 24, wp_dist);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 26);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN);
 #else
 	mavlink_nav_controller_output_t packet;
 	packet.nav_roll = nav_roll;
@@ -126,15 +133,19 @@ static inline uint16_t mavlink_msg_nav_c
 	packet.target_bearing = target_bearing;
 	packet.wp_dist = wp_dist;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 26);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 26, 183);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN);
+#endif
 }
 
 /**
- * @brief Encode a nav_controller_output struct into a message
+ * @brief Encode a nav_controller_output struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -147,6 +158,20 @@ static inline uint16_t mavlink_msg_nav_c
 }
 
 /**
+ * @brief Encode a nav_controller_output struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param nav_controller_output C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_nav_controller_output_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_nav_controller_output_t* nav_controller_output)
+{
+	return mavlink_msg_nav_controller_output_pack_chan(system_id, component_id, chan, msg, nav_controller_output->nav_roll, nav_controller_output->nav_pitch, nav_controller_output->nav_bearing, nav_controller_output->target_bearing, nav_controller_output->wp_dist, nav_controller_output->alt_error, nav_controller_output->aspd_error, nav_controller_output->xtrack_error);
+}
+
+/**
  * @brief Send a nav_controller_output message
  * @param chan MAVLink channel to send the message
  *
@@ -164,7 +189,7 @@ static inline uint16_t mavlink_msg_nav_c
 static inline void mavlink_msg_nav_controller_output_send(mavlink_channel_t chan, float nav_roll, float nav_pitch, int16_t nav_bearing, int16_t target_bearing, uint16_t wp_dist, float alt_error, float aspd_error, float xtrack_error)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[26];
+	char buf[MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN];
 	_mav_put_float(buf, 0, nav_roll);
 	_mav_put_float(buf, 4, nav_pitch);
 	_mav_put_float(buf, 8, alt_error);
@@ -174,7 +199,11 @@ static inline void mavlink_msg_nav_contr
 	_mav_put_int16_t(buf, 22, target_bearing);
 	_mav_put_uint16_t(buf, 24, wp_dist);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT, buf, 26, 183);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT, buf, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT, buf, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN);
+#endif
 #else
 	mavlink_nav_controller_output_t packet;
 	packet.nav_roll = nav_roll;
@@ -186,10 +215,60 @@ static inline void mavlink_msg_nav_contr
 	packet.target_bearing = target_bearing;
 	packet.wp_dist = wp_dist;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT, (const char *)&packet, 26, 183);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT, (const char *)&packet, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT, (const char *)&packet, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_nav_controller_output_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  float nav_roll, float nav_pitch, int16_t nav_bearing, int16_t target_bearing, uint16_t wp_dist, float alt_error, float aspd_error, float xtrack_error)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_float(buf, 0, nav_roll);
+	_mav_put_float(buf, 4, nav_pitch);
+	_mav_put_float(buf, 8, alt_error);
+	_mav_put_float(buf, 12, aspd_error);
+	_mav_put_float(buf, 16, xtrack_error);
+	_mav_put_int16_t(buf, 20, nav_bearing);
+	_mav_put_int16_t(buf, 22, target_bearing);
+	_mav_put_uint16_t(buf, 24, wp_dist);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT, buf, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT, buf, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN);
+#endif
+#else
+	mavlink_nav_controller_output_t *packet = (mavlink_nav_controller_output_t *)msgbuf;
+	packet->nav_roll = nav_roll;
+	packet->nav_pitch = nav_pitch;
+	packet->alt_error = alt_error;
+	packet->aspd_error = aspd_error;
+	packet->xtrack_error = xtrack_error;
+	packet->nav_bearing = nav_bearing;
+	packet->target_bearing = target_bearing;
+	packet->wp_dist = wp_dist;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT, (const char *)packet, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT, (const char *)packet, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE NAV_CONTROLLER_OUTPUT UNPACKING
@@ -293,6 +372,6 @@ static inline void mavlink_msg_nav_contr
 	nav_controller_output->target_bearing = mavlink_msg_nav_controller_output_get_target_bearing(msg);
 	nav_controller_output->wp_dist = mavlink_msg_nav_controller_output_get_wp_dist(msg);
 #else
-	memcpy(nav_controller_output, _MAV_PAYLOAD(msg), 26);
+	memcpy(nav_controller_output, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_optical_flow.h v1.0/common/mavlink_msg_optical_flow.h
--- v1.0.old/common/mavlink_msg_optical_flow.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_optical_flow.h	2015-02-06 11:50:58.000000000 +0500
@@ -8,8 +8,8 @@ typedef struct __mavlink_optical_flow_t
  float flow_comp_m_x; ///< Flow in meters in x-sensor direction, angular-speed compensated
  float flow_comp_m_y; ///< Flow in meters in y-sensor direction, angular-speed compensated
  float ground_distance; ///< Ground distance in meters. Positive value: distance known. Negative value: Unknown distance
- int16_t flow_x; ///< Flow in pixels in x-sensor direction
- int16_t flow_y; ///< Flow in pixels in y-sensor direction
+ int16_t flow_x; ///< Flow in pixels * 10 in x-sensor direction (dezi-pixels)
+ int16_t flow_y; ///< Flow in pixels * 10 in y-sensor direction (dezi-pixels)
  uint8_t sensor_id; ///< Sensor ID
  uint8_t quality; ///< Optical flow quality / confidence. 0: bad, 255: maximum quality
 } mavlink_optical_flow_t;
@@ -17,6 +17,9 @@ typedef struct __mavlink_optical_flow_t
 #define MAVLINK_MSG_ID_OPTICAL_FLOW_LEN 26
 #define MAVLINK_MSG_ID_100_LEN 26
 
+#define MAVLINK_MSG_ID_OPTICAL_FLOW_CRC 175
+#define MAVLINK_MSG_ID_100_CRC 175
+
 
 
 #define MAVLINK_MESSAGE_INFO_OPTICAL_FLOW { \
@@ -42,8 +45,8 @@ typedef struct __mavlink_optical_flow_t
  *
  * @param time_usec Timestamp (UNIX)
  * @param sensor_id Sensor ID
- * @param flow_x Flow in pixels in x-sensor direction
- * @param flow_y Flow in pixels in y-sensor direction
+ * @param flow_x Flow in pixels * 10 in x-sensor direction (dezi-pixels)
+ * @param flow_y Flow in pixels * 10 in y-sensor direction (dezi-pixels)
  * @param flow_comp_m_x Flow in meters in x-sensor direction, angular-speed compensated
  * @param flow_comp_m_y Flow in meters in y-sensor direction, angular-speed compensated
  * @param quality Optical flow quality / confidence. 0: bad, 255: maximum quality
@@ -54,7 +57,7 @@ static inline uint16_t mavlink_msg_optic
 						       uint64_t time_usec, uint8_t sensor_id, int16_t flow_x, int16_t flow_y, float flow_comp_m_x, float flow_comp_m_y, uint8_t quality, float ground_distance)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[26];
+	char buf[MAVLINK_MSG_ID_OPTICAL_FLOW_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_float(buf, 8, flow_comp_m_x);
 	_mav_put_float(buf, 12, flow_comp_m_y);
@@ -64,7 +67,7 @@ static inline uint16_t mavlink_msg_optic
 	_mav_put_uint8_t(buf, 24, sensor_id);
 	_mav_put_uint8_t(buf, 25, quality);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 26);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_OPTICAL_FLOW_LEN);
 #else
 	mavlink_optical_flow_t packet;
 	packet.time_usec = time_usec;
@@ -76,23 +79,27 @@ static inline uint16_t mavlink_msg_optic
 	packet.sensor_id = sensor_id;
 	packet.quality = quality;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 26);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_OPTICAL_FLOW_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_OPTICAL_FLOW;
-	return mavlink_finalize_message(msg, system_id, component_id, 26, 175);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_OPTICAL_FLOW_LEN, MAVLINK_MSG_ID_OPTICAL_FLOW_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_OPTICAL_FLOW_LEN);
+#endif
 }
 
 /**
  * @brief Pack a optical_flow message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_usec Timestamp (UNIX)
  * @param sensor_id Sensor ID
- * @param flow_x Flow in pixels in x-sensor direction
- * @param flow_y Flow in pixels in y-sensor direction
+ * @param flow_x Flow in pixels * 10 in x-sensor direction (dezi-pixels)
+ * @param flow_y Flow in pixels * 10 in y-sensor direction (dezi-pixels)
  * @param flow_comp_m_x Flow in meters in x-sensor direction, angular-speed compensated
  * @param flow_comp_m_y Flow in meters in y-sensor direction, angular-speed compensated
  * @param quality Optical flow quality / confidence. 0: bad, 255: maximum quality
@@ -104,7 +111,7 @@ static inline uint16_t mavlink_msg_optic
 						           uint64_t time_usec,uint8_t sensor_id,int16_t flow_x,int16_t flow_y,float flow_comp_m_x,float flow_comp_m_y,uint8_t quality,float ground_distance)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[26];
+	char buf[MAVLINK_MSG_ID_OPTICAL_FLOW_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_float(buf, 8, flow_comp_m_x);
 	_mav_put_float(buf, 12, flow_comp_m_y);
@@ -114,7 +121,7 @@ static inline uint16_t mavlink_msg_optic
 	_mav_put_uint8_t(buf, 24, sensor_id);
 	_mav_put_uint8_t(buf, 25, quality);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 26);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_OPTICAL_FLOW_LEN);
 #else
 	mavlink_optical_flow_t packet;
 	packet.time_usec = time_usec;
@@ -126,15 +133,19 @@ static inline uint16_t mavlink_msg_optic
 	packet.sensor_id = sensor_id;
 	packet.quality = quality;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 26);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_OPTICAL_FLOW_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_OPTICAL_FLOW;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 26, 175);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_OPTICAL_FLOW_LEN, MAVLINK_MSG_ID_OPTICAL_FLOW_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_OPTICAL_FLOW_LEN);
+#endif
 }
 
 /**
- * @brief Encode a optical_flow struct into a message
+ * @brief Encode a optical_flow struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -147,13 +158,27 @@ static inline uint16_t mavlink_msg_optic
 }
 
 /**
+ * @brief Encode a optical_flow struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param optical_flow C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_optical_flow_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_optical_flow_t* optical_flow)
+{
+	return mavlink_msg_optical_flow_pack_chan(system_id, component_id, chan, msg, optical_flow->time_usec, optical_flow->sensor_id, optical_flow->flow_x, optical_flow->flow_y, optical_flow->flow_comp_m_x, optical_flow->flow_comp_m_y, optical_flow->quality, optical_flow->ground_distance);
+}
+
+/**
  * @brief Send a optical_flow message
  * @param chan MAVLink channel to send the message
  *
  * @param time_usec Timestamp (UNIX)
  * @param sensor_id Sensor ID
- * @param flow_x Flow in pixels in x-sensor direction
- * @param flow_y Flow in pixels in y-sensor direction
+ * @param flow_x Flow in pixels * 10 in x-sensor direction (dezi-pixels)
+ * @param flow_y Flow in pixels * 10 in y-sensor direction (dezi-pixels)
  * @param flow_comp_m_x Flow in meters in x-sensor direction, angular-speed compensated
  * @param flow_comp_m_y Flow in meters in y-sensor direction, angular-speed compensated
  * @param quality Optical flow quality / confidence. 0: bad, 255: maximum quality
@@ -164,7 +189,7 @@ static inline uint16_t mavlink_msg_optic
 static inline void mavlink_msg_optical_flow_send(mavlink_channel_t chan, uint64_t time_usec, uint8_t sensor_id, int16_t flow_x, int16_t flow_y, float flow_comp_m_x, float flow_comp_m_y, uint8_t quality, float ground_distance)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[26];
+	char buf[MAVLINK_MSG_ID_OPTICAL_FLOW_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_float(buf, 8, flow_comp_m_x);
 	_mav_put_float(buf, 12, flow_comp_m_y);
@@ -174,7 +199,11 @@ static inline void mavlink_msg_optical_f
 	_mav_put_uint8_t(buf, 24, sensor_id);
 	_mav_put_uint8_t(buf, 25, quality);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW, buf, 26, 175);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW, buf, MAVLINK_MSG_ID_OPTICAL_FLOW_LEN, MAVLINK_MSG_ID_OPTICAL_FLOW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW, buf, MAVLINK_MSG_ID_OPTICAL_FLOW_LEN);
+#endif
 #else
 	mavlink_optical_flow_t packet;
 	packet.time_usec = time_usec;
@@ -186,10 +215,60 @@ static inline void mavlink_msg_optical_f
 	packet.sensor_id = sensor_id;
 	packet.quality = quality;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW, (const char *)&packet, 26, 175);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW, (const char *)&packet, MAVLINK_MSG_ID_OPTICAL_FLOW_LEN, MAVLINK_MSG_ID_OPTICAL_FLOW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW, (const char *)&packet, MAVLINK_MSG_ID_OPTICAL_FLOW_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_OPTICAL_FLOW_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_optical_flow_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t time_usec, uint8_t sensor_id, int16_t flow_x, int16_t flow_y, float flow_comp_m_x, float flow_comp_m_y, uint8_t quality, float ground_distance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_float(buf, 8, flow_comp_m_x);
+	_mav_put_float(buf, 12, flow_comp_m_y);
+	_mav_put_float(buf, 16, ground_distance);
+	_mav_put_int16_t(buf, 20, flow_x);
+	_mav_put_int16_t(buf, 22, flow_y);
+	_mav_put_uint8_t(buf, 24, sensor_id);
+	_mav_put_uint8_t(buf, 25, quality);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW, buf, MAVLINK_MSG_ID_OPTICAL_FLOW_LEN, MAVLINK_MSG_ID_OPTICAL_FLOW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW, buf, MAVLINK_MSG_ID_OPTICAL_FLOW_LEN);
+#endif
+#else
+	mavlink_optical_flow_t *packet = (mavlink_optical_flow_t *)msgbuf;
+	packet->time_usec = time_usec;
+	packet->flow_comp_m_x = flow_comp_m_x;
+	packet->flow_comp_m_y = flow_comp_m_y;
+	packet->ground_distance = ground_distance;
+	packet->flow_x = flow_x;
+	packet->flow_y = flow_y;
+	packet->sensor_id = sensor_id;
+	packet->quality = quality;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW, (const char *)packet, MAVLINK_MSG_ID_OPTICAL_FLOW_LEN, MAVLINK_MSG_ID_OPTICAL_FLOW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW, (const char *)packet, MAVLINK_MSG_ID_OPTICAL_FLOW_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE OPTICAL_FLOW UNPACKING
@@ -218,7 +297,7 @@ static inline uint8_t mavlink_msg_optica
 /**
  * @brief Get field flow_x from optical_flow message
  *
- * @return Flow in pixels in x-sensor direction
+ * @return Flow in pixels * 10 in x-sensor direction (dezi-pixels)
  */
 static inline int16_t mavlink_msg_optical_flow_get_flow_x(const mavlink_message_t* msg)
 {
@@ -228,7 +307,7 @@ static inline int16_t mavlink_msg_optica
 /**
  * @brief Get field flow_y from optical_flow message
  *
- * @return Flow in pixels in y-sensor direction
+ * @return Flow in pixels * 10 in y-sensor direction (dezi-pixels)
  */
 static inline int16_t mavlink_msg_optical_flow_get_flow_y(const mavlink_message_t* msg)
 {
@@ -293,6 +372,6 @@ static inline void mavlink_msg_optical_f
 	optical_flow->sensor_id = mavlink_msg_optical_flow_get_sensor_id(msg);
 	optical_flow->quality = mavlink_msg_optical_flow_get_quality(msg);
 #else
-	memcpy(optical_flow, _MAV_PAYLOAD(msg), 26);
+	memcpy(optical_flow, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_OPTICAL_FLOW_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_optical_flow_rad.h v1.0/common/mavlink_msg_optical_flow_rad.h
--- v1.0.old/common/mavlink_msg_optical_flow_rad.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_optical_flow_rad.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,473 @@
+// MESSAGE OPTICAL_FLOW_RAD PACKING
+
+#define MAVLINK_MSG_ID_OPTICAL_FLOW_RAD 106
+
+typedef struct __mavlink_optical_flow_rad_t
+{
+ uint64_t time_usec; ///< Timestamp (microseconds, synced to UNIX time or since system boot)
+ uint32_t integration_time_us; ///< Integration time in microseconds. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
+ float integrated_x; ///< Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
+ float integrated_y; ///< Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
+ float integrated_xgyro; ///< RH rotation around X axis (rad)
+ float integrated_ygyro; ///< RH rotation around Y axis (rad)
+ float integrated_zgyro; ///< RH rotation around Z axis (rad)
+ uint32_t time_delta_distance_us; ///< Time in microseconds since the distance was sampled.
+ float distance; ///< Distance to the center of the flow field in meters. Positive value (including zero): distance known. Negative value: Unknown distance.
+ int16_t temperature; ///< Temperature * 100 in centi-degrees Celsius
+ uint8_t sensor_id; ///< Sensor ID
+ uint8_t quality; ///< Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
+} mavlink_optical_flow_rad_t;
+
+#define MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN 44
+#define MAVLINK_MSG_ID_106_LEN 44
+
+#define MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_CRC 138
+#define MAVLINK_MSG_ID_106_CRC 138
+
+
+
+#define MAVLINK_MESSAGE_INFO_OPTICAL_FLOW_RAD { \
+	"OPTICAL_FLOW_RAD", \
+	12, \
+	{  { "time_usec", NULL, MAVLINK_TYPE_UINT64_T, 0, 0, offsetof(mavlink_optical_flow_rad_t, time_usec) }, \
+         { "integration_time_us", NULL, MAVLINK_TYPE_UINT32_T, 0, 8, offsetof(mavlink_optical_flow_rad_t, integration_time_us) }, \
+         { "integrated_x", NULL, MAVLINK_TYPE_FLOAT, 0, 12, offsetof(mavlink_optical_flow_rad_t, integrated_x) }, \
+         { "integrated_y", NULL, MAVLINK_TYPE_FLOAT, 0, 16, offsetof(mavlink_optical_flow_rad_t, integrated_y) }, \
+         { "integrated_xgyro", NULL, MAVLINK_TYPE_FLOAT, 0, 20, offsetof(mavlink_optical_flow_rad_t, integrated_xgyro) }, \
+         { "integrated_ygyro", NULL, MAVLINK_TYPE_FLOAT, 0, 24, offsetof(mavlink_optical_flow_rad_t, integrated_ygyro) }, \
+         { "integrated_zgyro", NULL, MAVLINK_TYPE_FLOAT, 0, 28, offsetof(mavlink_optical_flow_rad_t, integrated_zgyro) }, \
+         { "time_delta_distance_us", NULL, MAVLINK_TYPE_UINT32_T, 0, 32, offsetof(mavlink_optical_flow_rad_t, time_delta_distance_us) }, \
+         { "distance", NULL, MAVLINK_TYPE_FLOAT, 0, 36, offsetof(mavlink_optical_flow_rad_t, distance) }, \
+         { "temperature", NULL, MAVLINK_TYPE_INT16_T, 0, 40, offsetof(mavlink_optical_flow_rad_t, temperature) }, \
+         { "sensor_id", NULL, MAVLINK_TYPE_UINT8_T, 0, 42, offsetof(mavlink_optical_flow_rad_t, sensor_id) }, \
+         { "quality", NULL, MAVLINK_TYPE_UINT8_T, 0, 43, offsetof(mavlink_optical_flow_rad_t, quality) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a optical_flow_rad message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_usec Timestamp (microseconds, synced to UNIX time or since system boot)
+ * @param sensor_id Sensor ID
+ * @param integration_time_us Integration time in microseconds. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
+ * @param integrated_x Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
+ * @param integrated_y Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
+ * @param integrated_xgyro RH rotation around X axis (rad)
+ * @param integrated_ygyro RH rotation around Y axis (rad)
+ * @param integrated_zgyro RH rotation around Z axis (rad)
+ * @param temperature Temperature * 100 in centi-degrees Celsius
+ * @param quality Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
+ * @param time_delta_distance_us Time in microseconds since the distance was sampled.
+ * @param distance Distance to the center of the flow field in meters. Positive value (including zero): distance known. Negative value: Unknown distance.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_optical_flow_rad_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint64_t time_usec, uint8_t sensor_id, uint32_t integration_time_us, float integrated_x, float integrated_y, float integrated_xgyro, float integrated_ygyro, float integrated_zgyro, int16_t temperature, uint8_t quality, uint32_t time_delta_distance_us, float distance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_uint32_t(buf, 8, integration_time_us);
+	_mav_put_float(buf, 12, integrated_x);
+	_mav_put_float(buf, 16, integrated_y);
+	_mav_put_float(buf, 20, integrated_xgyro);
+	_mav_put_float(buf, 24, integrated_ygyro);
+	_mav_put_float(buf, 28, integrated_zgyro);
+	_mav_put_uint32_t(buf, 32, time_delta_distance_us);
+	_mav_put_float(buf, 36, distance);
+	_mav_put_int16_t(buf, 40, temperature);
+	_mav_put_uint8_t(buf, 42, sensor_id);
+	_mav_put_uint8_t(buf, 43, quality);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN);
+#else
+	mavlink_optical_flow_rad_t packet;
+	packet.time_usec = time_usec;
+	packet.integration_time_us = integration_time_us;
+	packet.integrated_x = integrated_x;
+	packet.integrated_y = integrated_y;
+	packet.integrated_xgyro = integrated_xgyro;
+	packet.integrated_ygyro = integrated_ygyro;
+	packet.integrated_zgyro = integrated_zgyro;
+	packet.time_delta_distance_us = time_delta_distance_us;
+	packet.distance = distance;
+	packet.temperature = temperature;
+	packet.sensor_id = sensor_id;
+	packet.quality = quality;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_OPTICAL_FLOW_RAD;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a optical_flow_rad message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_usec Timestamp (microseconds, synced to UNIX time or since system boot)
+ * @param sensor_id Sensor ID
+ * @param integration_time_us Integration time in microseconds. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
+ * @param integrated_x Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
+ * @param integrated_y Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
+ * @param integrated_xgyro RH rotation around X axis (rad)
+ * @param integrated_ygyro RH rotation around Y axis (rad)
+ * @param integrated_zgyro RH rotation around Z axis (rad)
+ * @param temperature Temperature * 100 in centi-degrees Celsius
+ * @param quality Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
+ * @param time_delta_distance_us Time in microseconds since the distance was sampled.
+ * @param distance Distance to the center of the flow field in meters. Positive value (including zero): distance known. Negative value: Unknown distance.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_optical_flow_rad_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint64_t time_usec,uint8_t sensor_id,uint32_t integration_time_us,float integrated_x,float integrated_y,float integrated_xgyro,float integrated_ygyro,float integrated_zgyro,int16_t temperature,uint8_t quality,uint32_t time_delta_distance_us,float distance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_uint32_t(buf, 8, integration_time_us);
+	_mav_put_float(buf, 12, integrated_x);
+	_mav_put_float(buf, 16, integrated_y);
+	_mav_put_float(buf, 20, integrated_xgyro);
+	_mav_put_float(buf, 24, integrated_ygyro);
+	_mav_put_float(buf, 28, integrated_zgyro);
+	_mav_put_uint32_t(buf, 32, time_delta_distance_us);
+	_mav_put_float(buf, 36, distance);
+	_mav_put_int16_t(buf, 40, temperature);
+	_mav_put_uint8_t(buf, 42, sensor_id);
+	_mav_put_uint8_t(buf, 43, quality);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN);
+#else
+	mavlink_optical_flow_rad_t packet;
+	packet.time_usec = time_usec;
+	packet.integration_time_us = integration_time_us;
+	packet.integrated_x = integrated_x;
+	packet.integrated_y = integrated_y;
+	packet.integrated_xgyro = integrated_xgyro;
+	packet.integrated_ygyro = integrated_ygyro;
+	packet.integrated_zgyro = integrated_zgyro;
+	packet.time_delta_distance_us = time_delta_distance_us;
+	packet.distance = distance;
+	packet.temperature = temperature;
+	packet.sensor_id = sensor_id;
+	packet.quality = quality;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_OPTICAL_FLOW_RAD;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a optical_flow_rad struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param optical_flow_rad C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_optical_flow_rad_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_optical_flow_rad_t* optical_flow_rad)
+{
+	return mavlink_msg_optical_flow_rad_pack(system_id, component_id, msg, optical_flow_rad->time_usec, optical_flow_rad->sensor_id, optical_flow_rad->integration_time_us, optical_flow_rad->integrated_x, optical_flow_rad->integrated_y, optical_flow_rad->integrated_xgyro, optical_flow_rad->integrated_ygyro, optical_flow_rad->integrated_zgyro, optical_flow_rad->temperature, optical_flow_rad->quality, optical_flow_rad->time_delta_distance_us, optical_flow_rad->distance);
+}
+
+/**
+ * @brief Encode a optical_flow_rad struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param optical_flow_rad C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_optical_flow_rad_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_optical_flow_rad_t* optical_flow_rad)
+{
+	return mavlink_msg_optical_flow_rad_pack_chan(system_id, component_id, chan, msg, optical_flow_rad->time_usec, optical_flow_rad->sensor_id, optical_flow_rad->integration_time_us, optical_flow_rad->integrated_x, optical_flow_rad->integrated_y, optical_flow_rad->integrated_xgyro, optical_flow_rad->integrated_ygyro, optical_flow_rad->integrated_zgyro, optical_flow_rad->temperature, optical_flow_rad->quality, optical_flow_rad->time_delta_distance_us, optical_flow_rad->distance);
+}
+
+/**
+ * @brief Send a optical_flow_rad message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_usec Timestamp (microseconds, synced to UNIX time or since system boot)
+ * @param sensor_id Sensor ID
+ * @param integration_time_us Integration time in microseconds. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
+ * @param integrated_x Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
+ * @param integrated_y Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
+ * @param integrated_xgyro RH rotation around X axis (rad)
+ * @param integrated_ygyro RH rotation around Y axis (rad)
+ * @param integrated_zgyro RH rotation around Z axis (rad)
+ * @param temperature Temperature * 100 in centi-degrees Celsius
+ * @param quality Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
+ * @param time_delta_distance_us Time in microseconds since the distance was sampled.
+ * @param distance Distance to the center of the flow field in meters. Positive value (including zero): distance known. Negative value: Unknown distance.
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_optical_flow_rad_send(mavlink_channel_t chan, uint64_t time_usec, uint8_t sensor_id, uint32_t integration_time_us, float integrated_x, float integrated_y, float integrated_xgyro, float integrated_ygyro, float integrated_zgyro, int16_t temperature, uint8_t quality, uint32_t time_delta_distance_us, float distance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN];
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_uint32_t(buf, 8, integration_time_us);
+	_mav_put_float(buf, 12, integrated_x);
+	_mav_put_float(buf, 16, integrated_y);
+	_mav_put_float(buf, 20, integrated_xgyro);
+	_mav_put_float(buf, 24, integrated_ygyro);
+	_mav_put_float(buf, 28, integrated_zgyro);
+	_mav_put_uint32_t(buf, 32, time_delta_distance_us);
+	_mav_put_float(buf, 36, distance);
+	_mav_put_int16_t(buf, 40, temperature);
+	_mav_put_uint8_t(buf, 42, sensor_id);
+	_mav_put_uint8_t(buf, 43, quality);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD, buf, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD, buf, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN);
+#endif
+#else
+	mavlink_optical_flow_rad_t packet;
+	packet.time_usec = time_usec;
+	packet.integration_time_us = integration_time_us;
+	packet.integrated_x = integrated_x;
+	packet.integrated_y = integrated_y;
+	packet.integrated_xgyro = integrated_xgyro;
+	packet.integrated_ygyro = integrated_ygyro;
+	packet.integrated_zgyro = integrated_zgyro;
+	packet.time_delta_distance_us = time_delta_distance_us;
+	packet.distance = distance;
+	packet.temperature = temperature;
+	packet.sensor_id = sensor_id;
+	packet.quality = quality;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD, (const char *)&packet, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD, (const char *)&packet, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_optical_flow_rad_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t time_usec, uint8_t sensor_id, uint32_t integration_time_us, float integrated_x, float integrated_y, float integrated_xgyro, float integrated_ygyro, float integrated_zgyro, int16_t temperature, uint8_t quality, uint32_t time_delta_distance_us, float distance)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_uint32_t(buf, 8, integration_time_us);
+	_mav_put_float(buf, 12, integrated_x);
+	_mav_put_float(buf, 16, integrated_y);
+	_mav_put_float(buf, 20, integrated_xgyro);
+	_mav_put_float(buf, 24, integrated_ygyro);
+	_mav_put_float(buf, 28, integrated_zgyro);
+	_mav_put_uint32_t(buf, 32, time_delta_distance_us);
+	_mav_put_float(buf, 36, distance);
+	_mav_put_int16_t(buf, 40, temperature);
+	_mav_put_uint8_t(buf, 42, sensor_id);
+	_mav_put_uint8_t(buf, 43, quality);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD, buf, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD, buf, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN);
+#endif
+#else
+	mavlink_optical_flow_rad_t *packet = (mavlink_optical_flow_rad_t *)msgbuf;
+	packet->time_usec = time_usec;
+	packet->integration_time_us = integration_time_us;
+	packet->integrated_x = integrated_x;
+	packet->integrated_y = integrated_y;
+	packet->integrated_xgyro = integrated_xgyro;
+	packet->integrated_ygyro = integrated_ygyro;
+	packet->integrated_zgyro = integrated_zgyro;
+	packet->time_delta_distance_us = time_delta_distance_us;
+	packet->distance = distance;
+	packet->temperature = temperature;
+	packet->sensor_id = sensor_id;
+	packet->quality = quality;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD, (const char *)packet, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD, (const char *)packet, MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE OPTICAL_FLOW_RAD UNPACKING
+
+
+/**
+ * @brief Get field time_usec from optical_flow_rad message
+ *
+ * @return Timestamp (microseconds, synced to UNIX time or since system boot)
+ */
+static inline uint64_t mavlink_msg_optical_flow_rad_get_time_usec(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint64_t(msg,  0);
+}
+
+/**
+ * @brief Get field sensor_id from optical_flow_rad message
+ *
+ * @return Sensor ID
+ */
+static inline uint8_t mavlink_msg_optical_flow_rad_get_sensor_id(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  42);
+}
+
+/**
+ * @brief Get field integration_time_us from optical_flow_rad message
+ *
+ * @return Integration time in microseconds. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
+ */
+static inline uint32_t mavlink_msg_optical_flow_rad_get_integration_time_us(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  8);
+}
+
+/**
+ * @brief Get field integrated_x from optical_flow_rad message
+ *
+ * @return Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
+ */
+static inline float mavlink_msg_optical_flow_rad_get_integrated_x(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  12);
+}
+
+/**
+ * @brief Get field integrated_y from optical_flow_rad message
+ *
+ * @return Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
+ */
+static inline float mavlink_msg_optical_flow_rad_get_integrated_y(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  16);
+}
+
+/**
+ * @brief Get field integrated_xgyro from optical_flow_rad message
+ *
+ * @return RH rotation around X axis (rad)
+ */
+static inline float mavlink_msg_optical_flow_rad_get_integrated_xgyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  20);
+}
+
+/**
+ * @brief Get field integrated_ygyro from optical_flow_rad message
+ *
+ * @return RH rotation around Y axis (rad)
+ */
+static inline float mavlink_msg_optical_flow_rad_get_integrated_ygyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  24);
+}
+
+/**
+ * @brief Get field integrated_zgyro from optical_flow_rad message
+ *
+ * @return RH rotation around Z axis (rad)
+ */
+static inline float mavlink_msg_optical_flow_rad_get_integrated_zgyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  28);
+}
+
+/**
+ * @brief Get field temperature from optical_flow_rad message
+ *
+ * @return Temperature * 100 in centi-degrees Celsius
+ */
+static inline int16_t mavlink_msg_optical_flow_rad_get_temperature(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  40);
+}
+
+/**
+ * @brief Get field quality from optical_flow_rad message
+ *
+ * @return Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
+ */
+static inline uint8_t mavlink_msg_optical_flow_rad_get_quality(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  43);
+}
+
+/**
+ * @brief Get field time_delta_distance_us from optical_flow_rad message
+ *
+ * @return Time in microseconds since the distance was sampled.
+ */
+static inline uint32_t mavlink_msg_optical_flow_rad_get_time_delta_distance_us(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  32);
+}
+
+/**
+ * @brief Get field distance from optical_flow_rad message
+ *
+ * @return Distance to the center of the flow field in meters. Positive value (including zero): distance known. Negative value: Unknown distance.
+ */
+static inline float mavlink_msg_optical_flow_rad_get_distance(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  36);
+}
+
+/**
+ * @brief Decode a optical_flow_rad message into a struct
+ *
+ * @param msg The message to decode
+ * @param optical_flow_rad C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_optical_flow_rad_decode(const mavlink_message_t* msg, mavlink_optical_flow_rad_t* optical_flow_rad)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	optical_flow_rad->time_usec = mavlink_msg_optical_flow_rad_get_time_usec(msg);
+	optical_flow_rad->integration_time_us = mavlink_msg_optical_flow_rad_get_integration_time_us(msg);
+	optical_flow_rad->integrated_x = mavlink_msg_optical_flow_rad_get_integrated_x(msg);
+	optical_flow_rad->integrated_y = mavlink_msg_optical_flow_rad_get_integrated_y(msg);
+	optical_flow_rad->integrated_xgyro = mavlink_msg_optical_flow_rad_get_integrated_xgyro(msg);
+	optical_flow_rad->integrated_ygyro = mavlink_msg_optical_flow_rad_get_integrated_ygyro(msg);
+	optical_flow_rad->integrated_zgyro = mavlink_msg_optical_flow_rad_get_integrated_zgyro(msg);
+	optical_flow_rad->time_delta_distance_us = mavlink_msg_optical_flow_rad_get_time_delta_distance_us(msg);
+	optical_flow_rad->distance = mavlink_msg_optical_flow_rad_get_distance(msg);
+	optical_flow_rad->temperature = mavlink_msg_optical_flow_rad_get_temperature(msg);
+	optical_flow_rad->sensor_id = mavlink_msg_optical_flow_rad_get_sensor_id(msg);
+	optical_flow_rad->quality = mavlink_msg_optical_flow_rad_get_quality(msg);
+#else
+	memcpy(optical_flow_rad, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_OPTICAL_FLOW_RAD_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_param_map_rc.h v1.0/common/mavlink_msg_param_map_rc.h
--- v1.0.old/common/mavlink_msg_param_map_rc.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_param_map_rc.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,393 @@
+// MESSAGE PARAM_MAP_RC PACKING
+
+#define MAVLINK_MSG_ID_PARAM_MAP_RC 50
+
+typedef struct __mavlink_param_map_rc_t
+{
+ float param_value0; ///< Initial parameter value
+ float scale; ///< Scale, maps the RC range [-1, 1] to a parameter value
+ float param_value_min; ///< Minimum param value. The protocol does not define if this overwrites an onboard minimum value. (Depends on implementation)
+ float param_value_max; ///< Maximum param value. The protocol does not define if this overwrites an onboard maximum value. (Depends on implementation)
+ int16_t param_index; ///< Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index.
+ uint8_t target_system; ///< System ID
+ uint8_t target_component; ///< Component ID
+ char param_id[16]; ///< Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ uint8_t parameter_rc_channel_index; ///< Index of parameter RC channel. Not equal to the RC channel id. Typically correpsonds to a potentiometer-knob on the RC.
+} mavlink_param_map_rc_t;
+
+#define MAVLINK_MSG_ID_PARAM_MAP_RC_LEN 37
+#define MAVLINK_MSG_ID_50_LEN 37
+
+#define MAVLINK_MSG_ID_PARAM_MAP_RC_CRC 78
+#define MAVLINK_MSG_ID_50_CRC 78
+
+#define MAVLINK_MSG_PARAM_MAP_RC_FIELD_PARAM_ID_LEN 16
+
+#define MAVLINK_MESSAGE_INFO_PARAM_MAP_RC { \
+	"PARAM_MAP_RC", \
+	9, \
+	{  { "param_value0", NULL, MAVLINK_TYPE_FLOAT, 0, 0, offsetof(mavlink_param_map_rc_t, param_value0) }, \
+         { "scale", NULL, MAVLINK_TYPE_FLOAT, 0, 4, offsetof(mavlink_param_map_rc_t, scale) }, \
+         { "param_value_min", NULL, MAVLINK_TYPE_FLOAT, 0, 8, offsetof(mavlink_param_map_rc_t, param_value_min) }, \
+         { "param_value_max", NULL, MAVLINK_TYPE_FLOAT, 0, 12, offsetof(mavlink_param_map_rc_t, param_value_max) }, \
+         { "param_index", NULL, MAVLINK_TYPE_INT16_T, 0, 16, offsetof(mavlink_param_map_rc_t, param_index) }, \
+         { "target_system", NULL, MAVLINK_TYPE_UINT8_T, 0, 18, offsetof(mavlink_param_map_rc_t, target_system) }, \
+         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 19, offsetof(mavlink_param_map_rc_t, target_component) }, \
+         { "param_id", NULL, MAVLINK_TYPE_CHAR, 16, 20, offsetof(mavlink_param_map_rc_t, param_id) }, \
+         { "parameter_rc_channel_index", NULL, MAVLINK_TYPE_UINT8_T, 0, 36, offsetof(mavlink_param_map_rc_t, parameter_rc_channel_index) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a param_map_rc message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ * @param param_index Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index.
+ * @param parameter_rc_channel_index Index of parameter RC channel. Not equal to the RC channel id. Typically correpsonds to a potentiometer-knob on the RC.
+ * @param param_value0 Initial parameter value
+ * @param scale Scale, maps the RC range [-1, 1] to a parameter value
+ * @param param_value_min Minimum param value. The protocol does not define if this overwrites an onboard minimum value. (Depends on implementation)
+ * @param param_value_max Maximum param value. The protocol does not define if this overwrites an onboard maximum value. (Depends on implementation)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_param_map_rc_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint8_t target_system, uint8_t target_component, const char *param_id, int16_t param_index, uint8_t parameter_rc_channel_index, float param_value0, float scale, float param_value_min, float param_value_max)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_PARAM_MAP_RC_LEN];
+	_mav_put_float(buf, 0, param_value0);
+	_mav_put_float(buf, 4, scale);
+	_mav_put_float(buf, 8, param_value_min);
+	_mav_put_float(buf, 12, param_value_max);
+	_mav_put_int16_t(buf, 16, param_index);
+	_mav_put_uint8_t(buf, 18, target_system);
+	_mav_put_uint8_t(buf, 19, target_component);
+	_mav_put_uint8_t(buf, 36, parameter_rc_channel_index);
+	_mav_put_char_array(buf, 20, param_id, 16);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_PARAM_MAP_RC_LEN);
+#else
+	mavlink_param_map_rc_t packet;
+	packet.param_value0 = param_value0;
+	packet.scale = scale;
+	packet.param_value_min = param_value_min;
+	packet.param_value_max = param_value_max;
+	packet.param_index = param_index;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.parameter_rc_channel_index = parameter_rc_channel_index;
+	mav_array_memcpy(packet.param_id, param_id, sizeof(char)*16);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_PARAM_MAP_RC_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_PARAM_MAP_RC;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PARAM_MAP_RC_LEN, MAVLINK_MSG_ID_PARAM_MAP_RC_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PARAM_MAP_RC_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a param_map_rc message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ * @param param_index Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index.
+ * @param parameter_rc_channel_index Index of parameter RC channel. Not equal to the RC channel id. Typically correpsonds to a potentiometer-knob on the RC.
+ * @param param_value0 Initial parameter value
+ * @param scale Scale, maps the RC range [-1, 1] to a parameter value
+ * @param param_value_min Minimum param value. The protocol does not define if this overwrites an onboard minimum value. (Depends on implementation)
+ * @param param_value_max Maximum param value. The protocol does not define if this overwrites an onboard maximum value. (Depends on implementation)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_param_map_rc_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint8_t target_system,uint8_t target_component,const char *param_id,int16_t param_index,uint8_t parameter_rc_channel_index,float param_value0,float scale,float param_value_min,float param_value_max)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_PARAM_MAP_RC_LEN];
+	_mav_put_float(buf, 0, param_value0);
+	_mav_put_float(buf, 4, scale);
+	_mav_put_float(buf, 8, param_value_min);
+	_mav_put_float(buf, 12, param_value_max);
+	_mav_put_int16_t(buf, 16, param_index);
+	_mav_put_uint8_t(buf, 18, target_system);
+	_mav_put_uint8_t(buf, 19, target_component);
+	_mav_put_uint8_t(buf, 36, parameter_rc_channel_index);
+	_mav_put_char_array(buf, 20, param_id, 16);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_PARAM_MAP_RC_LEN);
+#else
+	mavlink_param_map_rc_t packet;
+	packet.param_value0 = param_value0;
+	packet.scale = scale;
+	packet.param_value_min = param_value_min;
+	packet.param_value_max = param_value_max;
+	packet.param_index = param_index;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.parameter_rc_channel_index = parameter_rc_channel_index;
+	mav_array_memcpy(packet.param_id, param_id, sizeof(char)*16);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_PARAM_MAP_RC_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_PARAM_MAP_RC;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_PARAM_MAP_RC_LEN, MAVLINK_MSG_ID_PARAM_MAP_RC_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_PARAM_MAP_RC_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a param_map_rc struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param param_map_rc C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_param_map_rc_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_param_map_rc_t* param_map_rc)
+{
+	return mavlink_msg_param_map_rc_pack(system_id, component_id, msg, param_map_rc->target_system, param_map_rc->target_component, param_map_rc->param_id, param_map_rc->param_index, param_map_rc->parameter_rc_channel_index, param_map_rc->param_value0, param_map_rc->scale, param_map_rc->param_value_min, param_map_rc->param_value_max);
+}
+
+/**
+ * @brief Encode a param_map_rc struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param param_map_rc C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_param_map_rc_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_param_map_rc_t* param_map_rc)
+{
+	return mavlink_msg_param_map_rc_pack_chan(system_id, component_id, chan, msg, param_map_rc->target_system, param_map_rc->target_component, param_map_rc->param_id, param_map_rc->param_index, param_map_rc->parameter_rc_channel_index, param_map_rc->param_value0, param_map_rc->scale, param_map_rc->param_value_min, param_map_rc->param_value_max);
+}
+
+/**
+ * @brief Send a param_map_rc message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ * @param param_index Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index.
+ * @param parameter_rc_channel_index Index of parameter RC channel. Not equal to the RC channel id. Typically correpsonds to a potentiometer-knob on the RC.
+ * @param param_value0 Initial parameter value
+ * @param scale Scale, maps the RC range [-1, 1] to a parameter value
+ * @param param_value_min Minimum param value. The protocol does not define if this overwrites an onboard minimum value. (Depends on implementation)
+ * @param param_value_max Maximum param value. The protocol does not define if this overwrites an onboard maximum value. (Depends on implementation)
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_param_map_rc_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, const char *param_id, int16_t param_index, uint8_t parameter_rc_channel_index, float param_value0, float scale, float param_value_min, float param_value_max)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_PARAM_MAP_RC_LEN];
+	_mav_put_float(buf, 0, param_value0);
+	_mav_put_float(buf, 4, scale);
+	_mav_put_float(buf, 8, param_value_min);
+	_mav_put_float(buf, 12, param_value_max);
+	_mav_put_int16_t(buf, 16, param_index);
+	_mav_put_uint8_t(buf, 18, target_system);
+	_mav_put_uint8_t(buf, 19, target_component);
+	_mav_put_uint8_t(buf, 36, parameter_rc_channel_index);
+	_mav_put_char_array(buf, 20, param_id, 16);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_MAP_RC, buf, MAVLINK_MSG_ID_PARAM_MAP_RC_LEN, MAVLINK_MSG_ID_PARAM_MAP_RC_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_MAP_RC, buf, MAVLINK_MSG_ID_PARAM_MAP_RC_LEN);
+#endif
+#else
+	mavlink_param_map_rc_t packet;
+	packet.param_value0 = param_value0;
+	packet.scale = scale;
+	packet.param_value_min = param_value_min;
+	packet.param_value_max = param_value_max;
+	packet.param_index = param_index;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.parameter_rc_channel_index = parameter_rc_channel_index;
+	mav_array_memcpy(packet.param_id, param_id, sizeof(char)*16);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_MAP_RC, (const char *)&packet, MAVLINK_MSG_ID_PARAM_MAP_RC_LEN, MAVLINK_MSG_ID_PARAM_MAP_RC_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_MAP_RC, (const char *)&packet, MAVLINK_MSG_ID_PARAM_MAP_RC_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_PARAM_MAP_RC_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_param_map_rc_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, const char *param_id, int16_t param_index, uint8_t parameter_rc_channel_index, float param_value0, float scale, float param_value_min, float param_value_max)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_float(buf, 0, param_value0);
+	_mav_put_float(buf, 4, scale);
+	_mav_put_float(buf, 8, param_value_min);
+	_mav_put_float(buf, 12, param_value_max);
+	_mav_put_int16_t(buf, 16, param_index);
+	_mav_put_uint8_t(buf, 18, target_system);
+	_mav_put_uint8_t(buf, 19, target_component);
+	_mav_put_uint8_t(buf, 36, parameter_rc_channel_index);
+	_mav_put_char_array(buf, 20, param_id, 16);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_MAP_RC, buf, MAVLINK_MSG_ID_PARAM_MAP_RC_LEN, MAVLINK_MSG_ID_PARAM_MAP_RC_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_MAP_RC, buf, MAVLINK_MSG_ID_PARAM_MAP_RC_LEN);
+#endif
+#else
+	mavlink_param_map_rc_t *packet = (mavlink_param_map_rc_t *)msgbuf;
+	packet->param_value0 = param_value0;
+	packet->scale = scale;
+	packet->param_value_min = param_value_min;
+	packet->param_value_max = param_value_max;
+	packet->param_index = param_index;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+	packet->parameter_rc_channel_index = parameter_rc_channel_index;
+	mav_array_memcpy(packet->param_id, param_id, sizeof(char)*16);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_MAP_RC, (const char *)packet, MAVLINK_MSG_ID_PARAM_MAP_RC_LEN, MAVLINK_MSG_ID_PARAM_MAP_RC_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_MAP_RC, (const char *)packet, MAVLINK_MSG_ID_PARAM_MAP_RC_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE PARAM_MAP_RC UNPACKING
+
+
+/**
+ * @brief Get field target_system from param_map_rc message
+ *
+ * @return System ID
+ */
+static inline uint8_t mavlink_msg_param_map_rc_get_target_system(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  18);
+}
+
+/**
+ * @brief Get field target_component from param_map_rc message
+ *
+ * @return Component ID
+ */
+static inline uint8_t mavlink_msg_param_map_rc_get_target_component(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  19);
+}
+
+/**
+ * @brief Get field param_id from param_map_rc message
+ *
+ * @return Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ */
+static inline uint16_t mavlink_msg_param_map_rc_get_param_id(const mavlink_message_t* msg, char *param_id)
+{
+	return _MAV_RETURN_char_array(msg, param_id, 16,  20);
+}
+
+/**
+ * @brief Get field param_index from param_map_rc message
+ *
+ * @return Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index.
+ */
+static inline int16_t mavlink_msg_param_map_rc_get_param_index(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  16);
+}
+
+/**
+ * @brief Get field parameter_rc_channel_index from param_map_rc message
+ *
+ * @return Index of parameter RC channel. Not equal to the RC channel id. Typically correpsonds to a potentiometer-knob on the RC.
+ */
+static inline uint8_t mavlink_msg_param_map_rc_get_parameter_rc_channel_index(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  36);
+}
+
+/**
+ * @brief Get field param_value0 from param_map_rc message
+ *
+ * @return Initial parameter value
+ */
+static inline float mavlink_msg_param_map_rc_get_param_value0(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  0);
+}
+
+/**
+ * @brief Get field scale from param_map_rc message
+ *
+ * @return Scale, maps the RC range [-1, 1] to a parameter value
+ */
+static inline float mavlink_msg_param_map_rc_get_scale(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  4);
+}
+
+/**
+ * @brief Get field param_value_min from param_map_rc message
+ *
+ * @return Minimum param value. The protocol does not define if this overwrites an onboard minimum value. (Depends on implementation)
+ */
+static inline float mavlink_msg_param_map_rc_get_param_value_min(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  8);
+}
+
+/**
+ * @brief Get field param_value_max from param_map_rc message
+ *
+ * @return Maximum param value. The protocol does not define if this overwrites an onboard maximum value. (Depends on implementation)
+ */
+static inline float mavlink_msg_param_map_rc_get_param_value_max(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  12);
+}
+
+/**
+ * @brief Decode a param_map_rc message into a struct
+ *
+ * @param msg The message to decode
+ * @param param_map_rc C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_param_map_rc_decode(const mavlink_message_t* msg, mavlink_param_map_rc_t* param_map_rc)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	param_map_rc->param_value0 = mavlink_msg_param_map_rc_get_param_value0(msg);
+	param_map_rc->scale = mavlink_msg_param_map_rc_get_scale(msg);
+	param_map_rc->param_value_min = mavlink_msg_param_map_rc_get_param_value_min(msg);
+	param_map_rc->param_value_max = mavlink_msg_param_map_rc_get_param_value_max(msg);
+	param_map_rc->param_index = mavlink_msg_param_map_rc_get_param_index(msg);
+	param_map_rc->target_system = mavlink_msg_param_map_rc_get_target_system(msg);
+	param_map_rc->target_component = mavlink_msg_param_map_rc_get_target_component(msg);
+	mavlink_msg_param_map_rc_get_param_id(msg, param_map_rc->param_id);
+	param_map_rc->parameter_rc_channel_index = mavlink_msg_param_map_rc_get_parameter_rc_channel_index(msg);
+#else
+	memcpy(param_map_rc, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_PARAM_MAP_RC_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_param_request_list.h v1.0/common/mavlink_msg_param_request_list.h
--- v1.0.old/common/mavlink_msg_param_request_list.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_param_request_list.h	2015-02-06 11:50:58.000000000 +0500
@@ -11,6 +11,9 @@ typedef struct __mavlink_param_request_l
 #define MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN 2
 #define MAVLINK_MSG_ID_21_LEN 2
 
+#define MAVLINK_MSG_ID_PARAM_REQUEST_LIST_CRC 159
+#define MAVLINK_MSG_ID_21_CRC 159
+
 
 
 #define MAVLINK_MESSAGE_INFO_PARAM_REQUEST_LIST { \
@@ -36,28 +39,32 @@ static inline uint16_t mavlink_msg_param
 						       uint8_t target_system, uint8_t target_component)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[2];
+	char buf[MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN];
 	_mav_put_uint8_t(buf, 0, target_system);
 	_mav_put_uint8_t(buf, 1, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN);
 #else
 	mavlink_param_request_list_t packet;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_PARAM_REQUEST_LIST;
-	return mavlink_finalize_message(msg, system_id, component_id, 2, 159);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN);
+#endif
 }
 
 /**
  * @brief Pack a param_request_list message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system System ID
  * @param target_component Component ID
@@ -68,25 +75,29 @@ static inline uint16_t mavlink_msg_param
 						           uint8_t target_system,uint8_t target_component)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[2];
+	char buf[MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN];
 	_mav_put_uint8_t(buf, 0, target_system);
 	_mav_put_uint8_t(buf, 1, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN);
 #else
 	mavlink_param_request_list_t packet;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 2);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_PARAM_REQUEST_LIST;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 2, 159);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN);
+#endif
 }
 
 /**
- * @brief Encode a param_request_list struct into a message
+ * @brief Encode a param_request_list struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -99,6 +110,20 @@ static inline uint16_t mavlink_msg_param
 }
 
 /**
+ * @brief Encode a param_request_list struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param param_request_list C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_param_request_list_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_param_request_list_t* param_request_list)
+{
+	return mavlink_msg_param_request_list_pack_chan(system_id, component_id, chan, msg, param_request_list->target_system, param_request_list->target_component);
+}
+
+/**
  * @brief Send a param_request_list message
  * @param chan MAVLink channel to send the message
  *
@@ -110,20 +135,62 @@ static inline uint16_t mavlink_msg_param
 static inline void mavlink_msg_param_request_list_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[2];
+	char buf[MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN];
 	_mav_put_uint8_t(buf, 0, target_system);
 	_mav_put_uint8_t(buf, 1, target_component);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_LIST, buf, 2, 159);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_LIST, buf, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_LIST, buf, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN);
+#endif
 #else
 	mavlink_param_request_list_t packet;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_LIST, (const char *)&packet, 2, 159);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_LIST, (const char *)&packet, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_LIST, (const char *)&packet, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_param_request_list_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint8_t(buf, 0, target_system);
+	_mav_put_uint8_t(buf, 1, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_LIST, buf, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_LIST, buf, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN);
+#endif
+#else
+	mavlink_param_request_list_t *packet = (mavlink_param_request_list_t *)msgbuf;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_LIST, (const char *)packet, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_LIST, (const char *)packet, MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE PARAM_REQUEST_LIST UNPACKING
@@ -161,6 +228,6 @@ static inline void mavlink_msg_param_req
 	param_request_list->target_system = mavlink_msg_param_request_list_get_target_system(msg);
 	param_request_list->target_component = mavlink_msg_param_request_list_get_target_component(msg);
 #else
-	memcpy(param_request_list, _MAV_PAYLOAD(msg), 2);
+	memcpy(param_request_list, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_PARAM_REQUEST_LIST_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_param_request_read.h v1.0/common/mavlink_msg_param_request_read.h
--- v1.0.old/common/mavlink_msg_param_request_read.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_param_request_read.h	2015-02-06 11:50:58.000000000 +0500
@@ -7,12 +7,15 @@ typedef struct __mavlink_param_request_r
  int16_t param_index; ///< Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored)
  uint8_t target_system; ///< System ID
  uint8_t target_component; ///< Component ID
- char param_id[16]; ///< Onboard parameter id, terminated by NUL if the length is less than 16 human-readable chars and WITHOUT null termination (NUL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ char param_id[16]; ///< Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
 } mavlink_param_request_read_t;
 
 #define MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN 20
 #define MAVLINK_MSG_ID_20_LEN 20
 
+#define MAVLINK_MSG_ID_PARAM_REQUEST_READ_CRC 214
+#define MAVLINK_MSG_ID_20_CRC 214
+
 #define MAVLINK_MSG_PARAM_REQUEST_READ_FIELD_PARAM_ID_LEN 16
 
 #define MAVLINK_MESSAGE_INFO_PARAM_REQUEST_READ { \
@@ -34,7 +37,7 @@ typedef struct __mavlink_param_request_r
  *
  * @param target_system System ID
  * @param target_component Component ID
- * @param param_id Onboard parameter id, terminated by NUL if the length is less than 16 human-readable chars and WITHOUT null termination (NUL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  * @param param_index Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored)
  * @return length of the message in bytes (excluding serial stream start sign)
  */
@@ -42,34 +45,38 @@ static inline uint16_t mavlink_msg_param
 						       uint8_t target_system, uint8_t target_component, const char *param_id, int16_t param_index)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[20];
+	char buf[MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN];
 	_mav_put_int16_t(buf, 0, param_index);
 	_mav_put_uint8_t(buf, 2, target_system);
 	_mav_put_uint8_t(buf, 3, target_component);
 	_mav_put_char_array(buf, 4, param_id, 16);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 20);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN);
 #else
 	mavlink_param_request_read_t packet;
 	packet.param_index = param_index;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 	mav_array_memcpy(packet.param_id, param_id, sizeof(char)*16);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 20);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_PARAM_REQUEST_READ;
-	return mavlink_finalize_message(msg, system_id, component_id, 20, 214);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN, MAVLINK_MSG_ID_PARAM_REQUEST_READ_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN);
+#endif
 }
 
 /**
  * @brief Pack a param_request_read message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system System ID
  * @param target_component Component ID
- * @param param_id Onboard parameter id, terminated by NUL if the length is less than 16 human-readable chars and WITHOUT null termination (NUL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  * @param param_index Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored)
  * @return length of the message in bytes (excluding serial stream start sign)
  */
@@ -78,27 +85,31 @@ static inline uint16_t mavlink_msg_param
 						           uint8_t target_system,uint8_t target_component,const char *param_id,int16_t param_index)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[20];
+	char buf[MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN];
 	_mav_put_int16_t(buf, 0, param_index);
 	_mav_put_uint8_t(buf, 2, target_system);
 	_mav_put_uint8_t(buf, 3, target_component);
 	_mav_put_char_array(buf, 4, param_id, 16);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 20);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN);
 #else
 	mavlink_param_request_read_t packet;
 	packet.param_index = param_index;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 	mav_array_memcpy(packet.param_id, param_id, sizeof(char)*16);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 20);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_PARAM_REQUEST_READ;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 20, 214);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN, MAVLINK_MSG_ID_PARAM_REQUEST_READ_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN);
+#endif
 }
 
 /**
- * @brief Encode a param_request_read struct into a message
+ * @brief Encode a param_request_read struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -111,12 +122,26 @@ static inline uint16_t mavlink_msg_param
 }
 
 /**
+ * @brief Encode a param_request_read struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param param_request_read C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_param_request_read_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_param_request_read_t* param_request_read)
+{
+	return mavlink_msg_param_request_read_pack_chan(system_id, component_id, chan, msg, param_request_read->target_system, param_request_read->target_component, param_request_read->param_id, param_request_read->param_index);
+}
+
+/**
  * @brief Send a param_request_read message
  * @param chan MAVLink channel to send the message
  *
  * @param target_system System ID
  * @param target_component Component ID
- * @param param_id Onboard parameter id, terminated by NUL if the length is less than 16 human-readable chars and WITHOUT null termination (NUL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  * @param param_index Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored)
  */
 #ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
@@ -124,22 +149,66 @@ static inline uint16_t mavlink_msg_param
 static inline void mavlink_msg_param_request_read_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, const char *param_id, int16_t param_index)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[20];
+	char buf[MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN];
 	_mav_put_int16_t(buf, 0, param_index);
 	_mav_put_uint8_t(buf, 2, target_system);
 	_mav_put_uint8_t(buf, 3, target_component);
 	_mav_put_char_array(buf, 4, param_id, 16);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_READ, buf, 20, 214);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_READ, buf, MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN, MAVLINK_MSG_ID_PARAM_REQUEST_READ_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_READ, buf, MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN);
+#endif
 #else
 	mavlink_param_request_read_t packet;
 	packet.param_index = param_index;
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 	mav_array_memcpy(packet.param_id, param_id, sizeof(char)*16);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_READ, (const char *)&packet, 20, 214);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_READ, (const char *)&packet, MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN, MAVLINK_MSG_ID_PARAM_REQUEST_READ_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_READ, (const char *)&packet, MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_param_request_read_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, const char *param_id, int16_t param_index)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_int16_t(buf, 0, param_index);
+	_mav_put_uint8_t(buf, 2, target_system);
+	_mav_put_uint8_t(buf, 3, target_component);
+	_mav_put_char_array(buf, 4, param_id, 16);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_READ, buf, MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN, MAVLINK_MSG_ID_PARAM_REQUEST_READ_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_READ, buf, MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN);
+#endif
+#else
+	mavlink_param_request_read_t *packet = (mavlink_param_request_read_t *)msgbuf;
+	packet->param_index = param_index;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+	mav_array_memcpy(packet->param_id, param_id, sizeof(char)*16);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_READ, (const char *)packet, MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN, MAVLINK_MSG_ID_PARAM_REQUEST_READ_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_REQUEST_READ, (const char *)packet, MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE PARAM_REQUEST_READ UNPACKING
@@ -168,7 +237,7 @@ static inline uint8_t mavlink_msg_param_
 /**
  * @brief Get field param_id from param_request_read message
  *
- * @return Onboard parameter id, terminated by NUL if the length is less than 16 human-readable chars and WITHOUT null termination (NUL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ * @return Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  */
 static inline uint16_t mavlink_msg_param_request_read_get_param_id(const mavlink_message_t* msg, char *param_id)
 {
@@ -199,6 +268,6 @@ static inline void mavlink_msg_param_req
 	param_request_read->target_component = mavlink_msg_param_request_read_get_target_component(msg);
 	mavlink_msg_param_request_read_get_param_id(msg, param_request_read->param_id);
 #else
-	memcpy(param_request_read, _MAV_PAYLOAD(msg), 20);
+	memcpy(param_request_read, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_PARAM_REQUEST_READ_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_param_set.h v1.0/common/mavlink_msg_param_set.h
--- v1.0.old/common/mavlink_msg_param_set.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_param_set.h	2015-02-06 11:50:58.000000000 +0500
@@ -7,13 +7,16 @@ typedef struct __mavlink_param_set_t
  float param_value; ///< Onboard parameter value
  uint8_t target_system; ///< System ID
  uint8_t target_component; ///< Component ID
- char param_id[16]; ///< Onboard parameter id, terminated by NUL if the length is less than 16 human-readable chars and WITHOUT null termination (NUL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
- uint8_t param_type; ///< Onboard parameter type: see MAVLINK_TYPE enum in mavlink/mavlink_types.h
+ char param_id[16]; ///< Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ uint8_t param_type; ///< Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types.
 } mavlink_param_set_t;
 
 #define MAVLINK_MSG_ID_PARAM_SET_LEN 23
 #define MAVLINK_MSG_ID_23_LEN 23
 
+#define MAVLINK_MSG_ID_PARAM_SET_CRC 168
+#define MAVLINK_MSG_ID_23_CRC 168
+
 #define MAVLINK_MSG_PARAM_SET_FIELD_PARAM_ID_LEN 16
 
 #define MAVLINK_MESSAGE_INFO_PARAM_SET { \
@@ -36,22 +39,22 @@ typedef struct __mavlink_param_set_t
  *
  * @param target_system System ID
  * @param target_component Component ID
- * @param param_id Onboard parameter id, terminated by NUL if the length is less than 16 human-readable chars and WITHOUT null termination (NUL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  * @param param_value Onboard parameter value
- * @param param_type Onboard parameter type: see MAVLINK_TYPE enum in mavlink/mavlink_types.h
+ * @param param_type Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types.
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_param_set_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
 						       uint8_t target_system, uint8_t target_component, const char *param_id, float param_value, uint8_t param_type)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[23];
+	char buf[MAVLINK_MSG_ID_PARAM_SET_LEN];
 	_mav_put_float(buf, 0, param_value);
 	_mav_put_uint8_t(buf, 4, target_system);
 	_mav_put_uint8_t(buf, 5, target_component);
 	_mav_put_uint8_t(buf, 22, param_type);
 	_mav_put_char_array(buf, 6, param_id, 16);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 23);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_PARAM_SET_LEN);
 #else
 	mavlink_param_set_t packet;
 	packet.param_value = param_value;
@@ -59,24 +62,28 @@ static inline uint16_t mavlink_msg_param
 	packet.target_component = target_component;
 	packet.param_type = param_type;
 	mav_array_memcpy(packet.param_id, param_id, sizeof(char)*16);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 23);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_PARAM_SET_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_PARAM_SET;
-	return mavlink_finalize_message(msg, system_id, component_id, 23, 168);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PARAM_SET_LEN, MAVLINK_MSG_ID_PARAM_SET_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PARAM_SET_LEN);
+#endif
 }
 
 /**
  * @brief Pack a param_set message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system System ID
  * @param target_component Component ID
- * @param param_id Onboard parameter id, terminated by NUL if the length is less than 16 human-readable chars and WITHOUT null termination (NUL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  * @param param_value Onboard parameter value
- * @param param_type Onboard parameter type: see MAVLINK_TYPE enum in mavlink/mavlink_types.h
+ * @param param_type Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types.
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_param_set_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
@@ -84,13 +91,13 @@ static inline uint16_t mavlink_msg_param
 						           uint8_t target_system,uint8_t target_component,const char *param_id,float param_value,uint8_t param_type)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[23];
+	char buf[MAVLINK_MSG_ID_PARAM_SET_LEN];
 	_mav_put_float(buf, 0, param_value);
 	_mav_put_uint8_t(buf, 4, target_system);
 	_mav_put_uint8_t(buf, 5, target_component);
 	_mav_put_uint8_t(buf, 22, param_type);
 	_mav_put_char_array(buf, 6, param_id, 16);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 23);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_PARAM_SET_LEN);
 #else
 	mavlink_param_set_t packet;
 	packet.param_value = param_value;
@@ -98,15 +105,19 @@ static inline uint16_t mavlink_msg_param
 	packet.target_component = target_component;
 	packet.param_type = param_type;
 	mav_array_memcpy(packet.param_id, param_id, sizeof(char)*16);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 23);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_PARAM_SET_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_PARAM_SET;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 23, 168);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_PARAM_SET_LEN, MAVLINK_MSG_ID_PARAM_SET_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_PARAM_SET_LEN);
+#endif
 }
 
 /**
- * @brief Encode a param_set struct into a message
+ * @brief Encode a param_set struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -119,27 +130,45 @@ static inline uint16_t mavlink_msg_param
 }
 
 /**
+ * @brief Encode a param_set struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param param_set C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_param_set_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_param_set_t* param_set)
+{
+	return mavlink_msg_param_set_pack_chan(system_id, component_id, chan, msg, param_set->target_system, param_set->target_component, param_set->param_id, param_set->param_value, param_set->param_type);
+}
+
+/**
  * @brief Send a param_set message
  * @param chan MAVLink channel to send the message
  *
  * @param target_system System ID
  * @param target_component Component ID
- * @param param_id Onboard parameter id, terminated by NUL if the length is less than 16 human-readable chars and WITHOUT null termination (NUL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  * @param param_value Onboard parameter value
- * @param param_type Onboard parameter type: see MAVLINK_TYPE enum in mavlink/mavlink_types.h
+ * @param param_type Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types.
  */
 #ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
 
 static inline void mavlink_msg_param_set_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, const char *param_id, float param_value, uint8_t param_type)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[23];
+	char buf[MAVLINK_MSG_ID_PARAM_SET_LEN];
 	_mav_put_float(buf, 0, param_value);
 	_mav_put_uint8_t(buf, 4, target_system);
 	_mav_put_uint8_t(buf, 5, target_component);
 	_mav_put_uint8_t(buf, 22, param_type);
 	_mav_put_char_array(buf, 6, param_id, 16);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_SET, buf, 23, 168);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_SET, buf, MAVLINK_MSG_ID_PARAM_SET_LEN, MAVLINK_MSG_ID_PARAM_SET_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_SET, buf, MAVLINK_MSG_ID_PARAM_SET_LEN);
+#endif
 #else
 	mavlink_param_set_t packet;
 	packet.param_value = param_value;
@@ -147,9 +176,51 @@ static inline void mavlink_msg_param_set
 	packet.target_component = target_component;
 	packet.param_type = param_type;
 	mav_array_memcpy(packet.param_id, param_id, sizeof(char)*16);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_SET, (const char *)&packet, 23, 168);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_SET, (const char *)&packet, MAVLINK_MSG_ID_PARAM_SET_LEN, MAVLINK_MSG_ID_PARAM_SET_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_SET, (const char *)&packet, MAVLINK_MSG_ID_PARAM_SET_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_PARAM_SET_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_param_set_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, const char *param_id, float param_value, uint8_t param_type)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_float(buf, 0, param_value);
+	_mav_put_uint8_t(buf, 4, target_system);
+	_mav_put_uint8_t(buf, 5, target_component);
+	_mav_put_uint8_t(buf, 22, param_type);
+	_mav_put_char_array(buf, 6, param_id, 16);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_SET, buf, MAVLINK_MSG_ID_PARAM_SET_LEN, MAVLINK_MSG_ID_PARAM_SET_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_SET, buf, MAVLINK_MSG_ID_PARAM_SET_LEN);
+#endif
+#else
+	mavlink_param_set_t *packet = (mavlink_param_set_t *)msgbuf;
+	packet->param_value = param_value;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+	packet->param_type = param_type;
+	mav_array_memcpy(packet->param_id, param_id, sizeof(char)*16);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_SET, (const char *)packet, MAVLINK_MSG_ID_PARAM_SET_LEN, MAVLINK_MSG_ID_PARAM_SET_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_SET, (const char *)packet, MAVLINK_MSG_ID_PARAM_SET_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -179,7 +250,7 @@ static inline uint8_t mavlink_msg_param_
 /**
  * @brief Get field param_id from param_set message
  *
- * @return Onboard parameter id, terminated by NUL if the length is less than 16 human-readable chars and WITHOUT null termination (NUL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ * @return Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  */
 static inline uint16_t mavlink_msg_param_set_get_param_id(const mavlink_message_t* msg, char *param_id)
 {
@@ -199,7 +270,7 @@ static inline float mavlink_msg_param_se
 /**
  * @brief Get field param_type from param_set message
  *
- * @return Onboard parameter type: see MAVLINK_TYPE enum in mavlink/mavlink_types.h
+ * @return Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types.
  */
 static inline uint8_t mavlink_msg_param_set_get_param_type(const mavlink_message_t* msg)
 {
@@ -221,6 +292,6 @@ static inline void mavlink_msg_param_set
 	mavlink_msg_param_set_get_param_id(msg, param_set->param_id);
 	param_set->param_type = mavlink_msg_param_set_get_param_type(msg);
 #else
-	memcpy(param_set, _MAV_PAYLOAD(msg), 23);
+	memcpy(param_set, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_PARAM_SET_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_param_value.h v1.0/common/mavlink_msg_param_value.h
--- v1.0.old/common/mavlink_msg_param_value.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_param_value.h	2015-02-06 11:50:58.000000000 +0500
@@ -7,13 +7,16 @@ typedef struct __mavlink_param_value_t
  float param_value; ///< Onboard parameter value
  uint16_t param_count; ///< Total number of onboard parameters
  uint16_t param_index; ///< Index of this onboard parameter
- char param_id[16]; ///< Onboard parameter id, terminated by NUL if the length is less than 16 human-readable chars and WITHOUT null termination (NUL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
- uint8_t param_type; ///< Onboard parameter type: see MAVLINK_TYPE enum in mavlink/mavlink_types.h
+ char param_id[16]; ///< Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ uint8_t param_type; ///< Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types.
 } mavlink_param_value_t;
 
 #define MAVLINK_MSG_ID_PARAM_VALUE_LEN 25
 #define MAVLINK_MSG_ID_22_LEN 25
 
+#define MAVLINK_MSG_ID_PARAM_VALUE_CRC 220
+#define MAVLINK_MSG_ID_22_CRC 220
+
 #define MAVLINK_MSG_PARAM_VALUE_FIELD_PARAM_ID_LEN 16
 
 #define MAVLINK_MESSAGE_INFO_PARAM_VALUE { \
@@ -34,9 +37,9 @@ typedef struct __mavlink_param_value_t
  * @param component_id ID of this component (e.g. 200 for IMU)
  * @param msg The MAVLink message to compress the data into
  *
- * @param param_id Onboard parameter id, terminated by NUL if the length is less than 16 human-readable chars and WITHOUT null termination (NUL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  * @param param_value Onboard parameter value
- * @param param_type Onboard parameter type: see MAVLINK_TYPE enum in mavlink/mavlink_types.h
+ * @param param_type Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types.
  * @param param_count Total number of onboard parameters
  * @param param_index Index of this onboard parameter
  * @return length of the message in bytes (excluding serial stream start sign)
@@ -45,13 +48,13 @@ static inline uint16_t mavlink_msg_param
 						       const char *param_id, float param_value, uint8_t param_type, uint16_t param_count, uint16_t param_index)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[25];
+	char buf[MAVLINK_MSG_ID_PARAM_VALUE_LEN];
 	_mav_put_float(buf, 0, param_value);
 	_mav_put_uint16_t(buf, 4, param_count);
 	_mav_put_uint16_t(buf, 6, param_index);
 	_mav_put_uint8_t(buf, 24, param_type);
 	_mav_put_char_array(buf, 8, param_id, 16);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 25);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_PARAM_VALUE_LEN);
 #else
 	mavlink_param_value_t packet;
 	packet.param_value = param_value;
@@ -59,22 +62,26 @@ static inline uint16_t mavlink_msg_param
 	packet.param_index = param_index;
 	packet.param_type = param_type;
 	mav_array_memcpy(packet.param_id, param_id, sizeof(char)*16);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 25);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_PARAM_VALUE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_PARAM_VALUE;
-	return mavlink_finalize_message(msg, system_id, component_id, 25, 220);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PARAM_VALUE_LEN, MAVLINK_MSG_ID_PARAM_VALUE_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PARAM_VALUE_LEN);
+#endif
 }
 
 /**
  * @brief Pack a param_value message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
- * @param param_id Onboard parameter id, terminated by NUL if the length is less than 16 human-readable chars and WITHOUT null termination (NUL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  * @param param_value Onboard parameter value
- * @param param_type Onboard parameter type: see MAVLINK_TYPE enum in mavlink/mavlink_types.h
+ * @param param_type Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types.
  * @param param_count Total number of onboard parameters
  * @param param_index Index of this onboard parameter
  * @return length of the message in bytes (excluding serial stream start sign)
@@ -84,13 +91,13 @@ static inline uint16_t mavlink_msg_param
 						           const char *param_id,float param_value,uint8_t param_type,uint16_t param_count,uint16_t param_index)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[25];
+	char buf[MAVLINK_MSG_ID_PARAM_VALUE_LEN];
 	_mav_put_float(buf, 0, param_value);
 	_mav_put_uint16_t(buf, 4, param_count);
 	_mav_put_uint16_t(buf, 6, param_index);
 	_mav_put_uint8_t(buf, 24, param_type);
 	_mav_put_char_array(buf, 8, param_id, 16);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 25);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_PARAM_VALUE_LEN);
 #else
 	mavlink_param_value_t packet;
 	packet.param_value = param_value;
@@ -98,15 +105,19 @@ static inline uint16_t mavlink_msg_param
 	packet.param_index = param_index;
 	packet.param_type = param_type;
 	mav_array_memcpy(packet.param_id, param_id, sizeof(char)*16);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 25);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_PARAM_VALUE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_PARAM_VALUE;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 25, 220);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_PARAM_VALUE_LEN, MAVLINK_MSG_ID_PARAM_VALUE_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_PARAM_VALUE_LEN);
+#endif
 }
 
 /**
- * @brief Encode a param_value struct into a message
+ * @brief Encode a param_value struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -119,12 +130,26 @@ static inline uint16_t mavlink_msg_param
 }
 
 /**
+ * @brief Encode a param_value struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param param_value C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_param_value_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_param_value_t* param_value)
+{
+	return mavlink_msg_param_value_pack_chan(system_id, component_id, chan, msg, param_value->param_id, param_value->param_value, param_value->param_type, param_value->param_count, param_value->param_index);
+}
+
+/**
  * @brief Send a param_value message
  * @param chan MAVLink channel to send the message
  *
- * @param param_id Onboard parameter id, terminated by NUL if the length is less than 16 human-readable chars and WITHOUT null termination (NUL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  * @param param_value Onboard parameter value
- * @param param_type Onboard parameter type: see MAVLINK_TYPE enum in mavlink/mavlink_types.h
+ * @param param_type Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types.
  * @param param_count Total number of onboard parameters
  * @param param_index Index of this onboard parameter
  */
@@ -133,13 +158,17 @@ static inline uint16_t mavlink_msg_param
 static inline void mavlink_msg_param_value_send(mavlink_channel_t chan, const char *param_id, float param_value, uint8_t param_type, uint16_t param_count, uint16_t param_index)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[25];
+	char buf[MAVLINK_MSG_ID_PARAM_VALUE_LEN];
 	_mav_put_float(buf, 0, param_value);
 	_mav_put_uint16_t(buf, 4, param_count);
 	_mav_put_uint16_t(buf, 6, param_index);
 	_mav_put_uint8_t(buf, 24, param_type);
 	_mav_put_char_array(buf, 8, param_id, 16);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_VALUE, buf, 25, 220);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_VALUE, buf, MAVLINK_MSG_ID_PARAM_VALUE_LEN, MAVLINK_MSG_ID_PARAM_VALUE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_VALUE, buf, MAVLINK_MSG_ID_PARAM_VALUE_LEN);
+#endif
 #else
 	mavlink_param_value_t packet;
 	packet.param_value = param_value;
@@ -147,9 +176,51 @@ static inline void mavlink_msg_param_val
 	packet.param_index = param_index;
 	packet.param_type = param_type;
 	mav_array_memcpy(packet.param_id, param_id, sizeof(char)*16);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_VALUE, (const char *)&packet, 25, 220);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_VALUE, (const char *)&packet, MAVLINK_MSG_ID_PARAM_VALUE_LEN, MAVLINK_MSG_ID_PARAM_VALUE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_VALUE, (const char *)&packet, MAVLINK_MSG_ID_PARAM_VALUE_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_PARAM_VALUE_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_param_value_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  const char *param_id, float param_value, uint8_t param_type, uint16_t param_count, uint16_t param_index)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_float(buf, 0, param_value);
+	_mav_put_uint16_t(buf, 4, param_count);
+	_mav_put_uint16_t(buf, 6, param_index);
+	_mav_put_uint8_t(buf, 24, param_type);
+	_mav_put_char_array(buf, 8, param_id, 16);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_VALUE, buf, MAVLINK_MSG_ID_PARAM_VALUE_LEN, MAVLINK_MSG_ID_PARAM_VALUE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_VALUE, buf, MAVLINK_MSG_ID_PARAM_VALUE_LEN);
+#endif
+#else
+	mavlink_param_value_t *packet = (mavlink_param_value_t *)msgbuf;
+	packet->param_value = param_value;
+	packet->param_count = param_count;
+	packet->param_index = param_index;
+	packet->param_type = param_type;
+	mav_array_memcpy(packet->param_id, param_id, sizeof(char)*16);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_VALUE, (const char *)packet, MAVLINK_MSG_ID_PARAM_VALUE_LEN, MAVLINK_MSG_ID_PARAM_VALUE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PARAM_VALUE, (const char *)packet, MAVLINK_MSG_ID_PARAM_VALUE_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -159,7 +230,7 @@ static inline void mavlink_msg_param_val
 /**
  * @brief Get field param_id from param_value message
  *
- * @return Onboard parameter id, terminated by NUL if the length is less than 16 human-readable chars and WITHOUT null termination (NUL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
+ * @return Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  */
 static inline uint16_t mavlink_msg_param_value_get_param_id(const mavlink_message_t* msg, char *param_id)
 {
@@ -179,7 +250,7 @@ static inline float mavlink_msg_param_va
 /**
  * @brief Get field param_type from param_value message
  *
- * @return Onboard parameter type: see MAVLINK_TYPE enum in mavlink/mavlink_types.h
+ * @return Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types.
  */
 static inline uint8_t mavlink_msg_param_value_get_param_type(const mavlink_message_t* msg)
 {
@@ -221,6 +292,6 @@ static inline void mavlink_msg_param_val
 	mavlink_msg_param_value_get_param_id(msg, param_value->param_id);
 	param_value->param_type = mavlink_msg_param_value_get_param_type(msg);
 #else
-	memcpy(param_value, _MAV_PAYLOAD(msg), 25);
+	memcpy(param_value, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_PARAM_VALUE_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_ping.h v1.0/common/mavlink_msg_ping.h
--- v1.0.old/common/mavlink_msg_ping.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_ping.h	2015-02-06 11:50:58.000000000 +0500
@@ -4,7 +4,7 @@
 
 typedef struct __mavlink_ping_t
 {
- uint64_t time_usec; ///< Unix timestamp in microseconds
+ uint64_t time_usec; ///< Unix timestamp in microseconds or since system boot if smaller than MAVLink epoch (1.1.2009)
  uint32_t seq; ///< PING sequence
  uint8_t target_system; ///< 0: request ping from all receiving systems, if greater than 0: message is a ping response and number is the system id of the requesting system
  uint8_t target_component; ///< 0: request ping from all receiving components, if greater than 0: message is a ping response and number is the system id of the requesting system
@@ -13,6 +13,9 @@ typedef struct __mavlink_ping_t
 #define MAVLINK_MSG_ID_PING_LEN 14
 #define MAVLINK_MSG_ID_4_LEN 14
 
+#define MAVLINK_MSG_ID_PING_CRC 237
+#define MAVLINK_MSG_ID_4_CRC 237
+
 
 
 #define MAVLINK_MESSAGE_INFO_PING { \
@@ -32,7 +35,7 @@ typedef struct __mavlink_ping_t
  * @param component_id ID of this component (e.g. 200 for IMU)
  * @param msg The MAVLink message to compress the data into
  *
- * @param time_usec Unix timestamp in microseconds
+ * @param time_usec Unix timestamp in microseconds or since system boot if smaller than MAVLink epoch (1.1.2009)
  * @param seq PING sequence
  * @param target_system 0: request ping from all receiving systems, if greater than 0: message is a ping response and number is the system id of the requesting system
  * @param target_component 0: request ping from all receiving components, if greater than 0: message is a ping response and number is the system id of the requesting system
@@ -42,13 +45,13 @@ static inline uint16_t mavlink_msg_ping_
 						       uint64_t time_usec, uint32_t seq, uint8_t target_system, uint8_t target_component)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[14];
+	char buf[MAVLINK_MSG_ID_PING_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_uint32_t(buf, 8, seq);
 	_mav_put_uint8_t(buf, 12, target_system);
 	_mav_put_uint8_t(buf, 13, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 14);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_PING_LEN);
 #else
 	mavlink_ping_t packet;
 	packet.time_usec = time_usec;
@@ -56,20 +59,24 @@ static inline uint16_t mavlink_msg_ping_
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 14);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_PING_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_PING;
-	return mavlink_finalize_message(msg, system_id, component_id, 14, 237);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PING_LEN, MAVLINK_MSG_ID_PING_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PING_LEN);
+#endif
 }
 
 /**
  * @brief Pack a ping message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
- * @param time_usec Unix timestamp in microseconds
+ * @param time_usec Unix timestamp in microseconds or since system boot if smaller than MAVLink epoch (1.1.2009)
  * @param seq PING sequence
  * @param target_system 0: request ping from all receiving systems, if greater than 0: message is a ping response and number is the system id of the requesting system
  * @param target_component 0: request ping from all receiving components, if greater than 0: message is a ping response and number is the system id of the requesting system
@@ -80,13 +87,13 @@ static inline uint16_t mavlink_msg_ping_
 						           uint64_t time_usec,uint32_t seq,uint8_t target_system,uint8_t target_component)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[14];
+	char buf[MAVLINK_MSG_ID_PING_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_uint32_t(buf, 8, seq);
 	_mav_put_uint8_t(buf, 12, target_system);
 	_mav_put_uint8_t(buf, 13, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 14);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_PING_LEN);
 #else
 	mavlink_ping_t packet;
 	packet.time_usec = time_usec;
@@ -94,15 +101,19 @@ static inline uint16_t mavlink_msg_ping_
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 14);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_PING_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_PING;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 14, 237);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_PING_LEN, MAVLINK_MSG_ID_PING_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_PING_LEN);
+#endif
 }
 
 /**
- * @brief Encode a ping struct into a message
+ * @brief Encode a ping struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -115,10 +126,24 @@ static inline uint16_t mavlink_msg_ping_
 }
 
 /**
+ * @brief Encode a ping struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param ping C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_ping_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_ping_t* ping)
+{
+	return mavlink_msg_ping_pack_chan(system_id, component_id, chan, msg, ping->time_usec, ping->seq, ping->target_system, ping->target_component);
+}
+
+/**
  * @brief Send a ping message
  * @param chan MAVLink channel to send the message
  *
- * @param time_usec Unix timestamp in microseconds
+ * @param time_usec Unix timestamp in microseconds or since system boot if smaller than MAVLink epoch (1.1.2009)
  * @param seq PING sequence
  * @param target_system 0: request ping from all receiving systems, if greater than 0: message is a ping response and number is the system id of the requesting system
  * @param target_component 0: request ping from all receiving components, if greater than 0: message is a ping response and number is the system id of the requesting system
@@ -128,13 +153,17 @@ static inline uint16_t mavlink_msg_ping_
 static inline void mavlink_msg_ping_send(mavlink_channel_t chan, uint64_t time_usec, uint32_t seq, uint8_t target_system, uint8_t target_component)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[14];
+	char buf[MAVLINK_MSG_ID_PING_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_uint32_t(buf, 8, seq);
 	_mav_put_uint8_t(buf, 12, target_system);
 	_mav_put_uint8_t(buf, 13, target_component);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PING, buf, 14, 237);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PING, buf, MAVLINK_MSG_ID_PING_LEN, MAVLINK_MSG_ID_PING_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PING, buf, MAVLINK_MSG_ID_PING_LEN);
+#endif
 #else
 	mavlink_ping_t packet;
 	packet.time_usec = time_usec;
@@ -142,10 +171,52 @@ static inline void mavlink_msg_ping_send
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PING, (const char *)&packet, 14, 237);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PING, (const char *)&packet, MAVLINK_MSG_ID_PING_LEN, MAVLINK_MSG_ID_PING_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PING, (const char *)&packet, MAVLINK_MSG_ID_PING_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_PING_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_ping_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t time_usec, uint32_t seq, uint8_t target_system, uint8_t target_component)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_uint32_t(buf, 8, seq);
+	_mav_put_uint8_t(buf, 12, target_system);
+	_mav_put_uint8_t(buf, 13, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PING, buf, MAVLINK_MSG_ID_PING_LEN, MAVLINK_MSG_ID_PING_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PING, buf, MAVLINK_MSG_ID_PING_LEN);
+#endif
+#else
+	mavlink_ping_t *packet = (mavlink_ping_t *)msgbuf;
+	packet->time_usec = time_usec;
+	packet->seq = seq;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PING, (const char *)packet, MAVLINK_MSG_ID_PING_LEN, MAVLINK_MSG_ID_PING_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_PING, (const char *)packet, MAVLINK_MSG_ID_PING_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE PING UNPACKING
@@ -154,7 +225,7 @@ static inline void mavlink_msg_ping_send
 /**
  * @brief Get field time_usec from ping message
  *
- * @return Unix timestamp in microseconds
+ * @return Unix timestamp in microseconds or since system boot if smaller than MAVLink epoch (1.1.2009)
  */
 static inline uint64_t mavlink_msg_ping_get_time_usec(const mavlink_message_t* msg)
 {
@@ -205,6 +276,6 @@ static inline void mavlink_msg_ping_deco
 	ping->target_system = mavlink_msg_ping_get_target_system(msg);
 	ping->target_component = mavlink_msg_ping_get_target_component(msg);
 #else
-	memcpy(ping, _MAV_PAYLOAD(msg), 14);
+	memcpy(ping, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_PING_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_position_target_global_int.h v1.0/common/mavlink_msg_position_target_global_int.h
--- v1.0.old/common/mavlink_msg_position_target_global_int.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_position_target_global_int.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,521 @@
+// MESSAGE POSITION_TARGET_GLOBAL_INT PACKING
+
+#define MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT 87
+
+typedef struct __mavlink_position_target_global_int_t
+{
+ uint32_t time_boot_ms; ///< Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
+ int32_t lat_int; ///< X Position in WGS84 frame in 1e7 * meters
+ int32_t lon_int; ///< Y Position in WGS84 frame in 1e7 * meters
+ float alt; ///< Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT
+ float vx; ///< X velocity in NED frame in meter / s
+ float vy; ///< Y velocity in NED frame in meter / s
+ float vz; ///< Z velocity in NED frame in meter / s
+ float afx; ///< X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ float afy; ///< Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ float afz; ///< Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ float yaw; ///< yaw setpoint in rad
+ float yaw_rate; ///< yaw rate setpoint in rad/s
+ uint16_t type_mask; ///< Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ uint8_t coordinate_frame; ///< Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
+} mavlink_position_target_global_int_t;
+
+#define MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN 51
+#define MAVLINK_MSG_ID_87_LEN 51
+
+#define MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_CRC 150
+#define MAVLINK_MSG_ID_87_CRC 150
+
+
+
+#define MAVLINK_MESSAGE_INFO_POSITION_TARGET_GLOBAL_INT { \
+	"POSITION_TARGET_GLOBAL_INT", \
+	14, \
+	{  { "time_boot_ms", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_position_target_global_int_t, time_boot_ms) }, \
+         { "lat_int", NULL, MAVLINK_TYPE_INT32_T, 0, 4, offsetof(mavlink_position_target_global_int_t, lat_int) }, \
+         { "lon_int", NULL, MAVLINK_TYPE_INT32_T, 0, 8, offsetof(mavlink_position_target_global_int_t, lon_int) }, \
+         { "alt", NULL, MAVLINK_TYPE_FLOAT, 0, 12, offsetof(mavlink_position_target_global_int_t, alt) }, \
+         { "vx", NULL, MAVLINK_TYPE_FLOAT, 0, 16, offsetof(mavlink_position_target_global_int_t, vx) }, \
+         { "vy", NULL, MAVLINK_TYPE_FLOAT, 0, 20, offsetof(mavlink_position_target_global_int_t, vy) }, \
+         { "vz", NULL, MAVLINK_TYPE_FLOAT, 0, 24, offsetof(mavlink_position_target_global_int_t, vz) }, \
+         { "afx", NULL, MAVLINK_TYPE_FLOAT, 0, 28, offsetof(mavlink_position_target_global_int_t, afx) }, \
+         { "afy", NULL, MAVLINK_TYPE_FLOAT, 0, 32, offsetof(mavlink_position_target_global_int_t, afy) }, \
+         { "afz", NULL, MAVLINK_TYPE_FLOAT, 0, 36, offsetof(mavlink_position_target_global_int_t, afz) }, \
+         { "yaw", NULL, MAVLINK_TYPE_FLOAT, 0, 40, offsetof(mavlink_position_target_global_int_t, yaw) }, \
+         { "yaw_rate", NULL, MAVLINK_TYPE_FLOAT, 0, 44, offsetof(mavlink_position_target_global_int_t, yaw_rate) }, \
+         { "type_mask", NULL, MAVLINK_TYPE_UINT16_T, 0, 48, offsetof(mavlink_position_target_global_int_t, type_mask) }, \
+         { "coordinate_frame", NULL, MAVLINK_TYPE_UINT8_T, 0, 50, offsetof(mavlink_position_target_global_int_t, coordinate_frame) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a position_target_global_int message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_boot_ms Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
+ * @param coordinate_frame Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
+ * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ * @param lat_int X Position in WGS84 frame in 1e7 * meters
+ * @param lon_int Y Position in WGS84 frame in 1e7 * meters
+ * @param alt Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT
+ * @param vx X velocity in NED frame in meter / s
+ * @param vy Y velocity in NED frame in meter / s
+ * @param vz Z velocity in NED frame in meter / s
+ * @param afx X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afy Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afz Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param yaw yaw setpoint in rad
+ * @param yaw_rate yaw rate setpoint in rad/s
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_position_target_global_int_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint32_t time_boot_ms, uint8_t coordinate_frame, uint16_t type_mask, int32_t lat_int, int32_t lon_int, float alt, float vx, float vy, float vz, float afx, float afy, float afz, float yaw, float yaw_rate)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_int32_t(buf, 4, lat_int);
+	_mav_put_int32_t(buf, 8, lon_int);
+	_mav_put_float(buf, 12, alt);
+	_mav_put_float(buf, 16, vx);
+	_mav_put_float(buf, 20, vy);
+	_mav_put_float(buf, 24, vz);
+	_mav_put_float(buf, 28, afx);
+	_mav_put_float(buf, 32, afy);
+	_mav_put_float(buf, 36, afz);
+	_mav_put_float(buf, 40, yaw);
+	_mav_put_float(buf, 44, yaw_rate);
+	_mav_put_uint16_t(buf, 48, type_mask);
+	_mav_put_uint8_t(buf, 50, coordinate_frame);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN);
+#else
+	mavlink_position_target_global_int_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.lat_int = lat_int;
+	packet.lon_int = lon_int;
+	packet.alt = alt;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.afx = afx;
+	packet.afy = afy;
+	packet.afz = afz;
+	packet.yaw = yaw;
+	packet.yaw_rate = yaw_rate;
+	packet.type_mask = type_mask;
+	packet.coordinate_frame = coordinate_frame;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a position_target_global_int message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_boot_ms Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
+ * @param coordinate_frame Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
+ * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ * @param lat_int X Position in WGS84 frame in 1e7 * meters
+ * @param lon_int Y Position in WGS84 frame in 1e7 * meters
+ * @param alt Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT
+ * @param vx X velocity in NED frame in meter / s
+ * @param vy Y velocity in NED frame in meter / s
+ * @param vz Z velocity in NED frame in meter / s
+ * @param afx X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afy Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afz Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param yaw yaw setpoint in rad
+ * @param yaw_rate yaw rate setpoint in rad/s
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_position_target_global_int_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint32_t time_boot_ms,uint8_t coordinate_frame,uint16_t type_mask,int32_t lat_int,int32_t lon_int,float alt,float vx,float vy,float vz,float afx,float afy,float afz,float yaw,float yaw_rate)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_int32_t(buf, 4, lat_int);
+	_mav_put_int32_t(buf, 8, lon_int);
+	_mav_put_float(buf, 12, alt);
+	_mav_put_float(buf, 16, vx);
+	_mav_put_float(buf, 20, vy);
+	_mav_put_float(buf, 24, vz);
+	_mav_put_float(buf, 28, afx);
+	_mav_put_float(buf, 32, afy);
+	_mav_put_float(buf, 36, afz);
+	_mav_put_float(buf, 40, yaw);
+	_mav_put_float(buf, 44, yaw_rate);
+	_mav_put_uint16_t(buf, 48, type_mask);
+	_mav_put_uint8_t(buf, 50, coordinate_frame);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN);
+#else
+	mavlink_position_target_global_int_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.lat_int = lat_int;
+	packet.lon_int = lon_int;
+	packet.alt = alt;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.afx = afx;
+	packet.afy = afy;
+	packet.afz = afz;
+	packet.yaw = yaw;
+	packet.yaw_rate = yaw_rate;
+	packet.type_mask = type_mask;
+	packet.coordinate_frame = coordinate_frame;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a position_target_global_int struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param position_target_global_int C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_position_target_global_int_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_position_target_global_int_t* position_target_global_int)
+{
+	return mavlink_msg_position_target_global_int_pack(system_id, component_id, msg, position_target_global_int->time_boot_ms, position_target_global_int->coordinate_frame, position_target_global_int->type_mask, position_target_global_int->lat_int, position_target_global_int->lon_int, position_target_global_int->alt, position_target_global_int->vx, position_target_global_int->vy, position_target_global_int->vz, position_target_global_int->afx, position_target_global_int->afy, position_target_global_int->afz, position_target_global_int->yaw, position_target_global_int->yaw_rate);
+}
+
+/**
+ * @brief Encode a position_target_global_int struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param position_target_global_int C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_position_target_global_int_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_position_target_global_int_t* position_target_global_int)
+{
+	return mavlink_msg_position_target_global_int_pack_chan(system_id, component_id, chan, msg, position_target_global_int->time_boot_ms, position_target_global_int->coordinate_frame, position_target_global_int->type_mask, position_target_global_int->lat_int, position_target_global_int->lon_int, position_target_global_int->alt, position_target_global_int->vx, position_target_global_int->vy, position_target_global_int->vz, position_target_global_int->afx, position_target_global_int->afy, position_target_global_int->afz, position_target_global_int->yaw, position_target_global_int->yaw_rate);
+}
+
+/**
+ * @brief Send a position_target_global_int message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_boot_ms Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
+ * @param coordinate_frame Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
+ * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ * @param lat_int X Position in WGS84 frame in 1e7 * meters
+ * @param lon_int Y Position in WGS84 frame in 1e7 * meters
+ * @param alt Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT
+ * @param vx X velocity in NED frame in meter / s
+ * @param vy Y velocity in NED frame in meter / s
+ * @param vz Z velocity in NED frame in meter / s
+ * @param afx X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afy Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afz Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param yaw yaw setpoint in rad
+ * @param yaw_rate yaw rate setpoint in rad/s
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_position_target_global_int_send(mavlink_channel_t chan, uint32_t time_boot_ms, uint8_t coordinate_frame, uint16_t type_mask, int32_t lat_int, int32_t lon_int, float alt, float vx, float vy, float vz, float afx, float afy, float afz, float yaw, float yaw_rate)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_int32_t(buf, 4, lat_int);
+	_mav_put_int32_t(buf, 8, lon_int);
+	_mav_put_float(buf, 12, alt);
+	_mav_put_float(buf, 16, vx);
+	_mav_put_float(buf, 20, vy);
+	_mav_put_float(buf, 24, vz);
+	_mav_put_float(buf, 28, afx);
+	_mav_put_float(buf, 32, afy);
+	_mav_put_float(buf, 36, afz);
+	_mav_put_float(buf, 40, yaw);
+	_mav_put_float(buf, 44, yaw_rate);
+	_mav_put_uint16_t(buf, 48, type_mask);
+	_mav_put_uint8_t(buf, 50, coordinate_frame);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT, buf, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT, buf, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+#else
+	mavlink_position_target_global_int_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.lat_int = lat_int;
+	packet.lon_int = lon_int;
+	packet.alt = alt;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.afx = afx;
+	packet.afy = afy;
+	packet.afz = afz;
+	packet.yaw = yaw;
+	packet.yaw_rate = yaw_rate;
+	packet.type_mask = type_mask;
+	packet.coordinate_frame = coordinate_frame;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT, (const char *)&packet, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT, (const char *)&packet, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_position_target_global_int_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, uint8_t coordinate_frame, uint16_t type_mask, int32_t lat_int, int32_t lon_int, float alt, float vx, float vy, float vz, float afx, float afy, float afz, float yaw, float yaw_rate)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_int32_t(buf, 4, lat_int);
+	_mav_put_int32_t(buf, 8, lon_int);
+	_mav_put_float(buf, 12, alt);
+	_mav_put_float(buf, 16, vx);
+	_mav_put_float(buf, 20, vy);
+	_mav_put_float(buf, 24, vz);
+	_mav_put_float(buf, 28, afx);
+	_mav_put_float(buf, 32, afy);
+	_mav_put_float(buf, 36, afz);
+	_mav_put_float(buf, 40, yaw);
+	_mav_put_float(buf, 44, yaw_rate);
+	_mav_put_uint16_t(buf, 48, type_mask);
+	_mav_put_uint8_t(buf, 50, coordinate_frame);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT, buf, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT, buf, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+#else
+	mavlink_position_target_global_int_t *packet = (mavlink_position_target_global_int_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->lat_int = lat_int;
+	packet->lon_int = lon_int;
+	packet->alt = alt;
+	packet->vx = vx;
+	packet->vy = vy;
+	packet->vz = vz;
+	packet->afx = afx;
+	packet->afy = afy;
+	packet->afz = afz;
+	packet->yaw = yaw;
+	packet->yaw_rate = yaw_rate;
+	packet->type_mask = type_mask;
+	packet->coordinate_frame = coordinate_frame;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT, (const char *)packet, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT, (const char *)packet, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE POSITION_TARGET_GLOBAL_INT UNPACKING
+
+
+/**
+ * @brief Get field time_boot_ms from position_target_global_int message
+ *
+ * @return Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
+ */
+static inline uint32_t mavlink_msg_position_target_global_int_get_time_boot_ms(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field coordinate_frame from position_target_global_int message
+ *
+ * @return Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
+ */
+static inline uint8_t mavlink_msg_position_target_global_int_get_coordinate_frame(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  50);
+}
+
+/**
+ * @brief Get field type_mask from position_target_global_int message
+ *
+ * @return Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ */
+static inline uint16_t mavlink_msg_position_target_global_int_get_type_mask(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  48);
+}
+
+/**
+ * @brief Get field lat_int from position_target_global_int message
+ *
+ * @return X Position in WGS84 frame in 1e7 * meters
+ */
+static inline int32_t mavlink_msg_position_target_global_int_get_lat_int(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  4);
+}
+
+/**
+ * @brief Get field lon_int from position_target_global_int message
+ *
+ * @return Y Position in WGS84 frame in 1e7 * meters
+ */
+static inline int32_t mavlink_msg_position_target_global_int_get_lon_int(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  8);
+}
+
+/**
+ * @brief Get field alt from position_target_global_int message
+ *
+ * @return Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT
+ */
+static inline float mavlink_msg_position_target_global_int_get_alt(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  12);
+}
+
+/**
+ * @brief Get field vx from position_target_global_int message
+ *
+ * @return X velocity in NED frame in meter / s
+ */
+static inline float mavlink_msg_position_target_global_int_get_vx(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  16);
+}
+
+/**
+ * @brief Get field vy from position_target_global_int message
+ *
+ * @return Y velocity in NED frame in meter / s
+ */
+static inline float mavlink_msg_position_target_global_int_get_vy(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  20);
+}
+
+/**
+ * @brief Get field vz from position_target_global_int message
+ *
+ * @return Z velocity in NED frame in meter / s
+ */
+static inline float mavlink_msg_position_target_global_int_get_vz(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  24);
+}
+
+/**
+ * @brief Get field afx from position_target_global_int message
+ *
+ * @return X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ */
+static inline float mavlink_msg_position_target_global_int_get_afx(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  28);
+}
+
+/**
+ * @brief Get field afy from position_target_global_int message
+ *
+ * @return Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ */
+static inline float mavlink_msg_position_target_global_int_get_afy(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  32);
+}
+
+/**
+ * @brief Get field afz from position_target_global_int message
+ *
+ * @return Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ */
+static inline float mavlink_msg_position_target_global_int_get_afz(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  36);
+}
+
+/**
+ * @brief Get field yaw from position_target_global_int message
+ *
+ * @return yaw setpoint in rad
+ */
+static inline float mavlink_msg_position_target_global_int_get_yaw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  40);
+}
+
+/**
+ * @brief Get field yaw_rate from position_target_global_int message
+ *
+ * @return yaw rate setpoint in rad/s
+ */
+static inline float mavlink_msg_position_target_global_int_get_yaw_rate(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  44);
+}
+
+/**
+ * @brief Decode a position_target_global_int message into a struct
+ *
+ * @param msg The message to decode
+ * @param position_target_global_int C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_position_target_global_int_decode(const mavlink_message_t* msg, mavlink_position_target_global_int_t* position_target_global_int)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	position_target_global_int->time_boot_ms = mavlink_msg_position_target_global_int_get_time_boot_ms(msg);
+	position_target_global_int->lat_int = mavlink_msg_position_target_global_int_get_lat_int(msg);
+	position_target_global_int->lon_int = mavlink_msg_position_target_global_int_get_lon_int(msg);
+	position_target_global_int->alt = mavlink_msg_position_target_global_int_get_alt(msg);
+	position_target_global_int->vx = mavlink_msg_position_target_global_int_get_vx(msg);
+	position_target_global_int->vy = mavlink_msg_position_target_global_int_get_vy(msg);
+	position_target_global_int->vz = mavlink_msg_position_target_global_int_get_vz(msg);
+	position_target_global_int->afx = mavlink_msg_position_target_global_int_get_afx(msg);
+	position_target_global_int->afy = mavlink_msg_position_target_global_int_get_afy(msg);
+	position_target_global_int->afz = mavlink_msg_position_target_global_int_get_afz(msg);
+	position_target_global_int->yaw = mavlink_msg_position_target_global_int_get_yaw(msg);
+	position_target_global_int->yaw_rate = mavlink_msg_position_target_global_int_get_yaw_rate(msg);
+	position_target_global_int->type_mask = mavlink_msg_position_target_global_int_get_type_mask(msg);
+	position_target_global_int->coordinate_frame = mavlink_msg_position_target_global_int_get_coordinate_frame(msg);
+#else
+	memcpy(position_target_global_int, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_position_target_local_ned.h v1.0/common/mavlink_msg_position_target_local_ned.h
--- v1.0.old/common/mavlink_msg_position_target_local_ned.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_position_target_local_ned.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,521 @@
+// MESSAGE POSITION_TARGET_LOCAL_NED PACKING
+
+#define MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED 85
+
+typedef struct __mavlink_position_target_local_ned_t
+{
+ uint32_t time_boot_ms; ///< Timestamp in milliseconds since system boot
+ float x; ///< X Position in NED frame in meters
+ float y; ///< Y Position in NED frame in meters
+ float z; ///< Z Position in NED frame in meters (note, altitude is negative in NED)
+ float vx; ///< X velocity in NED frame in meter / s
+ float vy; ///< Y velocity in NED frame in meter / s
+ float vz; ///< Z velocity in NED frame in meter / s
+ float afx; ///< X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ float afy; ///< Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ float afz; ///< Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ float yaw; ///< yaw setpoint in rad
+ float yaw_rate; ///< yaw rate setpoint in rad/s
+ uint16_t type_mask; ///< Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ uint8_t coordinate_frame; ///< Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
+} mavlink_position_target_local_ned_t;
+
+#define MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN 51
+#define MAVLINK_MSG_ID_85_LEN 51
+
+#define MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_CRC 140
+#define MAVLINK_MSG_ID_85_CRC 140
+
+
+
+#define MAVLINK_MESSAGE_INFO_POSITION_TARGET_LOCAL_NED { \
+	"POSITION_TARGET_LOCAL_NED", \
+	14, \
+	{  { "time_boot_ms", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_position_target_local_ned_t, time_boot_ms) }, \
+         { "x", NULL, MAVLINK_TYPE_FLOAT, 0, 4, offsetof(mavlink_position_target_local_ned_t, x) }, \
+         { "y", NULL, MAVLINK_TYPE_FLOAT, 0, 8, offsetof(mavlink_position_target_local_ned_t, y) }, \
+         { "z", NULL, MAVLINK_TYPE_FLOAT, 0, 12, offsetof(mavlink_position_target_local_ned_t, z) }, \
+         { "vx", NULL, MAVLINK_TYPE_FLOAT, 0, 16, offsetof(mavlink_position_target_local_ned_t, vx) }, \
+         { "vy", NULL, MAVLINK_TYPE_FLOAT, 0, 20, offsetof(mavlink_position_target_local_ned_t, vy) }, \
+         { "vz", NULL, MAVLINK_TYPE_FLOAT, 0, 24, offsetof(mavlink_position_target_local_ned_t, vz) }, \
+         { "afx", NULL, MAVLINK_TYPE_FLOAT, 0, 28, offsetof(mavlink_position_target_local_ned_t, afx) }, \
+         { "afy", NULL, MAVLINK_TYPE_FLOAT, 0, 32, offsetof(mavlink_position_target_local_ned_t, afy) }, \
+         { "afz", NULL, MAVLINK_TYPE_FLOAT, 0, 36, offsetof(mavlink_position_target_local_ned_t, afz) }, \
+         { "yaw", NULL, MAVLINK_TYPE_FLOAT, 0, 40, offsetof(mavlink_position_target_local_ned_t, yaw) }, \
+         { "yaw_rate", NULL, MAVLINK_TYPE_FLOAT, 0, 44, offsetof(mavlink_position_target_local_ned_t, yaw_rate) }, \
+         { "type_mask", NULL, MAVLINK_TYPE_UINT16_T, 0, 48, offsetof(mavlink_position_target_local_ned_t, type_mask) }, \
+         { "coordinate_frame", NULL, MAVLINK_TYPE_UINT8_T, 0, 50, offsetof(mavlink_position_target_local_ned_t, coordinate_frame) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a position_target_local_ned message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_boot_ms Timestamp in milliseconds since system boot
+ * @param coordinate_frame Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
+ * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ * @param x X Position in NED frame in meters
+ * @param y Y Position in NED frame in meters
+ * @param z Z Position in NED frame in meters (note, altitude is negative in NED)
+ * @param vx X velocity in NED frame in meter / s
+ * @param vy Y velocity in NED frame in meter / s
+ * @param vz Z velocity in NED frame in meter / s
+ * @param afx X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afy Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afz Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param yaw yaw setpoint in rad
+ * @param yaw_rate yaw rate setpoint in rad/s
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_position_target_local_ned_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint32_t time_boot_ms, uint8_t coordinate_frame, uint16_t type_mask, float x, float y, float z, float vx, float vy, float vz, float afx, float afy, float afz, float yaw, float yaw_rate)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, x);
+	_mav_put_float(buf, 8, y);
+	_mav_put_float(buf, 12, z);
+	_mav_put_float(buf, 16, vx);
+	_mav_put_float(buf, 20, vy);
+	_mav_put_float(buf, 24, vz);
+	_mav_put_float(buf, 28, afx);
+	_mav_put_float(buf, 32, afy);
+	_mav_put_float(buf, 36, afz);
+	_mav_put_float(buf, 40, yaw);
+	_mav_put_float(buf, 44, yaw_rate);
+	_mav_put_uint16_t(buf, 48, type_mask);
+	_mav_put_uint8_t(buf, 50, coordinate_frame);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN);
+#else
+	mavlink_position_target_local_ned_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.afx = afx;
+	packet.afy = afy;
+	packet.afz = afz;
+	packet.yaw = yaw;
+	packet.yaw_rate = yaw_rate;
+	packet.type_mask = type_mask;
+	packet.coordinate_frame = coordinate_frame;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a position_target_local_ned message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_boot_ms Timestamp in milliseconds since system boot
+ * @param coordinate_frame Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
+ * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ * @param x X Position in NED frame in meters
+ * @param y Y Position in NED frame in meters
+ * @param z Z Position in NED frame in meters (note, altitude is negative in NED)
+ * @param vx X velocity in NED frame in meter / s
+ * @param vy Y velocity in NED frame in meter / s
+ * @param vz Z velocity in NED frame in meter / s
+ * @param afx X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afy Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afz Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param yaw yaw setpoint in rad
+ * @param yaw_rate yaw rate setpoint in rad/s
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_position_target_local_ned_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint32_t time_boot_ms,uint8_t coordinate_frame,uint16_t type_mask,float x,float y,float z,float vx,float vy,float vz,float afx,float afy,float afz,float yaw,float yaw_rate)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, x);
+	_mav_put_float(buf, 8, y);
+	_mav_put_float(buf, 12, z);
+	_mav_put_float(buf, 16, vx);
+	_mav_put_float(buf, 20, vy);
+	_mav_put_float(buf, 24, vz);
+	_mav_put_float(buf, 28, afx);
+	_mav_put_float(buf, 32, afy);
+	_mav_put_float(buf, 36, afz);
+	_mav_put_float(buf, 40, yaw);
+	_mav_put_float(buf, 44, yaw_rate);
+	_mav_put_uint16_t(buf, 48, type_mask);
+	_mav_put_uint8_t(buf, 50, coordinate_frame);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN);
+#else
+	mavlink_position_target_local_ned_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.afx = afx;
+	packet.afy = afy;
+	packet.afz = afz;
+	packet.yaw = yaw;
+	packet.yaw_rate = yaw_rate;
+	packet.type_mask = type_mask;
+	packet.coordinate_frame = coordinate_frame;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a position_target_local_ned struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param position_target_local_ned C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_position_target_local_ned_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_position_target_local_ned_t* position_target_local_ned)
+{
+	return mavlink_msg_position_target_local_ned_pack(system_id, component_id, msg, position_target_local_ned->time_boot_ms, position_target_local_ned->coordinate_frame, position_target_local_ned->type_mask, position_target_local_ned->x, position_target_local_ned->y, position_target_local_ned->z, position_target_local_ned->vx, position_target_local_ned->vy, position_target_local_ned->vz, position_target_local_ned->afx, position_target_local_ned->afy, position_target_local_ned->afz, position_target_local_ned->yaw, position_target_local_ned->yaw_rate);
+}
+
+/**
+ * @brief Encode a position_target_local_ned struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param position_target_local_ned C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_position_target_local_ned_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_position_target_local_ned_t* position_target_local_ned)
+{
+	return mavlink_msg_position_target_local_ned_pack_chan(system_id, component_id, chan, msg, position_target_local_ned->time_boot_ms, position_target_local_ned->coordinate_frame, position_target_local_ned->type_mask, position_target_local_ned->x, position_target_local_ned->y, position_target_local_ned->z, position_target_local_ned->vx, position_target_local_ned->vy, position_target_local_ned->vz, position_target_local_ned->afx, position_target_local_ned->afy, position_target_local_ned->afz, position_target_local_ned->yaw, position_target_local_ned->yaw_rate);
+}
+
+/**
+ * @brief Send a position_target_local_ned message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_boot_ms Timestamp in milliseconds since system boot
+ * @param coordinate_frame Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
+ * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ * @param x X Position in NED frame in meters
+ * @param y Y Position in NED frame in meters
+ * @param z Z Position in NED frame in meters (note, altitude is negative in NED)
+ * @param vx X velocity in NED frame in meter / s
+ * @param vy Y velocity in NED frame in meter / s
+ * @param vz Z velocity in NED frame in meter / s
+ * @param afx X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afy Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afz Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param yaw yaw setpoint in rad
+ * @param yaw_rate yaw rate setpoint in rad/s
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_position_target_local_ned_send(mavlink_channel_t chan, uint32_t time_boot_ms, uint8_t coordinate_frame, uint16_t type_mask, float x, float y, float z, float vx, float vy, float vz, float afx, float afy, float afz, float yaw, float yaw_rate)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, x);
+	_mav_put_float(buf, 8, y);
+	_mav_put_float(buf, 12, z);
+	_mav_put_float(buf, 16, vx);
+	_mav_put_float(buf, 20, vy);
+	_mav_put_float(buf, 24, vz);
+	_mav_put_float(buf, 28, afx);
+	_mav_put_float(buf, 32, afy);
+	_mav_put_float(buf, 36, afz);
+	_mav_put_float(buf, 40, yaw);
+	_mav_put_float(buf, 44, yaw_rate);
+	_mav_put_uint16_t(buf, 48, type_mask);
+	_mav_put_uint8_t(buf, 50, coordinate_frame);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED, buf, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED, buf, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+#else
+	mavlink_position_target_local_ned_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.afx = afx;
+	packet.afy = afy;
+	packet.afz = afz;
+	packet.yaw = yaw;
+	packet.yaw_rate = yaw_rate;
+	packet.type_mask = type_mask;
+	packet.coordinate_frame = coordinate_frame;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED, (const char *)&packet, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED, (const char *)&packet, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_position_target_local_ned_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, uint8_t coordinate_frame, uint16_t type_mask, float x, float y, float z, float vx, float vy, float vz, float afx, float afy, float afz, float yaw, float yaw_rate)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, x);
+	_mav_put_float(buf, 8, y);
+	_mav_put_float(buf, 12, z);
+	_mav_put_float(buf, 16, vx);
+	_mav_put_float(buf, 20, vy);
+	_mav_put_float(buf, 24, vz);
+	_mav_put_float(buf, 28, afx);
+	_mav_put_float(buf, 32, afy);
+	_mav_put_float(buf, 36, afz);
+	_mav_put_float(buf, 40, yaw);
+	_mav_put_float(buf, 44, yaw_rate);
+	_mav_put_uint16_t(buf, 48, type_mask);
+	_mav_put_uint8_t(buf, 50, coordinate_frame);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED, buf, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED, buf, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+#else
+	mavlink_position_target_local_ned_t *packet = (mavlink_position_target_local_ned_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->x = x;
+	packet->y = y;
+	packet->z = z;
+	packet->vx = vx;
+	packet->vy = vy;
+	packet->vz = vz;
+	packet->afx = afx;
+	packet->afy = afy;
+	packet->afz = afz;
+	packet->yaw = yaw;
+	packet->yaw_rate = yaw_rate;
+	packet->type_mask = type_mask;
+	packet->coordinate_frame = coordinate_frame;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED, (const char *)packet, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED, (const char *)packet, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE POSITION_TARGET_LOCAL_NED UNPACKING
+
+
+/**
+ * @brief Get field time_boot_ms from position_target_local_ned message
+ *
+ * @return Timestamp in milliseconds since system boot
+ */
+static inline uint32_t mavlink_msg_position_target_local_ned_get_time_boot_ms(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field coordinate_frame from position_target_local_ned message
+ *
+ * @return Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
+ */
+static inline uint8_t mavlink_msg_position_target_local_ned_get_coordinate_frame(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  50);
+}
+
+/**
+ * @brief Get field type_mask from position_target_local_ned message
+ *
+ * @return Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ */
+static inline uint16_t mavlink_msg_position_target_local_ned_get_type_mask(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  48);
+}
+
+/**
+ * @brief Get field x from position_target_local_ned message
+ *
+ * @return X Position in NED frame in meters
+ */
+static inline float mavlink_msg_position_target_local_ned_get_x(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  4);
+}
+
+/**
+ * @brief Get field y from position_target_local_ned message
+ *
+ * @return Y Position in NED frame in meters
+ */
+static inline float mavlink_msg_position_target_local_ned_get_y(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  8);
+}
+
+/**
+ * @brief Get field z from position_target_local_ned message
+ *
+ * @return Z Position in NED frame in meters (note, altitude is negative in NED)
+ */
+static inline float mavlink_msg_position_target_local_ned_get_z(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  12);
+}
+
+/**
+ * @brief Get field vx from position_target_local_ned message
+ *
+ * @return X velocity in NED frame in meter / s
+ */
+static inline float mavlink_msg_position_target_local_ned_get_vx(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  16);
+}
+
+/**
+ * @brief Get field vy from position_target_local_ned message
+ *
+ * @return Y velocity in NED frame in meter / s
+ */
+static inline float mavlink_msg_position_target_local_ned_get_vy(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  20);
+}
+
+/**
+ * @brief Get field vz from position_target_local_ned message
+ *
+ * @return Z velocity in NED frame in meter / s
+ */
+static inline float mavlink_msg_position_target_local_ned_get_vz(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  24);
+}
+
+/**
+ * @brief Get field afx from position_target_local_ned message
+ *
+ * @return X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ */
+static inline float mavlink_msg_position_target_local_ned_get_afx(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  28);
+}
+
+/**
+ * @brief Get field afy from position_target_local_ned message
+ *
+ * @return Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ */
+static inline float mavlink_msg_position_target_local_ned_get_afy(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  32);
+}
+
+/**
+ * @brief Get field afz from position_target_local_ned message
+ *
+ * @return Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ */
+static inline float mavlink_msg_position_target_local_ned_get_afz(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  36);
+}
+
+/**
+ * @brief Get field yaw from position_target_local_ned message
+ *
+ * @return yaw setpoint in rad
+ */
+static inline float mavlink_msg_position_target_local_ned_get_yaw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  40);
+}
+
+/**
+ * @brief Get field yaw_rate from position_target_local_ned message
+ *
+ * @return yaw rate setpoint in rad/s
+ */
+static inline float mavlink_msg_position_target_local_ned_get_yaw_rate(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  44);
+}
+
+/**
+ * @brief Decode a position_target_local_ned message into a struct
+ *
+ * @param msg The message to decode
+ * @param position_target_local_ned C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_position_target_local_ned_decode(const mavlink_message_t* msg, mavlink_position_target_local_ned_t* position_target_local_ned)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	position_target_local_ned->time_boot_ms = mavlink_msg_position_target_local_ned_get_time_boot_ms(msg);
+	position_target_local_ned->x = mavlink_msg_position_target_local_ned_get_x(msg);
+	position_target_local_ned->y = mavlink_msg_position_target_local_ned_get_y(msg);
+	position_target_local_ned->z = mavlink_msg_position_target_local_ned_get_z(msg);
+	position_target_local_ned->vx = mavlink_msg_position_target_local_ned_get_vx(msg);
+	position_target_local_ned->vy = mavlink_msg_position_target_local_ned_get_vy(msg);
+	position_target_local_ned->vz = mavlink_msg_position_target_local_ned_get_vz(msg);
+	position_target_local_ned->afx = mavlink_msg_position_target_local_ned_get_afx(msg);
+	position_target_local_ned->afy = mavlink_msg_position_target_local_ned_get_afy(msg);
+	position_target_local_ned->afz = mavlink_msg_position_target_local_ned_get_afz(msg);
+	position_target_local_ned->yaw = mavlink_msg_position_target_local_ned_get_yaw(msg);
+	position_target_local_ned->yaw_rate = mavlink_msg_position_target_local_ned_get_yaw_rate(msg);
+	position_target_local_ned->type_mask = mavlink_msg_position_target_local_ned_get_type_mask(msg);
+	position_target_local_ned->coordinate_frame = mavlink_msg_position_target_local_ned_get_coordinate_frame(msg);
+#else
+	memcpy(position_target_local_ned, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_power_status.h v1.0/common/mavlink_msg_power_status.h
--- v1.0.old/common/mavlink_msg_power_status.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_power_status.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,257 @@
+// MESSAGE POWER_STATUS PACKING
+
+#define MAVLINK_MSG_ID_POWER_STATUS 125
+
+typedef struct __mavlink_power_status_t
+{
+ uint16_t Vcc; ///< 5V rail voltage in millivolts
+ uint16_t Vservo; ///< servo rail voltage in millivolts
+ uint16_t flags; ///< power supply status flags (see MAV_POWER_STATUS enum)
+} mavlink_power_status_t;
+
+#define MAVLINK_MSG_ID_POWER_STATUS_LEN 6
+#define MAVLINK_MSG_ID_125_LEN 6
+
+#define MAVLINK_MSG_ID_POWER_STATUS_CRC 203
+#define MAVLINK_MSG_ID_125_CRC 203
+
+
+
+#define MAVLINK_MESSAGE_INFO_POWER_STATUS { \
+	"POWER_STATUS", \
+	3, \
+	{  { "Vcc", NULL, MAVLINK_TYPE_UINT16_T, 0, 0, offsetof(mavlink_power_status_t, Vcc) }, \
+         { "Vservo", NULL, MAVLINK_TYPE_UINT16_T, 0, 2, offsetof(mavlink_power_status_t, Vservo) }, \
+         { "flags", NULL, MAVLINK_TYPE_UINT16_T, 0, 4, offsetof(mavlink_power_status_t, flags) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a power_status message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param Vcc 5V rail voltage in millivolts
+ * @param Vservo servo rail voltage in millivolts
+ * @param flags power supply status flags (see MAV_POWER_STATUS enum)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_power_status_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint16_t Vcc, uint16_t Vservo, uint16_t flags)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_POWER_STATUS_LEN];
+	_mav_put_uint16_t(buf, 0, Vcc);
+	_mav_put_uint16_t(buf, 2, Vservo);
+	_mav_put_uint16_t(buf, 4, flags);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_POWER_STATUS_LEN);
+#else
+	mavlink_power_status_t packet;
+	packet.Vcc = Vcc;
+	packet.Vservo = Vservo;
+	packet.flags = flags;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_POWER_STATUS_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_POWER_STATUS;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_POWER_STATUS_LEN, MAVLINK_MSG_ID_POWER_STATUS_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_POWER_STATUS_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a power_status message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param Vcc 5V rail voltage in millivolts
+ * @param Vservo servo rail voltage in millivolts
+ * @param flags power supply status flags (see MAV_POWER_STATUS enum)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_power_status_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint16_t Vcc,uint16_t Vservo,uint16_t flags)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_POWER_STATUS_LEN];
+	_mav_put_uint16_t(buf, 0, Vcc);
+	_mav_put_uint16_t(buf, 2, Vservo);
+	_mav_put_uint16_t(buf, 4, flags);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_POWER_STATUS_LEN);
+#else
+	mavlink_power_status_t packet;
+	packet.Vcc = Vcc;
+	packet.Vservo = Vservo;
+	packet.flags = flags;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_POWER_STATUS_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_POWER_STATUS;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_POWER_STATUS_LEN, MAVLINK_MSG_ID_POWER_STATUS_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_POWER_STATUS_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a power_status struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param power_status C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_power_status_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_power_status_t* power_status)
+{
+	return mavlink_msg_power_status_pack(system_id, component_id, msg, power_status->Vcc, power_status->Vservo, power_status->flags);
+}
+
+/**
+ * @brief Encode a power_status struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param power_status C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_power_status_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_power_status_t* power_status)
+{
+	return mavlink_msg_power_status_pack_chan(system_id, component_id, chan, msg, power_status->Vcc, power_status->Vservo, power_status->flags);
+}
+
+/**
+ * @brief Send a power_status message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param Vcc 5V rail voltage in millivolts
+ * @param Vservo servo rail voltage in millivolts
+ * @param flags power supply status flags (see MAV_POWER_STATUS enum)
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_power_status_send(mavlink_channel_t chan, uint16_t Vcc, uint16_t Vservo, uint16_t flags)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_POWER_STATUS_LEN];
+	_mav_put_uint16_t(buf, 0, Vcc);
+	_mav_put_uint16_t(buf, 2, Vservo);
+	_mav_put_uint16_t(buf, 4, flags);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POWER_STATUS, buf, MAVLINK_MSG_ID_POWER_STATUS_LEN, MAVLINK_MSG_ID_POWER_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POWER_STATUS, buf, MAVLINK_MSG_ID_POWER_STATUS_LEN);
+#endif
+#else
+	mavlink_power_status_t packet;
+	packet.Vcc = Vcc;
+	packet.Vservo = Vservo;
+	packet.flags = flags;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POWER_STATUS, (const char *)&packet, MAVLINK_MSG_ID_POWER_STATUS_LEN, MAVLINK_MSG_ID_POWER_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POWER_STATUS, (const char *)&packet, MAVLINK_MSG_ID_POWER_STATUS_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_POWER_STATUS_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_power_status_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint16_t Vcc, uint16_t Vservo, uint16_t flags)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint16_t(buf, 0, Vcc);
+	_mav_put_uint16_t(buf, 2, Vservo);
+	_mav_put_uint16_t(buf, 4, flags);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POWER_STATUS, buf, MAVLINK_MSG_ID_POWER_STATUS_LEN, MAVLINK_MSG_ID_POWER_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POWER_STATUS, buf, MAVLINK_MSG_ID_POWER_STATUS_LEN);
+#endif
+#else
+	mavlink_power_status_t *packet = (mavlink_power_status_t *)msgbuf;
+	packet->Vcc = Vcc;
+	packet->Vservo = Vservo;
+	packet->flags = flags;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POWER_STATUS, (const char *)packet, MAVLINK_MSG_ID_POWER_STATUS_LEN, MAVLINK_MSG_ID_POWER_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_POWER_STATUS, (const char *)packet, MAVLINK_MSG_ID_POWER_STATUS_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE POWER_STATUS UNPACKING
+
+
+/**
+ * @brief Get field Vcc from power_status message
+ *
+ * @return 5V rail voltage in millivolts
+ */
+static inline uint16_t mavlink_msg_power_status_get_Vcc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  0);
+}
+
+/**
+ * @brief Get field Vservo from power_status message
+ *
+ * @return servo rail voltage in millivolts
+ */
+static inline uint16_t mavlink_msg_power_status_get_Vservo(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  2);
+}
+
+/**
+ * @brief Get field flags from power_status message
+ *
+ * @return power supply status flags (see MAV_POWER_STATUS enum)
+ */
+static inline uint16_t mavlink_msg_power_status_get_flags(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  4);
+}
+
+/**
+ * @brief Decode a power_status message into a struct
+ *
+ * @param msg The message to decode
+ * @param power_status C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_power_status_decode(const mavlink_message_t* msg, mavlink_power_status_t* power_status)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	power_status->Vcc = mavlink_msg_power_status_get_Vcc(msg);
+	power_status->Vservo = mavlink_msg_power_status_get_Vservo(msg);
+	power_status->flags = mavlink_msg_power_status_get_flags(msg);
+#else
+	memcpy(power_status, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_POWER_STATUS_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_radio_status.h v1.0/common/mavlink_msg_radio_status.h
--- v1.0.old/common/mavlink_msg_radio_status.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_radio_status.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,353 @@
+// MESSAGE RADIO_STATUS PACKING
+
+#define MAVLINK_MSG_ID_RADIO_STATUS 109
+
+typedef struct __mavlink_radio_status_t
+{
+ uint16_t rxerrors; ///< receive errors
+ uint16_t fixed; ///< count of error corrected packets
+ uint8_t rssi; ///< local signal strength
+ uint8_t remrssi; ///< remote signal strength
+ uint8_t txbuf; ///< how full the tx buffer is as a percentage
+ uint8_t noise; ///< background noise level
+ uint8_t remnoise; ///< remote background noise level
+} mavlink_radio_status_t;
+
+#define MAVLINK_MSG_ID_RADIO_STATUS_LEN 9
+#define MAVLINK_MSG_ID_109_LEN 9
+
+#define MAVLINK_MSG_ID_RADIO_STATUS_CRC 185
+#define MAVLINK_MSG_ID_109_CRC 185
+
+
+
+#define MAVLINK_MESSAGE_INFO_RADIO_STATUS { \
+	"RADIO_STATUS", \
+	7, \
+	{  { "rxerrors", NULL, MAVLINK_TYPE_UINT16_T, 0, 0, offsetof(mavlink_radio_status_t, rxerrors) }, \
+         { "fixed", NULL, MAVLINK_TYPE_UINT16_T, 0, 2, offsetof(mavlink_radio_status_t, fixed) }, \
+         { "rssi", NULL, MAVLINK_TYPE_UINT8_T, 0, 4, offsetof(mavlink_radio_status_t, rssi) }, \
+         { "remrssi", NULL, MAVLINK_TYPE_UINT8_T, 0, 5, offsetof(mavlink_radio_status_t, remrssi) }, \
+         { "txbuf", NULL, MAVLINK_TYPE_UINT8_T, 0, 6, offsetof(mavlink_radio_status_t, txbuf) }, \
+         { "noise", NULL, MAVLINK_TYPE_UINT8_T, 0, 7, offsetof(mavlink_radio_status_t, noise) }, \
+         { "remnoise", NULL, MAVLINK_TYPE_UINT8_T, 0, 8, offsetof(mavlink_radio_status_t, remnoise) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a radio_status message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param rssi local signal strength
+ * @param remrssi remote signal strength
+ * @param txbuf how full the tx buffer is as a percentage
+ * @param noise background noise level
+ * @param remnoise remote background noise level
+ * @param rxerrors receive errors
+ * @param fixed count of error corrected packets
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_radio_status_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint8_t rssi, uint8_t remrssi, uint8_t txbuf, uint8_t noise, uint8_t remnoise, uint16_t rxerrors, uint16_t fixed)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_RADIO_STATUS_LEN];
+	_mav_put_uint16_t(buf, 0, rxerrors);
+	_mav_put_uint16_t(buf, 2, fixed);
+	_mav_put_uint8_t(buf, 4, rssi);
+	_mav_put_uint8_t(buf, 5, remrssi);
+	_mav_put_uint8_t(buf, 6, txbuf);
+	_mav_put_uint8_t(buf, 7, noise);
+	_mav_put_uint8_t(buf, 8, remnoise);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RADIO_STATUS_LEN);
+#else
+	mavlink_radio_status_t packet;
+	packet.rxerrors = rxerrors;
+	packet.fixed = fixed;
+	packet.rssi = rssi;
+	packet.remrssi = remrssi;
+	packet.txbuf = txbuf;
+	packet.noise = noise;
+	packet.remnoise = remnoise;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RADIO_STATUS_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_RADIO_STATUS;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RADIO_STATUS_LEN, MAVLINK_MSG_ID_RADIO_STATUS_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RADIO_STATUS_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a radio_status message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param rssi local signal strength
+ * @param remrssi remote signal strength
+ * @param txbuf how full the tx buffer is as a percentage
+ * @param noise background noise level
+ * @param remnoise remote background noise level
+ * @param rxerrors receive errors
+ * @param fixed count of error corrected packets
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_radio_status_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint8_t rssi,uint8_t remrssi,uint8_t txbuf,uint8_t noise,uint8_t remnoise,uint16_t rxerrors,uint16_t fixed)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_RADIO_STATUS_LEN];
+	_mav_put_uint16_t(buf, 0, rxerrors);
+	_mav_put_uint16_t(buf, 2, fixed);
+	_mav_put_uint8_t(buf, 4, rssi);
+	_mav_put_uint8_t(buf, 5, remrssi);
+	_mav_put_uint8_t(buf, 6, txbuf);
+	_mav_put_uint8_t(buf, 7, noise);
+	_mav_put_uint8_t(buf, 8, remnoise);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RADIO_STATUS_LEN);
+#else
+	mavlink_radio_status_t packet;
+	packet.rxerrors = rxerrors;
+	packet.fixed = fixed;
+	packet.rssi = rssi;
+	packet.remrssi = remrssi;
+	packet.txbuf = txbuf;
+	packet.noise = noise;
+	packet.remnoise = remnoise;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RADIO_STATUS_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_RADIO_STATUS;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RADIO_STATUS_LEN, MAVLINK_MSG_ID_RADIO_STATUS_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RADIO_STATUS_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a radio_status struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param radio_status C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_radio_status_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_radio_status_t* radio_status)
+{
+	return mavlink_msg_radio_status_pack(system_id, component_id, msg, radio_status->rssi, radio_status->remrssi, radio_status->txbuf, radio_status->noise, radio_status->remnoise, radio_status->rxerrors, radio_status->fixed);
+}
+
+/**
+ * @brief Encode a radio_status struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param radio_status C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_radio_status_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_radio_status_t* radio_status)
+{
+	return mavlink_msg_radio_status_pack_chan(system_id, component_id, chan, msg, radio_status->rssi, radio_status->remrssi, radio_status->txbuf, radio_status->noise, radio_status->remnoise, radio_status->rxerrors, radio_status->fixed);
+}
+
+/**
+ * @brief Send a radio_status message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param rssi local signal strength
+ * @param remrssi remote signal strength
+ * @param txbuf how full the tx buffer is as a percentage
+ * @param noise background noise level
+ * @param remnoise remote background noise level
+ * @param rxerrors receive errors
+ * @param fixed count of error corrected packets
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_radio_status_send(mavlink_channel_t chan, uint8_t rssi, uint8_t remrssi, uint8_t txbuf, uint8_t noise, uint8_t remnoise, uint16_t rxerrors, uint16_t fixed)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_RADIO_STATUS_LEN];
+	_mav_put_uint16_t(buf, 0, rxerrors);
+	_mav_put_uint16_t(buf, 2, fixed);
+	_mav_put_uint8_t(buf, 4, rssi);
+	_mav_put_uint8_t(buf, 5, remrssi);
+	_mav_put_uint8_t(buf, 6, txbuf);
+	_mav_put_uint8_t(buf, 7, noise);
+	_mav_put_uint8_t(buf, 8, remnoise);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RADIO_STATUS, buf, MAVLINK_MSG_ID_RADIO_STATUS_LEN, MAVLINK_MSG_ID_RADIO_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RADIO_STATUS, buf, MAVLINK_MSG_ID_RADIO_STATUS_LEN);
+#endif
+#else
+	mavlink_radio_status_t packet;
+	packet.rxerrors = rxerrors;
+	packet.fixed = fixed;
+	packet.rssi = rssi;
+	packet.remrssi = remrssi;
+	packet.txbuf = txbuf;
+	packet.noise = noise;
+	packet.remnoise = remnoise;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RADIO_STATUS, (const char *)&packet, MAVLINK_MSG_ID_RADIO_STATUS_LEN, MAVLINK_MSG_ID_RADIO_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RADIO_STATUS, (const char *)&packet, MAVLINK_MSG_ID_RADIO_STATUS_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_RADIO_STATUS_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_radio_status_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t rssi, uint8_t remrssi, uint8_t txbuf, uint8_t noise, uint8_t remnoise, uint16_t rxerrors, uint16_t fixed)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint16_t(buf, 0, rxerrors);
+	_mav_put_uint16_t(buf, 2, fixed);
+	_mav_put_uint8_t(buf, 4, rssi);
+	_mav_put_uint8_t(buf, 5, remrssi);
+	_mav_put_uint8_t(buf, 6, txbuf);
+	_mav_put_uint8_t(buf, 7, noise);
+	_mav_put_uint8_t(buf, 8, remnoise);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RADIO_STATUS, buf, MAVLINK_MSG_ID_RADIO_STATUS_LEN, MAVLINK_MSG_ID_RADIO_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RADIO_STATUS, buf, MAVLINK_MSG_ID_RADIO_STATUS_LEN);
+#endif
+#else
+	mavlink_radio_status_t *packet = (mavlink_radio_status_t *)msgbuf;
+	packet->rxerrors = rxerrors;
+	packet->fixed = fixed;
+	packet->rssi = rssi;
+	packet->remrssi = remrssi;
+	packet->txbuf = txbuf;
+	packet->noise = noise;
+	packet->remnoise = remnoise;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RADIO_STATUS, (const char *)packet, MAVLINK_MSG_ID_RADIO_STATUS_LEN, MAVLINK_MSG_ID_RADIO_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RADIO_STATUS, (const char *)packet, MAVLINK_MSG_ID_RADIO_STATUS_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE RADIO_STATUS UNPACKING
+
+
+/**
+ * @brief Get field rssi from radio_status message
+ *
+ * @return local signal strength
+ */
+static inline uint8_t mavlink_msg_radio_status_get_rssi(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  4);
+}
+
+/**
+ * @brief Get field remrssi from radio_status message
+ *
+ * @return remote signal strength
+ */
+static inline uint8_t mavlink_msg_radio_status_get_remrssi(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  5);
+}
+
+/**
+ * @brief Get field txbuf from radio_status message
+ *
+ * @return how full the tx buffer is as a percentage
+ */
+static inline uint8_t mavlink_msg_radio_status_get_txbuf(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  6);
+}
+
+/**
+ * @brief Get field noise from radio_status message
+ *
+ * @return background noise level
+ */
+static inline uint8_t mavlink_msg_radio_status_get_noise(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  7);
+}
+
+/**
+ * @brief Get field remnoise from radio_status message
+ *
+ * @return remote background noise level
+ */
+static inline uint8_t mavlink_msg_radio_status_get_remnoise(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  8);
+}
+
+/**
+ * @brief Get field rxerrors from radio_status message
+ *
+ * @return receive errors
+ */
+static inline uint16_t mavlink_msg_radio_status_get_rxerrors(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  0);
+}
+
+/**
+ * @brief Get field fixed from radio_status message
+ *
+ * @return count of error corrected packets
+ */
+static inline uint16_t mavlink_msg_radio_status_get_fixed(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  2);
+}
+
+/**
+ * @brief Decode a radio_status message into a struct
+ *
+ * @param msg The message to decode
+ * @param radio_status C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_radio_status_decode(const mavlink_message_t* msg, mavlink_radio_status_t* radio_status)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	radio_status->rxerrors = mavlink_msg_radio_status_get_rxerrors(msg);
+	radio_status->fixed = mavlink_msg_radio_status_get_fixed(msg);
+	radio_status->rssi = mavlink_msg_radio_status_get_rssi(msg);
+	radio_status->remrssi = mavlink_msg_radio_status_get_remrssi(msg);
+	radio_status->txbuf = mavlink_msg_radio_status_get_txbuf(msg);
+	radio_status->noise = mavlink_msg_radio_status_get_noise(msg);
+	radio_status->remnoise = mavlink_msg_radio_status_get_remnoise(msg);
+#else
+	memcpy(radio_status, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_RADIO_STATUS_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_raw_imu.h v1.0/common/mavlink_msg_raw_imu.h
--- v1.0.old/common/mavlink_msg_raw_imu.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_raw_imu.h	2015-02-06 11:50:58.000000000 +0500
@@ -19,6 +19,9 @@ typedef struct __mavlink_raw_imu_t
 #define MAVLINK_MSG_ID_RAW_IMU_LEN 26
 #define MAVLINK_MSG_ID_27_LEN 26
 
+#define MAVLINK_MSG_ID_RAW_IMU_CRC 144
+#define MAVLINK_MSG_ID_27_CRC 144
+
 
 
 #define MAVLINK_MESSAGE_INFO_RAW_IMU { \
@@ -60,7 +63,7 @@ static inline uint16_t mavlink_msg_raw_i
 						       uint64_t time_usec, int16_t xacc, int16_t yacc, int16_t zacc, int16_t xgyro, int16_t ygyro, int16_t zgyro, int16_t xmag, int16_t ymag, int16_t zmag)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[26];
+	char buf[MAVLINK_MSG_ID_RAW_IMU_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_int16_t(buf, 8, xacc);
 	_mav_put_int16_t(buf, 10, yacc);
@@ -72,7 +75,7 @@ static inline uint16_t mavlink_msg_raw_i
 	_mav_put_int16_t(buf, 22, ymag);
 	_mav_put_int16_t(buf, 24, zmag);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 26);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RAW_IMU_LEN);
 #else
 	mavlink_raw_imu_t packet;
 	packet.time_usec = time_usec;
@@ -86,18 +89,22 @@ static inline uint16_t mavlink_msg_raw_i
 	packet.ymag = ymag;
 	packet.zmag = zmag;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 26);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RAW_IMU_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_RAW_IMU;
-	return mavlink_finalize_message(msg, system_id, component_id, 26, 144);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RAW_IMU_LEN, MAVLINK_MSG_ID_RAW_IMU_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RAW_IMU_LEN);
+#endif
 }
 
 /**
  * @brief Pack a raw_imu message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
  * @param xacc X acceleration (raw)
@@ -116,7 +123,7 @@ static inline uint16_t mavlink_msg_raw_i
 						           uint64_t time_usec,int16_t xacc,int16_t yacc,int16_t zacc,int16_t xgyro,int16_t ygyro,int16_t zgyro,int16_t xmag,int16_t ymag,int16_t zmag)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[26];
+	char buf[MAVLINK_MSG_ID_RAW_IMU_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_int16_t(buf, 8, xacc);
 	_mav_put_int16_t(buf, 10, yacc);
@@ -128,7 +135,7 @@ static inline uint16_t mavlink_msg_raw_i
 	_mav_put_int16_t(buf, 22, ymag);
 	_mav_put_int16_t(buf, 24, zmag);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 26);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RAW_IMU_LEN);
 #else
 	mavlink_raw_imu_t packet;
 	packet.time_usec = time_usec;
@@ -142,15 +149,19 @@ static inline uint16_t mavlink_msg_raw_i
 	packet.ymag = ymag;
 	packet.zmag = zmag;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 26);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RAW_IMU_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_RAW_IMU;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 26, 144);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RAW_IMU_LEN, MAVLINK_MSG_ID_RAW_IMU_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RAW_IMU_LEN);
+#endif
 }
 
 /**
- * @brief Encode a raw_imu struct into a message
+ * @brief Encode a raw_imu struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -163,6 +174,20 @@ static inline uint16_t mavlink_msg_raw_i
 }
 
 /**
+ * @brief Encode a raw_imu struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param raw_imu C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_raw_imu_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_raw_imu_t* raw_imu)
+{
+	return mavlink_msg_raw_imu_pack_chan(system_id, component_id, chan, msg, raw_imu->time_usec, raw_imu->xacc, raw_imu->yacc, raw_imu->zacc, raw_imu->xgyro, raw_imu->ygyro, raw_imu->zgyro, raw_imu->xmag, raw_imu->ymag, raw_imu->zmag);
+}
+
+/**
  * @brief Send a raw_imu message
  * @param chan MAVLink channel to send the message
  *
@@ -182,7 +207,7 @@ static inline uint16_t mavlink_msg_raw_i
 static inline void mavlink_msg_raw_imu_send(mavlink_channel_t chan, uint64_t time_usec, int16_t xacc, int16_t yacc, int16_t zacc, int16_t xgyro, int16_t ygyro, int16_t zgyro, int16_t xmag, int16_t ymag, int16_t zmag)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[26];
+	char buf[MAVLINK_MSG_ID_RAW_IMU_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_int16_t(buf, 8, xacc);
 	_mav_put_int16_t(buf, 10, yacc);
@@ -194,7 +219,11 @@ static inline void mavlink_msg_raw_imu_s
 	_mav_put_int16_t(buf, 22, ymag);
 	_mav_put_int16_t(buf, 24, zmag);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_IMU, buf, 26, 144);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_IMU, buf, MAVLINK_MSG_ID_RAW_IMU_LEN, MAVLINK_MSG_ID_RAW_IMU_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_IMU, buf, MAVLINK_MSG_ID_RAW_IMU_LEN);
+#endif
 #else
 	mavlink_raw_imu_t packet;
 	packet.time_usec = time_usec;
@@ -208,10 +237,64 @@ static inline void mavlink_msg_raw_imu_s
 	packet.ymag = ymag;
 	packet.zmag = zmag;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_IMU, (const char *)&packet, 26, 144);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_IMU, (const char *)&packet, MAVLINK_MSG_ID_RAW_IMU_LEN, MAVLINK_MSG_ID_RAW_IMU_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_IMU, (const char *)&packet, MAVLINK_MSG_ID_RAW_IMU_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_RAW_IMU_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_raw_imu_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t time_usec, int16_t xacc, int16_t yacc, int16_t zacc, int16_t xgyro, int16_t ygyro, int16_t zgyro, int16_t xmag, int16_t ymag, int16_t zmag)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_int16_t(buf, 8, xacc);
+	_mav_put_int16_t(buf, 10, yacc);
+	_mav_put_int16_t(buf, 12, zacc);
+	_mav_put_int16_t(buf, 14, xgyro);
+	_mav_put_int16_t(buf, 16, ygyro);
+	_mav_put_int16_t(buf, 18, zgyro);
+	_mav_put_int16_t(buf, 20, xmag);
+	_mav_put_int16_t(buf, 22, ymag);
+	_mav_put_int16_t(buf, 24, zmag);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_IMU, buf, MAVLINK_MSG_ID_RAW_IMU_LEN, MAVLINK_MSG_ID_RAW_IMU_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_IMU, buf, MAVLINK_MSG_ID_RAW_IMU_LEN);
+#endif
+#else
+	mavlink_raw_imu_t *packet = (mavlink_raw_imu_t *)msgbuf;
+	packet->time_usec = time_usec;
+	packet->xacc = xacc;
+	packet->yacc = yacc;
+	packet->zacc = zacc;
+	packet->xgyro = xgyro;
+	packet->ygyro = ygyro;
+	packet->zgyro = zgyro;
+	packet->xmag = xmag;
+	packet->ymag = ymag;
+	packet->zmag = zmag;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_IMU, (const char *)packet, MAVLINK_MSG_ID_RAW_IMU_LEN, MAVLINK_MSG_ID_RAW_IMU_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_IMU, (const char *)packet, MAVLINK_MSG_ID_RAW_IMU_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE RAW_IMU UNPACKING
@@ -337,6 +420,6 @@ static inline void mavlink_msg_raw_imu_d
 	raw_imu->ymag = mavlink_msg_raw_imu_get_ymag(msg);
 	raw_imu->zmag = mavlink_msg_raw_imu_get_zmag(msg);
 #else
-	memcpy(raw_imu, _MAV_PAYLOAD(msg), 26);
+	memcpy(raw_imu, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_RAW_IMU_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_raw_pressure.h v1.0/common/mavlink_msg_raw_pressure.h
--- v1.0.old/common/mavlink_msg_raw_pressure.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_raw_pressure.h	2015-02-06 11:50:58.000000000 +0500
@@ -14,6 +14,9 @@ typedef struct __mavlink_raw_pressure_t
 #define MAVLINK_MSG_ID_RAW_PRESSURE_LEN 16
 #define MAVLINK_MSG_ID_28_LEN 16
 
+#define MAVLINK_MSG_ID_RAW_PRESSURE_CRC 67
+#define MAVLINK_MSG_ID_28_CRC 67
+
 
 
 #define MAVLINK_MESSAGE_INFO_RAW_PRESSURE { \
@@ -45,14 +48,14 @@ static inline uint16_t mavlink_msg_raw_p
 						       uint64_t time_usec, int16_t press_abs, int16_t press_diff1, int16_t press_diff2, int16_t temperature)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[16];
+	char buf[MAVLINK_MSG_ID_RAW_PRESSURE_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_int16_t(buf, 8, press_abs);
 	_mav_put_int16_t(buf, 10, press_diff1);
 	_mav_put_int16_t(buf, 12, press_diff2);
 	_mav_put_int16_t(buf, 14, temperature);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 16);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
 #else
 	mavlink_raw_pressure_t packet;
 	packet.time_usec = time_usec;
@@ -61,18 +64,22 @@ static inline uint16_t mavlink_msg_raw_p
 	packet.press_diff2 = press_diff2;
 	packet.temperature = temperature;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 16);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_RAW_PRESSURE;
-	return mavlink_finalize_message(msg, system_id, component_id, 16, 67);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RAW_PRESSURE_LEN, MAVLINK_MSG_ID_RAW_PRESSURE_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
+#endif
 }
 
 /**
  * @brief Pack a raw_pressure message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
  * @param press_abs Absolute pressure (raw)
@@ -86,14 +93,14 @@ static inline uint16_t mavlink_msg_raw_p
 						           uint64_t time_usec,int16_t press_abs,int16_t press_diff1,int16_t press_diff2,int16_t temperature)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[16];
+	char buf[MAVLINK_MSG_ID_RAW_PRESSURE_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_int16_t(buf, 8, press_abs);
 	_mav_put_int16_t(buf, 10, press_diff1);
 	_mav_put_int16_t(buf, 12, press_diff2);
 	_mav_put_int16_t(buf, 14, temperature);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 16);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
 #else
 	mavlink_raw_pressure_t packet;
 	packet.time_usec = time_usec;
@@ -102,15 +109,19 @@ static inline uint16_t mavlink_msg_raw_p
 	packet.press_diff2 = press_diff2;
 	packet.temperature = temperature;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 16);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_RAW_PRESSURE;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 16, 67);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RAW_PRESSURE_LEN, MAVLINK_MSG_ID_RAW_PRESSURE_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
+#endif
 }
 
 /**
- * @brief Encode a raw_pressure struct into a message
+ * @brief Encode a raw_pressure struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -123,6 +134,20 @@ static inline uint16_t mavlink_msg_raw_p
 }
 
 /**
+ * @brief Encode a raw_pressure struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param raw_pressure C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_raw_pressure_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_raw_pressure_t* raw_pressure)
+{
+	return mavlink_msg_raw_pressure_pack_chan(system_id, component_id, chan, msg, raw_pressure->time_usec, raw_pressure->press_abs, raw_pressure->press_diff1, raw_pressure->press_diff2, raw_pressure->temperature);
+}
+
+/**
  * @brief Send a raw_pressure message
  * @param chan MAVLink channel to send the message
  *
@@ -137,14 +162,18 @@ static inline uint16_t mavlink_msg_raw_p
 static inline void mavlink_msg_raw_pressure_send(mavlink_channel_t chan, uint64_t time_usec, int16_t press_abs, int16_t press_diff1, int16_t press_diff2, int16_t temperature)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[16];
+	char buf[MAVLINK_MSG_ID_RAW_PRESSURE_LEN];
 	_mav_put_uint64_t(buf, 0, time_usec);
 	_mav_put_int16_t(buf, 8, press_abs);
 	_mav_put_int16_t(buf, 10, press_diff1);
 	_mav_put_int16_t(buf, 12, press_diff2);
 	_mav_put_int16_t(buf, 14, temperature);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_PRESSURE, buf, 16, 67);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_PRESSURE, buf, MAVLINK_MSG_ID_RAW_PRESSURE_LEN, MAVLINK_MSG_ID_RAW_PRESSURE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_PRESSURE, buf, MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
+#endif
 #else
 	mavlink_raw_pressure_t packet;
 	packet.time_usec = time_usec;
@@ -153,9 +182,53 @@ static inline void mavlink_msg_raw_press
 	packet.press_diff2 = press_diff2;
 	packet.temperature = temperature;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_PRESSURE, (const char *)&packet, 16, 67);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_PRESSURE, (const char *)&packet, MAVLINK_MSG_ID_RAW_PRESSURE_LEN, MAVLINK_MSG_ID_RAW_PRESSURE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_PRESSURE, (const char *)&packet, MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_RAW_PRESSURE_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_raw_pressure_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t time_usec, int16_t press_abs, int16_t press_diff1, int16_t press_diff2, int16_t temperature)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_usec);
+	_mav_put_int16_t(buf, 8, press_abs);
+	_mav_put_int16_t(buf, 10, press_diff1);
+	_mav_put_int16_t(buf, 12, press_diff2);
+	_mav_put_int16_t(buf, 14, temperature);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_PRESSURE, buf, MAVLINK_MSG_ID_RAW_PRESSURE_LEN, MAVLINK_MSG_ID_RAW_PRESSURE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_PRESSURE, buf, MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
+#endif
+#else
+	mavlink_raw_pressure_t *packet = (mavlink_raw_pressure_t *)msgbuf;
+	packet->time_usec = time_usec;
+	packet->press_abs = press_abs;
+	packet->press_diff1 = press_diff1;
+	packet->press_diff2 = press_diff2;
+	packet->temperature = temperature;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_PRESSURE, (const char *)packet, MAVLINK_MSG_ID_RAW_PRESSURE_LEN, MAVLINK_MSG_ID_RAW_PRESSURE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RAW_PRESSURE, (const char *)packet, MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -227,6 +300,6 @@ static inline void mavlink_msg_raw_press
 	raw_pressure->press_diff2 = mavlink_msg_raw_pressure_get_press_diff2(msg);
 	raw_pressure->temperature = mavlink_msg_raw_pressure_get_temperature(msg);
 #else
-	memcpy(raw_pressure, _MAV_PAYLOAD(msg), 16);
+	memcpy(raw_pressure, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_rc_channels.h v1.0/common/mavlink_msg_rc_channels.h
--- v1.0.old/common/mavlink_msg_rc_channels.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_rc_channels.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,689 @@
+// MESSAGE RC_CHANNELS PACKING
+
+#define MAVLINK_MSG_ID_RC_CHANNELS 65
+
+typedef struct __mavlink_rc_channels_t
+{
+ uint32_t time_boot_ms; ///< Timestamp (milliseconds since system boot)
+ uint16_t chan1_raw; ///< RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan2_raw; ///< RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan3_raw; ///< RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan4_raw; ///< RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan5_raw; ///< RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan6_raw; ///< RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan7_raw; ///< RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan8_raw; ///< RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan9_raw; ///< RC channel 9 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan10_raw; ///< RC channel 10 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan11_raw; ///< RC channel 11 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan12_raw; ///< RC channel 12 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan13_raw; ///< RC channel 13 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan14_raw; ///< RC channel 14 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan15_raw; ///< RC channel 15 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan16_raw; ///< RC channel 16 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan17_raw; ///< RC channel 17 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan18_raw; ///< RC channel 18 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint8_t chancount; ///< Total number of RC channels being received. This can be larger than 18, indicating that more channels are available but not given in this message. This value should be 0 when no RC channels are available.
+ uint8_t rssi; ///< Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
+} mavlink_rc_channels_t;
+
+#define MAVLINK_MSG_ID_RC_CHANNELS_LEN 42
+#define MAVLINK_MSG_ID_65_LEN 42
+
+#define MAVLINK_MSG_ID_RC_CHANNELS_CRC 118
+#define MAVLINK_MSG_ID_65_CRC 118
+
+
+
+#define MAVLINK_MESSAGE_INFO_RC_CHANNELS { \
+	"RC_CHANNELS", \
+	21, \
+	{  { "time_boot_ms", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_rc_channels_t, time_boot_ms) }, \
+         { "chan1_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 4, offsetof(mavlink_rc_channels_t, chan1_raw) }, \
+         { "chan2_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 6, offsetof(mavlink_rc_channels_t, chan2_raw) }, \
+         { "chan3_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 8, offsetof(mavlink_rc_channels_t, chan3_raw) }, \
+         { "chan4_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 10, offsetof(mavlink_rc_channels_t, chan4_raw) }, \
+         { "chan5_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 12, offsetof(mavlink_rc_channels_t, chan5_raw) }, \
+         { "chan6_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 14, offsetof(mavlink_rc_channels_t, chan6_raw) }, \
+         { "chan7_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 16, offsetof(mavlink_rc_channels_t, chan7_raw) }, \
+         { "chan8_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 18, offsetof(mavlink_rc_channels_t, chan8_raw) }, \
+         { "chan9_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 20, offsetof(mavlink_rc_channels_t, chan9_raw) }, \
+         { "chan10_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 22, offsetof(mavlink_rc_channels_t, chan10_raw) }, \
+         { "chan11_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 24, offsetof(mavlink_rc_channels_t, chan11_raw) }, \
+         { "chan12_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 26, offsetof(mavlink_rc_channels_t, chan12_raw) }, \
+         { "chan13_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 28, offsetof(mavlink_rc_channels_t, chan13_raw) }, \
+         { "chan14_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 30, offsetof(mavlink_rc_channels_t, chan14_raw) }, \
+         { "chan15_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 32, offsetof(mavlink_rc_channels_t, chan15_raw) }, \
+         { "chan16_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 34, offsetof(mavlink_rc_channels_t, chan16_raw) }, \
+         { "chan17_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 36, offsetof(mavlink_rc_channels_t, chan17_raw) }, \
+         { "chan18_raw", NULL, MAVLINK_TYPE_UINT16_T, 0, 38, offsetof(mavlink_rc_channels_t, chan18_raw) }, \
+         { "chancount", NULL, MAVLINK_TYPE_UINT8_T, 0, 40, offsetof(mavlink_rc_channels_t, chancount) }, \
+         { "rssi", NULL, MAVLINK_TYPE_UINT8_T, 0, 41, offsetof(mavlink_rc_channels_t, rssi) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a rc_channels message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param chancount Total number of RC channels being received. This can be larger than 18, indicating that more channels are available but not given in this message. This value should be 0 when no RC channels are available.
+ * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan2_raw RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan3_raw RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan4_raw RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan5_raw RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan6_raw RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan7_raw RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan8_raw RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan9_raw RC channel 9 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan10_raw RC channel 10 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan11_raw RC channel 11 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan12_raw RC channel 12 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan13_raw RC channel 13 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan14_raw RC channel 14 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan15_raw RC channel 15 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan16_raw RC channel 16 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan17_raw RC channel 17 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan18_raw RC channel 18 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param rssi Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_rc_channels_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint32_t time_boot_ms, uint8_t chancount, uint16_t chan1_raw, uint16_t chan2_raw, uint16_t chan3_raw, uint16_t chan4_raw, uint16_t chan5_raw, uint16_t chan6_raw, uint16_t chan7_raw, uint16_t chan8_raw, uint16_t chan9_raw, uint16_t chan10_raw, uint16_t chan11_raw, uint16_t chan12_raw, uint16_t chan13_raw, uint16_t chan14_raw, uint16_t chan15_raw, uint16_t chan16_raw, uint16_t chan17_raw, uint16_t chan18_raw, uint8_t rssi)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_RC_CHANNELS_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_uint16_t(buf, 4, chan1_raw);
+	_mav_put_uint16_t(buf, 6, chan2_raw);
+	_mav_put_uint16_t(buf, 8, chan3_raw);
+	_mav_put_uint16_t(buf, 10, chan4_raw);
+	_mav_put_uint16_t(buf, 12, chan5_raw);
+	_mav_put_uint16_t(buf, 14, chan6_raw);
+	_mav_put_uint16_t(buf, 16, chan7_raw);
+	_mav_put_uint16_t(buf, 18, chan8_raw);
+	_mav_put_uint16_t(buf, 20, chan9_raw);
+	_mav_put_uint16_t(buf, 22, chan10_raw);
+	_mav_put_uint16_t(buf, 24, chan11_raw);
+	_mav_put_uint16_t(buf, 26, chan12_raw);
+	_mav_put_uint16_t(buf, 28, chan13_raw);
+	_mav_put_uint16_t(buf, 30, chan14_raw);
+	_mav_put_uint16_t(buf, 32, chan15_raw);
+	_mav_put_uint16_t(buf, 34, chan16_raw);
+	_mav_put_uint16_t(buf, 36, chan17_raw);
+	_mav_put_uint16_t(buf, 38, chan18_raw);
+	_mav_put_uint8_t(buf, 40, chancount);
+	_mav_put_uint8_t(buf, 41, rssi);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RC_CHANNELS_LEN);
+#else
+	mavlink_rc_channels_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.chan1_raw = chan1_raw;
+	packet.chan2_raw = chan2_raw;
+	packet.chan3_raw = chan3_raw;
+	packet.chan4_raw = chan4_raw;
+	packet.chan5_raw = chan5_raw;
+	packet.chan6_raw = chan6_raw;
+	packet.chan7_raw = chan7_raw;
+	packet.chan8_raw = chan8_raw;
+	packet.chan9_raw = chan9_raw;
+	packet.chan10_raw = chan10_raw;
+	packet.chan11_raw = chan11_raw;
+	packet.chan12_raw = chan12_raw;
+	packet.chan13_raw = chan13_raw;
+	packet.chan14_raw = chan14_raw;
+	packet.chan15_raw = chan15_raw;
+	packet.chan16_raw = chan16_raw;
+	packet.chan17_raw = chan17_raw;
+	packet.chan18_raw = chan18_raw;
+	packet.chancount = chancount;
+	packet.rssi = rssi;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RC_CHANNELS_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_RC_CHANNELS;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RC_CHANNELS_LEN, MAVLINK_MSG_ID_RC_CHANNELS_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RC_CHANNELS_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a rc_channels message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param chancount Total number of RC channels being received. This can be larger than 18, indicating that more channels are available but not given in this message. This value should be 0 when no RC channels are available.
+ * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan2_raw RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan3_raw RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan4_raw RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan5_raw RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan6_raw RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan7_raw RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan8_raw RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan9_raw RC channel 9 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan10_raw RC channel 10 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan11_raw RC channel 11 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan12_raw RC channel 12 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan13_raw RC channel 13 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan14_raw RC channel 14 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan15_raw RC channel 15 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan16_raw RC channel 16 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan17_raw RC channel 17 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan18_raw RC channel 18 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param rssi Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_rc_channels_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint32_t time_boot_ms,uint8_t chancount,uint16_t chan1_raw,uint16_t chan2_raw,uint16_t chan3_raw,uint16_t chan4_raw,uint16_t chan5_raw,uint16_t chan6_raw,uint16_t chan7_raw,uint16_t chan8_raw,uint16_t chan9_raw,uint16_t chan10_raw,uint16_t chan11_raw,uint16_t chan12_raw,uint16_t chan13_raw,uint16_t chan14_raw,uint16_t chan15_raw,uint16_t chan16_raw,uint16_t chan17_raw,uint16_t chan18_raw,uint8_t rssi)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_RC_CHANNELS_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_uint16_t(buf, 4, chan1_raw);
+	_mav_put_uint16_t(buf, 6, chan2_raw);
+	_mav_put_uint16_t(buf, 8, chan3_raw);
+	_mav_put_uint16_t(buf, 10, chan4_raw);
+	_mav_put_uint16_t(buf, 12, chan5_raw);
+	_mav_put_uint16_t(buf, 14, chan6_raw);
+	_mav_put_uint16_t(buf, 16, chan7_raw);
+	_mav_put_uint16_t(buf, 18, chan8_raw);
+	_mav_put_uint16_t(buf, 20, chan9_raw);
+	_mav_put_uint16_t(buf, 22, chan10_raw);
+	_mav_put_uint16_t(buf, 24, chan11_raw);
+	_mav_put_uint16_t(buf, 26, chan12_raw);
+	_mav_put_uint16_t(buf, 28, chan13_raw);
+	_mav_put_uint16_t(buf, 30, chan14_raw);
+	_mav_put_uint16_t(buf, 32, chan15_raw);
+	_mav_put_uint16_t(buf, 34, chan16_raw);
+	_mav_put_uint16_t(buf, 36, chan17_raw);
+	_mav_put_uint16_t(buf, 38, chan18_raw);
+	_mav_put_uint8_t(buf, 40, chancount);
+	_mav_put_uint8_t(buf, 41, rssi);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RC_CHANNELS_LEN);
+#else
+	mavlink_rc_channels_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.chan1_raw = chan1_raw;
+	packet.chan2_raw = chan2_raw;
+	packet.chan3_raw = chan3_raw;
+	packet.chan4_raw = chan4_raw;
+	packet.chan5_raw = chan5_raw;
+	packet.chan6_raw = chan6_raw;
+	packet.chan7_raw = chan7_raw;
+	packet.chan8_raw = chan8_raw;
+	packet.chan9_raw = chan9_raw;
+	packet.chan10_raw = chan10_raw;
+	packet.chan11_raw = chan11_raw;
+	packet.chan12_raw = chan12_raw;
+	packet.chan13_raw = chan13_raw;
+	packet.chan14_raw = chan14_raw;
+	packet.chan15_raw = chan15_raw;
+	packet.chan16_raw = chan16_raw;
+	packet.chan17_raw = chan17_raw;
+	packet.chan18_raw = chan18_raw;
+	packet.chancount = chancount;
+	packet.rssi = rssi;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RC_CHANNELS_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_RC_CHANNELS;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RC_CHANNELS_LEN, MAVLINK_MSG_ID_RC_CHANNELS_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RC_CHANNELS_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a rc_channels struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param rc_channels C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_rc_channels_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_rc_channels_t* rc_channels)
+{
+	return mavlink_msg_rc_channels_pack(system_id, component_id, msg, rc_channels->time_boot_ms, rc_channels->chancount, rc_channels->chan1_raw, rc_channels->chan2_raw, rc_channels->chan3_raw, rc_channels->chan4_raw, rc_channels->chan5_raw, rc_channels->chan6_raw, rc_channels->chan7_raw, rc_channels->chan8_raw, rc_channels->chan9_raw, rc_channels->chan10_raw, rc_channels->chan11_raw, rc_channels->chan12_raw, rc_channels->chan13_raw, rc_channels->chan14_raw, rc_channels->chan15_raw, rc_channels->chan16_raw, rc_channels->chan17_raw, rc_channels->chan18_raw, rc_channels->rssi);
+}
+
+/**
+ * @brief Encode a rc_channels struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param rc_channels C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_rc_channels_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_rc_channels_t* rc_channels)
+{
+	return mavlink_msg_rc_channels_pack_chan(system_id, component_id, chan, msg, rc_channels->time_boot_ms, rc_channels->chancount, rc_channels->chan1_raw, rc_channels->chan2_raw, rc_channels->chan3_raw, rc_channels->chan4_raw, rc_channels->chan5_raw, rc_channels->chan6_raw, rc_channels->chan7_raw, rc_channels->chan8_raw, rc_channels->chan9_raw, rc_channels->chan10_raw, rc_channels->chan11_raw, rc_channels->chan12_raw, rc_channels->chan13_raw, rc_channels->chan14_raw, rc_channels->chan15_raw, rc_channels->chan16_raw, rc_channels->chan17_raw, rc_channels->chan18_raw, rc_channels->rssi);
+}
+
+/**
+ * @brief Send a rc_channels message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param chancount Total number of RC channels being received. This can be larger than 18, indicating that more channels are available but not given in this message. This value should be 0 when no RC channels are available.
+ * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan2_raw RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan3_raw RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan4_raw RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan5_raw RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan6_raw RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan7_raw RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan8_raw RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan9_raw RC channel 9 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan10_raw RC channel 10 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan11_raw RC channel 11 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan12_raw RC channel 12 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan13_raw RC channel 13 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan14_raw RC channel 14 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan15_raw RC channel 15 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan16_raw RC channel 16 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan17_raw RC channel 17 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan18_raw RC channel 18 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param rssi Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_rc_channels_send(mavlink_channel_t chan, uint32_t time_boot_ms, uint8_t chancount, uint16_t chan1_raw, uint16_t chan2_raw, uint16_t chan3_raw, uint16_t chan4_raw, uint16_t chan5_raw, uint16_t chan6_raw, uint16_t chan7_raw, uint16_t chan8_raw, uint16_t chan9_raw, uint16_t chan10_raw, uint16_t chan11_raw, uint16_t chan12_raw, uint16_t chan13_raw, uint16_t chan14_raw, uint16_t chan15_raw, uint16_t chan16_raw, uint16_t chan17_raw, uint16_t chan18_raw, uint8_t rssi)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_RC_CHANNELS_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_uint16_t(buf, 4, chan1_raw);
+	_mav_put_uint16_t(buf, 6, chan2_raw);
+	_mav_put_uint16_t(buf, 8, chan3_raw);
+	_mav_put_uint16_t(buf, 10, chan4_raw);
+	_mav_put_uint16_t(buf, 12, chan5_raw);
+	_mav_put_uint16_t(buf, 14, chan6_raw);
+	_mav_put_uint16_t(buf, 16, chan7_raw);
+	_mav_put_uint16_t(buf, 18, chan8_raw);
+	_mav_put_uint16_t(buf, 20, chan9_raw);
+	_mav_put_uint16_t(buf, 22, chan10_raw);
+	_mav_put_uint16_t(buf, 24, chan11_raw);
+	_mav_put_uint16_t(buf, 26, chan12_raw);
+	_mav_put_uint16_t(buf, 28, chan13_raw);
+	_mav_put_uint16_t(buf, 30, chan14_raw);
+	_mav_put_uint16_t(buf, 32, chan15_raw);
+	_mav_put_uint16_t(buf, 34, chan16_raw);
+	_mav_put_uint16_t(buf, 36, chan17_raw);
+	_mav_put_uint16_t(buf, 38, chan18_raw);
+	_mav_put_uint8_t(buf, 40, chancount);
+	_mav_put_uint8_t(buf, 41, rssi);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS, buf, MAVLINK_MSG_ID_RC_CHANNELS_LEN, MAVLINK_MSG_ID_RC_CHANNELS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS, buf, MAVLINK_MSG_ID_RC_CHANNELS_LEN);
+#endif
+#else
+	mavlink_rc_channels_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.chan1_raw = chan1_raw;
+	packet.chan2_raw = chan2_raw;
+	packet.chan3_raw = chan3_raw;
+	packet.chan4_raw = chan4_raw;
+	packet.chan5_raw = chan5_raw;
+	packet.chan6_raw = chan6_raw;
+	packet.chan7_raw = chan7_raw;
+	packet.chan8_raw = chan8_raw;
+	packet.chan9_raw = chan9_raw;
+	packet.chan10_raw = chan10_raw;
+	packet.chan11_raw = chan11_raw;
+	packet.chan12_raw = chan12_raw;
+	packet.chan13_raw = chan13_raw;
+	packet.chan14_raw = chan14_raw;
+	packet.chan15_raw = chan15_raw;
+	packet.chan16_raw = chan16_raw;
+	packet.chan17_raw = chan17_raw;
+	packet.chan18_raw = chan18_raw;
+	packet.chancount = chancount;
+	packet.rssi = rssi;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS, (const char *)&packet, MAVLINK_MSG_ID_RC_CHANNELS_LEN, MAVLINK_MSG_ID_RC_CHANNELS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS, (const char *)&packet, MAVLINK_MSG_ID_RC_CHANNELS_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_RC_CHANNELS_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_rc_channels_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, uint8_t chancount, uint16_t chan1_raw, uint16_t chan2_raw, uint16_t chan3_raw, uint16_t chan4_raw, uint16_t chan5_raw, uint16_t chan6_raw, uint16_t chan7_raw, uint16_t chan8_raw, uint16_t chan9_raw, uint16_t chan10_raw, uint16_t chan11_raw, uint16_t chan12_raw, uint16_t chan13_raw, uint16_t chan14_raw, uint16_t chan15_raw, uint16_t chan16_raw, uint16_t chan17_raw, uint16_t chan18_raw, uint8_t rssi)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_uint16_t(buf, 4, chan1_raw);
+	_mav_put_uint16_t(buf, 6, chan2_raw);
+	_mav_put_uint16_t(buf, 8, chan3_raw);
+	_mav_put_uint16_t(buf, 10, chan4_raw);
+	_mav_put_uint16_t(buf, 12, chan5_raw);
+	_mav_put_uint16_t(buf, 14, chan6_raw);
+	_mav_put_uint16_t(buf, 16, chan7_raw);
+	_mav_put_uint16_t(buf, 18, chan8_raw);
+	_mav_put_uint16_t(buf, 20, chan9_raw);
+	_mav_put_uint16_t(buf, 22, chan10_raw);
+	_mav_put_uint16_t(buf, 24, chan11_raw);
+	_mav_put_uint16_t(buf, 26, chan12_raw);
+	_mav_put_uint16_t(buf, 28, chan13_raw);
+	_mav_put_uint16_t(buf, 30, chan14_raw);
+	_mav_put_uint16_t(buf, 32, chan15_raw);
+	_mav_put_uint16_t(buf, 34, chan16_raw);
+	_mav_put_uint16_t(buf, 36, chan17_raw);
+	_mav_put_uint16_t(buf, 38, chan18_raw);
+	_mav_put_uint8_t(buf, 40, chancount);
+	_mav_put_uint8_t(buf, 41, rssi);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS, buf, MAVLINK_MSG_ID_RC_CHANNELS_LEN, MAVLINK_MSG_ID_RC_CHANNELS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS, buf, MAVLINK_MSG_ID_RC_CHANNELS_LEN);
+#endif
+#else
+	mavlink_rc_channels_t *packet = (mavlink_rc_channels_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->chan1_raw = chan1_raw;
+	packet->chan2_raw = chan2_raw;
+	packet->chan3_raw = chan3_raw;
+	packet->chan4_raw = chan4_raw;
+	packet->chan5_raw = chan5_raw;
+	packet->chan6_raw = chan6_raw;
+	packet->chan7_raw = chan7_raw;
+	packet->chan8_raw = chan8_raw;
+	packet->chan9_raw = chan9_raw;
+	packet->chan10_raw = chan10_raw;
+	packet->chan11_raw = chan11_raw;
+	packet->chan12_raw = chan12_raw;
+	packet->chan13_raw = chan13_raw;
+	packet->chan14_raw = chan14_raw;
+	packet->chan15_raw = chan15_raw;
+	packet->chan16_raw = chan16_raw;
+	packet->chan17_raw = chan17_raw;
+	packet->chan18_raw = chan18_raw;
+	packet->chancount = chancount;
+	packet->rssi = rssi;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS, (const char *)packet, MAVLINK_MSG_ID_RC_CHANNELS_LEN, MAVLINK_MSG_ID_RC_CHANNELS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS, (const char *)packet, MAVLINK_MSG_ID_RC_CHANNELS_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE RC_CHANNELS UNPACKING
+
+
+/**
+ * @brief Get field time_boot_ms from rc_channels message
+ *
+ * @return Timestamp (milliseconds since system boot)
+ */
+static inline uint32_t mavlink_msg_rc_channels_get_time_boot_ms(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field chancount from rc_channels message
+ *
+ * @return Total number of RC channels being received. This can be larger than 18, indicating that more channels are available but not given in this message. This value should be 0 when no RC channels are available.
+ */
+static inline uint8_t mavlink_msg_rc_channels_get_chancount(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  40);
+}
+
+/**
+ * @brief Get field chan1_raw from rc_channels message
+ *
+ * @return RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan1_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  4);
+}
+
+/**
+ * @brief Get field chan2_raw from rc_channels message
+ *
+ * @return RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan2_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  6);
+}
+
+/**
+ * @brief Get field chan3_raw from rc_channels message
+ *
+ * @return RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan3_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  8);
+}
+
+/**
+ * @brief Get field chan4_raw from rc_channels message
+ *
+ * @return RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan4_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  10);
+}
+
+/**
+ * @brief Get field chan5_raw from rc_channels message
+ *
+ * @return RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan5_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  12);
+}
+
+/**
+ * @brief Get field chan6_raw from rc_channels message
+ *
+ * @return RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan6_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  14);
+}
+
+/**
+ * @brief Get field chan7_raw from rc_channels message
+ *
+ * @return RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan7_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  16);
+}
+
+/**
+ * @brief Get field chan8_raw from rc_channels message
+ *
+ * @return RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan8_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  18);
+}
+
+/**
+ * @brief Get field chan9_raw from rc_channels message
+ *
+ * @return RC channel 9 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan9_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  20);
+}
+
+/**
+ * @brief Get field chan10_raw from rc_channels message
+ *
+ * @return RC channel 10 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan10_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  22);
+}
+
+/**
+ * @brief Get field chan11_raw from rc_channels message
+ *
+ * @return RC channel 11 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan11_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  24);
+}
+
+/**
+ * @brief Get field chan12_raw from rc_channels message
+ *
+ * @return RC channel 12 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan12_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  26);
+}
+
+/**
+ * @brief Get field chan13_raw from rc_channels message
+ *
+ * @return RC channel 13 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan13_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  28);
+}
+
+/**
+ * @brief Get field chan14_raw from rc_channels message
+ *
+ * @return RC channel 14 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan14_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  30);
+}
+
+/**
+ * @brief Get field chan15_raw from rc_channels message
+ *
+ * @return RC channel 15 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan15_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  32);
+}
+
+/**
+ * @brief Get field chan16_raw from rc_channels message
+ *
+ * @return RC channel 16 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan16_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  34);
+}
+
+/**
+ * @brief Get field chan17_raw from rc_channels message
+ *
+ * @return RC channel 17 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan17_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  36);
+}
+
+/**
+ * @brief Get field chan18_raw from rc_channels message
+ *
+ * @return RC channel 18 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ */
+static inline uint16_t mavlink_msg_rc_channels_get_chan18_raw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  38);
+}
+
+/**
+ * @brief Get field rssi from rc_channels message
+ *
+ * @return Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
+ */
+static inline uint8_t mavlink_msg_rc_channels_get_rssi(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  41);
+}
+
+/**
+ * @brief Decode a rc_channels message into a struct
+ *
+ * @param msg The message to decode
+ * @param rc_channels C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_rc_channels_decode(const mavlink_message_t* msg, mavlink_rc_channels_t* rc_channels)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	rc_channels->time_boot_ms = mavlink_msg_rc_channels_get_time_boot_ms(msg);
+	rc_channels->chan1_raw = mavlink_msg_rc_channels_get_chan1_raw(msg);
+	rc_channels->chan2_raw = mavlink_msg_rc_channels_get_chan2_raw(msg);
+	rc_channels->chan3_raw = mavlink_msg_rc_channels_get_chan3_raw(msg);
+	rc_channels->chan4_raw = mavlink_msg_rc_channels_get_chan4_raw(msg);
+	rc_channels->chan5_raw = mavlink_msg_rc_channels_get_chan5_raw(msg);
+	rc_channels->chan6_raw = mavlink_msg_rc_channels_get_chan6_raw(msg);
+	rc_channels->chan7_raw = mavlink_msg_rc_channels_get_chan7_raw(msg);
+	rc_channels->chan8_raw = mavlink_msg_rc_channels_get_chan8_raw(msg);
+	rc_channels->chan9_raw = mavlink_msg_rc_channels_get_chan9_raw(msg);
+	rc_channels->chan10_raw = mavlink_msg_rc_channels_get_chan10_raw(msg);
+	rc_channels->chan11_raw = mavlink_msg_rc_channels_get_chan11_raw(msg);
+	rc_channels->chan12_raw = mavlink_msg_rc_channels_get_chan12_raw(msg);
+	rc_channels->chan13_raw = mavlink_msg_rc_channels_get_chan13_raw(msg);
+	rc_channels->chan14_raw = mavlink_msg_rc_channels_get_chan14_raw(msg);
+	rc_channels->chan15_raw = mavlink_msg_rc_channels_get_chan15_raw(msg);
+	rc_channels->chan16_raw = mavlink_msg_rc_channels_get_chan16_raw(msg);
+	rc_channels->chan17_raw = mavlink_msg_rc_channels_get_chan17_raw(msg);
+	rc_channels->chan18_raw = mavlink_msg_rc_channels_get_chan18_raw(msg);
+	rc_channels->chancount = mavlink_msg_rc_channels_get_chancount(msg);
+	rc_channels->rssi = mavlink_msg_rc_channels_get_rssi(msg);
+#else
+	memcpy(rc_channels, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_RC_CHANNELS_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_rc_channels_override.h v1.0/common/mavlink_msg_rc_channels_override.h
--- v1.0.old/common/mavlink_msg_rc_channels_override.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_rc_channels_override.h	2015-02-06 11:50:58.000000000 +0500
@@ -4,14 +4,14 @@
 
 typedef struct __mavlink_rc_channels_override_t
 {
- uint16_t chan1_raw; ///< RC channel 1 value, in microseconds
- uint16_t chan2_raw; ///< RC channel 2 value, in microseconds
- uint16_t chan3_raw; ///< RC channel 3 value, in microseconds
- uint16_t chan4_raw; ///< RC channel 4 value, in microseconds
- uint16_t chan5_raw; ///< RC channel 5 value, in microseconds
- uint16_t chan6_raw; ///< RC channel 6 value, in microseconds
- uint16_t chan7_raw; ///< RC channel 7 value, in microseconds
- uint16_t chan8_raw; ///< RC channel 8 value, in microseconds
+ uint16_t chan1_raw; ///< RC channel 1 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ uint16_t chan2_raw; ///< RC channel 2 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ uint16_t chan3_raw; ///< RC channel 3 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ uint16_t chan4_raw; ///< RC channel 4 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ uint16_t chan5_raw; ///< RC channel 5 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ uint16_t chan6_raw; ///< RC channel 6 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ uint16_t chan7_raw; ///< RC channel 7 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ uint16_t chan8_raw; ///< RC channel 8 value, in microseconds. A value of UINT16_MAX means to ignore this field.
  uint8_t target_system; ///< System ID
  uint8_t target_component; ///< Component ID
 } mavlink_rc_channels_override_t;
@@ -19,6 +19,9 @@ typedef struct __mavlink_rc_channels_ove
 #define MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN 18
 #define MAVLINK_MSG_ID_70_LEN 18
 
+#define MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_CRC 124
+#define MAVLINK_MSG_ID_70_CRC 124
+
 
 
 #define MAVLINK_MESSAGE_INFO_RC_CHANNELS_OVERRIDE { \
@@ -46,21 +49,21 @@ typedef struct __mavlink_rc_channels_ove
  *
  * @param target_system System ID
  * @param target_component Component ID
- * @param chan1_raw RC channel 1 value, in microseconds
- * @param chan2_raw RC channel 2 value, in microseconds
- * @param chan3_raw RC channel 3 value, in microseconds
- * @param chan4_raw RC channel 4 value, in microseconds
- * @param chan5_raw RC channel 5 value, in microseconds
- * @param chan6_raw RC channel 6 value, in microseconds
- * @param chan7_raw RC channel 7 value, in microseconds
- * @param chan8_raw RC channel 8 value, in microseconds
+ * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan2_raw RC channel 2 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan3_raw RC channel 3 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan4_raw RC channel 4 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan5_raw RC channel 5 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan6_raw RC channel 6 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan7_raw RC channel 7 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan8_raw RC channel 8 value, in microseconds. A value of UINT16_MAX means to ignore this field.
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_rc_channels_override_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
 						       uint8_t target_system, uint8_t target_component, uint16_t chan1_raw, uint16_t chan2_raw, uint16_t chan3_raw, uint16_t chan4_raw, uint16_t chan5_raw, uint16_t chan6_raw, uint16_t chan7_raw, uint16_t chan8_raw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[18];
+	char buf[MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN];
 	_mav_put_uint16_t(buf, 0, chan1_raw);
 	_mav_put_uint16_t(buf, 2, chan2_raw);
 	_mav_put_uint16_t(buf, 4, chan3_raw);
@@ -72,7 +75,7 @@ static inline uint16_t mavlink_msg_rc_ch
 	_mav_put_uint8_t(buf, 16, target_system);
 	_mav_put_uint8_t(buf, 17, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 18);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN);
 #else
 	mavlink_rc_channels_override_t packet;
 	packet.chan1_raw = chan1_raw;
@@ -86,29 +89,33 @@ static inline uint16_t mavlink_msg_rc_ch
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 18);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE;
-	return mavlink_finalize_message(msg, system_id, component_id, 18, 124);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN);
+#endif
 }
 
 /**
  * @brief Pack a rc_channels_override message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system System ID
  * @param target_component Component ID
- * @param chan1_raw RC channel 1 value, in microseconds
- * @param chan2_raw RC channel 2 value, in microseconds
- * @param chan3_raw RC channel 3 value, in microseconds
- * @param chan4_raw RC channel 4 value, in microseconds
- * @param chan5_raw RC channel 5 value, in microseconds
- * @param chan6_raw RC channel 6 value, in microseconds
- * @param chan7_raw RC channel 7 value, in microseconds
- * @param chan8_raw RC channel 8 value, in microseconds
+ * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan2_raw RC channel 2 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan3_raw RC channel 3 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan4_raw RC channel 4 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan5_raw RC channel 5 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan6_raw RC channel 6 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan7_raw RC channel 7 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan8_raw RC channel 8 value, in microseconds. A value of UINT16_MAX means to ignore this field.
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_rc_channels_override_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
@@ -116,7 +123,7 @@ static inline uint16_t mavlink_msg_rc_ch
 						           uint8_t target_system,uint8_t target_component,uint16_t chan1_raw,uint16_t chan2_raw,uint16_t chan3_raw,uint16_t chan4_raw,uint16_t chan5_raw,uint16_t chan6_raw,uint16_t chan7_raw,uint16_t chan8_raw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[18];
+	char buf[MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN];
 	_mav_put_uint16_t(buf, 0, chan1_raw);
 	_mav_put_uint16_t(buf, 2, chan2_raw);
 	_mav_put_uint16_t(buf, 4, chan3_raw);
@@ -128,7 +135,7 @@ static inline uint16_t mavlink_msg_rc_ch
 	_mav_put_uint8_t(buf, 16, target_system);
 	_mav_put_uint8_t(buf, 17, target_component);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 18);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN);
 #else
 	mavlink_rc_channels_override_t packet;
 	packet.chan1_raw = chan1_raw;
@@ -142,15 +149,19 @@ static inline uint16_t mavlink_msg_rc_ch
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 18);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 18, 124);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN);
+#endif
 }
 
 /**
- * @brief Encode a rc_channels_override struct into a message
+ * @brief Encode a rc_channels_override struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -163,26 +174,40 @@ static inline uint16_t mavlink_msg_rc_ch
 }
 
 /**
+ * @brief Encode a rc_channels_override struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param rc_channels_override C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_rc_channels_override_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_rc_channels_override_t* rc_channels_override)
+{
+	return mavlink_msg_rc_channels_override_pack_chan(system_id, component_id, chan, msg, rc_channels_override->target_system, rc_channels_override->target_component, rc_channels_override->chan1_raw, rc_channels_override->chan2_raw, rc_channels_override->chan3_raw, rc_channels_override->chan4_raw, rc_channels_override->chan5_raw, rc_channels_override->chan6_raw, rc_channels_override->chan7_raw, rc_channels_override->chan8_raw);
+}
+
+/**
  * @brief Send a rc_channels_override message
  * @param chan MAVLink channel to send the message
  *
  * @param target_system System ID
  * @param target_component Component ID
- * @param chan1_raw RC channel 1 value, in microseconds
- * @param chan2_raw RC channel 2 value, in microseconds
- * @param chan3_raw RC channel 3 value, in microseconds
- * @param chan4_raw RC channel 4 value, in microseconds
- * @param chan5_raw RC channel 5 value, in microseconds
- * @param chan6_raw RC channel 6 value, in microseconds
- * @param chan7_raw RC channel 7 value, in microseconds
- * @param chan8_raw RC channel 8 value, in microseconds
+ * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan2_raw RC channel 2 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan3_raw RC channel 3 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan4_raw RC channel 4 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan5_raw RC channel 5 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan6_raw RC channel 6 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan7_raw RC channel 7 value, in microseconds. A value of UINT16_MAX means to ignore this field.
+ * @param chan8_raw RC channel 8 value, in microseconds. A value of UINT16_MAX means to ignore this field.
  */
 #ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
 
 static inline void mavlink_msg_rc_channels_override_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, uint16_t chan1_raw, uint16_t chan2_raw, uint16_t chan3_raw, uint16_t chan4_raw, uint16_t chan5_raw, uint16_t chan6_raw, uint16_t chan7_raw, uint16_t chan8_raw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[18];
+	char buf[MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN];
 	_mav_put_uint16_t(buf, 0, chan1_raw);
 	_mav_put_uint16_t(buf, 2, chan2_raw);
 	_mav_put_uint16_t(buf, 4, chan3_raw);
@@ -194,7 +219,11 @@ static inline void mavlink_msg_rc_channe
 	_mav_put_uint8_t(buf, 16, target_system);
 	_mav_put_uint8_t(buf, 17, target_component);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE, buf, 18, 124);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE, buf, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE, buf, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN);
+#endif
 #else
 	mavlink_rc_channels_override_t packet;
 	packet.chan1_raw = chan1_raw;
@@ -208,10 +237,64 @@ static inline void mavlink_msg_rc_channe
 	packet.target_system = target_system;
 	packet.target_component = target_component;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE, (const char *)&packet, 18, 124);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE, (const char *)&packet, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE, (const char *)&packet, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_rc_channels_override_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, uint16_t chan1_raw, uint16_t chan2_raw, uint16_t chan3_raw, uint16_t chan4_raw, uint16_t chan5_raw, uint16_t chan6_raw, uint16_t chan7_raw, uint16_t chan8_raw)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint16_t(buf, 0, chan1_raw);
+	_mav_put_uint16_t(buf, 2, chan2_raw);
+	_mav_put_uint16_t(buf, 4, chan3_raw);
+	_mav_put_uint16_t(buf, 6, chan4_raw);
+	_mav_put_uint16_t(buf, 8, chan5_raw);
+	_mav_put_uint16_t(buf, 10, chan6_raw);
+	_mav_put_uint16_t(buf, 12, chan7_raw);
+	_mav_put_uint16_t(buf, 14, chan8_raw);
+	_mav_put_uint8_t(buf, 16, target_system);
+	_mav_put_uint8_t(buf, 17, target_component);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE, buf, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE, buf, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN);
+#endif
+#else
+	mavlink_rc_channels_override_t *packet = (mavlink_rc_channels_override_t *)msgbuf;
+	packet->chan1_raw = chan1_raw;
+	packet->chan2_raw = chan2_raw;
+	packet->chan3_raw = chan3_raw;
+	packet->chan4_raw = chan4_raw;
+	packet->chan5_raw = chan5_raw;
+	packet->chan6_raw = chan6_raw;
+	packet->chan7_raw = chan7_raw;
+	packet->chan8_raw = chan8_raw;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE, (const char *)packet, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE, (const char *)packet, MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE RC_CHANNELS_OVERRIDE UNPACKING
@@ -240,7 +323,7 @@ static inline uint8_t mavlink_msg_rc_cha
 /**
  * @brief Get field chan1_raw from rc_channels_override message
  *
- * @return RC channel 1 value, in microseconds
+ * @return RC channel 1 value, in microseconds. A value of UINT16_MAX means to ignore this field.
  */
 static inline uint16_t mavlink_msg_rc_channels_override_get_chan1_raw(const mavlink_message_t* msg)
 {
@@ -250,7 +333,7 @@ static inline uint16_t mavlink_msg_rc_ch
 /**
  * @brief Get field chan2_raw from rc_channels_override message
  *
- * @return RC channel 2 value, in microseconds
+ * @return RC channel 2 value, in microseconds. A value of UINT16_MAX means to ignore this field.
  */
 static inline uint16_t mavlink_msg_rc_channels_override_get_chan2_raw(const mavlink_message_t* msg)
 {
@@ -260,7 +343,7 @@ static inline uint16_t mavlink_msg_rc_ch
 /**
  * @brief Get field chan3_raw from rc_channels_override message
  *
- * @return RC channel 3 value, in microseconds
+ * @return RC channel 3 value, in microseconds. A value of UINT16_MAX means to ignore this field.
  */
 static inline uint16_t mavlink_msg_rc_channels_override_get_chan3_raw(const mavlink_message_t* msg)
 {
@@ -270,7 +353,7 @@ static inline uint16_t mavlink_msg_rc_ch
 /**
  * @brief Get field chan4_raw from rc_channels_override message
  *
- * @return RC channel 4 value, in microseconds
+ * @return RC channel 4 value, in microseconds. A value of UINT16_MAX means to ignore this field.
  */
 static inline uint16_t mavlink_msg_rc_channels_override_get_chan4_raw(const mavlink_message_t* msg)
 {
@@ -280,7 +363,7 @@ static inline uint16_t mavlink_msg_rc_ch
 /**
  * @brief Get field chan5_raw from rc_channels_override message
  *
- * @return RC channel 5 value, in microseconds
+ * @return RC channel 5 value, in microseconds. A value of UINT16_MAX means to ignore this field.
  */
 static inline uint16_t mavlink_msg_rc_channels_override_get_chan5_raw(const mavlink_message_t* msg)
 {
@@ -290,7 +373,7 @@ static inline uint16_t mavlink_msg_rc_ch
 /**
  * @brief Get field chan6_raw from rc_channels_override message
  *
- * @return RC channel 6 value, in microseconds
+ * @return RC channel 6 value, in microseconds. A value of UINT16_MAX means to ignore this field.
  */
 static inline uint16_t mavlink_msg_rc_channels_override_get_chan6_raw(const mavlink_message_t* msg)
 {
@@ -300,7 +383,7 @@ static inline uint16_t mavlink_msg_rc_ch
 /**
  * @brief Get field chan7_raw from rc_channels_override message
  *
- * @return RC channel 7 value, in microseconds
+ * @return RC channel 7 value, in microseconds. A value of UINT16_MAX means to ignore this field.
  */
 static inline uint16_t mavlink_msg_rc_channels_override_get_chan7_raw(const mavlink_message_t* msg)
 {
@@ -310,7 +393,7 @@ static inline uint16_t mavlink_msg_rc_ch
 /**
  * @brief Get field chan8_raw from rc_channels_override message
  *
- * @return RC channel 8 value, in microseconds
+ * @return RC channel 8 value, in microseconds. A value of UINT16_MAX means to ignore this field.
  */
 static inline uint16_t mavlink_msg_rc_channels_override_get_chan8_raw(const mavlink_message_t* msg)
 {
@@ -337,6 +420,6 @@ static inline void mavlink_msg_rc_channe
 	rc_channels_override->target_system = mavlink_msg_rc_channels_override_get_target_system(msg);
 	rc_channels_override->target_component = mavlink_msg_rc_channels_override_get_target_component(msg);
 #else
-	memcpy(rc_channels_override, _MAV_PAYLOAD(msg), 18);
+	memcpy(rc_channels_override, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_rc_channels_raw.h v1.0/common/mavlink_msg_rc_channels_raw.h
--- v1.0.old/common/mavlink_msg_rc_channels_raw.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_rc_channels_raw.h	2015-02-06 11:50:58.000000000 +0500
@@ -5,21 +5,24 @@
 typedef struct __mavlink_rc_channels_raw_t
 {
  uint32_t time_boot_ms; ///< Timestamp (milliseconds since system boot)
- uint16_t chan1_raw; ///< RC channel 1 value, in microseconds
- uint16_t chan2_raw; ///< RC channel 2 value, in microseconds
- uint16_t chan3_raw; ///< RC channel 3 value, in microseconds
- uint16_t chan4_raw; ///< RC channel 4 value, in microseconds
- uint16_t chan5_raw; ///< RC channel 5 value, in microseconds
- uint16_t chan6_raw; ///< RC channel 6 value, in microseconds
- uint16_t chan7_raw; ///< RC channel 7 value, in microseconds
- uint16_t chan8_raw; ///< RC channel 8 value, in microseconds
- uint8_t port; ///< Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
- uint8_t rssi; ///< Receive signal strength indicator, 0: 0%, 255: 100%
+ uint16_t chan1_raw; ///< RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan2_raw; ///< RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan3_raw; ///< RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan4_raw; ///< RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan5_raw; ///< RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan6_raw; ///< RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan7_raw; ///< RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint16_t chan8_raw; ///< RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ uint8_t port; ///< Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
+ uint8_t rssi; ///< Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
 } mavlink_rc_channels_raw_t;
 
 #define MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN 22
 #define MAVLINK_MSG_ID_35_LEN 22
 
+#define MAVLINK_MSG_ID_RC_CHANNELS_RAW_CRC 244
+#define MAVLINK_MSG_ID_35_CRC 244
+
 
 
 #define MAVLINK_MESSAGE_INFO_RC_CHANNELS_RAW { \
@@ -47,23 +50,23 @@ typedef struct __mavlink_rc_channels_raw
  * @param msg The MAVLink message to compress the data into
  *
  * @param time_boot_ms Timestamp (milliseconds since system boot)
- * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
- * @param chan1_raw RC channel 1 value, in microseconds
- * @param chan2_raw RC channel 2 value, in microseconds
- * @param chan3_raw RC channel 3 value, in microseconds
- * @param chan4_raw RC channel 4 value, in microseconds
- * @param chan5_raw RC channel 5 value, in microseconds
- * @param chan6_raw RC channel 6 value, in microseconds
- * @param chan7_raw RC channel 7 value, in microseconds
- * @param chan8_raw RC channel 8 value, in microseconds
- * @param rssi Receive signal strength indicator, 0: 0%, 255: 100%
+ * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
+ * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan2_raw RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan3_raw RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan4_raw RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan5_raw RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan6_raw RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan7_raw RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan8_raw RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param rssi Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_rc_channels_raw_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
 						       uint32_t time_boot_ms, uint8_t port, uint16_t chan1_raw, uint16_t chan2_raw, uint16_t chan3_raw, uint16_t chan4_raw, uint16_t chan5_raw, uint16_t chan6_raw, uint16_t chan7_raw, uint16_t chan8_raw, uint8_t rssi)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[22];
+	char buf[MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_uint16_t(buf, 4, chan1_raw);
 	_mav_put_uint16_t(buf, 6, chan2_raw);
@@ -76,7 +79,7 @@ static inline uint16_t mavlink_msg_rc_ch
 	_mav_put_uint8_t(buf, 20, port);
 	_mav_put_uint8_t(buf, 21, rssi);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 22);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
 #else
 	mavlink_rc_channels_raw_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -91,30 +94,34 @@ static inline uint16_t mavlink_msg_rc_ch
 	packet.port = port;
 	packet.rssi = rssi;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 22);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_RC_CHANNELS_RAW;
-	return mavlink_finalize_message(msg, system_id, component_id, 22, 244);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN, MAVLINK_MSG_ID_RC_CHANNELS_RAW_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
+#endif
 }
 
 /**
  * @brief Pack a rc_channels_raw message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_boot_ms Timestamp (milliseconds since system boot)
- * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
- * @param chan1_raw RC channel 1 value, in microseconds
- * @param chan2_raw RC channel 2 value, in microseconds
- * @param chan3_raw RC channel 3 value, in microseconds
- * @param chan4_raw RC channel 4 value, in microseconds
- * @param chan5_raw RC channel 5 value, in microseconds
- * @param chan6_raw RC channel 6 value, in microseconds
- * @param chan7_raw RC channel 7 value, in microseconds
- * @param chan8_raw RC channel 8 value, in microseconds
- * @param rssi Receive signal strength indicator, 0: 0%, 255: 100%
+ * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
+ * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan2_raw RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan3_raw RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan4_raw RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan5_raw RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan6_raw RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan7_raw RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan8_raw RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param rssi Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_rc_channels_raw_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
@@ -122,7 +129,7 @@ static inline uint16_t mavlink_msg_rc_ch
 						           uint32_t time_boot_ms,uint8_t port,uint16_t chan1_raw,uint16_t chan2_raw,uint16_t chan3_raw,uint16_t chan4_raw,uint16_t chan5_raw,uint16_t chan6_raw,uint16_t chan7_raw,uint16_t chan8_raw,uint8_t rssi)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[22];
+	char buf[MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_uint16_t(buf, 4, chan1_raw);
 	_mav_put_uint16_t(buf, 6, chan2_raw);
@@ -135,7 +142,7 @@ static inline uint16_t mavlink_msg_rc_ch
 	_mav_put_uint8_t(buf, 20, port);
 	_mav_put_uint8_t(buf, 21, rssi);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 22);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
 #else
 	mavlink_rc_channels_raw_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -150,15 +157,19 @@ static inline uint16_t mavlink_msg_rc_ch
 	packet.port = port;
 	packet.rssi = rssi;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 22);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_RC_CHANNELS_RAW;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 22, 244);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN, MAVLINK_MSG_ID_RC_CHANNELS_RAW_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
+#endif
 }
 
 /**
- * @brief Encode a rc_channels_raw struct into a message
+ * @brief Encode a rc_channels_raw struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -171,27 +182,41 @@ static inline uint16_t mavlink_msg_rc_ch
 }
 
 /**
+ * @brief Encode a rc_channels_raw struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param rc_channels_raw C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_rc_channels_raw_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_rc_channels_raw_t* rc_channels_raw)
+{
+	return mavlink_msg_rc_channels_raw_pack_chan(system_id, component_id, chan, msg, rc_channels_raw->time_boot_ms, rc_channels_raw->port, rc_channels_raw->chan1_raw, rc_channels_raw->chan2_raw, rc_channels_raw->chan3_raw, rc_channels_raw->chan4_raw, rc_channels_raw->chan5_raw, rc_channels_raw->chan6_raw, rc_channels_raw->chan7_raw, rc_channels_raw->chan8_raw, rc_channels_raw->rssi);
+}
+
+/**
  * @brief Send a rc_channels_raw message
  * @param chan MAVLink channel to send the message
  *
  * @param time_boot_ms Timestamp (milliseconds since system boot)
- * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
- * @param chan1_raw RC channel 1 value, in microseconds
- * @param chan2_raw RC channel 2 value, in microseconds
- * @param chan3_raw RC channel 3 value, in microseconds
- * @param chan4_raw RC channel 4 value, in microseconds
- * @param chan5_raw RC channel 5 value, in microseconds
- * @param chan6_raw RC channel 6 value, in microseconds
- * @param chan7_raw RC channel 7 value, in microseconds
- * @param chan8_raw RC channel 8 value, in microseconds
- * @param rssi Receive signal strength indicator, 0: 0%, 255: 100%
+ * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
+ * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan2_raw RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan3_raw RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan4_raw RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan5_raw RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan6_raw RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan7_raw RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param chan8_raw RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
+ * @param rssi Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
  */
 #ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
 
 static inline void mavlink_msg_rc_channels_raw_send(mavlink_channel_t chan, uint32_t time_boot_ms, uint8_t port, uint16_t chan1_raw, uint16_t chan2_raw, uint16_t chan3_raw, uint16_t chan4_raw, uint16_t chan5_raw, uint16_t chan6_raw, uint16_t chan7_raw, uint16_t chan8_raw, uint8_t rssi)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[22];
+	char buf[MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_uint16_t(buf, 4, chan1_raw);
 	_mav_put_uint16_t(buf, 6, chan2_raw);
@@ -204,7 +229,11 @@ static inline void mavlink_msg_rc_channe
 	_mav_put_uint8_t(buf, 20, port);
 	_mav_put_uint8_t(buf, 21, rssi);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_RAW, buf, 22, 244);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_RAW, buf, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN, MAVLINK_MSG_ID_RC_CHANNELS_RAW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_RAW, buf, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
+#endif
 #else
 	mavlink_rc_channels_raw_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -219,9 +248,65 @@ static inline void mavlink_msg_rc_channe
 	packet.port = port;
 	packet.rssi = rssi;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_RAW, (const char *)&packet, 22, 244);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_RAW, (const char *)&packet, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN, MAVLINK_MSG_ID_RC_CHANNELS_RAW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_RAW, (const char *)&packet, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_rc_channels_raw_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, uint8_t port, uint16_t chan1_raw, uint16_t chan2_raw, uint16_t chan3_raw, uint16_t chan4_raw, uint16_t chan5_raw, uint16_t chan6_raw, uint16_t chan7_raw, uint16_t chan8_raw, uint8_t rssi)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_uint16_t(buf, 4, chan1_raw);
+	_mav_put_uint16_t(buf, 6, chan2_raw);
+	_mav_put_uint16_t(buf, 8, chan3_raw);
+	_mav_put_uint16_t(buf, 10, chan4_raw);
+	_mav_put_uint16_t(buf, 12, chan5_raw);
+	_mav_put_uint16_t(buf, 14, chan6_raw);
+	_mav_put_uint16_t(buf, 16, chan7_raw);
+	_mav_put_uint16_t(buf, 18, chan8_raw);
+	_mav_put_uint8_t(buf, 20, port);
+	_mav_put_uint8_t(buf, 21, rssi);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_RAW, buf, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN, MAVLINK_MSG_ID_RC_CHANNELS_RAW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_RAW, buf, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
+#endif
+#else
+	mavlink_rc_channels_raw_t *packet = (mavlink_rc_channels_raw_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->chan1_raw = chan1_raw;
+	packet->chan2_raw = chan2_raw;
+	packet->chan3_raw = chan3_raw;
+	packet->chan4_raw = chan4_raw;
+	packet->chan5_raw = chan5_raw;
+	packet->chan6_raw = chan6_raw;
+	packet->chan7_raw = chan7_raw;
+	packet->chan8_raw = chan8_raw;
+	packet->port = port;
+	packet->rssi = rssi;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_RAW, (const char *)packet, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN, MAVLINK_MSG_ID_RC_CHANNELS_RAW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_RAW, (const char *)packet, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -241,7 +326,7 @@ static inline uint32_t mavlink_msg_rc_ch
 /**
  * @brief Get field port from rc_channels_raw message
  *
- * @return Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
+ * @return Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
  */
 static inline uint8_t mavlink_msg_rc_channels_raw_get_port(const mavlink_message_t* msg)
 {
@@ -251,7 +336,7 @@ static inline uint8_t mavlink_msg_rc_cha
 /**
  * @brief Get field chan1_raw from rc_channels_raw message
  *
- * @return RC channel 1 value, in microseconds
+ * @return RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
  */
 static inline uint16_t mavlink_msg_rc_channels_raw_get_chan1_raw(const mavlink_message_t* msg)
 {
@@ -261,7 +346,7 @@ static inline uint16_t mavlink_msg_rc_ch
 /**
  * @brief Get field chan2_raw from rc_channels_raw message
  *
- * @return RC channel 2 value, in microseconds
+ * @return RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
  */
 static inline uint16_t mavlink_msg_rc_channels_raw_get_chan2_raw(const mavlink_message_t* msg)
 {
@@ -271,7 +356,7 @@ static inline uint16_t mavlink_msg_rc_ch
 /**
  * @brief Get field chan3_raw from rc_channels_raw message
  *
- * @return RC channel 3 value, in microseconds
+ * @return RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
  */
 static inline uint16_t mavlink_msg_rc_channels_raw_get_chan3_raw(const mavlink_message_t* msg)
 {
@@ -281,7 +366,7 @@ static inline uint16_t mavlink_msg_rc_ch
 /**
  * @brief Get field chan4_raw from rc_channels_raw message
  *
- * @return RC channel 4 value, in microseconds
+ * @return RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
  */
 static inline uint16_t mavlink_msg_rc_channels_raw_get_chan4_raw(const mavlink_message_t* msg)
 {
@@ -291,7 +376,7 @@ static inline uint16_t mavlink_msg_rc_ch
 /**
  * @brief Get field chan5_raw from rc_channels_raw message
  *
- * @return RC channel 5 value, in microseconds
+ * @return RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
  */
 static inline uint16_t mavlink_msg_rc_channels_raw_get_chan5_raw(const mavlink_message_t* msg)
 {
@@ -301,7 +386,7 @@ static inline uint16_t mavlink_msg_rc_ch
 /**
  * @brief Get field chan6_raw from rc_channels_raw message
  *
- * @return RC channel 6 value, in microseconds
+ * @return RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
  */
 static inline uint16_t mavlink_msg_rc_channels_raw_get_chan6_raw(const mavlink_message_t* msg)
 {
@@ -311,7 +396,7 @@ static inline uint16_t mavlink_msg_rc_ch
 /**
  * @brief Get field chan7_raw from rc_channels_raw message
  *
- * @return RC channel 7 value, in microseconds
+ * @return RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
  */
 static inline uint16_t mavlink_msg_rc_channels_raw_get_chan7_raw(const mavlink_message_t* msg)
 {
@@ -321,7 +406,7 @@ static inline uint16_t mavlink_msg_rc_ch
 /**
  * @brief Get field chan8_raw from rc_channels_raw message
  *
- * @return RC channel 8 value, in microseconds
+ * @return RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
  */
 static inline uint16_t mavlink_msg_rc_channels_raw_get_chan8_raw(const mavlink_message_t* msg)
 {
@@ -331,7 +416,7 @@ static inline uint16_t mavlink_msg_rc_ch
 /**
  * @brief Get field rssi from rc_channels_raw message
  *
- * @return Receive signal strength indicator, 0: 0%, 255: 100%
+ * @return Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
  */
 static inline uint8_t mavlink_msg_rc_channels_raw_get_rssi(const mavlink_message_t* msg)
 {
@@ -359,6 +444,6 @@ static inline void mavlink_msg_rc_channe
 	rc_channels_raw->port = mavlink_msg_rc_channels_raw_get_port(msg);
 	rc_channels_raw->rssi = mavlink_msg_rc_channels_raw_get_rssi(msg);
 #else
-	memcpy(rc_channels_raw, _MAV_PAYLOAD(msg), 22);
+	memcpy(rc_channels_raw, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_rc_channels_scaled.h v1.0/common/mavlink_msg_rc_channels_scaled.h
--- v1.0.old/common/mavlink_msg_rc_channels_scaled.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_rc_channels_scaled.h	2015-02-06 11:50:58.000000000 +0500
@@ -5,21 +5,24 @@
 typedef struct __mavlink_rc_channels_scaled_t
 {
  uint32_t time_boot_ms; ///< Timestamp (milliseconds since system boot)
- int16_t chan1_scaled; ///< RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- int16_t chan2_scaled; ///< RC channel 2 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- int16_t chan3_scaled; ///< RC channel 3 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- int16_t chan4_scaled; ///< RC channel 4 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- int16_t chan5_scaled; ///< RC channel 5 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- int16_t chan6_scaled; ///< RC channel 6 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- int16_t chan7_scaled; ///< RC channel 7 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- int16_t chan8_scaled; ///< RC channel 8 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- uint8_t port; ///< Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
- uint8_t rssi; ///< Receive signal strength indicator, 0: 0%, 255: 100%
+ int16_t chan1_scaled; ///< RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ int16_t chan2_scaled; ///< RC channel 2 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ int16_t chan3_scaled; ///< RC channel 3 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ int16_t chan4_scaled; ///< RC channel 4 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ int16_t chan5_scaled; ///< RC channel 5 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ int16_t chan6_scaled; ///< RC channel 6 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ int16_t chan7_scaled; ///< RC channel 7 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ int16_t chan8_scaled; ///< RC channel 8 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ uint8_t port; ///< Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
+ uint8_t rssi; ///< Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
 } mavlink_rc_channels_scaled_t;
 
 #define MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN 22
 #define MAVLINK_MSG_ID_34_LEN 22
 
+#define MAVLINK_MSG_ID_RC_CHANNELS_SCALED_CRC 237
+#define MAVLINK_MSG_ID_34_CRC 237
+
 
 
 #define MAVLINK_MESSAGE_INFO_RC_CHANNELS_SCALED { \
@@ -47,23 +50,23 @@ typedef struct __mavlink_rc_channels_sca
  * @param msg The MAVLink message to compress the data into
  *
  * @param time_boot_ms Timestamp (milliseconds since system boot)
- * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
- * @param chan1_scaled RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan2_scaled RC channel 2 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan3_scaled RC channel 3 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan4_scaled RC channel 4 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan5_scaled RC channel 5 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan6_scaled RC channel 6 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan7_scaled RC channel 7 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan8_scaled RC channel 8 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param rssi Receive signal strength indicator, 0: 0%, 255: 100%
+ * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
+ * @param chan1_scaled RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan2_scaled RC channel 2 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan3_scaled RC channel 3 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan4_scaled RC channel 4 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan5_scaled RC channel 5 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan6_scaled RC channel 6 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan7_scaled RC channel 7 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan8_scaled RC channel 8 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param rssi Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_rc_channels_scaled_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
 						       uint32_t time_boot_ms, uint8_t port, int16_t chan1_scaled, int16_t chan2_scaled, int16_t chan3_scaled, int16_t chan4_scaled, int16_t chan5_scaled, int16_t chan6_scaled, int16_t chan7_scaled, int16_t chan8_scaled, uint8_t rssi)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[22];
+	char buf[MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_int16_t(buf, 4, chan1_scaled);
 	_mav_put_int16_t(buf, 6, chan2_scaled);
@@ -76,7 +79,7 @@ static inline uint16_t mavlink_msg_rc_ch
 	_mav_put_uint8_t(buf, 20, port);
 	_mav_put_uint8_t(buf, 21, rssi);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 22);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN);
 #else
 	mavlink_rc_channels_scaled_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -91,30 +94,34 @@ static inline uint16_t mavlink_msg_rc_ch
 	packet.port = port;
 	packet.rssi = rssi;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 22);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_RC_CHANNELS_SCALED;
-	return mavlink_finalize_message(msg, system_id, component_id, 22, 237);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN);
+#endif
 }
 
 /**
  * @brief Pack a rc_channels_scaled message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_boot_ms Timestamp (milliseconds since system boot)
- * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
- * @param chan1_scaled RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan2_scaled RC channel 2 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan3_scaled RC channel 3 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan4_scaled RC channel 4 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan5_scaled RC channel 5 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan6_scaled RC channel 6 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan7_scaled RC channel 7 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan8_scaled RC channel 8 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param rssi Receive signal strength indicator, 0: 0%, 255: 100%
+ * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
+ * @param chan1_scaled RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan2_scaled RC channel 2 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan3_scaled RC channel 3 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan4_scaled RC channel 4 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan5_scaled RC channel 5 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan6_scaled RC channel 6 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan7_scaled RC channel 7 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan8_scaled RC channel 8 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param rssi Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_rc_channels_scaled_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
@@ -122,7 +129,7 @@ static inline uint16_t mavlink_msg_rc_ch
 						           uint32_t time_boot_ms,uint8_t port,int16_t chan1_scaled,int16_t chan2_scaled,int16_t chan3_scaled,int16_t chan4_scaled,int16_t chan5_scaled,int16_t chan6_scaled,int16_t chan7_scaled,int16_t chan8_scaled,uint8_t rssi)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[22];
+	char buf[MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_int16_t(buf, 4, chan1_scaled);
 	_mav_put_int16_t(buf, 6, chan2_scaled);
@@ -135,7 +142,7 @@ static inline uint16_t mavlink_msg_rc_ch
 	_mav_put_uint8_t(buf, 20, port);
 	_mav_put_uint8_t(buf, 21, rssi);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 22);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN);
 #else
 	mavlink_rc_channels_scaled_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -150,15 +157,19 @@ static inline uint16_t mavlink_msg_rc_ch
 	packet.port = port;
 	packet.rssi = rssi;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 22);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_RC_CHANNELS_SCALED;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 22, 237);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN);
+#endif
 }
 
 /**
- * @brief Encode a rc_channels_scaled struct into a message
+ * @brief Encode a rc_channels_scaled struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -171,27 +182,41 @@ static inline uint16_t mavlink_msg_rc_ch
 }
 
 /**
+ * @brief Encode a rc_channels_scaled struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param rc_channels_scaled C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_rc_channels_scaled_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_rc_channels_scaled_t* rc_channels_scaled)
+{
+	return mavlink_msg_rc_channels_scaled_pack_chan(system_id, component_id, chan, msg, rc_channels_scaled->time_boot_ms, rc_channels_scaled->port, rc_channels_scaled->chan1_scaled, rc_channels_scaled->chan2_scaled, rc_channels_scaled->chan3_scaled, rc_channels_scaled->chan4_scaled, rc_channels_scaled->chan5_scaled, rc_channels_scaled->chan6_scaled, rc_channels_scaled->chan7_scaled, rc_channels_scaled->chan8_scaled, rc_channels_scaled->rssi);
+}
+
+/**
  * @brief Send a rc_channels_scaled message
  * @param chan MAVLink channel to send the message
  *
  * @param time_boot_ms Timestamp (milliseconds since system boot)
- * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
- * @param chan1_scaled RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan2_scaled RC channel 2 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan3_scaled RC channel 3 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan4_scaled RC channel 4 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan5_scaled RC channel 5 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan6_scaled RC channel 6 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan7_scaled RC channel 7 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param chan8_scaled RC channel 8 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
- * @param rssi Receive signal strength indicator, 0: 0%, 255: 100%
+ * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
+ * @param chan1_scaled RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan2_scaled RC channel 2 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan3_scaled RC channel 3 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan4_scaled RC channel 4 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan5_scaled RC channel 5 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan6_scaled RC channel 6 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan7_scaled RC channel 7 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param chan8_scaled RC channel 8 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
+ * @param rssi Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
  */
 #ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
 
 static inline void mavlink_msg_rc_channels_scaled_send(mavlink_channel_t chan, uint32_t time_boot_ms, uint8_t port, int16_t chan1_scaled, int16_t chan2_scaled, int16_t chan3_scaled, int16_t chan4_scaled, int16_t chan5_scaled, int16_t chan6_scaled, int16_t chan7_scaled, int16_t chan8_scaled, uint8_t rssi)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[22];
+	char buf[MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_int16_t(buf, 4, chan1_scaled);
 	_mav_put_int16_t(buf, 6, chan2_scaled);
@@ -204,7 +229,11 @@ static inline void mavlink_msg_rc_channe
 	_mav_put_uint8_t(buf, 20, port);
 	_mav_put_uint8_t(buf, 21, rssi);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_SCALED, buf, 22, 237);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_SCALED, buf, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_SCALED, buf, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN);
+#endif
 #else
 	mavlink_rc_channels_scaled_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -219,9 +248,65 @@ static inline void mavlink_msg_rc_channe
 	packet.port = port;
 	packet.rssi = rssi;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_SCALED, (const char *)&packet, 22, 237);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_SCALED, (const char *)&packet, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_SCALED, (const char *)&packet, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_rc_channels_scaled_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, uint8_t port, int16_t chan1_scaled, int16_t chan2_scaled, int16_t chan3_scaled, int16_t chan4_scaled, int16_t chan5_scaled, int16_t chan6_scaled, int16_t chan7_scaled, int16_t chan8_scaled, uint8_t rssi)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_int16_t(buf, 4, chan1_scaled);
+	_mav_put_int16_t(buf, 6, chan2_scaled);
+	_mav_put_int16_t(buf, 8, chan3_scaled);
+	_mav_put_int16_t(buf, 10, chan4_scaled);
+	_mav_put_int16_t(buf, 12, chan5_scaled);
+	_mav_put_int16_t(buf, 14, chan6_scaled);
+	_mav_put_int16_t(buf, 16, chan7_scaled);
+	_mav_put_int16_t(buf, 18, chan8_scaled);
+	_mav_put_uint8_t(buf, 20, port);
+	_mav_put_uint8_t(buf, 21, rssi);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_SCALED, buf, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_SCALED, buf, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN);
+#endif
+#else
+	mavlink_rc_channels_scaled_t *packet = (mavlink_rc_channels_scaled_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->chan1_scaled = chan1_scaled;
+	packet->chan2_scaled = chan2_scaled;
+	packet->chan3_scaled = chan3_scaled;
+	packet->chan4_scaled = chan4_scaled;
+	packet->chan5_scaled = chan5_scaled;
+	packet->chan6_scaled = chan6_scaled;
+	packet->chan7_scaled = chan7_scaled;
+	packet->chan8_scaled = chan8_scaled;
+	packet->port = port;
+	packet->rssi = rssi;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_SCALED, (const char *)packet, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_RC_CHANNELS_SCALED, (const char *)packet, MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -241,7 +326,7 @@ static inline uint32_t mavlink_msg_rc_ch
 /**
  * @brief Get field port from rc_channels_scaled message
  *
- * @return Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
+ * @return Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
  */
 static inline uint8_t mavlink_msg_rc_channels_scaled_get_port(const mavlink_message_t* msg)
 {
@@ -251,7 +336,7 @@ static inline uint8_t mavlink_msg_rc_cha
 /**
  * @brief Get field chan1_scaled from rc_channels_scaled message
  *
- * @return RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
+ * @return RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
  */
 static inline int16_t mavlink_msg_rc_channels_scaled_get_chan1_scaled(const mavlink_message_t* msg)
 {
@@ -261,7 +346,7 @@ static inline int16_t mavlink_msg_rc_cha
 /**
  * @brief Get field chan2_scaled from rc_channels_scaled message
  *
- * @return RC channel 2 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
+ * @return RC channel 2 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
  */
 static inline int16_t mavlink_msg_rc_channels_scaled_get_chan2_scaled(const mavlink_message_t* msg)
 {
@@ -271,7 +356,7 @@ static inline int16_t mavlink_msg_rc_cha
 /**
  * @brief Get field chan3_scaled from rc_channels_scaled message
  *
- * @return RC channel 3 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
+ * @return RC channel 3 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
  */
 static inline int16_t mavlink_msg_rc_channels_scaled_get_chan3_scaled(const mavlink_message_t* msg)
 {
@@ -281,7 +366,7 @@ static inline int16_t mavlink_msg_rc_cha
 /**
  * @brief Get field chan4_scaled from rc_channels_scaled message
  *
- * @return RC channel 4 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
+ * @return RC channel 4 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
  */
 static inline int16_t mavlink_msg_rc_channels_scaled_get_chan4_scaled(const mavlink_message_t* msg)
 {
@@ -291,7 +376,7 @@ static inline int16_t mavlink_msg_rc_cha
 /**
  * @brief Get field chan5_scaled from rc_channels_scaled message
  *
- * @return RC channel 5 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
+ * @return RC channel 5 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
  */
 static inline int16_t mavlink_msg_rc_channels_scaled_get_chan5_scaled(const mavlink_message_t* msg)
 {
@@ -301,7 +386,7 @@ static inline int16_t mavlink_msg_rc_cha
 /**
  * @brief Get field chan6_scaled from rc_channels_scaled message
  *
- * @return RC channel 6 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
+ * @return RC channel 6 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
  */
 static inline int16_t mavlink_msg_rc_channels_scaled_get_chan6_scaled(const mavlink_message_t* msg)
 {
@@ -311,7 +396,7 @@ static inline int16_t mavlink_msg_rc_cha
 /**
  * @brief Get field chan7_scaled from rc_channels_scaled message
  *
- * @return RC channel 7 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
+ * @return RC channel 7 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
  */
 static inline int16_t mavlink_msg_rc_channels_scaled_get_chan7_scaled(const mavlink_message_t* msg)
 {
@@ -321,7 +406,7 @@ static inline int16_t mavlink_msg_rc_cha
 /**
  * @brief Get field chan8_scaled from rc_channels_scaled message
  *
- * @return RC channel 8 value scaled, (-100%) -10000, (0%) 0, (100%) 10000
+ * @return RC channel 8 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
  */
 static inline int16_t mavlink_msg_rc_channels_scaled_get_chan8_scaled(const mavlink_message_t* msg)
 {
@@ -331,7 +416,7 @@ static inline int16_t mavlink_msg_rc_cha
 /**
  * @brief Get field rssi from rc_channels_scaled message
  *
- * @return Receive signal strength indicator, 0: 0%, 255: 100%
+ * @return Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
  */
 static inline uint8_t mavlink_msg_rc_channels_scaled_get_rssi(const mavlink_message_t* msg)
 {
@@ -359,6 +444,6 @@ static inline void mavlink_msg_rc_channe
 	rc_channels_scaled->port = mavlink_msg_rc_channels_scaled_get_port(msg);
 	rc_channels_scaled->rssi = mavlink_msg_rc_channels_scaled_get_rssi(msg);
 #else
-	memcpy(rc_channels_scaled, _MAV_PAYLOAD(msg), 22);
+	memcpy(rc_channels_scaled, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_RC_CHANNELS_SCALED_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_request_data_stream.h v1.0/common/mavlink_msg_request_data_stream.h
--- v1.0.old/common/mavlink_msg_request_data_stream.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_request_data_stream.h	2015-02-06 11:50:58.000000000 +0500
@@ -14,6 +14,9 @@ typedef struct __mavlink_request_data_st
 #define MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN 6
 #define MAVLINK_MSG_ID_66_LEN 6
 
+#define MAVLINK_MSG_ID_REQUEST_DATA_STREAM_CRC 148
+#define MAVLINK_MSG_ID_66_CRC 148
+
 
 
 #define MAVLINK_MESSAGE_INFO_REQUEST_DATA_STREAM { \
@@ -45,14 +48,14 @@ static inline uint16_t mavlink_msg_reque
 						       uint8_t target_system, uint8_t target_component, uint8_t req_stream_id, uint16_t req_message_rate, uint8_t start_stop)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[6];
+	char buf[MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN];
 	_mav_put_uint16_t(buf, 0, req_message_rate);
 	_mav_put_uint8_t(buf, 2, target_system);
 	_mav_put_uint8_t(buf, 3, target_component);
 	_mav_put_uint8_t(buf, 4, req_stream_id);
 	_mav_put_uint8_t(buf, 5, start_stop);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 6);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN);
 #else
 	mavlink_request_data_stream_t packet;
 	packet.req_message_rate = req_message_rate;
@@ -61,18 +64,22 @@ static inline uint16_t mavlink_msg_reque
 	packet.req_stream_id = req_stream_id;
 	packet.start_stop = start_stop;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 6);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_REQUEST_DATA_STREAM;
-	return mavlink_finalize_message(msg, system_id, component_id, 6, 148);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN);
+#endif
 }
 
 /**
  * @brief Pack a request_data_stream message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system The target requested to send the message stream.
  * @param target_component The target requested to send the message stream.
@@ -86,14 +93,14 @@ static inline uint16_t mavlink_msg_reque
 						           uint8_t target_system,uint8_t target_component,uint8_t req_stream_id,uint16_t req_message_rate,uint8_t start_stop)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[6];
+	char buf[MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN];
 	_mav_put_uint16_t(buf, 0, req_message_rate);
 	_mav_put_uint8_t(buf, 2, target_system);
 	_mav_put_uint8_t(buf, 3, target_component);
 	_mav_put_uint8_t(buf, 4, req_stream_id);
 	_mav_put_uint8_t(buf, 5, start_stop);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 6);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN);
 #else
 	mavlink_request_data_stream_t packet;
 	packet.req_message_rate = req_message_rate;
@@ -102,15 +109,19 @@ static inline uint16_t mavlink_msg_reque
 	packet.req_stream_id = req_stream_id;
 	packet.start_stop = start_stop;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 6);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_REQUEST_DATA_STREAM;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 6, 148);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN);
+#endif
 }
 
 /**
- * @brief Encode a request_data_stream struct into a message
+ * @brief Encode a request_data_stream struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -123,6 +134,20 @@ static inline uint16_t mavlink_msg_reque
 }
 
 /**
+ * @brief Encode a request_data_stream struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param request_data_stream C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_request_data_stream_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_request_data_stream_t* request_data_stream)
+{
+	return mavlink_msg_request_data_stream_pack_chan(system_id, component_id, chan, msg, request_data_stream->target_system, request_data_stream->target_component, request_data_stream->req_stream_id, request_data_stream->req_message_rate, request_data_stream->start_stop);
+}
+
+/**
  * @brief Send a request_data_stream message
  * @param chan MAVLink channel to send the message
  *
@@ -137,14 +162,18 @@ static inline uint16_t mavlink_msg_reque
 static inline void mavlink_msg_request_data_stream_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, uint8_t req_stream_id, uint16_t req_message_rate, uint8_t start_stop)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[6];
+	char buf[MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN];
 	_mav_put_uint16_t(buf, 0, req_message_rate);
 	_mav_put_uint8_t(buf, 2, target_system);
 	_mav_put_uint8_t(buf, 3, target_component);
 	_mav_put_uint8_t(buf, 4, req_stream_id);
 	_mav_put_uint8_t(buf, 5, start_stop);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_REQUEST_DATA_STREAM, buf, 6, 148);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_REQUEST_DATA_STREAM, buf, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_REQUEST_DATA_STREAM, buf, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN);
+#endif
 #else
 	mavlink_request_data_stream_t packet;
 	packet.req_message_rate = req_message_rate;
@@ -153,9 +182,53 @@ static inline void mavlink_msg_request_d
 	packet.req_stream_id = req_stream_id;
 	packet.start_stop = start_stop;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_REQUEST_DATA_STREAM, (const char *)&packet, 6, 148);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_REQUEST_DATA_STREAM, (const char *)&packet, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_REQUEST_DATA_STREAM, (const char *)&packet, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_request_data_stream_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, uint8_t req_stream_id, uint16_t req_message_rate, uint8_t start_stop)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint16_t(buf, 0, req_message_rate);
+	_mav_put_uint8_t(buf, 2, target_system);
+	_mav_put_uint8_t(buf, 3, target_component);
+	_mav_put_uint8_t(buf, 4, req_stream_id);
+	_mav_put_uint8_t(buf, 5, start_stop);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_REQUEST_DATA_STREAM, buf, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_REQUEST_DATA_STREAM, buf, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN);
+#endif
+#else
+	mavlink_request_data_stream_t *packet = (mavlink_request_data_stream_t *)msgbuf;
+	packet->req_message_rate = req_message_rate;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+	packet->req_stream_id = req_stream_id;
+	packet->start_stop = start_stop;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_REQUEST_DATA_STREAM, (const char *)packet, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_REQUEST_DATA_STREAM, (const char *)packet, MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -227,6 +300,6 @@ static inline void mavlink_msg_request_d
 	request_data_stream->req_stream_id = mavlink_msg_request_data_stream_get_req_stream_id(msg);
 	request_data_stream->start_stop = mavlink_msg_request_data_stream_get_start_stop(msg);
 #else
-	memcpy(request_data_stream, _MAV_PAYLOAD(msg), 6);
+	memcpy(request_data_stream, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_safety_allowed_area.h v1.0/common/mavlink_msg_safety_allowed_area.h
--- v1.0.old/common/mavlink_msg_safety_allowed_area.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_safety_allowed_area.h	2015-02-06 11:50:58.000000000 +0500
@@ -16,6 +16,9 @@ typedef struct __mavlink_safety_allowed_
 #define MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN 25
 #define MAVLINK_MSG_ID_55_LEN 25
 
+#define MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_CRC 3
+#define MAVLINK_MSG_ID_55_CRC 3
+
 
 
 #define MAVLINK_MESSAGE_INFO_SAFETY_ALLOWED_AREA { \
@@ -51,7 +54,7 @@ static inline uint16_t mavlink_msg_safet
 						       uint8_t frame, float p1x, float p1y, float p1z, float p2x, float p2y, float p2z)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[25];
+	char buf[MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN];
 	_mav_put_float(buf, 0, p1x);
 	_mav_put_float(buf, 4, p1y);
 	_mav_put_float(buf, 8, p1z);
@@ -60,7 +63,7 @@ static inline uint16_t mavlink_msg_safet
 	_mav_put_float(buf, 20, p2z);
 	_mav_put_uint8_t(buf, 24, frame);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 25);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN);
 #else
 	mavlink_safety_allowed_area_t packet;
 	packet.p1x = p1x;
@@ -71,18 +74,22 @@ static inline uint16_t mavlink_msg_safet
 	packet.p2z = p2z;
 	packet.frame = frame;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 25);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA;
-	return mavlink_finalize_message(msg, system_id, component_id, 25, 3);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN);
+#endif
 }
 
 /**
  * @brief Pack a safety_allowed_area message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param frame Coordinate frame, as defined by MAV_FRAME enum in mavlink_types.h. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down.
  * @param p1x x position 1 / Latitude 1
@@ -98,7 +105,7 @@ static inline uint16_t mavlink_msg_safet
 						           uint8_t frame,float p1x,float p1y,float p1z,float p2x,float p2y,float p2z)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[25];
+	char buf[MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN];
 	_mav_put_float(buf, 0, p1x);
 	_mav_put_float(buf, 4, p1y);
 	_mav_put_float(buf, 8, p1z);
@@ -107,7 +114,7 @@ static inline uint16_t mavlink_msg_safet
 	_mav_put_float(buf, 20, p2z);
 	_mav_put_uint8_t(buf, 24, frame);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 25);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN);
 #else
 	mavlink_safety_allowed_area_t packet;
 	packet.p1x = p1x;
@@ -118,15 +125,19 @@ static inline uint16_t mavlink_msg_safet
 	packet.p2z = p2z;
 	packet.frame = frame;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 25);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 25, 3);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN);
+#endif
 }
 
 /**
- * @brief Encode a safety_allowed_area struct into a message
+ * @brief Encode a safety_allowed_area struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -139,6 +150,20 @@ static inline uint16_t mavlink_msg_safet
 }
 
 /**
+ * @brief Encode a safety_allowed_area struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param safety_allowed_area C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_safety_allowed_area_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_safety_allowed_area_t* safety_allowed_area)
+{
+	return mavlink_msg_safety_allowed_area_pack_chan(system_id, component_id, chan, msg, safety_allowed_area->frame, safety_allowed_area->p1x, safety_allowed_area->p1y, safety_allowed_area->p1z, safety_allowed_area->p2x, safety_allowed_area->p2y, safety_allowed_area->p2z);
+}
+
+/**
  * @brief Send a safety_allowed_area message
  * @param chan MAVLink channel to send the message
  *
@@ -155,7 +180,7 @@ static inline uint16_t mavlink_msg_safet
 static inline void mavlink_msg_safety_allowed_area_send(mavlink_channel_t chan, uint8_t frame, float p1x, float p1y, float p1z, float p2x, float p2y, float p2z)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[25];
+	char buf[MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN];
 	_mav_put_float(buf, 0, p1x);
 	_mav_put_float(buf, 4, p1y);
 	_mav_put_float(buf, 8, p1z);
@@ -164,7 +189,11 @@ static inline void mavlink_msg_safety_al
 	_mav_put_float(buf, 20, p2z);
 	_mav_put_uint8_t(buf, 24, frame);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA, buf, 25, 3);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA, buf, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA, buf, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN);
+#endif
 #else
 	mavlink_safety_allowed_area_t packet;
 	packet.p1x = p1x;
@@ -175,9 +204,57 @@ static inline void mavlink_msg_safety_al
 	packet.p2z = p2z;
 	packet.frame = frame;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA, (const char *)&packet, 25, 3);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA, (const char *)&packet, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA, (const char *)&packet, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_safety_allowed_area_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t frame, float p1x, float p1y, float p1z, float p2x, float p2y, float p2z)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_float(buf, 0, p1x);
+	_mav_put_float(buf, 4, p1y);
+	_mav_put_float(buf, 8, p1z);
+	_mav_put_float(buf, 12, p2x);
+	_mav_put_float(buf, 16, p2y);
+	_mav_put_float(buf, 20, p2z);
+	_mav_put_uint8_t(buf, 24, frame);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA, buf, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA, buf, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN);
+#endif
+#else
+	mavlink_safety_allowed_area_t *packet = (mavlink_safety_allowed_area_t *)msgbuf;
+	packet->p1x = p1x;
+	packet->p1y = p1y;
+	packet->p1z = p1z;
+	packet->p2x = p2x;
+	packet->p2y = p2y;
+	packet->p2z = p2z;
+	packet->frame = frame;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA, (const char *)packet, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA, (const char *)packet, MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -271,6 +348,6 @@ static inline void mavlink_msg_safety_al
 	safety_allowed_area->p2z = mavlink_msg_safety_allowed_area_get_p2z(msg);
 	safety_allowed_area->frame = mavlink_msg_safety_allowed_area_get_frame(msg);
 #else
-	memcpy(safety_allowed_area, _MAV_PAYLOAD(msg), 25);
+	memcpy(safety_allowed_area, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_safety_set_allowed_area.h v1.0/common/mavlink_msg_safety_set_allowed_area.h
--- v1.0.old/common/mavlink_msg_safety_set_allowed_area.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_safety_set_allowed_area.h	2015-02-06 11:50:58.000000000 +0500
@@ -18,6 +18,9 @@ typedef struct __mavlink_safety_set_allo
 #define MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN 27
 #define MAVLINK_MSG_ID_54_LEN 27
 
+#define MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_CRC 15
+#define MAVLINK_MSG_ID_54_CRC 15
+
 
 
 #define MAVLINK_MESSAGE_INFO_SAFETY_SET_ALLOWED_AREA { \
@@ -57,7 +60,7 @@ static inline uint16_t mavlink_msg_safet
 						       uint8_t target_system, uint8_t target_component, uint8_t frame, float p1x, float p1y, float p1z, float p2x, float p2y, float p2z)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[27];
+	char buf[MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN];
 	_mav_put_float(buf, 0, p1x);
 	_mav_put_float(buf, 4, p1y);
 	_mav_put_float(buf, 8, p1z);
@@ -68,7 +71,7 @@ static inline uint16_t mavlink_msg_safet
 	_mav_put_uint8_t(buf, 25, target_component);
 	_mav_put_uint8_t(buf, 26, frame);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 27);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN);
 #else
 	mavlink_safety_set_allowed_area_t packet;
 	packet.p1x = p1x;
@@ -81,18 +84,22 @@ static inline uint16_t mavlink_msg_safet
 	packet.target_component = target_component;
 	packet.frame = frame;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 27);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA;
-	return mavlink_finalize_message(msg, system_id, component_id, 27, 15);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN);
+#endif
 }
 
 /**
  * @brief Pack a safety_set_allowed_area message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system System ID
  * @param target_component Component ID
@@ -110,7 +117,7 @@ static inline uint16_t mavlink_msg_safet
 						           uint8_t target_system,uint8_t target_component,uint8_t frame,float p1x,float p1y,float p1z,float p2x,float p2y,float p2z)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[27];
+	char buf[MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN];
 	_mav_put_float(buf, 0, p1x);
 	_mav_put_float(buf, 4, p1y);
 	_mav_put_float(buf, 8, p1z);
@@ -121,7 +128,7 @@ static inline uint16_t mavlink_msg_safet
 	_mav_put_uint8_t(buf, 25, target_component);
 	_mav_put_uint8_t(buf, 26, frame);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 27);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN);
 #else
 	mavlink_safety_set_allowed_area_t packet;
 	packet.p1x = p1x;
@@ -134,15 +141,19 @@ static inline uint16_t mavlink_msg_safet
 	packet.target_component = target_component;
 	packet.frame = frame;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 27);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 27, 15);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN);
+#endif
 }
 
 /**
- * @brief Encode a safety_set_allowed_area struct into a message
+ * @brief Encode a safety_set_allowed_area struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -155,6 +166,20 @@ static inline uint16_t mavlink_msg_safet
 }
 
 /**
+ * @brief Encode a safety_set_allowed_area struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param safety_set_allowed_area C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_safety_set_allowed_area_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_safety_set_allowed_area_t* safety_set_allowed_area)
+{
+	return mavlink_msg_safety_set_allowed_area_pack_chan(system_id, component_id, chan, msg, safety_set_allowed_area->target_system, safety_set_allowed_area->target_component, safety_set_allowed_area->frame, safety_set_allowed_area->p1x, safety_set_allowed_area->p1y, safety_set_allowed_area->p1z, safety_set_allowed_area->p2x, safety_set_allowed_area->p2y, safety_set_allowed_area->p2z);
+}
+
+/**
  * @brief Send a safety_set_allowed_area message
  * @param chan MAVLink channel to send the message
  *
@@ -173,7 +198,7 @@ static inline uint16_t mavlink_msg_safet
 static inline void mavlink_msg_safety_set_allowed_area_send(mavlink_channel_t chan, uint8_t target_system, uint8_t target_component, uint8_t frame, float p1x, float p1y, float p1z, float p2x, float p2y, float p2z)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[27];
+	char buf[MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN];
 	_mav_put_float(buf, 0, p1x);
 	_mav_put_float(buf, 4, p1y);
 	_mav_put_float(buf, 8, p1z);
@@ -184,7 +209,11 @@ static inline void mavlink_msg_safety_se
 	_mav_put_uint8_t(buf, 25, target_component);
 	_mav_put_uint8_t(buf, 26, frame);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA, buf, 27, 15);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA, buf, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA, buf, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN);
+#endif
 #else
 	mavlink_safety_set_allowed_area_t packet;
 	packet.p1x = p1x;
@@ -197,9 +226,61 @@ static inline void mavlink_msg_safety_se
 	packet.target_component = target_component;
 	packet.frame = frame;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA, (const char *)&packet, 27, 15);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA, (const char *)&packet, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA, (const char *)&packet, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_safety_set_allowed_area_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t target_component, uint8_t frame, float p1x, float p1y, float p1z, float p2x, float p2y, float p2z)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_float(buf, 0, p1x);
+	_mav_put_float(buf, 4, p1y);
+	_mav_put_float(buf, 8, p1z);
+	_mav_put_float(buf, 12, p2x);
+	_mav_put_float(buf, 16, p2y);
+	_mav_put_float(buf, 20, p2z);
+	_mav_put_uint8_t(buf, 24, target_system);
+	_mav_put_uint8_t(buf, 25, target_component);
+	_mav_put_uint8_t(buf, 26, frame);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA, buf, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA, buf, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN);
+#endif
+#else
+	mavlink_safety_set_allowed_area_t *packet = (mavlink_safety_set_allowed_area_t *)msgbuf;
+	packet->p1x = p1x;
+	packet->p1y = p1y;
+	packet->p1z = p1z;
+	packet->p2x = p2x;
+	packet->p2y = p2y;
+	packet->p2z = p2z;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+	packet->frame = frame;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA, (const char *)packet, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA, (const char *)packet, MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -315,6 +396,6 @@ static inline void mavlink_msg_safety_se
 	safety_set_allowed_area->target_component = mavlink_msg_safety_set_allowed_area_get_target_component(msg);
 	safety_set_allowed_area->frame = mavlink_msg_safety_set_allowed_area_get_frame(msg);
 #else
-	memcpy(safety_set_allowed_area, _MAV_PAYLOAD(msg), 27);
+	memcpy(safety_set_allowed_area, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_scaled_imu2.h v1.0/common/mavlink_msg_scaled_imu2.h
--- v1.0.old/common/mavlink_msg_scaled_imu2.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_scaled_imu2.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,425 @@
+// MESSAGE SCALED_IMU2 PACKING
+
+#define MAVLINK_MSG_ID_SCALED_IMU2 116
+
+typedef struct __mavlink_scaled_imu2_t
+{
+ uint32_t time_boot_ms; ///< Timestamp (milliseconds since system boot)
+ int16_t xacc; ///< X acceleration (mg)
+ int16_t yacc; ///< Y acceleration (mg)
+ int16_t zacc; ///< Z acceleration (mg)
+ int16_t xgyro; ///< Angular speed around X axis (millirad /sec)
+ int16_t ygyro; ///< Angular speed around Y axis (millirad /sec)
+ int16_t zgyro; ///< Angular speed around Z axis (millirad /sec)
+ int16_t xmag; ///< X Magnetic field (milli tesla)
+ int16_t ymag; ///< Y Magnetic field (milli tesla)
+ int16_t zmag; ///< Z Magnetic field (milli tesla)
+} mavlink_scaled_imu2_t;
+
+#define MAVLINK_MSG_ID_SCALED_IMU2_LEN 22
+#define MAVLINK_MSG_ID_116_LEN 22
+
+#define MAVLINK_MSG_ID_SCALED_IMU2_CRC 76
+#define MAVLINK_MSG_ID_116_CRC 76
+
+
+
+#define MAVLINK_MESSAGE_INFO_SCALED_IMU2 { \
+	"SCALED_IMU2", \
+	10, \
+	{  { "time_boot_ms", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_scaled_imu2_t, time_boot_ms) }, \
+         { "xacc", NULL, MAVLINK_TYPE_INT16_T, 0, 4, offsetof(mavlink_scaled_imu2_t, xacc) }, \
+         { "yacc", NULL, MAVLINK_TYPE_INT16_T, 0, 6, offsetof(mavlink_scaled_imu2_t, yacc) }, \
+         { "zacc", NULL, MAVLINK_TYPE_INT16_T, 0, 8, offsetof(mavlink_scaled_imu2_t, zacc) }, \
+         { "xgyro", NULL, MAVLINK_TYPE_INT16_T, 0, 10, offsetof(mavlink_scaled_imu2_t, xgyro) }, \
+         { "ygyro", NULL, MAVLINK_TYPE_INT16_T, 0, 12, offsetof(mavlink_scaled_imu2_t, ygyro) }, \
+         { "zgyro", NULL, MAVLINK_TYPE_INT16_T, 0, 14, offsetof(mavlink_scaled_imu2_t, zgyro) }, \
+         { "xmag", NULL, MAVLINK_TYPE_INT16_T, 0, 16, offsetof(mavlink_scaled_imu2_t, xmag) }, \
+         { "ymag", NULL, MAVLINK_TYPE_INT16_T, 0, 18, offsetof(mavlink_scaled_imu2_t, ymag) }, \
+         { "zmag", NULL, MAVLINK_TYPE_INT16_T, 0, 20, offsetof(mavlink_scaled_imu2_t, zmag) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a scaled_imu2 message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param xacc X acceleration (mg)
+ * @param yacc Y acceleration (mg)
+ * @param zacc Z acceleration (mg)
+ * @param xgyro Angular speed around X axis (millirad /sec)
+ * @param ygyro Angular speed around Y axis (millirad /sec)
+ * @param zgyro Angular speed around Z axis (millirad /sec)
+ * @param xmag X Magnetic field (milli tesla)
+ * @param ymag Y Magnetic field (milli tesla)
+ * @param zmag Z Magnetic field (milli tesla)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_scaled_imu2_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint32_t time_boot_ms, int16_t xacc, int16_t yacc, int16_t zacc, int16_t xgyro, int16_t ygyro, int16_t zgyro, int16_t xmag, int16_t ymag, int16_t zmag)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SCALED_IMU2_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_int16_t(buf, 4, xacc);
+	_mav_put_int16_t(buf, 6, yacc);
+	_mav_put_int16_t(buf, 8, zacc);
+	_mav_put_int16_t(buf, 10, xgyro);
+	_mav_put_int16_t(buf, 12, ygyro);
+	_mav_put_int16_t(buf, 14, zgyro);
+	_mav_put_int16_t(buf, 16, xmag);
+	_mav_put_int16_t(buf, 18, ymag);
+	_mav_put_int16_t(buf, 20, zmag);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SCALED_IMU2_LEN);
+#else
+	mavlink_scaled_imu2_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.xacc = xacc;
+	packet.yacc = yacc;
+	packet.zacc = zacc;
+	packet.xgyro = xgyro;
+	packet.ygyro = ygyro;
+	packet.zgyro = zgyro;
+	packet.xmag = xmag;
+	packet.ymag = ymag;
+	packet.zmag = zmag;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SCALED_IMU2_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_SCALED_IMU2;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SCALED_IMU2_LEN, MAVLINK_MSG_ID_SCALED_IMU2_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SCALED_IMU2_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a scaled_imu2 message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param xacc X acceleration (mg)
+ * @param yacc Y acceleration (mg)
+ * @param zacc Z acceleration (mg)
+ * @param xgyro Angular speed around X axis (millirad /sec)
+ * @param ygyro Angular speed around Y axis (millirad /sec)
+ * @param zgyro Angular speed around Z axis (millirad /sec)
+ * @param xmag X Magnetic field (milli tesla)
+ * @param ymag Y Magnetic field (milli tesla)
+ * @param zmag Z Magnetic field (milli tesla)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_scaled_imu2_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint32_t time_boot_ms,int16_t xacc,int16_t yacc,int16_t zacc,int16_t xgyro,int16_t ygyro,int16_t zgyro,int16_t xmag,int16_t ymag,int16_t zmag)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SCALED_IMU2_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_int16_t(buf, 4, xacc);
+	_mav_put_int16_t(buf, 6, yacc);
+	_mav_put_int16_t(buf, 8, zacc);
+	_mav_put_int16_t(buf, 10, xgyro);
+	_mav_put_int16_t(buf, 12, ygyro);
+	_mav_put_int16_t(buf, 14, zgyro);
+	_mav_put_int16_t(buf, 16, xmag);
+	_mav_put_int16_t(buf, 18, ymag);
+	_mav_put_int16_t(buf, 20, zmag);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SCALED_IMU2_LEN);
+#else
+	mavlink_scaled_imu2_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.xacc = xacc;
+	packet.yacc = yacc;
+	packet.zacc = zacc;
+	packet.xgyro = xgyro;
+	packet.ygyro = ygyro;
+	packet.zgyro = zgyro;
+	packet.xmag = xmag;
+	packet.ymag = ymag;
+	packet.zmag = zmag;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SCALED_IMU2_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_SCALED_IMU2;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SCALED_IMU2_LEN, MAVLINK_MSG_ID_SCALED_IMU2_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SCALED_IMU2_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a scaled_imu2 struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param scaled_imu2 C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_scaled_imu2_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_scaled_imu2_t* scaled_imu2)
+{
+	return mavlink_msg_scaled_imu2_pack(system_id, component_id, msg, scaled_imu2->time_boot_ms, scaled_imu2->xacc, scaled_imu2->yacc, scaled_imu2->zacc, scaled_imu2->xgyro, scaled_imu2->ygyro, scaled_imu2->zgyro, scaled_imu2->xmag, scaled_imu2->ymag, scaled_imu2->zmag);
+}
+
+/**
+ * @brief Encode a scaled_imu2 struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param scaled_imu2 C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_scaled_imu2_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_scaled_imu2_t* scaled_imu2)
+{
+	return mavlink_msg_scaled_imu2_pack_chan(system_id, component_id, chan, msg, scaled_imu2->time_boot_ms, scaled_imu2->xacc, scaled_imu2->yacc, scaled_imu2->zacc, scaled_imu2->xgyro, scaled_imu2->ygyro, scaled_imu2->zgyro, scaled_imu2->xmag, scaled_imu2->ymag, scaled_imu2->zmag);
+}
+
+/**
+ * @brief Send a scaled_imu2 message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param xacc X acceleration (mg)
+ * @param yacc Y acceleration (mg)
+ * @param zacc Z acceleration (mg)
+ * @param xgyro Angular speed around X axis (millirad /sec)
+ * @param ygyro Angular speed around Y axis (millirad /sec)
+ * @param zgyro Angular speed around Z axis (millirad /sec)
+ * @param xmag X Magnetic field (milli tesla)
+ * @param ymag Y Magnetic field (milli tesla)
+ * @param zmag Z Magnetic field (milli tesla)
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_scaled_imu2_send(mavlink_channel_t chan, uint32_t time_boot_ms, int16_t xacc, int16_t yacc, int16_t zacc, int16_t xgyro, int16_t ygyro, int16_t zgyro, int16_t xmag, int16_t ymag, int16_t zmag)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SCALED_IMU2_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_int16_t(buf, 4, xacc);
+	_mav_put_int16_t(buf, 6, yacc);
+	_mav_put_int16_t(buf, 8, zacc);
+	_mav_put_int16_t(buf, 10, xgyro);
+	_mav_put_int16_t(buf, 12, ygyro);
+	_mav_put_int16_t(buf, 14, zgyro);
+	_mav_put_int16_t(buf, 16, xmag);
+	_mav_put_int16_t(buf, 18, ymag);
+	_mav_put_int16_t(buf, 20, zmag);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU2, buf, MAVLINK_MSG_ID_SCALED_IMU2_LEN, MAVLINK_MSG_ID_SCALED_IMU2_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU2, buf, MAVLINK_MSG_ID_SCALED_IMU2_LEN);
+#endif
+#else
+	mavlink_scaled_imu2_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.xacc = xacc;
+	packet.yacc = yacc;
+	packet.zacc = zacc;
+	packet.xgyro = xgyro;
+	packet.ygyro = ygyro;
+	packet.zgyro = zgyro;
+	packet.xmag = xmag;
+	packet.ymag = ymag;
+	packet.zmag = zmag;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU2, (const char *)&packet, MAVLINK_MSG_ID_SCALED_IMU2_LEN, MAVLINK_MSG_ID_SCALED_IMU2_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU2, (const char *)&packet, MAVLINK_MSG_ID_SCALED_IMU2_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_SCALED_IMU2_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_scaled_imu2_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, int16_t xacc, int16_t yacc, int16_t zacc, int16_t xgyro, int16_t ygyro, int16_t zgyro, int16_t xmag, int16_t ymag, int16_t zmag)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_int16_t(buf, 4, xacc);
+	_mav_put_int16_t(buf, 6, yacc);
+	_mav_put_int16_t(buf, 8, zacc);
+	_mav_put_int16_t(buf, 10, xgyro);
+	_mav_put_int16_t(buf, 12, ygyro);
+	_mav_put_int16_t(buf, 14, zgyro);
+	_mav_put_int16_t(buf, 16, xmag);
+	_mav_put_int16_t(buf, 18, ymag);
+	_mav_put_int16_t(buf, 20, zmag);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU2, buf, MAVLINK_MSG_ID_SCALED_IMU2_LEN, MAVLINK_MSG_ID_SCALED_IMU2_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU2, buf, MAVLINK_MSG_ID_SCALED_IMU2_LEN);
+#endif
+#else
+	mavlink_scaled_imu2_t *packet = (mavlink_scaled_imu2_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->xacc = xacc;
+	packet->yacc = yacc;
+	packet->zacc = zacc;
+	packet->xgyro = xgyro;
+	packet->ygyro = ygyro;
+	packet->zgyro = zgyro;
+	packet->xmag = xmag;
+	packet->ymag = ymag;
+	packet->zmag = zmag;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU2, (const char *)packet, MAVLINK_MSG_ID_SCALED_IMU2_LEN, MAVLINK_MSG_ID_SCALED_IMU2_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU2, (const char *)packet, MAVLINK_MSG_ID_SCALED_IMU2_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE SCALED_IMU2 UNPACKING
+
+
+/**
+ * @brief Get field time_boot_ms from scaled_imu2 message
+ *
+ * @return Timestamp (milliseconds since system boot)
+ */
+static inline uint32_t mavlink_msg_scaled_imu2_get_time_boot_ms(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field xacc from scaled_imu2 message
+ *
+ * @return X acceleration (mg)
+ */
+static inline int16_t mavlink_msg_scaled_imu2_get_xacc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  4);
+}
+
+/**
+ * @brief Get field yacc from scaled_imu2 message
+ *
+ * @return Y acceleration (mg)
+ */
+static inline int16_t mavlink_msg_scaled_imu2_get_yacc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  6);
+}
+
+/**
+ * @brief Get field zacc from scaled_imu2 message
+ *
+ * @return Z acceleration (mg)
+ */
+static inline int16_t mavlink_msg_scaled_imu2_get_zacc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  8);
+}
+
+/**
+ * @brief Get field xgyro from scaled_imu2 message
+ *
+ * @return Angular speed around X axis (millirad /sec)
+ */
+static inline int16_t mavlink_msg_scaled_imu2_get_xgyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  10);
+}
+
+/**
+ * @brief Get field ygyro from scaled_imu2 message
+ *
+ * @return Angular speed around Y axis (millirad /sec)
+ */
+static inline int16_t mavlink_msg_scaled_imu2_get_ygyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  12);
+}
+
+/**
+ * @brief Get field zgyro from scaled_imu2 message
+ *
+ * @return Angular speed around Z axis (millirad /sec)
+ */
+static inline int16_t mavlink_msg_scaled_imu2_get_zgyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  14);
+}
+
+/**
+ * @brief Get field xmag from scaled_imu2 message
+ *
+ * @return X Magnetic field (milli tesla)
+ */
+static inline int16_t mavlink_msg_scaled_imu2_get_xmag(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  16);
+}
+
+/**
+ * @brief Get field ymag from scaled_imu2 message
+ *
+ * @return Y Magnetic field (milli tesla)
+ */
+static inline int16_t mavlink_msg_scaled_imu2_get_ymag(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  18);
+}
+
+/**
+ * @brief Get field zmag from scaled_imu2 message
+ *
+ * @return Z Magnetic field (milli tesla)
+ */
+static inline int16_t mavlink_msg_scaled_imu2_get_zmag(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  20);
+}
+
+/**
+ * @brief Decode a scaled_imu2 message into a struct
+ *
+ * @param msg The message to decode
+ * @param scaled_imu2 C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_scaled_imu2_decode(const mavlink_message_t* msg, mavlink_scaled_imu2_t* scaled_imu2)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	scaled_imu2->time_boot_ms = mavlink_msg_scaled_imu2_get_time_boot_ms(msg);
+	scaled_imu2->xacc = mavlink_msg_scaled_imu2_get_xacc(msg);
+	scaled_imu2->yacc = mavlink_msg_scaled_imu2_get_yacc(msg);
+	scaled_imu2->zacc = mavlink_msg_scaled_imu2_get_zacc(msg);
+	scaled_imu2->xgyro = mavlink_msg_scaled_imu2_get_xgyro(msg);
+	scaled_imu2->ygyro = mavlink_msg_scaled_imu2_get_ygyro(msg);
+	scaled_imu2->zgyro = mavlink_msg_scaled_imu2_get_zgyro(msg);
+	scaled_imu2->xmag = mavlink_msg_scaled_imu2_get_xmag(msg);
+	scaled_imu2->ymag = mavlink_msg_scaled_imu2_get_ymag(msg);
+	scaled_imu2->zmag = mavlink_msg_scaled_imu2_get_zmag(msg);
+#else
+	memcpy(scaled_imu2, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SCALED_IMU2_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_scaled_imu.h v1.0/common/mavlink_msg_scaled_imu.h
--- v1.0.old/common/mavlink_msg_scaled_imu.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_scaled_imu.h	2015-02-06 11:50:58.000000000 +0500
@@ -19,6 +19,9 @@ typedef struct __mavlink_scaled_imu_t
 #define MAVLINK_MSG_ID_SCALED_IMU_LEN 22
 #define MAVLINK_MSG_ID_26_LEN 22
 
+#define MAVLINK_MSG_ID_SCALED_IMU_CRC 170
+#define MAVLINK_MSG_ID_26_CRC 170
+
 
 
 #define MAVLINK_MESSAGE_INFO_SCALED_IMU { \
@@ -60,7 +63,7 @@ static inline uint16_t mavlink_msg_scale
 						       uint32_t time_boot_ms, int16_t xacc, int16_t yacc, int16_t zacc, int16_t xgyro, int16_t ygyro, int16_t zgyro, int16_t xmag, int16_t ymag, int16_t zmag)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[22];
+	char buf[MAVLINK_MSG_ID_SCALED_IMU_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_int16_t(buf, 4, xacc);
 	_mav_put_int16_t(buf, 6, yacc);
@@ -72,7 +75,7 @@ static inline uint16_t mavlink_msg_scale
 	_mav_put_int16_t(buf, 18, ymag);
 	_mav_put_int16_t(buf, 20, zmag);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 22);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SCALED_IMU_LEN);
 #else
 	mavlink_scaled_imu_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -86,18 +89,22 @@ static inline uint16_t mavlink_msg_scale
 	packet.ymag = ymag;
 	packet.zmag = zmag;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 22);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SCALED_IMU_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SCALED_IMU;
-	return mavlink_finalize_message(msg, system_id, component_id, 22, 170);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SCALED_IMU_LEN, MAVLINK_MSG_ID_SCALED_IMU_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SCALED_IMU_LEN);
+#endif
 }
 
 /**
  * @brief Pack a scaled_imu message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_boot_ms Timestamp (milliseconds since system boot)
  * @param xacc X acceleration (mg)
@@ -116,7 +123,7 @@ static inline uint16_t mavlink_msg_scale
 						           uint32_t time_boot_ms,int16_t xacc,int16_t yacc,int16_t zacc,int16_t xgyro,int16_t ygyro,int16_t zgyro,int16_t xmag,int16_t ymag,int16_t zmag)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[22];
+	char buf[MAVLINK_MSG_ID_SCALED_IMU_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_int16_t(buf, 4, xacc);
 	_mav_put_int16_t(buf, 6, yacc);
@@ -128,7 +135,7 @@ static inline uint16_t mavlink_msg_scale
 	_mav_put_int16_t(buf, 18, ymag);
 	_mav_put_int16_t(buf, 20, zmag);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 22);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SCALED_IMU_LEN);
 #else
 	mavlink_scaled_imu_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -142,15 +149,19 @@ static inline uint16_t mavlink_msg_scale
 	packet.ymag = ymag;
 	packet.zmag = zmag;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 22);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SCALED_IMU_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SCALED_IMU;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 22, 170);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SCALED_IMU_LEN, MAVLINK_MSG_ID_SCALED_IMU_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SCALED_IMU_LEN);
+#endif
 }
 
 /**
- * @brief Encode a scaled_imu struct into a message
+ * @brief Encode a scaled_imu struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -163,6 +174,20 @@ static inline uint16_t mavlink_msg_scale
 }
 
 /**
+ * @brief Encode a scaled_imu struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param scaled_imu C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_scaled_imu_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_scaled_imu_t* scaled_imu)
+{
+	return mavlink_msg_scaled_imu_pack_chan(system_id, component_id, chan, msg, scaled_imu->time_boot_ms, scaled_imu->xacc, scaled_imu->yacc, scaled_imu->zacc, scaled_imu->xgyro, scaled_imu->ygyro, scaled_imu->zgyro, scaled_imu->xmag, scaled_imu->ymag, scaled_imu->zmag);
+}
+
+/**
  * @brief Send a scaled_imu message
  * @param chan MAVLink channel to send the message
  *
@@ -182,7 +207,7 @@ static inline uint16_t mavlink_msg_scale
 static inline void mavlink_msg_scaled_imu_send(mavlink_channel_t chan, uint32_t time_boot_ms, int16_t xacc, int16_t yacc, int16_t zacc, int16_t xgyro, int16_t ygyro, int16_t zgyro, int16_t xmag, int16_t ymag, int16_t zmag)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[22];
+	char buf[MAVLINK_MSG_ID_SCALED_IMU_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_int16_t(buf, 4, xacc);
 	_mav_put_int16_t(buf, 6, yacc);
@@ -194,7 +219,11 @@ static inline void mavlink_msg_scaled_im
 	_mav_put_int16_t(buf, 18, ymag);
 	_mav_put_int16_t(buf, 20, zmag);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU, buf, 22, 170);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU, buf, MAVLINK_MSG_ID_SCALED_IMU_LEN, MAVLINK_MSG_ID_SCALED_IMU_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU, buf, MAVLINK_MSG_ID_SCALED_IMU_LEN);
+#endif
 #else
 	mavlink_scaled_imu_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -208,10 +237,64 @@ static inline void mavlink_msg_scaled_im
 	packet.ymag = ymag;
 	packet.zmag = zmag;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU, (const char *)&packet, 22, 170);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU, (const char *)&packet, MAVLINK_MSG_ID_SCALED_IMU_LEN, MAVLINK_MSG_ID_SCALED_IMU_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU, (const char *)&packet, MAVLINK_MSG_ID_SCALED_IMU_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_SCALED_IMU_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_scaled_imu_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, int16_t xacc, int16_t yacc, int16_t zacc, int16_t xgyro, int16_t ygyro, int16_t zgyro, int16_t xmag, int16_t ymag, int16_t zmag)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_int16_t(buf, 4, xacc);
+	_mav_put_int16_t(buf, 6, yacc);
+	_mav_put_int16_t(buf, 8, zacc);
+	_mav_put_int16_t(buf, 10, xgyro);
+	_mav_put_int16_t(buf, 12, ygyro);
+	_mav_put_int16_t(buf, 14, zgyro);
+	_mav_put_int16_t(buf, 16, xmag);
+	_mav_put_int16_t(buf, 18, ymag);
+	_mav_put_int16_t(buf, 20, zmag);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU, buf, MAVLINK_MSG_ID_SCALED_IMU_LEN, MAVLINK_MSG_ID_SCALED_IMU_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU, buf, MAVLINK_MSG_ID_SCALED_IMU_LEN);
+#endif
+#else
+	mavlink_scaled_imu_t *packet = (mavlink_scaled_imu_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->xacc = xacc;
+	packet->yacc = yacc;
+	packet->zacc = zacc;
+	packet->xgyro = xgyro;
+	packet->ygyro = ygyro;
+	packet->zgyro = zgyro;
+	packet->xmag = xmag;
+	packet->ymag = ymag;
+	packet->zmag = zmag;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU, (const char *)packet, MAVLINK_MSG_ID_SCALED_IMU_LEN, MAVLINK_MSG_ID_SCALED_IMU_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_IMU, (const char *)packet, MAVLINK_MSG_ID_SCALED_IMU_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE SCALED_IMU UNPACKING
@@ -337,6 +420,6 @@ static inline void mavlink_msg_scaled_im
 	scaled_imu->ymag = mavlink_msg_scaled_imu_get_ymag(msg);
 	scaled_imu->zmag = mavlink_msg_scaled_imu_get_zmag(msg);
 #else
-	memcpy(scaled_imu, _MAV_PAYLOAD(msg), 22);
+	memcpy(scaled_imu, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SCALED_IMU_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_scaled_pressure2.h v1.0/common/mavlink_msg_scaled_pressure2.h
--- v1.0.old/common/mavlink_msg_scaled_pressure2.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_scaled_pressure2.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,281 @@
+// MESSAGE SCALED_PRESSURE2 PACKING
+
+#define MAVLINK_MSG_ID_SCALED_PRESSURE2 137
+
+typedef struct __mavlink_scaled_pressure2_t
+{
+ uint32_t time_boot_ms; ///< Timestamp (milliseconds since system boot)
+ float press_abs; ///< Absolute pressure (hectopascal)
+ float press_diff; ///< Differential pressure 1 (hectopascal)
+ int16_t temperature; ///< Temperature measurement (0.01 degrees celsius)
+} mavlink_scaled_pressure2_t;
+
+#define MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN 14
+#define MAVLINK_MSG_ID_137_LEN 14
+
+#define MAVLINK_MSG_ID_SCALED_PRESSURE2_CRC 195
+#define MAVLINK_MSG_ID_137_CRC 195
+
+
+
+#define MAVLINK_MESSAGE_INFO_SCALED_PRESSURE2 { \
+	"SCALED_PRESSURE2", \
+	4, \
+	{  { "time_boot_ms", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_scaled_pressure2_t, time_boot_ms) }, \
+         { "press_abs", NULL, MAVLINK_TYPE_FLOAT, 0, 4, offsetof(mavlink_scaled_pressure2_t, press_abs) }, \
+         { "press_diff", NULL, MAVLINK_TYPE_FLOAT, 0, 8, offsetof(mavlink_scaled_pressure2_t, press_diff) }, \
+         { "temperature", NULL, MAVLINK_TYPE_INT16_T, 0, 12, offsetof(mavlink_scaled_pressure2_t, temperature) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a scaled_pressure2 message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param press_abs Absolute pressure (hectopascal)
+ * @param press_diff Differential pressure 1 (hectopascal)
+ * @param temperature Temperature measurement (0.01 degrees celsius)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_scaled_pressure2_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint32_t time_boot_ms, float press_abs, float press_diff, int16_t temperature)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, press_abs);
+	_mav_put_float(buf, 8, press_diff);
+	_mav_put_int16_t(buf, 12, temperature);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN);
+#else
+	mavlink_scaled_pressure2_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.press_abs = press_abs;
+	packet.press_diff = press_diff;
+	packet.temperature = temperature;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_SCALED_PRESSURE2;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN, MAVLINK_MSG_ID_SCALED_PRESSURE2_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a scaled_pressure2 message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param press_abs Absolute pressure (hectopascal)
+ * @param press_diff Differential pressure 1 (hectopascal)
+ * @param temperature Temperature measurement (0.01 degrees celsius)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_scaled_pressure2_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint32_t time_boot_ms,float press_abs,float press_diff,int16_t temperature)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, press_abs);
+	_mav_put_float(buf, 8, press_diff);
+	_mav_put_int16_t(buf, 12, temperature);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN);
+#else
+	mavlink_scaled_pressure2_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.press_abs = press_abs;
+	packet.press_diff = press_diff;
+	packet.temperature = temperature;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_SCALED_PRESSURE2;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN, MAVLINK_MSG_ID_SCALED_PRESSURE2_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a scaled_pressure2 struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param scaled_pressure2 C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_scaled_pressure2_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_scaled_pressure2_t* scaled_pressure2)
+{
+	return mavlink_msg_scaled_pressure2_pack(system_id, component_id, msg, scaled_pressure2->time_boot_ms, scaled_pressure2->press_abs, scaled_pressure2->press_diff, scaled_pressure2->temperature);
+}
+
+/**
+ * @brief Encode a scaled_pressure2 struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param scaled_pressure2 C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_scaled_pressure2_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_scaled_pressure2_t* scaled_pressure2)
+{
+	return mavlink_msg_scaled_pressure2_pack_chan(system_id, component_id, chan, msg, scaled_pressure2->time_boot_ms, scaled_pressure2->press_abs, scaled_pressure2->press_diff, scaled_pressure2->temperature);
+}
+
+/**
+ * @brief Send a scaled_pressure2 message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_boot_ms Timestamp (milliseconds since system boot)
+ * @param press_abs Absolute pressure (hectopascal)
+ * @param press_diff Differential pressure 1 (hectopascal)
+ * @param temperature Temperature measurement (0.01 degrees celsius)
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_scaled_pressure2_send(mavlink_channel_t chan, uint32_t time_boot_ms, float press_abs, float press_diff, int16_t temperature)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, press_abs);
+	_mav_put_float(buf, 8, press_diff);
+	_mav_put_int16_t(buf, 12, temperature);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE2, buf, MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN, MAVLINK_MSG_ID_SCALED_PRESSURE2_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE2, buf, MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN);
+#endif
+#else
+	mavlink_scaled_pressure2_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.press_abs = press_abs;
+	packet.press_diff = press_diff;
+	packet.temperature = temperature;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE2, (const char *)&packet, MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN, MAVLINK_MSG_ID_SCALED_PRESSURE2_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE2, (const char *)&packet, MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_scaled_pressure2_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, float press_abs, float press_diff, int16_t temperature)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, press_abs);
+	_mav_put_float(buf, 8, press_diff);
+	_mav_put_int16_t(buf, 12, temperature);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE2, buf, MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN, MAVLINK_MSG_ID_SCALED_PRESSURE2_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE2, buf, MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN);
+#endif
+#else
+	mavlink_scaled_pressure2_t *packet = (mavlink_scaled_pressure2_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->press_abs = press_abs;
+	packet->press_diff = press_diff;
+	packet->temperature = temperature;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE2, (const char *)packet, MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN, MAVLINK_MSG_ID_SCALED_PRESSURE2_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE2, (const char *)packet, MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE SCALED_PRESSURE2 UNPACKING
+
+
+/**
+ * @brief Get field time_boot_ms from scaled_pressure2 message
+ *
+ * @return Timestamp (milliseconds since system boot)
+ */
+static inline uint32_t mavlink_msg_scaled_pressure2_get_time_boot_ms(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field press_abs from scaled_pressure2 message
+ *
+ * @return Absolute pressure (hectopascal)
+ */
+static inline float mavlink_msg_scaled_pressure2_get_press_abs(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  4);
+}
+
+/**
+ * @brief Get field press_diff from scaled_pressure2 message
+ *
+ * @return Differential pressure 1 (hectopascal)
+ */
+static inline float mavlink_msg_scaled_pressure2_get_press_diff(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  8);
+}
+
+/**
+ * @brief Get field temperature from scaled_pressure2 message
+ *
+ * @return Temperature measurement (0.01 degrees celsius)
+ */
+static inline int16_t mavlink_msg_scaled_pressure2_get_temperature(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int16_t(msg,  12);
+}
+
+/**
+ * @brief Decode a scaled_pressure2 message into a struct
+ *
+ * @param msg The message to decode
+ * @param scaled_pressure2 C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_scaled_pressure2_decode(const mavlink_message_t* msg, mavlink_scaled_pressure2_t* scaled_pressure2)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	scaled_pressure2->time_boot_ms = mavlink_msg_scaled_pressure2_get_time_boot_ms(msg);
+	scaled_pressure2->press_abs = mavlink_msg_scaled_pressure2_get_press_abs(msg);
+	scaled_pressure2->press_diff = mavlink_msg_scaled_pressure2_get_press_diff(msg);
+	scaled_pressure2->temperature = mavlink_msg_scaled_pressure2_get_temperature(msg);
+#else
+	memcpy(scaled_pressure2, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SCALED_PRESSURE2_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_scaled_pressure.h v1.0/common/mavlink_msg_scaled_pressure.h
--- v1.0.old/common/mavlink_msg_scaled_pressure.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_scaled_pressure.h	2015-02-06 11:50:58.000000000 +0500
@@ -13,6 +13,9 @@ typedef struct __mavlink_scaled_pressure
 #define MAVLINK_MSG_ID_SCALED_PRESSURE_LEN 14
 #define MAVLINK_MSG_ID_29_LEN 14
 
+#define MAVLINK_MSG_ID_SCALED_PRESSURE_CRC 115
+#define MAVLINK_MSG_ID_29_CRC 115
+
 
 
 #define MAVLINK_MESSAGE_INFO_SCALED_PRESSURE { \
@@ -42,13 +45,13 @@ static inline uint16_t mavlink_msg_scale
 						       uint32_t time_boot_ms, float press_abs, float press_diff, int16_t temperature)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[14];
+	char buf[MAVLINK_MSG_ID_SCALED_PRESSURE_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, press_abs);
 	_mav_put_float(buf, 8, press_diff);
 	_mav_put_int16_t(buf, 12, temperature);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 14);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
 #else
 	mavlink_scaled_pressure_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -56,18 +59,22 @@ static inline uint16_t mavlink_msg_scale
 	packet.press_diff = press_diff;
 	packet.temperature = temperature;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 14);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SCALED_PRESSURE;
-	return mavlink_finalize_message(msg, system_id, component_id, 14, 115);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN, MAVLINK_MSG_ID_SCALED_PRESSURE_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
+#endif
 }
 
 /**
  * @brief Pack a scaled_pressure message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_boot_ms Timestamp (milliseconds since system boot)
  * @param press_abs Absolute pressure (hectopascal)
@@ -80,13 +87,13 @@ static inline uint16_t mavlink_msg_scale
 						           uint32_t time_boot_ms,float press_abs,float press_diff,int16_t temperature)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[14];
+	char buf[MAVLINK_MSG_ID_SCALED_PRESSURE_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, press_abs);
 	_mav_put_float(buf, 8, press_diff);
 	_mav_put_int16_t(buf, 12, temperature);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 14);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
 #else
 	mavlink_scaled_pressure_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -94,15 +101,19 @@ static inline uint16_t mavlink_msg_scale
 	packet.press_diff = press_diff;
 	packet.temperature = temperature;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 14);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SCALED_PRESSURE;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 14, 115);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN, MAVLINK_MSG_ID_SCALED_PRESSURE_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
+#endif
 }
 
 /**
- * @brief Encode a scaled_pressure struct into a message
+ * @brief Encode a scaled_pressure struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -115,6 +126,20 @@ static inline uint16_t mavlink_msg_scale
 }
 
 /**
+ * @brief Encode a scaled_pressure struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param scaled_pressure C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_scaled_pressure_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_scaled_pressure_t* scaled_pressure)
+{
+	return mavlink_msg_scaled_pressure_pack_chan(system_id, component_id, chan, msg, scaled_pressure->time_boot_ms, scaled_pressure->press_abs, scaled_pressure->press_diff, scaled_pressure->temperature);
+}
+
+/**
  * @brief Send a scaled_pressure message
  * @param chan MAVLink channel to send the message
  *
@@ -128,13 +153,17 @@ static inline uint16_t mavlink_msg_scale
 static inline void mavlink_msg_scaled_pressure_send(mavlink_channel_t chan, uint32_t time_boot_ms, float press_abs, float press_diff, int16_t temperature)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[14];
+	char buf[MAVLINK_MSG_ID_SCALED_PRESSURE_LEN];
 	_mav_put_uint32_t(buf, 0, time_boot_ms);
 	_mav_put_float(buf, 4, press_abs);
 	_mav_put_float(buf, 8, press_diff);
 	_mav_put_int16_t(buf, 12, temperature);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE, buf, 14, 115);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE, buf, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN, MAVLINK_MSG_ID_SCALED_PRESSURE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE, buf, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
+#endif
 #else
 	mavlink_scaled_pressure_t packet;
 	packet.time_boot_ms = time_boot_ms;
@@ -142,10 +171,52 @@ static inline void mavlink_msg_scaled_pr
 	packet.press_diff = press_diff;
 	packet.temperature = temperature;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE, (const char *)&packet, 14, 115);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE, (const char *)&packet, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN, MAVLINK_MSG_ID_SCALED_PRESSURE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE, (const char *)&packet, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_SCALED_PRESSURE_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_scaled_pressure_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, float press_abs, float press_diff, int16_t temperature)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, press_abs);
+	_mav_put_float(buf, 8, press_diff);
+	_mav_put_int16_t(buf, 12, temperature);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE, buf, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN, MAVLINK_MSG_ID_SCALED_PRESSURE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE, buf, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
+#endif
+#else
+	mavlink_scaled_pressure_t *packet = (mavlink_scaled_pressure_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->press_abs = press_abs;
+	packet->press_diff = press_diff;
+	packet->temperature = temperature;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE, (const char *)packet, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN, MAVLINK_MSG_ID_SCALED_PRESSURE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SCALED_PRESSURE, (const char *)packet, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE SCALED_PRESSURE UNPACKING
@@ -205,6 +276,6 @@ static inline void mavlink_msg_scaled_pr
 	scaled_pressure->press_diff = mavlink_msg_scaled_pressure_get_press_diff(msg);
 	scaled_pressure->temperature = mavlink_msg_scaled_pressure_get_temperature(msg);
 #else
-	memcpy(scaled_pressure, _MAV_PAYLOAD(msg), 14);
+	memcpy(scaled_pressure, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_serial_control.h v1.0/common/mavlink_msg_serial_control.h
--- v1.0.old/common/mavlink_msg_serial_control.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_serial_control.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,321 @@
+// MESSAGE SERIAL_CONTROL PACKING
+
+#define MAVLINK_MSG_ID_SERIAL_CONTROL 126
+
+typedef struct __mavlink_serial_control_t
+{
+ uint32_t baudrate; ///< Baudrate of transfer. Zero means no change.
+ uint16_t timeout; ///< Timeout for reply data in milliseconds
+ uint8_t device; ///< See SERIAL_CONTROL_DEV enum
+ uint8_t flags; ///< See SERIAL_CONTROL_FLAG enum
+ uint8_t count; ///< how many bytes in this transfer
+ uint8_t data[70]; ///< serial data
+} mavlink_serial_control_t;
+
+#define MAVLINK_MSG_ID_SERIAL_CONTROL_LEN 79
+#define MAVLINK_MSG_ID_126_LEN 79
+
+#define MAVLINK_MSG_ID_SERIAL_CONTROL_CRC 220
+#define MAVLINK_MSG_ID_126_CRC 220
+
+#define MAVLINK_MSG_SERIAL_CONTROL_FIELD_DATA_LEN 70
+
+#define MAVLINK_MESSAGE_INFO_SERIAL_CONTROL { \
+	"SERIAL_CONTROL", \
+	6, \
+	{  { "baudrate", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_serial_control_t, baudrate) }, \
+         { "timeout", NULL, MAVLINK_TYPE_UINT16_T, 0, 4, offsetof(mavlink_serial_control_t, timeout) }, \
+         { "device", NULL, MAVLINK_TYPE_UINT8_T, 0, 6, offsetof(mavlink_serial_control_t, device) }, \
+         { "flags", NULL, MAVLINK_TYPE_UINT8_T, 0, 7, offsetof(mavlink_serial_control_t, flags) }, \
+         { "count", NULL, MAVLINK_TYPE_UINT8_T, 0, 8, offsetof(mavlink_serial_control_t, count) }, \
+         { "data", NULL, MAVLINK_TYPE_UINT8_T, 70, 9, offsetof(mavlink_serial_control_t, data) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a serial_control message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param device See SERIAL_CONTROL_DEV enum
+ * @param flags See SERIAL_CONTROL_FLAG enum
+ * @param timeout Timeout for reply data in milliseconds
+ * @param baudrate Baudrate of transfer. Zero means no change.
+ * @param count how many bytes in this transfer
+ * @param data serial data
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_serial_control_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint8_t device, uint8_t flags, uint16_t timeout, uint32_t baudrate, uint8_t count, const uint8_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SERIAL_CONTROL_LEN];
+	_mav_put_uint32_t(buf, 0, baudrate);
+	_mav_put_uint16_t(buf, 4, timeout);
+	_mav_put_uint8_t(buf, 6, device);
+	_mav_put_uint8_t(buf, 7, flags);
+	_mav_put_uint8_t(buf, 8, count);
+	_mav_put_uint8_t_array(buf, 9, data, 70);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SERIAL_CONTROL_LEN);
+#else
+	mavlink_serial_control_t packet;
+	packet.baudrate = baudrate;
+	packet.timeout = timeout;
+	packet.device = device;
+	packet.flags = flags;
+	packet.count = count;
+	mav_array_memcpy(packet.data, data, sizeof(uint8_t)*70);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SERIAL_CONTROL_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_SERIAL_CONTROL;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SERIAL_CONTROL_LEN, MAVLINK_MSG_ID_SERIAL_CONTROL_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SERIAL_CONTROL_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a serial_control message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param device See SERIAL_CONTROL_DEV enum
+ * @param flags See SERIAL_CONTROL_FLAG enum
+ * @param timeout Timeout for reply data in milliseconds
+ * @param baudrate Baudrate of transfer. Zero means no change.
+ * @param count how many bytes in this transfer
+ * @param data serial data
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_serial_control_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint8_t device,uint8_t flags,uint16_t timeout,uint32_t baudrate,uint8_t count,const uint8_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SERIAL_CONTROL_LEN];
+	_mav_put_uint32_t(buf, 0, baudrate);
+	_mav_put_uint16_t(buf, 4, timeout);
+	_mav_put_uint8_t(buf, 6, device);
+	_mav_put_uint8_t(buf, 7, flags);
+	_mav_put_uint8_t(buf, 8, count);
+	_mav_put_uint8_t_array(buf, 9, data, 70);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SERIAL_CONTROL_LEN);
+#else
+	mavlink_serial_control_t packet;
+	packet.baudrate = baudrate;
+	packet.timeout = timeout;
+	packet.device = device;
+	packet.flags = flags;
+	packet.count = count;
+	mav_array_memcpy(packet.data, data, sizeof(uint8_t)*70);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SERIAL_CONTROL_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_SERIAL_CONTROL;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SERIAL_CONTROL_LEN, MAVLINK_MSG_ID_SERIAL_CONTROL_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SERIAL_CONTROL_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a serial_control struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param serial_control C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_serial_control_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_serial_control_t* serial_control)
+{
+	return mavlink_msg_serial_control_pack(system_id, component_id, msg, serial_control->device, serial_control->flags, serial_control->timeout, serial_control->baudrate, serial_control->count, serial_control->data);
+}
+
+/**
+ * @brief Encode a serial_control struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param serial_control C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_serial_control_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_serial_control_t* serial_control)
+{
+	return mavlink_msg_serial_control_pack_chan(system_id, component_id, chan, msg, serial_control->device, serial_control->flags, serial_control->timeout, serial_control->baudrate, serial_control->count, serial_control->data);
+}
+
+/**
+ * @brief Send a serial_control message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param device See SERIAL_CONTROL_DEV enum
+ * @param flags See SERIAL_CONTROL_FLAG enum
+ * @param timeout Timeout for reply data in milliseconds
+ * @param baudrate Baudrate of transfer. Zero means no change.
+ * @param count how many bytes in this transfer
+ * @param data serial data
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_serial_control_send(mavlink_channel_t chan, uint8_t device, uint8_t flags, uint16_t timeout, uint32_t baudrate, uint8_t count, const uint8_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SERIAL_CONTROL_LEN];
+	_mav_put_uint32_t(buf, 0, baudrate);
+	_mav_put_uint16_t(buf, 4, timeout);
+	_mav_put_uint8_t(buf, 6, device);
+	_mav_put_uint8_t(buf, 7, flags);
+	_mav_put_uint8_t(buf, 8, count);
+	_mav_put_uint8_t_array(buf, 9, data, 70);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERIAL_CONTROL, buf, MAVLINK_MSG_ID_SERIAL_CONTROL_LEN, MAVLINK_MSG_ID_SERIAL_CONTROL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERIAL_CONTROL, buf, MAVLINK_MSG_ID_SERIAL_CONTROL_LEN);
+#endif
+#else
+	mavlink_serial_control_t packet;
+	packet.baudrate = baudrate;
+	packet.timeout = timeout;
+	packet.device = device;
+	packet.flags = flags;
+	packet.count = count;
+	mav_array_memcpy(packet.data, data, sizeof(uint8_t)*70);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERIAL_CONTROL, (const char *)&packet, MAVLINK_MSG_ID_SERIAL_CONTROL_LEN, MAVLINK_MSG_ID_SERIAL_CONTROL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERIAL_CONTROL, (const char *)&packet, MAVLINK_MSG_ID_SERIAL_CONTROL_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_SERIAL_CONTROL_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_serial_control_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t device, uint8_t flags, uint16_t timeout, uint32_t baudrate, uint8_t count, const uint8_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, baudrate);
+	_mav_put_uint16_t(buf, 4, timeout);
+	_mav_put_uint8_t(buf, 6, device);
+	_mav_put_uint8_t(buf, 7, flags);
+	_mav_put_uint8_t(buf, 8, count);
+	_mav_put_uint8_t_array(buf, 9, data, 70);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERIAL_CONTROL, buf, MAVLINK_MSG_ID_SERIAL_CONTROL_LEN, MAVLINK_MSG_ID_SERIAL_CONTROL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERIAL_CONTROL, buf, MAVLINK_MSG_ID_SERIAL_CONTROL_LEN);
+#endif
+#else
+	mavlink_serial_control_t *packet = (mavlink_serial_control_t *)msgbuf;
+	packet->baudrate = baudrate;
+	packet->timeout = timeout;
+	packet->device = device;
+	packet->flags = flags;
+	packet->count = count;
+	mav_array_memcpy(packet->data, data, sizeof(uint8_t)*70);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERIAL_CONTROL, (const char *)packet, MAVLINK_MSG_ID_SERIAL_CONTROL_LEN, MAVLINK_MSG_ID_SERIAL_CONTROL_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERIAL_CONTROL, (const char *)packet, MAVLINK_MSG_ID_SERIAL_CONTROL_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE SERIAL_CONTROL UNPACKING
+
+
+/**
+ * @brief Get field device from serial_control message
+ *
+ * @return See SERIAL_CONTROL_DEV enum
+ */
+static inline uint8_t mavlink_msg_serial_control_get_device(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  6);
+}
+
+/**
+ * @brief Get field flags from serial_control message
+ *
+ * @return See SERIAL_CONTROL_FLAG enum
+ */
+static inline uint8_t mavlink_msg_serial_control_get_flags(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  7);
+}
+
+/**
+ * @brief Get field timeout from serial_control message
+ *
+ * @return Timeout for reply data in milliseconds
+ */
+static inline uint16_t mavlink_msg_serial_control_get_timeout(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  4);
+}
+
+/**
+ * @brief Get field baudrate from serial_control message
+ *
+ * @return Baudrate of transfer. Zero means no change.
+ */
+static inline uint32_t mavlink_msg_serial_control_get_baudrate(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field count from serial_control message
+ *
+ * @return how many bytes in this transfer
+ */
+static inline uint8_t mavlink_msg_serial_control_get_count(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  8);
+}
+
+/**
+ * @brief Get field data from serial_control message
+ *
+ * @return serial data
+ */
+static inline uint16_t mavlink_msg_serial_control_get_data(const mavlink_message_t* msg, uint8_t *data)
+{
+	return _MAV_RETURN_uint8_t_array(msg, data, 70,  9);
+}
+
+/**
+ * @brief Decode a serial_control message into a struct
+ *
+ * @param msg The message to decode
+ * @param serial_control C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_serial_control_decode(const mavlink_message_t* msg, mavlink_serial_control_t* serial_control)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	serial_control->baudrate = mavlink_msg_serial_control_get_baudrate(msg);
+	serial_control->timeout = mavlink_msg_serial_control_get_timeout(msg);
+	serial_control->device = mavlink_msg_serial_control_get_device(msg);
+	serial_control->flags = mavlink_msg_serial_control_get_flags(msg);
+	serial_control->count = mavlink_msg_serial_control_get_count(msg);
+	mavlink_msg_serial_control_get_data(msg, serial_control->data);
+#else
+	memcpy(serial_control, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SERIAL_CONTROL_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_servo_output_raw.h v1.0/common/mavlink_msg_servo_output_raw.h
--- v1.0.old/common/mavlink_msg_servo_output_raw.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_servo_output_raw.h	2015-02-06 11:50:58.000000000 +0500
@@ -19,6 +19,9 @@ typedef struct __mavlink_servo_output_ra
 #define MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN 21
 #define MAVLINK_MSG_ID_36_LEN 21
 
+#define MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_CRC 222
+#define MAVLINK_MSG_ID_36_CRC 222
+
 
 
 #define MAVLINK_MESSAGE_INFO_SERVO_OUTPUT_RAW { \
@@ -60,7 +63,7 @@ static inline uint16_t mavlink_msg_servo
 						       uint32_t time_usec, uint8_t port, uint16_t servo1_raw, uint16_t servo2_raw, uint16_t servo3_raw, uint16_t servo4_raw, uint16_t servo5_raw, uint16_t servo6_raw, uint16_t servo7_raw, uint16_t servo8_raw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[21];
+	char buf[MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN];
 	_mav_put_uint32_t(buf, 0, time_usec);
 	_mav_put_uint16_t(buf, 4, servo1_raw);
 	_mav_put_uint16_t(buf, 6, servo2_raw);
@@ -72,7 +75,7 @@ static inline uint16_t mavlink_msg_servo
 	_mav_put_uint16_t(buf, 18, servo8_raw);
 	_mav_put_uint8_t(buf, 20, port);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 21);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
 #else
 	mavlink_servo_output_raw_t packet;
 	packet.time_usec = time_usec;
@@ -86,18 +89,22 @@ static inline uint16_t mavlink_msg_servo
 	packet.servo8_raw = servo8_raw;
 	packet.port = port;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 21);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SERVO_OUTPUT_RAW;
-	return mavlink_finalize_message(msg, system_id, component_id, 21, 222);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
+#endif
 }
 
 /**
  * @brief Pack a servo_output_raw message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_usec Timestamp (microseconds since system boot)
  * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
@@ -116,7 +123,7 @@ static inline uint16_t mavlink_msg_servo
 						           uint32_t time_usec,uint8_t port,uint16_t servo1_raw,uint16_t servo2_raw,uint16_t servo3_raw,uint16_t servo4_raw,uint16_t servo5_raw,uint16_t servo6_raw,uint16_t servo7_raw,uint16_t servo8_raw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[21];
+	char buf[MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN];
 	_mav_put_uint32_t(buf, 0, time_usec);
 	_mav_put_uint16_t(buf, 4, servo1_raw);
 	_mav_put_uint16_t(buf, 6, servo2_raw);
@@ -128,7 +135,7 @@ static inline uint16_t mavlink_msg_servo
 	_mav_put_uint16_t(buf, 18, servo8_raw);
 	_mav_put_uint8_t(buf, 20, port);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 21);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
 #else
 	mavlink_servo_output_raw_t packet;
 	packet.time_usec = time_usec;
@@ -142,15 +149,19 @@ static inline uint16_t mavlink_msg_servo
 	packet.servo8_raw = servo8_raw;
 	packet.port = port;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 21);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SERVO_OUTPUT_RAW;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 21, 222);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
+#endif
 }
 
 /**
- * @brief Encode a servo_output_raw struct into a message
+ * @brief Encode a servo_output_raw struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -163,6 +174,20 @@ static inline uint16_t mavlink_msg_servo
 }
 
 /**
+ * @brief Encode a servo_output_raw struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param servo_output_raw C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_servo_output_raw_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_servo_output_raw_t* servo_output_raw)
+{
+	return mavlink_msg_servo_output_raw_pack_chan(system_id, component_id, chan, msg, servo_output_raw->time_usec, servo_output_raw->port, servo_output_raw->servo1_raw, servo_output_raw->servo2_raw, servo_output_raw->servo3_raw, servo_output_raw->servo4_raw, servo_output_raw->servo5_raw, servo_output_raw->servo6_raw, servo_output_raw->servo7_raw, servo_output_raw->servo8_raw);
+}
+
+/**
  * @brief Send a servo_output_raw message
  * @param chan MAVLink channel to send the message
  *
@@ -182,7 +207,7 @@ static inline uint16_t mavlink_msg_servo
 static inline void mavlink_msg_servo_output_raw_send(mavlink_channel_t chan, uint32_t time_usec, uint8_t port, uint16_t servo1_raw, uint16_t servo2_raw, uint16_t servo3_raw, uint16_t servo4_raw, uint16_t servo5_raw, uint16_t servo6_raw, uint16_t servo7_raw, uint16_t servo8_raw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[21];
+	char buf[MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN];
 	_mav_put_uint32_t(buf, 0, time_usec);
 	_mav_put_uint16_t(buf, 4, servo1_raw);
 	_mav_put_uint16_t(buf, 6, servo2_raw);
@@ -194,7 +219,11 @@ static inline void mavlink_msg_servo_out
 	_mav_put_uint16_t(buf, 18, servo8_raw);
 	_mav_put_uint8_t(buf, 20, port);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW, buf, 21, 222);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW, buf, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW, buf, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
+#endif
 #else
 	mavlink_servo_output_raw_t packet;
 	packet.time_usec = time_usec;
@@ -208,10 +237,64 @@ static inline void mavlink_msg_servo_out
 	packet.servo8_raw = servo8_raw;
 	packet.port = port;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW, (const char *)&packet, 21, 222);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW, (const char *)&packet, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW, (const char *)&packet, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_servo_output_raw_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_usec, uint8_t port, uint16_t servo1_raw, uint16_t servo2_raw, uint16_t servo3_raw, uint16_t servo4_raw, uint16_t servo5_raw, uint16_t servo6_raw, uint16_t servo7_raw, uint16_t servo8_raw)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_usec);
+	_mav_put_uint16_t(buf, 4, servo1_raw);
+	_mav_put_uint16_t(buf, 6, servo2_raw);
+	_mav_put_uint16_t(buf, 8, servo3_raw);
+	_mav_put_uint16_t(buf, 10, servo4_raw);
+	_mav_put_uint16_t(buf, 12, servo5_raw);
+	_mav_put_uint16_t(buf, 14, servo6_raw);
+	_mav_put_uint16_t(buf, 16, servo7_raw);
+	_mav_put_uint16_t(buf, 18, servo8_raw);
+	_mav_put_uint8_t(buf, 20, port);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW, buf, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW, buf, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
+#endif
+#else
+	mavlink_servo_output_raw_t *packet = (mavlink_servo_output_raw_t *)msgbuf;
+	packet->time_usec = time_usec;
+	packet->servo1_raw = servo1_raw;
+	packet->servo2_raw = servo2_raw;
+	packet->servo3_raw = servo3_raw;
+	packet->servo4_raw = servo4_raw;
+	packet->servo5_raw = servo5_raw;
+	packet->servo6_raw = servo6_raw;
+	packet->servo7_raw = servo7_raw;
+	packet->servo8_raw = servo8_raw;
+	packet->port = port;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW, (const char *)packet, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW, (const char *)packet, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE SERVO_OUTPUT_RAW UNPACKING
@@ -337,6 +420,6 @@ static inline void mavlink_msg_servo_out
 	servo_output_raw->servo8_raw = mavlink_msg_servo_output_raw_get_servo8_raw(msg);
 	servo_output_raw->port = mavlink_msg_servo_output_raw_get_port(msg);
 #else
-	memcpy(servo_output_raw, _MAV_PAYLOAD(msg), 21);
+	memcpy(servo_output_raw, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_set_attitude_target.h v1.0/common/mavlink_msg_set_attitude_target.h
--- v1.0.old/common/mavlink_msg_set_attitude_target.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_set_attitude_target.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,393 @@
+// MESSAGE SET_ATTITUDE_TARGET PACKING
+
+#define MAVLINK_MSG_ID_SET_ATTITUDE_TARGET 82
+
+typedef struct __mavlink_set_attitude_target_t
+{
+ uint32_t time_boot_ms; ///< Timestamp in milliseconds since system boot
+ float q[4]; ///< Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
+ float body_roll_rate; ///< Body roll rate in radians per second
+ float body_pitch_rate; ///< Body roll rate in radians per second
+ float body_yaw_rate; ///< Body roll rate in radians per second
+ float thrust; ///< Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
+ uint8_t target_system; ///< System ID
+ uint8_t target_component; ///< Component ID
+ uint8_t type_mask; ///< Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 6: reserved, bit 7: throttle, bit 8: attitude
+} mavlink_set_attitude_target_t;
+
+#define MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN 39
+#define MAVLINK_MSG_ID_82_LEN 39
+
+#define MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_CRC 49
+#define MAVLINK_MSG_ID_82_CRC 49
+
+#define MAVLINK_MSG_SET_ATTITUDE_TARGET_FIELD_Q_LEN 4
+
+#define MAVLINK_MESSAGE_INFO_SET_ATTITUDE_TARGET { \
+	"SET_ATTITUDE_TARGET", \
+	9, \
+	{  { "time_boot_ms", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_set_attitude_target_t, time_boot_ms) }, \
+         { "q", NULL, MAVLINK_TYPE_FLOAT, 4, 4, offsetof(mavlink_set_attitude_target_t, q) }, \
+         { "body_roll_rate", NULL, MAVLINK_TYPE_FLOAT, 0, 20, offsetof(mavlink_set_attitude_target_t, body_roll_rate) }, \
+         { "body_pitch_rate", NULL, MAVLINK_TYPE_FLOAT, 0, 24, offsetof(mavlink_set_attitude_target_t, body_pitch_rate) }, \
+         { "body_yaw_rate", NULL, MAVLINK_TYPE_FLOAT, 0, 28, offsetof(mavlink_set_attitude_target_t, body_yaw_rate) }, \
+         { "thrust", NULL, MAVLINK_TYPE_FLOAT, 0, 32, offsetof(mavlink_set_attitude_target_t, thrust) }, \
+         { "target_system", NULL, MAVLINK_TYPE_UINT8_T, 0, 36, offsetof(mavlink_set_attitude_target_t, target_system) }, \
+         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 37, offsetof(mavlink_set_attitude_target_t, target_component) }, \
+         { "type_mask", NULL, MAVLINK_TYPE_UINT8_T, 0, 38, offsetof(mavlink_set_attitude_target_t, type_mask) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a set_attitude_target message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_boot_ms Timestamp in milliseconds since system boot
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param type_mask Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 6: reserved, bit 7: throttle, bit 8: attitude
+ * @param q Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
+ * @param body_roll_rate Body roll rate in radians per second
+ * @param body_pitch_rate Body roll rate in radians per second
+ * @param body_yaw_rate Body roll rate in radians per second
+ * @param thrust Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_set_attitude_target_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint32_t time_boot_ms, uint8_t target_system, uint8_t target_component, uint8_t type_mask, const float *q, float body_roll_rate, float body_pitch_rate, float body_yaw_rate, float thrust)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 20, body_roll_rate);
+	_mav_put_float(buf, 24, body_pitch_rate);
+	_mav_put_float(buf, 28, body_yaw_rate);
+	_mav_put_float(buf, 32, thrust);
+	_mav_put_uint8_t(buf, 36, target_system);
+	_mav_put_uint8_t(buf, 37, target_component);
+	_mav_put_uint8_t(buf, 38, type_mask);
+	_mav_put_float_array(buf, 4, q, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN);
+#else
+	mavlink_set_attitude_target_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.body_roll_rate = body_roll_rate;
+	packet.body_pitch_rate = body_pitch_rate;
+	packet.body_yaw_rate = body_yaw_rate;
+	packet.thrust = thrust;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.type_mask = type_mask;
+	mav_array_memcpy(packet.q, q, sizeof(float)*4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_SET_ATTITUDE_TARGET;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a set_attitude_target message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_boot_ms Timestamp in milliseconds since system boot
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param type_mask Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 6: reserved, bit 7: throttle, bit 8: attitude
+ * @param q Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
+ * @param body_roll_rate Body roll rate in radians per second
+ * @param body_pitch_rate Body roll rate in radians per second
+ * @param body_yaw_rate Body roll rate in radians per second
+ * @param thrust Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_set_attitude_target_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint32_t time_boot_ms,uint8_t target_system,uint8_t target_component,uint8_t type_mask,const float *q,float body_roll_rate,float body_pitch_rate,float body_yaw_rate,float thrust)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 20, body_roll_rate);
+	_mav_put_float(buf, 24, body_pitch_rate);
+	_mav_put_float(buf, 28, body_yaw_rate);
+	_mav_put_float(buf, 32, thrust);
+	_mav_put_uint8_t(buf, 36, target_system);
+	_mav_put_uint8_t(buf, 37, target_component);
+	_mav_put_uint8_t(buf, 38, type_mask);
+	_mav_put_float_array(buf, 4, q, 4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN);
+#else
+	mavlink_set_attitude_target_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.body_roll_rate = body_roll_rate;
+	packet.body_pitch_rate = body_pitch_rate;
+	packet.body_yaw_rate = body_yaw_rate;
+	packet.thrust = thrust;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.type_mask = type_mask;
+	mav_array_memcpy(packet.q, q, sizeof(float)*4);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_SET_ATTITUDE_TARGET;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a set_attitude_target struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param set_attitude_target C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_set_attitude_target_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_set_attitude_target_t* set_attitude_target)
+{
+	return mavlink_msg_set_attitude_target_pack(system_id, component_id, msg, set_attitude_target->time_boot_ms, set_attitude_target->target_system, set_attitude_target->target_component, set_attitude_target->type_mask, set_attitude_target->q, set_attitude_target->body_roll_rate, set_attitude_target->body_pitch_rate, set_attitude_target->body_yaw_rate, set_attitude_target->thrust);
+}
+
+/**
+ * @brief Encode a set_attitude_target struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param set_attitude_target C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_set_attitude_target_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_set_attitude_target_t* set_attitude_target)
+{
+	return mavlink_msg_set_attitude_target_pack_chan(system_id, component_id, chan, msg, set_attitude_target->time_boot_ms, set_attitude_target->target_system, set_attitude_target->target_component, set_attitude_target->type_mask, set_attitude_target->q, set_attitude_target->body_roll_rate, set_attitude_target->body_pitch_rate, set_attitude_target->body_yaw_rate, set_attitude_target->thrust);
+}
+
+/**
+ * @brief Send a set_attitude_target message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_boot_ms Timestamp in milliseconds since system boot
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param type_mask Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 6: reserved, bit 7: throttle, bit 8: attitude
+ * @param q Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
+ * @param body_roll_rate Body roll rate in radians per second
+ * @param body_pitch_rate Body roll rate in radians per second
+ * @param body_yaw_rate Body roll rate in radians per second
+ * @param thrust Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_set_attitude_target_send(mavlink_channel_t chan, uint32_t time_boot_ms, uint8_t target_system, uint8_t target_component, uint8_t type_mask, const float *q, float body_roll_rate, float body_pitch_rate, float body_yaw_rate, float thrust)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 20, body_roll_rate);
+	_mav_put_float(buf, 24, body_pitch_rate);
+	_mav_put_float(buf, 28, body_yaw_rate);
+	_mav_put_float(buf, 32, thrust);
+	_mav_put_uint8_t(buf, 36, target_system);
+	_mav_put_uint8_t(buf, 37, target_component);
+	_mav_put_uint8_t(buf, 38, type_mask);
+	_mav_put_float_array(buf, 4, q, 4);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET, buf, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET, buf, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN);
+#endif
+#else
+	mavlink_set_attitude_target_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.body_roll_rate = body_roll_rate;
+	packet.body_pitch_rate = body_pitch_rate;
+	packet.body_yaw_rate = body_yaw_rate;
+	packet.thrust = thrust;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.type_mask = type_mask;
+	mav_array_memcpy(packet.q, q, sizeof(float)*4);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET, (const char *)&packet, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET, (const char *)&packet, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_set_attitude_target_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, uint8_t target_system, uint8_t target_component, uint8_t type_mask, const float *q, float body_roll_rate, float body_pitch_rate, float body_yaw_rate, float thrust)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 20, body_roll_rate);
+	_mav_put_float(buf, 24, body_pitch_rate);
+	_mav_put_float(buf, 28, body_yaw_rate);
+	_mav_put_float(buf, 32, thrust);
+	_mav_put_uint8_t(buf, 36, target_system);
+	_mav_put_uint8_t(buf, 37, target_component);
+	_mav_put_uint8_t(buf, 38, type_mask);
+	_mav_put_float_array(buf, 4, q, 4);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET, buf, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET, buf, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN);
+#endif
+#else
+	mavlink_set_attitude_target_t *packet = (mavlink_set_attitude_target_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->body_roll_rate = body_roll_rate;
+	packet->body_pitch_rate = body_pitch_rate;
+	packet->body_yaw_rate = body_yaw_rate;
+	packet->thrust = thrust;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+	packet->type_mask = type_mask;
+	mav_array_memcpy(packet->q, q, sizeof(float)*4);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET, (const char *)packet, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET, (const char *)packet, MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE SET_ATTITUDE_TARGET UNPACKING
+
+
+/**
+ * @brief Get field time_boot_ms from set_attitude_target message
+ *
+ * @return Timestamp in milliseconds since system boot
+ */
+static inline uint32_t mavlink_msg_set_attitude_target_get_time_boot_ms(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field target_system from set_attitude_target message
+ *
+ * @return System ID
+ */
+static inline uint8_t mavlink_msg_set_attitude_target_get_target_system(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  36);
+}
+
+/**
+ * @brief Get field target_component from set_attitude_target message
+ *
+ * @return Component ID
+ */
+static inline uint8_t mavlink_msg_set_attitude_target_get_target_component(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  37);
+}
+
+/**
+ * @brief Get field type_mask from set_attitude_target message
+ *
+ * @return Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 6: reserved, bit 7: throttle, bit 8: attitude
+ */
+static inline uint8_t mavlink_msg_set_attitude_target_get_type_mask(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  38);
+}
+
+/**
+ * @brief Get field q from set_attitude_target message
+ *
+ * @return Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
+ */
+static inline uint16_t mavlink_msg_set_attitude_target_get_q(const mavlink_message_t* msg, float *q)
+{
+	return _MAV_RETURN_float_array(msg, q, 4,  4);
+}
+
+/**
+ * @brief Get field body_roll_rate from set_attitude_target message
+ *
+ * @return Body roll rate in radians per second
+ */
+static inline float mavlink_msg_set_attitude_target_get_body_roll_rate(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  20);
+}
+
+/**
+ * @brief Get field body_pitch_rate from set_attitude_target message
+ *
+ * @return Body roll rate in radians per second
+ */
+static inline float mavlink_msg_set_attitude_target_get_body_pitch_rate(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  24);
+}
+
+/**
+ * @brief Get field body_yaw_rate from set_attitude_target message
+ *
+ * @return Body roll rate in radians per second
+ */
+static inline float mavlink_msg_set_attitude_target_get_body_yaw_rate(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  28);
+}
+
+/**
+ * @brief Get field thrust from set_attitude_target message
+ *
+ * @return Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
+ */
+static inline float mavlink_msg_set_attitude_target_get_thrust(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  32);
+}
+
+/**
+ * @brief Decode a set_attitude_target message into a struct
+ *
+ * @param msg The message to decode
+ * @param set_attitude_target C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_set_attitude_target_decode(const mavlink_message_t* msg, mavlink_set_attitude_target_t* set_attitude_target)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	set_attitude_target->time_boot_ms = mavlink_msg_set_attitude_target_get_time_boot_ms(msg);
+	mavlink_msg_set_attitude_target_get_q(msg, set_attitude_target->q);
+	set_attitude_target->body_roll_rate = mavlink_msg_set_attitude_target_get_body_roll_rate(msg);
+	set_attitude_target->body_pitch_rate = mavlink_msg_set_attitude_target_get_body_pitch_rate(msg);
+	set_attitude_target->body_yaw_rate = mavlink_msg_set_attitude_target_get_body_yaw_rate(msg);
+	set_attitude_target->thrust = mavlink_msg_set_attitude_target_get_thrust(msg);
+	set_attitude_target->target_system = mavlink_msg_set_attitude_target_get_target_system(msg);
+	set_attitude_target->target_component = mavlink_msg_set_attitude_target_get_target_component(msg);
+	set_attitude_target->type_mask = mavlink_msg_set_attitude_target_get_type_mask(msg);
+#else
+	memcpy(set_attitude_target, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SET_ATTITUDE_TARGET_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_set_gps_global_origin.h v1.0/common/mavlink_msg_set_gps_global_origin.h
--- v1.0.old/common/mavlink_msg_set_gps_global_origin.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_set_gps_global_origin.h	2015-02-06 11:50:58.000000000 +0500
@@ -4,15 +4,18 @@
 
 typedef struct __mavlink_set_gps_global_origin_t
 {
- int32_t latitude; ///< global position * 1E7
- int32_t longitude; ///< global position * 1E7
- int32_t altitude; ///< global position * 1000
+ int32_t latitude; ///< Latitude (WGS84), in degrees * 1E7
+ int32_t longitude; ///< Longitude (WGS84, in degrees * 1E7
+ int32_t altitude; ///< Altitude (AMSL), in meters * 1000 (positive for up)
  uint8_t target_system; ///< System ID
 } mavlink_set_gps_global_origin_t;
 
 #define MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN 13
 #define MAVLINK_MSG_ID_48_LEN 13
 
+#define MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_CRC 41
+#define MAVLINK_MSG_ID_48_CRC 41
+
 
 
 #define MAVLINK_MESSAGE_INFO_SET_GPS_GLOBAL_ORIGIN { \
@@ -33,22 +36,22 @@ typedef struct __mavlink_set_gps_global_
  * @param msg The MAVLink message to compress the data into
  *
  * @param target_system System ID
- * @param latitude global position * 1E7
- * @param longitude global position * 1E7
- * @param altitude global position * 1000
+ * @param latitude Latitude (WGS84), in degrees * 1E7
+ * @param longitude Longitude (WGS84, in degrees * 1E7
+ * @param altitude Altitude (AMSL), in meters * 1000 (positive for up)
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_set_gps_global_origin_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
 						       uint8_t target_system, int32_t latitude, int32_t longitude, int32_t altitude)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[13];
+	char buf[MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN];
 	_mav_put_int32_t(buf, 0, latitude);
 	_mav_put_int32_t(buf, 4, longitude);
 	_mav_put_int32_t(buf, 8, altitude);
 	_mav_put_uint8_t(buf, 12, target_system);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 13);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN);
 #else
 	mavlink_set_gps_global_origin_t packet;
 	packet.latitude = latitude;
@@ -56,23 +59,27 @@ static inline uint16_t mavlink_msg_set_g
 	packet.altitude = altitude;
 	packet.target_system = target_system;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 13);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN;
-	return mavlink_finalize_message(msg, system_id, component_id, 13, 41);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN);
+#endif
 }
 
 /**
  * @brief Pack a set_gps_global_origin message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system System ID
- * @param latitude global position * 1E7
- * @param longitude global position * 1E7
- * @param altitude global position * 1000
+ * @param latitude Latitude (WGS84), in degrees * 1E7
+ * @param longitude Longitude (WGS84, in degrees * 1E7
+ * @param altitude Altitude (AMSL), in meters * 1000 (positive for up)
  * @return length of the message in bytes (excluding serial stream start sign)
  */
 static inline uint16_t mavlink_msg_set_gps_global_origin_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
@@ -80,13 +87,13 @@ static inline uint16_t mavlink_msg_set_g
 						           uint8_t target_system,int32_t latitude,int32_t longitude,int32_t altitude)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[13];
+	char buf[MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN];
 	_mav_put_int32_t(buf, 0, latitude);
 	_mav_put_int32_t(buf, 4, longitude);
 	_mav_put_int32_t(buf, 8, altitude);
 	_mav_put_uint8_t(buf, 12, target_system);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 13);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN);
 #else
 	mavlink_set_gps_global_origin_t packet;
 	packet.latitude = latitude;
@@ -94,15 +101,19 @@ static inline uint16_t mavlink_msg_set_g
 	packet.altitude = altitude;
 	packet.target_system = target_system;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 13);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 13, 41);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN);
+#endif
 }
 
 /**
- * @brief Encode a set_gps_global_origin struct into a message
+ * @brief Encode a set_gps_global_origin struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -115,26 +126,44 @@ static inline uint16_t mavlink_msg_set_g
 }
 
 /**
+ * @brief Encode a set_gps_global_origin struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param set_gps_global_origin C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_set_gps_global_origin_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_set_gps_global_origin_t* set_gps_global_origin)
+{
+	return mavlink_msg_set_gps_global_origin_pack_chan(system_id, component_id, chan, msg, set_gps_global_origin->target_system, set_gps_global_origin->latitude, set_gps_global_origin->longitude, set_gps_global_origin->altitude);
+}
+
+/**
  * @brief Send a set_gps_global_origin message
  * @param chan MAVLink channel to send the message
  *
  * @param target_system System ID
- * @param latitude global position * 1E7
- * @param longitude global position * 1E7
- * @param altitude global position * 1000
+ * @param latitude Latitude (WGS84), in degrees * 1E7
+ * @param longitude Longitude (WGS84, in degrees * 1E7
+ * @param altitude Altitude (AMSL), in meters * 1000 (positive for up)
  */
 #ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
 
 static inline void mavlink_msg_set_gps_global_origin_send(mavlink_channel_t chan, uint8_t target_system, int32_t latitude, int32_t longitude, int32_t altitude)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[13];
+	char buf[MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN];
 	_mav_put_int32_t(buf, 0, latitude);
 	_mav_put_int32_t(buf, 4, longitude);
 	_mav_put_int32_t(buf, 8, altitude);
 	_mav_put_uint8_t(buf, 12, target_system);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN, buf, 13, 41);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN, buf, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN, buf, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN);
+#endif
 #else
 	mavlink_set_gps_global_origin_t packet;
 	packet.latitude = latitude;
@@ -142,10 +171,52 @@ static inline void mavlink_msg_set_gps_g
 	packet.altitude = altitude;
 	packet.target_system = target_system;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN, (const char *)&packet, 13, 41);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN, (const char *)&packet, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN, (const char *)&packet, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_set_gps_global_origin_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, int32_t latitude, int32_t longitude, int32_t altitude)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_int32_t(buf, 0, latitude);
+	_mav_put_int32_t(buf, 4, longitude);
+	_mav_put_int32_t(buf, 8, altitude);
+	_mav_put_uint8_t(buf, 12, target_system);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN, buf, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN, buf, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN);
+#endif
+#else
+	mavlink_set_gps_global_origin_t *packet = (mavlink_set_gps_global_origin_t *)msgbuf;
+	packet->latitude = latitude;
+	packet->longitude = longitude;
+	packet->altitude = altitude;
+	packet->target_system = target_system;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN, (const char *)packet, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN, (const char *)packet, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE SET_GPS_GLOBAL_ORIGIN UNPACKING
@@ -164,7 +235,7 @@ static inline uint8_t mavlink_msg_set_gp
 /**
  * @brief Get field latitude from set_gps_global_origin message
  *
- * @return global position * 1E7
+ * @return Latitude (WGS84), in degrees * 1E7
  */
 static inline int32_t mavlink_msg_set_gps_global_origin_get_latitude(const mavlink_message_t* msg)
 {
@@ -174,7 +245,7 @@ static inline int32_t mavlink_msg_set_gp
 /**
  * @brief Get field longitude from set_gps_global_origin message
  *
- * @return global position * 1E7
+ * @return Longitude (WGS84, in degrees * 1E7
  */
 static inline int32_t mavlink_msg_set_gps_global_origin_get_longitude(const mavlink_message_t* msg)
 {
@@ -184,7 +255,7 @@ static inline int32_t mavlink_msg_set_gp
 /**
  * @brief Get field altitude from set_gps_global_origin message
  *
- * @return global position * 1000
+ * @return Altitude (AMSL), in meters * 1000 (positive for up)
  */
 static inline int32_t mavlink_msg_set_gps_global_origin_get_altitude(const mavlink_message_t* msg)
 {
@@ -205,6 +276,6 @@ static inline void mavlink_msg_set_gps_g
 	set_gps_global_origin->altitude = mavlink_msg_set_gps_global_origin_get_altitude(msg);
 	set_gps_global_origin->target_system = mavlink_msg_set_gps_global_origin_get_target_system(msg);
 #else
-	memcpy(set_gps_global_origin, _MAV_PAYLOAD(msg), 13);
+	memcpy(set_gps_global_origin, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_set_mode.h v1.0/common/mavlink_msg_set_mode.h
--- v1.0.old/common/mavlink_msg_set_mode.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_set_mode.h	2015-02-06 11:50:58.000000000 +0500
@@ -12,6 +12,9 @@ typedef struct __mavlink_set_mode_t
 #define MAVLINK_MSG_ID_SET_MODE_LEN 6
 #define MAVLINK_MSG_ID_11_LEN 6
 
+#define MAVLINK_MSG_ID_SET_MODE_CRC 89
+#define MAVLINK_MSG_ID_11_CRC 89
+
 
 
 #define MAVLINK_MESSAGE_INFO_SET_MODE { \
@@ -39,30 +42,34 @@ static inline uint16_t mavlink_msg_set_m
 						       uint8_t target_system, uint8_t base_mode, uint32_t custom_mode)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[6];
+	char buf[MAVLINK_MSG_ID_SET_MODE_LEN];
 	_mav_put_uint32_t(buf, 0, custom_mode);
 	_mav_put_uint8_t(buf, 4, target_system);
 	_mav_put_uint8_t(buf, 5, base_mode);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 6);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SET_MODE_LEN);
 #else
 	mavlink_set_mode_t packet;
 	packet.custom_mode = custom_mode;
 	packet.target_system = target_system;
 	packet.base_mode = base_mode;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 6);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SET_MODE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SET_MODE;
-	return mavlink_finalize_message(msg, system_id, component_id, 6, 89);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SET_MODE_LEN, MAVLINK_MSG_ID_SET_MODE_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SET_MODE_LEN);
+#endif
 }
 
 /**
  * @brief Pack a set_mode message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param target_system The system setting the mode
  * @param base_mode The new base mode
@@ -74,27 +81,31 @@ static inline uint16_t mavlink_msg_set_m
 						           uint8_t target_system,uint8_t base_mode,uint32_t custom_mode)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[6];
+	char buf[MAVLINK_MSG_ID_SET_MODE_LEN];
 	_mav_put_uint32_t(buf, 0, custom_mode);
 	_mav_put_uint8_t(buf, 4, target_system);
 	_mav_put_uint8_t(buf, 5, base_mode);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 6);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SET_MODE_LEN);
 #else
 	mavlink_set_mode_t packet;
 	packet.custom_mode = custom_mode;
 	packet.target_system = target_system;
 	packet.base_mode = base_mode;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 6);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SET_MODE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SET_MODE;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 6, 89);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SET_MODE_LEN, MAVLINK_MSG_ID_SET_MODE_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SET_MODE_LEN);
+#endif
 }
 
 /**
- * @brief Encode a set_mode struct into a message
+ * @brief Encode a set_mode struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -107,6 +118,20 @@ static inline uint16_t mavlink_msg_set_m
 }
 
 /**
+ * @brief Encode a set_mode struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param set_mode C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_set_mode_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_set_mode_t* set_mode)
+{
+	return mavlink_msg_set_mode_pack_chan(system_id, component_id, chan, msg, set_mode->target_system, set_mode->base_mode, set_mode->custom_mode);
+}
+
+/**
  * @brief Send a set_mode message
  * @param chan MAVLink channel to send the message
  *
@@ -119,21 +144,65 @@ static inline uint16_t mavlink_msg_set_m
 static inline void mavlink_msg_set_mode_send(mavlink_channel_t chan, uint8_t target_system, uint8_t base_mode, uint32_t custom_mode)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[6];
+	char buf[MAVLINK_MSG_ID_SET_MODE_LEN];
 	_mav_put_uint32_t(buf, 0, custom_mode);
 	_mav_put_uint8_t(buf, 4, target_system);
 	_mav_put_uint8_t(buf, 5, base_mode);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_MODE, buf, 6, 89);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_MODE, buf, MAVLINK_MSG_ID_SET_MODE_LEN, MAVLINK_MSG_ID_SET_MODE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_MODE, buf, MAVLINK_MSG_ID_SET_MODE_LEN);
+#endif
 #else
 	mavlink_set_mode_t packet;
 	packet.custom_mode = custom_mode;
 	packet.target_system = target_system;
 	packet.base_mode = base_mode;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_MODE, (const char *)&packet, 6, 89);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_MODE, (const char *)&packet, MAVLINK_MSG_ID_SET_MODE_LEN, MAVLINK_MSG_ID_SET_MODE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_MODE, (const char *)&packet, MAVLINK_MSG_ID_SET_MODE_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_SET_MODE_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_set_mode_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_system, uint8_t base_mode, uint32_t custom_mode)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, custom_mode);
+	_mav_put_uint8_t(buf, 4, target_system);
+	_mav_put_uint8_t(buf, 5, base_mode);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_MODE, buf, MAVLINK_MSG_ID_SET_MODE_LEN, MAVLINK_MSG_ID_SET_MODE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_MODE, buf, MAVLINK_MSG_ID_SET_MODE_LEN);
+#endif
+#else
+	mavlink_set_mode_t *packet = (mavlink_set_mode_t *)msgbuf;
+	packet->custom_mode = custom_mode;
+	packet->target_system = target_system;
+	packet->base_mode = base_mode;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_MODE, (const char *)packet, MAVLINK_MSG_ID_SET_MODE_LEN, MAVLINK_MSG_ID_SET_MODE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_MODE, (const char *)packet, MAVLINK_MSG_ID_SET_MODE_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -183,6 +252,6 @@ static inline void mavlink_msg_set_mode_
 	set_mode->target_system = mavlink_msg_set_mode_get_target_system(msg);
 	set_mode->base_mode = mavlink_msg_set_mode_get_base_mode(msg);
 #else
-	memcpy(set_mode, _MAV_PAYLOAD(msg), 6);
+	memcpy(set_mode, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SET_MODE_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_set_position_target_global_int.h v1.0/common/mavlink_msg_set_position_target_global_int.h
--- v1.0.old/common/mavlink_msg_set_position_target_global_int.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_set_position_target_global_int.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,569 @@
+// MESSAGE SET_POSITION_TARGET_GLOBAL_INT PACKING
+
+#define MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT 86
+
+typedef struct __mavlink_set_position_target_global_int_t
+{
+ uint32_t time_boot_ms; ///< Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
+ int32_t lat_int; ///< X Position in WGS84 frame in 1e7 * meters
+ int32_t lon_int; ///< Y Position in WGS84 frame in 1e7 * meters
+ float alt; ///< Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT
+ float vx; ///< X velocity in NED frame in meter / s
+ float vy; ///< Y velocity in NED frame in meter / s
+ float vz; ///< Z velocity in NED frame in meter / s
+ float afx; ///< X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ float afy; ///< Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ float afz; ///< Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ float yaw; ///< yaw setpoint in rad
+ float yaw_rate; ///< yaw rate setpoint in rad/s
+ uint16_t type_mask; ///< Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ uint8_t target_system; ///< System ID
+ uint8_t target_component; ///< Component ID
+ uint8_t coordinate_frame; ///< Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
+} mavlink_set_position_target_global_int_t;
+
+#define MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN 53
+#define MAVLINK_MSG_ID_86_LEN 53
+
+#define MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_CRC 5
+#define MAVLINK_MSG_ID_86_CRC 5
+
+
+
+#define MAVLINK_MESSAGE_INFO_SET_POSITION_TARGET_GLOBAL_INT { \
+	"SET_POSITION_TARGET_GLOBAL_INT", \
+	16, \
+	{  { "time_boot_ms", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_set_position_target_global_int_t, time_boot_ms) }, \
+         { "lat_int", NULL, MAVLINK_TYPE_INT32_T, 0, 4, offsetof(mavlink_set_position_target_global_int_t, lat_int) }, \
+         { "lon_int", NULL, MAVLINK_TYPE_INT32_T, 0, 8, offsetof(mavlink_set_position_target_global_int_t, lon_int) }, \
+         { "alt", NULL, MAVLINK_TYPE_FLOAT, 0, 12, offsetof(mavlink_set_position_target_global_int_t, alt) }, \
+         { "vx", NULL, MAVLINK_TYPE_FLOAT, 0, 16, offsetof(mavlink_set_position_target_global_int_t, vx) }, \
+         { "vy", NULL, MAVLINK_TYPE_FLOAT, 0, 20, offsetof(mavlink_set_position_target_global_int_t, vy) }, \
+         { "vz", NULL, MAVLINK_TYPE_FLOAT, 0, 24, offsetof(mavlink_set_position_target_global_int_t, vz) }, \
+         { "afx", NULL, MAVLINK_TYPE_FLOAT, 0, 28, offsetof(mavlink_set_position_target_global_int_t, afx) }, \
+         { "afy", NULL, MAVLINK_TYPE_FLOAT, 0, 32, offsetof(mavlink_set_position_target_global_int_t, afy) }, \
+         { "afz", NULL, MAVLINK_TYPE_FLOAT, 0, 36, offsetof(mavlink_set_position_target_global_int_t, afz) }, \
+         { "yaw", NULL, MAVLINK_TYPE_FLOAT, 0, 40, offsetof(mavlink_set_position_target_global_int_t, yaw) }, \
+         { "yaw_rate", NULL, MAVLINK_TYPE_FLOAT, 0, 44, offsetof(mavlink_set_position_target_global_int_t, yaw_rate) }, \
+         { "type_mask", NULL, MAVLINK_TYPE_UINT16_T, 0, 48, offsetof(mavlink_set_position_target_global_int_t, type_mask) }, \
+         { "target_system", NULL, MAVLINK_TYPE_UINT8_T, 0, 50, offsetof(mavlink_set_position_target_global_int_t, target_system) }, \
+         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 51, offsetof(mavlink_set_position_target_global_int_t, target_component) }, \
+         { "coordinate_frame", NULL, MAVLINK_TYPE_UINT8_T, 0, 52, offsetof(mavlink_set_position_target_global_int_t, coordinate_frame) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a set_position_target_global_int message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_boot_ms Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param coordinate_frame Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
+ * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ * @param lat_int X Position in WGS84 frame in 1e7 * meters
+ * @param lon_int Y Position in WGS84 frame in 1e7 * meters
+ * @param alt Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT
+ * @param vx X velocity in NED frame in meter / s
+ * @param vy Y velocity in NED frame in meter / s
+ * @param vz Z velocity in NED frame in meter / s
+ * @param afx X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afy Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afz Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param yaw yaw setpoint in rad
+ * @param yaw_rate yaw rate setpoint in rad/s
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_set_position_target_global_int_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint32_t time_boot_ms, uint8_t target_system, uint8_t target_component, uint8_t coordinate_frame, uint16_t type_mask, int32_t lat_int, int32_t lon_int, float alt, float vx, float vy, float vz, float afx, float afy, float afz, float yaw, float yaw_rate)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_int32_t(buf, 4, lat_int);
+	_mav_put_int32_t(buf, 8, lon_int);
+	_mav_put_float(buf, 12, alt);
+	_mav_put_float(buf, 16, vx);
+	_mav_put_float(buf, 20, vy);
+	_mav_put_float(buf, 24, vz);
+	_mav_put_float(buf, 28, afx);
+	_mav_put_float(buf, 32, afy);
+	_mav_put_float(buf, 36, afz);
+	_mav_put_float(buf, 40, yaw);
+	_mav_put_float(buf, 44, yaw_rate);
+	_mav_put_uint16_t(buf, 48, type_mask);
+	_mav_put_uint8_t(buf, 50, target_system);
+	_mav_put_uint8_t(buf, 51, target_component);
+	_mav_put_uint8_t(buf, 52, coordinate_frame);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN);
+#else
+	mavlink_set_position_target_global_int_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.lat_int = lat_int;
+	packet.lon_int = lon_int;
+	packet.alt = alt;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.afx = afx;
+	packet.afy = afy;
+	packet.afz = afz;
+	packet.yaw = yaw;
+	packet.yaw_rate = yaw_rate;
+	packet.type_mask = type_mask;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.coordinate_frame = coordinate_frame;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a set_position_target_global_int message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_boot_ms Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param coordinate_frame Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
+ * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ * @param lat_int X Position in WGS84 frame in 1e7 * meters
+ * @param lon_int Y Position in WGS84 frame in 1e7 * meters
+ * @param alt Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT
+ * @param vx X velocity in NED frame in meter / s
+ * @param vy Y velocity in NED frame in meter / s
+ * @param vz Z velocity in NED frame in meter / s
+ * @param afx X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afy Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afz Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param yaw yaw setpoint in rad
+ * @param yaw_rate yaw rate setpoint in rad/s
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_set_position_target_global_int_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint32_t time_boot_ms,uint8_t target_system,uint8_t target_component,uint8_t coordinate_frame,uint16_t type_mask,int32_t lat_int,int32_t lon_int,float alt,float vx,float vy,float vz,float afx,float afy,float afz,float yaw,float yaw_rate)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_int32_t(buf, 4, lat_int);
+	_mav_put_int32_t(buf, 8, lon_int);
+	_mav_put_float(buf, 12, alt);
+	_mav_put_float(buf, 16, vx);
+	_mav_put_float(buf, 20, vy);
+	_mav_put_float(buf, 24, vz);
+	_mav_put_float(buf, 28, afx);
+	_mav_put_float(buf, 32, afy);
+	_mav_put_float(buf, 36, afz);
+	_mav_put_float(buf, 40, yaw);
+	_mav_put_float(buf, 44, yaw_rate);
+	_mav_put_uint16_t(buf, 48, type_mask);
+	_mav_put_uint8_t(buf, 50, target_system);
+	_mav_put_uint8_t(buf, 51, target_component);
+	_mav_put_uint8_t(buf, 52, coordinate_frame);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN);
+#else
+	mavlink_set_position_target_global_int_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.lat_int = lat_int;
+	packet.lon_int = lon_int;
+	packet.alt = alt;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.afx = afx;
+	packet.afy = afy;
+	packet.afz = afz;
+	packet.yaw = yaw;
+	packet.yaw_rate = yaw_rate;
+	packet.type_mask = type_mask;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.coordinate_frame = coordinate_frame;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a set_position_target_global_int struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param set_position_target_global_int C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_set_position_target_global_int_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_set_position_target_global_int_t* set_position_target_global_int)
+{
+	return mavlink_msg_set_position_target_global_int_pack(system_id, component_id, msg, set_position_target_global_int->time_boot_ms, set_position_target_global_int->target_system, set_position_target_global_int->target_component, set_position_target_global_int->coordinate_frame, set_position_target_global_int->type_mask, set_position_target_global_int->lat_int, set_position_target_global_int->lon_int, set_position_target_global_int->alt, set_position_target_global_int->vx, set_position_target_global_int->vy, set_position_target_global_int->vz, set_position_target_global_int->afx, set_position_target_global_int->afy, set_position_target_global_int->afz, set_position_target_global_int->yaw, set_position_target_global_int->yaw_rate);
+}
+
+/**
+ * @brief Encode a set_position_target_global_int struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param set_position_target_global_int C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_set_position_target_global_int_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_set_position_target_global_int_t* set_position_target_global_int)
+{
+	return mavlink_msg_set_position_target_global_int_pack_chan(system_id, component_id, chan, msg, set_position_target_global_int->time_boot_ms, set_position_target_global_int->target_system, set_position_target_global_int->target_component, set_position_target_global_int->coordinate_frame, set_position_target_global_int->type_mask, set_position_target_global_int->lat_int, set_position_target_global_int->lon_int, set_position_target_global_int->alt, set_position_target_global_int->vx, set_position_target_global_int->vy, set_position_target_global_int->vz, set_position_target_global_int->afx, set_position_target_global_int->afy, set_position_target_global_int->afz, set_position_target_global_int->yaw, set_position_target_global_int->yaw_rate);
+}
+
+/**
+ * @brief Send a set_position_target_global_int message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_boot_ms Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param coordinate_frame Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
+ * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ * @param lat_int X Position in WGS84 frame in 1e7 * meters
+ * @param lon_int Y Position in WGS84 frame in 1e7 * meters
+ * @param alt Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT
+ * @param vx X velocity in NED frame in meter / s
+ * @param vy Y velocity in NED frame in meter / s
+ * @param vz Z velocity in NED frame in meter / s
+ * @param afx X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afy Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afz Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param yaw yaw setpoint in rad
+ * @param yaw_rate yaw rate setpoint in rad/s
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_set_position_target_global_int_send(mavlink_channel_t chan, uint32_t time_boot_ms, uint8_t target_system, uint8_t target_component, uint8_t coordinate_frame, uint16_t type_mask, int32_t lat_int, int32_t lon_int, float alt, float vx, float vy, float vz, float afx, float afy, float afz, float yaw, float yaw_rate)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_int32_t(buf, 4, lat_int);
+	_mav_put_int32_t(buf, 8, lon_int);
+	_mav_put_float(buf, 12, alt);
+	_mav_put_float(buf, 16, vx);
+	_mav_put_float(buf, 20, vy);
+	_mav_put_float(buf, 24, vz);
+	_mav_put_float(buf, 28, afx);
+	_mav_put_float(buf, 32, afy);
+	_mav_put_float(buf, 36, afz);
+	_mav_put_float(buf, 40, yaw);
+	_mav_put_float(buf, 44, yaw_rate);
+	_mav_put_uint16_t(buf, 48, type_mask);
+	_mav_put_uint8_t(buf, 50, target_system);
+	_mav_put_uint8_t(buf, 51, target_component);
+	_mav_put_uint8_t(buf, 52, coordinate_frame);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT, buf, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT, buf, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+#else
+	mavlink_set_position_target_global_int_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.lat_int = lat_int;
+	packet.lon_int = lon_int;
+	packet.alt = alt;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.afx = afx;
+	packet.afy = afy;
+	packet.afz = afz;
+	packet.yaw = yaw;
+	packet.yaw_rate = yaw_rate;
+	packet.type_mask = type_mask;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.coordinate_frame = coordinate_frame;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT, (const char *)&packet, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT, (const char *)&packet, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_set_position_target_global_int_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, uint8_t target_system, uint8_t target_component, uint8_t coordinate_frame, uint16_t type_mask, int32_t lat_int, int32_t lon_int, float alt, float vx, float vy, float vz, float afx, float afy, float afz, float yaw, float yaw_rate)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_int32_t(buf, 4, lat_int);
+	_mav_put_int32_t(buf, 8, lon_int);
+	_mav_put_float(buf, 12, alt);
+	_mav_put_float(buf, 16, vx);
+	_mav_put_float(buf, 20, vy);
+	_mav_put_float(buf, 24, vz);
+	_mav_put_float(buf, 28, afx);
+	_mav_put_float(buf, 32, afy);
+	_mav_put_float(buf, 36, afz);
+	_mav_put_float(buf, 40, yaw);
+	_mav_put_float(buf, 44, yaw_rate);
+	_mav_put_uint16_t(buf, 48, type_mask);
+	_mav_put_uint8_t(buf, 50, target_system);
+	_mav_put_uint8_t(buf, 51, target_component);
+	_mav_put_uint8_t(buf, 52, coordinate_frame);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT, buf, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT, buf, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+#else
+	mavlink_set_position_target_global_int_t *packet = (mavlink_set_position_target_global_int_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->lat_int = lat_int;
+	packet->lon_int = lon_int;
+	packet->alt = alt;
+	packet->vx = vx;
+	packet->vy = vy;
+	packet->vz = vz;
+	packet->afx = afx;
+	packet->afy = afy;
+	packet->afz = afz;
+	packet->yaw = yaw;
+	packet->yaw_rate = yaw_rate;
+	packet->type_mask = type_mask;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+	packet->coordinate_frame = coordinate_frame;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT, (const char *)packet, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT, (const char *)packet, MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE SET_POSITION_TARGET_GLOBAL_INT UNPACKING
+
+
+/**
+ * @brief Get field time_boot_ms from set_position_target_global_int message
+ *
+ * @return Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
+ */
+static inline uint32_t mavlink_msg_set_position_target_global_int_get_time_boot_ms(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field target_system from set_position_target_global_int message
+ *
+ * @return System ID
+ */
+static inline uint8_t mavlink_msg_set_position_target_global_int_get_target_system(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  50);
+}
+
+/**
+ * @brief Get field target_component from set_position_target_global_int message
+ *
+ * @return Component ID
+ */
+static inline uint8_t mavlink_msg_set_position_target_global_int_get_target_component(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  51);
+}
+
+/**
+ * @brief Get field coordinate_frame from set_position_target_global_int message
+ *
+ * @return Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
+ */
+static inline uint8_t mavlink_msg_set_position_target_global_int_get_coordinate_frame(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  52);
+}
+
+/**
+ * @brief Get field type_mask from set_position_target_global_int message
+ *
+ * @return Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ */
+static inline uint16_t mavlink_msg_set_position_target_global_int_get_type_mask(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  48);
+}
+
+/**
+ * @brief Get field lat_int from set_position_target_global_int message
+ *
+ * @return X Position in WGS84 frame in 1e7 * meters
+ */
+static inline int32_t mavlink_msg_set_position_target_global_int_get_lat_int(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  4);
+}
+
+/**
+ * @brief Get field lon_int from set_position_target_global_int message
+ *
+ * @return Y Position in WGS84 frame in 1e7 * meters
+ */
+static inline int32_t mavlink_msg_set_position_target_global_int_get_lon_int(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  8);
+}
+
+/**
+ * @brief Get field alt from set_position_target_global_int message
+ *
+ * @return Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT
+ */
+static inline float mavlink_msg_set_position_target_global_int_get_alt(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  12);
+}
+
+/**
+ * @brief Get field vx from set_position_target_global_int message
+ *
+ * @return X velocity in NED frame in meter / s
+ */
+static inline float mavlink_msg_set_position_target_global_int_get_vx(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  16);
+}
+
+/**
+ * @brief Get field vy from set_position_target_global_int message
+ *
+ * @return Y velocity in NED frame in meter / s
+ */
+static inline float mavlink_msg_set_position_target_global_int_get_vy(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  20);
+}
+
+/**
+ * @brief Get field vz from set_position_target_global_int message
+ *
+ * @return Z velocity in NED frame in meter / s
+ */
+static inline float mavlink_msg_set_position_target_global_int_get_vz(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  24);
+}
+
+/**
+ * @brief Get field afx from set_position_target_global_int message
+ *
+ * @return X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ */
+static inline float mavlink_msg_set_position_target_global_int_get_afx(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  28);
+}
+
+/**
+ * @brief Get field afy from set_position_target_global_int message
+ *
+ * @return Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ */
+static inline float mavlink_msg_set_position_target_global_int_get_afy(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  32);
+}
+
+/**
+ * @brief Get field afz from set_position_target_global_int message
+ *
+ * @return Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ */
+static inline float mavlink_msg_set_position_target_global_int_get_afz(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  36);
+}
+
+/**
+ * @brief Get field yaw from set_position_target_global_int message
+ *
+ * @return yaw setpoint in rad
+ */
+static inline float mavlink_msg_set_position_target_global_int_get_yaw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  40);
+}
+
+/**
+ * @brief Get field yaw_rate from set_position_target_global_int message
+ *
+ * @return yaw rate setpoint in rad/s
+ */
+static inline float mavlink_msg_set_position_target_global_int_get_yaw_rate(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  44);
+}
+
+/**
+ * @brief Decode a set_position_target_global_int message into a struct
+ *
+ * @param msg The message to decode
+ * @param set_position_target_global_int C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_set_position_target_global_int_decode(const mavlink_message_t* msg, mavlink_set_position_target_global_int_t* set_position_target_global_int)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	set_position_target_global_int->time_boot_ms = mavlink_msg_set_position_target_global_int_get_time_boot_ms(msg);
+	set_position_target_global_int->lat_int = mavlink_msg_set_position_target_global_int_get_lat_int(msg);
+	set_position_target_global_int->lon_int = mavlink_msg_set_position_target_global_int_get_lon_int(msg);
+	set_position_target_global_int->alt = mavlink_msg_set_position_target_global_int_get_alt(msg);
+	set_position_target_global_int->vx = mavlink_msg_set_position_target_global_int_get_vx(msg);
+	set_position_target_global_int->vy = mavlink_msg_set_position_target_global_int_get_vy(msg);
+	set_position_target_global_int->vz = mavlink_msg_set_position_target_global_int_get_vz(msg);
+	set_position_target_global_int->afx = mavlink_msg_set_position_target_global_int_get_afx(msg);
+	set_position_target_global_int->afy = mavlink_msg_set_position_target_global_int_get_afy(msg);
+	set_position_target_global_int->afz = mavlink_msg_set_position_target_global_int_get_afz(msg);
+	set_position_target_global_int->yaw = mavlink_msg_set_position_target_global_int_get_yaw(msg);
+	set_position_target_global_int->yaw_rate = mavlink_msg_set_position_target_global_int_get_yaw_rate(msg);
+	set_position_target_global_int->type_mask = mavlink_msg_set_position_target_global_int_get_type_mask(msg);
+	set_position_target_global_int->target_system = mavlink_msg_set_position_target_global_int_get_target_system(msg);
+	set_position_target_global_int->target_component = mavlink_msg_set_position_target_global_int_get_target_component(msg);
+	set_position_target_global_int->coordinate_frame = mavlink_msg_set_position_target_global_int_get_coordinate_frame(msg);
+#else
+	memcpy(set_position_target_global_int, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_set_position_target_local_ned.h v1.0/common/mavlink_msg_set_position_target_local_ned.h
--- v1.0.old/common/mavlink_msg_set_position_target_local_ned.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_set_position_target_local_ned.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,569 @@
+// MESSAGE SET_POSITION_TARGET_LOCAL_NED PACKING
+
+#define MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED 84
+
+typedef struct __mavlink_set_position_target_local_ned_t
+{
+ uint32_t time_boot_ms; ///< Timestamp in milliseconds since system boot
+ float x; ///< X Position in NED frame in meters
+ float y; ///< Y Position in NED frame in meters
+ float z; ///< Z Position in NED frame in meters (note, altitude is negative in NED)
+ float vx; ///< X velocity in NED frame in meter / s
+ float vy; ///< Y velocity in NED frame in meter / s
+ float vz; ///< Z velocity in NED frame in meter / s
+ float afx; ///< X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ float afy; ///< Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ float afz; ///< Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ float yaw; ///< yaw setpoint in rad
+ float yaw_rate; ///< yaw rate setpoint in rad/s
+ uint16_t type_mask; ///< Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ uint8_t target_system; ///< System ID
+ uint8_t target_component; ///< Component ID
+ uint8_t coordinate_frame; ///< Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
+} mavlink_set_position_target_local_ned_t;
+
+#define MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN 53
+#define MAVLINK_MSG_ID_84_LEN 53
+
+#define MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_CRC 143
+#define MAVLINK_MSG_ID_84_CRC 143
+
+
+
+#define MAVLINK_MESSAGE_INFO_SET_POSITION_TARGET_LOCAL_NED { \
+	"SET_POSITION_TARGET_LOCAL_NED", \
+	16, \
+	{  { "time_boot_ms", NULL, MAVLINK_TYPE_UINT32_T, 0, 0, offsetof(mavlink_set_position_target_local_ned_t, time_boot_ms) }, \
+         { "x", NULL, MAVLINK_TYPE_FLOAT, 0, 4, offsetof(mavlink_set_position_target_local_ned_t, x) }, \
+         { "y", NULL, MAVLINK_TYPE_FLOAT, 0, 8, offsetof(mavlink_set_position_target_local_ned_t, y) }, \
+         { "z", NULL, MAVLINK_TYPE_FLOAT, 0, 12, offsetof(mavlink_set_position_target_local_ned_t, z) }, \
+         { "vx", NULL, MAVLINK_TYPE_FLOAT, 0, 16, offsetof(mavlink_set_position_target_local_ned_t, vx) }, \
+         { "vy", NULL, MAVLINK_TYPE_FLOAT, 0, 20, offsetof(mavlink_set_position_target_local_ned_t, vy) }, \
+         { "vz", NULL, MAVLINK_TYPE_FLOAT, 0, 24, offsetof(mavlink_set_position_target_local_ned_t, vz) }, \
+         { "afx", NULL, MAVLINK_TYPE_FLOAT, 0, 28, offsetof(mavlink_set_position_target_local_ned_t, afx) }, \
+         { "afy", NULL, MAVLINK_TYPE_FLOAT, 0, 32, offsetof(mavlink_set_position_target_local_ned_t, afy) }, \
+         { "afz", NULL, MAVLINK_TYPE_FLOAT, 0, 36, offsetof(mavlink_set_position_target_local_ned_t, afz) }, \
+         { "yaw", NULL, MAVLINK_TYPE_FLOAT, 0, 40, offsetof(mavlink_set_position_target_local_ned_t, yaw) }, \
+         { "yaw_rate", NULL, MAVLINK_TYPE_FLOAT, 0, 44, offsetof(mavlink_set_position_target_local_ned_t, yaw_rate) }, \
+         { "type_mask", NULL, MAVLINK_TYPE_UINT16_T, 0, 48, offsetof(mavlink_set_position_target_local_ned_t, type_mask) }, \
+         { "target_system", NULL, MAVLINK_TYPE_UINT8_T, 0, 50, offsetof(mavlink_set_position_target_local_ned_t, target_system) }, \
+         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 51, offsetof(mavlink_set_position_target_local_ned_t, target_component) }, \
+         { "coordinate_frame", NULL, MAVLINK_TYPE_UINT8_T, 0, 52, offsetof(mavlink_set_position_target_local_ned_t, coordinate_frame) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a set_position_target_local_ned message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param time_boot_ms Timestamp in milliseconds since system boot
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param coordinate_frame Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
+ * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ * @param x X Position in NED frame in meters
+ * @param y Y Position in NED frame in meters
+ * @param z Z Position in NED frame in meters (note, altitude is negative in NED)
+ * @param vx X velocity in NED frame in meter / s
+ * @param vy Y velocity in NED frame in meter / s
+ * @param vz Z velocity in NED frame in meter / s
+ * @param afx X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afy Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afz Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param yaw yaw setpoint in rad
+ * @param yaw_rate yaw rate setpoint in rad/s
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_set_position_target_local_ned_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint32_t time_boot_ms, uint8_t target_system, uint8_t target_component, uint8_t coordinate_frame, uint16_t type_mask, float x, float y, float z, float vx, float vy, float vz, float afx, float afy, float afz, float yaw, float yaw_rate)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, x);
+	_mav_put_float(buf, 8, y);
+	_mav_put_float(buf, 12, z);
+	_mav_put_float(buf, 16, vx);
+	_mav_put_float(buf, 20, vy);
+	_mav_put_float(buf, 24, vz);
+	_mav_put_float(buf, 28, afx);
+	_mav_put_float(buf, 32, afy);
+	_mav_put_float(buf, 36, afz);
+	_mav_put_float(buf, 40, yaw);
+	_mav_put_float(buf, 44, yaw_rate);
+	_mav_put_uint16_t(buf, 48, type_mask);
+	_mav_put_uint8_t(buf, 50, target_system);
+	_mav_put_uint8_t(buf, 51, target_component);
+	_mav_put_uint8_t(buf, 52, coordinate_frame);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN);
+#else
+	mavlink_set_position_target_local_ned_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.afx = afx;
+	packet.afy = afy;
+	packet.afz = afz;
+	packet.yaw = yaw;
+	packet.yaw_rate = yaw_rate;
+	packet.type_mask = type_mask;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.coordinate_frame = coordinate_frame;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a set_position_target_local_ned message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param time_boot_ms Timestamp in milliseconds since system boot
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param coordinate_frame Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
+ * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ * @param x X Position in NED frame in meters
+ * @param y Y Position in NED frame in meters
+ * @param z Z Position in NED frame in meters (note, altitude is negative in NED)
+ * @param vx X velocity in NED frame in meter / s
+ * @param vy Y velocity in NED frame in meter / s
+ * @param vz Z velocity in NED frame in meter / s
+ * @param afx X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afy Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afz Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param yaw yaw setpoint in rad
+ * @param yaw_rate yaw rate setpoint in rad/s
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_set_position_target_local_ned_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint32_t time_boot_ms,uint8_t target_system,uint8_t target_component,uint8_t coordinate_frame,uint16_t type_mask,float x,float y,float z,float vx,float vy,float vz,float afx,float afy,float afz,float yaw,float yaw_rate)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, x);
+	_mav_put_float(buf, 8, y);
+	_mav_put_float(buf, 12, z);
+	_mav_put_float(buf, 16, vx);
+	_mav_put_float(buf, 20, vy);
+	_mav_put_float(buf, 24, vz);
+	_mav_put_float(buf, 28, afx);
+	_mav_put_float(buf, 32, afy);
+	_mav_put_float(buf, 36, afz);
+	_mav_put_float(buf, 40, yaw);
+	_mav_put_float(buf, 44, yaw_rate);
+	_mav_put_uint16_t(buf, 48, type_mask);
+	_mav_put_uint8_t(buf, 50, target_system);
+	_mav_put_uint8_t(buf, 51, target_component);
+	_mav_put_uint8_t(buf, 52, coordinate_frame);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN);
+#else
+	mavlink_set_position_target_local_ned_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.afx = afx;
+	packet.afy = afy;
+	packet.afz = afz;
+	packet.yaw = yaw;
+	packet.yaw_rate = yaw_rate;
+	packet.type_mask = type_mask;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.coordinate_frame = coordinate_frame;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a set_position_target_local_ned struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param set_position_target_local_ned C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_set_position_target_local_ned_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_set_position_target_local_ned_t* set_position_target_local_ned)
+{
+	return mavlink_msg_set_position_target_local_ned_pack(system_id, component_id, msg, set_position_target_local_ned->time_boot_ms, set_position_target_local_ned->target_system, set_position_target_local_ned->target_component, set_position_target_local_ned->coordinate_frame, set_position_target_local_ned->type_mask, set_position_target_local_ned->x, set_position_target_local_ned->y, set_position_target_local_ned->z, set_position_target_local_ned->vx, set_position_target_local_ned->vy, set_position_target_local_ned->vz, set_position_target_local_ned->afx, set_position_target_local_ned->afy, set_position_target_local_ned->afz, set_position_target_local_ned->yaw, set_position_target_local_ned->yaw_rate);
+}
+
+/**
+ * @brief Encode a set_position_target_local_ned struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param set_position_target_local_ned C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_set_position_target_local_ned_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_set_position_target_local_ned_t* set_position_target_local_ned)
+{
+	return mavlink_msg_set_position_target_local_ned_pack_chan(system_id, component_id, chan, msg, set_position_target_local_ned->time_boot_ms, set_position_target_local_ned->target_system, set_position_target_local_ned->target_component, set_position_target_local_ned->coordinate_frame, set_position_target_local_ned->type_mask, set_position_target_local_ned->x, set_position_target_local_ned->y, set_position_target_local_ned->z, set_position_target_local_ned->vx, set_position_target_local_ned->vy, set_position_target_local_ned->vz, set_position_target_local_ned->afx, set_position_target_local_ned->afy, set_position_target_local_ned->afz, set_position_target_local_ned->yaw, set_position_target_local_ned->yaw_rate);
+}
+
+/**
+ * @brief Send a set_position_target_local_ned message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param time_boot_ms Timestamp in milliseconds since system boot
+ * @param target_system System ID
+ * @param target_component Component ID
+ * @param coordinate_frame Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
+ * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ * @param x X Position in NED frame in meters
+ * @param y Y Position in NED frame in meters
+ * @param z Z Position in NED frame in meters (note, altitude is negative in NED)
+ * @param vx X velocity in NED frame in meter / s
+ * @param vy Y velocity in NED frame in meter / s
+ * @param vz Z velocity in NED frame in meter / s
+ * @param afx X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afy Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param afz Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ * @param yaw yaw setpoint in rad
+ * @param yaw_rate yaw rate setpoint in rad/s
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_set_position_target_local_ned_send(mavlink_channel_t chan, uint32_t time_boot_ms, uint8_t target_system, uint8_t target_component, uint8_t coordinate_frame, uint16_t type_mask, float x, float y, float z, float vx, float vy, float vz, float afx, float afy, float afz, float yaw, float yaw_rate)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN];
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, x);
+	_mav_put_float(buf, 8, y);
+	_mav_put_float(buf, 12, z);
+	_mav_put_float(buf, 16, vx);
+	_mav_put_float(buf, 20, vy);
+	_mav_put_float(buf, 24, vz);
+	_mav_put_float(buf, 28, afx);
+	_mav_put_float(buf, 32, afy);
+	_mav_put_float(buf, 36, afz);
+	_mav_put_float(buf, 40, yaw);
+	_mav_put_float(buf, 44, yaw_rate);
+	_mav_put_uint16_t(buf, 48, type_mask);
+	_mav_put_uint8_t(buf, 50, target_system);
+	_mav_put_uint8_t(buf, 51, target_component);
+	_mav_put_uint8_t(buf, 52, coordinate_frame);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED, buf, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED, buf, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+#else
+	mavlink_set_position_target_local_ned_t packet;
+	packet.time_boot_ms = time_boot_ms;
+	packet.x = x;
+	packet.y = y;
+	packet.z = z;
+	packet.vx = vx;
+	packet.vy = vy;
+	packet.vz = vz;
+	packet.afx = afx;
+	packet.afy = afy;
+	packet.afz = afz;
+	packet.yaw = yaw;
+	packet.yaw_rate = yaw_rate;
+	packet.type_mask = type_mask;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	packet.coordinate_frame = coordinate_frame;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED, (const char *)&packet, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED, (const char *)&packet, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_set_position_target_local_ned_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t time_boot_ms, uint8_t target_system, uint8_t target_component, uint8_t coordinate_frame, uint16_t type_mask, float x, float y, float z, float vx, float vy, float vz, float afx, float afy, float afz, float yaw, float yaw_rate)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, time_boot_ms);
+	_mav_put_float(buf, 4, x);
+	_mav_put_float(buf, 8, y);
+	_mav_put_float(buf, 12, z);
+	_mav_put_float(buf, 16, vx);
+	_mav_put_float(buf, 20, vy);
+	_mav_put_float(buf, 24, vz);
+	_mav_put_float(buf, 28, afx);
+	_mav_put_float(buf, 32, afy);
+	_mav_put_float(buf, 36, afz);
+	_mav_put_float(buf, 40, yaw);
+	_mav_put_float(buf, 44, yaw_rate);
+	_mav_put_uint16_t(buf, 48, type_mask);
+	_mav_put_uint8_t(buf, 50, target_system);
+	_mav_put_uint8_t(buf, 51, target_component);
+	_mav_put_uint8_t(buf, 52, coordinate_frame);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED, buf, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED, buf, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+#else
+	mavlink_set_position_target_local_ned_t *packet = (mavlink_set_position_target_local_ned_t *)msgbuf;
+	packet->time_boot_ms = time_boot_ms;
+	packet->x = x;
+	packet->y = y;
+	packet->z = z;
+	packet->vx = vx;
+	packet->vy = vy;
+	packet->vz = vz;
+	packet->afx = afx;
+	packet->afy = afy;
+	packet->afz = afz;
+	packet->yaw = yaw;
+	packet->yaw_rate = yaw_rate;
+	packet->type_mask = type_mask;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+	packet->coordinate_frame = coordinate_frame;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED, (const char *)packet, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED, (const char *)packet, MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE SET_POSITION_TARGET_LOCAL_NED UNPACKING
+
+
+/**
+ * @brief Get field time_boot_ms from set_position_target_local_ned message
+ *
+ * @return Timestamp in milliseconds since system boot
+ */
+static inline uint32_t mavlink_msg_set_position_target_local_ned_get_time_boot_ms(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint32_t(msg,  0);
+}
+
+/**
+ * @brief Get field target_system from set_position_target_local_ned message
+ *
+ * @return System ID
+ */
+static inline uint8_t mavlink_msg_set_position_target_local_ned_get_target_system(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  50);
+}
+
+/**
+ * @brief Get field target_component from set_position_target_local_ned message
+ *
+ * @return Component ID
+ */
+static inline uint8_t mavlink_msg_set_position_target_local_ned_get_target_component(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  51);
+}
+
+/**
+ * @brief Get field coordinate_frame from set_position_target_local_ned message
+ *
+ * @return Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
+ */
+static inline uint8_t mavlink_msg_set_position_target_local_ned_get_coordinate_frame(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  52);
+}
+
+/**
+ * @brief Get field type_mask from set_position_target_local_ned message
+ *
+ * @return Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
+ */
+static inline uint16_t mavlink_msg_set_position_target_local_ned_get_type_mask(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  48);
+}
+
+/**
+ * @brief Get field x from set_position_target_local_ned message
+ *
+ * @return X Position in NED frame in meters
+ */
+static inline float mavlink_msg_set_position_target_local_ned_get_x(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  4);
+}
+
+/**
+ * @brief Get field y from set_position_target_local_ned message
+ *
+ * @return Y Position in NED frame in meters
+ */
+static inline float mavlink_msg_set_position_target_local_ned_get_y(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  8);
+}
+
+/**
+ * @brief Get field z from set_position_target_local_ned message
+ *
+ * @return Z Position in NED frame in meters (note, altitude is negative in NED)
+ */
+static inline float mavlink_msg_set_position_target_local_ned_get_z(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  12);
+}
+
+/**
+ * @brief Get field vx from set_position_target_local_ned message
+ *
+ * @return X velocity in NED frame in meter / s
+ */
+static inline float mavlink_msg_set_position_target_local_ned_get_vx(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  16);
+}
+
+/**
+ * @brief Get field vy from set_position_target_local_ned message
+ *
+ * @return Y velocity in NED frame in meter / s
+ */
+static inline float mavlink_msg_set_position_target_local_ned_get_vy(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  20);
+}
+
+/**
+ * @brief Get field vz from set_position_target_local_ned message
+ *
+ * @return Z velocity in NED frame in meter / s
+ */
+static inline float mavlink_msg_set_position_target_local_ned_get_vz(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  24);
+}
+
+/**
+ * @brief Get field afx from set_position_target_local_ned message
+ *
+ * @return X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ */
+static inline float mavlink_msg_set_position_target_local_ned_get_afx(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  28);
+}
+
+/**
+ * @brief Get field afy from set_position_target_local_ned message
+ *
+ * @return Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ */
+static inline float mavlink_msg_set_position_target_local_ned_get_afy(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  32);
+}
+
+/**
+ * @brief Get field afz from set_position_target_local_ned message
+ *
+ * @return Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
+ */
+static inline float mavlink_msg_set_position_target_local_ned_get_afz(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  36);
+}
+
+/**
+ * @brief Get field yaw from set_position_target_local_ned message
+ *
+ * @return yaw setpoint in rad
+ */
+static inline float mavlink_msg_set_position_target_local_ned_get_yaw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  40);
+}
+
+/**
+ * @brief Get field yaw_rate from set_position_target_local_ned message
+ *
+ * @return yaw rate setpoint in rad/s
+ */
+static inline float mavlink_msg_set_position_target_local_ned_get_yaw_rate(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  44);
+}
+
+/**
+ * @brief Decode a set_position_target_local_ned message into a struct
+ *
+ * @param msg The message to decode
+ * @param set_position_target_local_ned C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_set_position_target_local_ned_decode(const mavlink_message_t* msg, mavlink_set_position_target_local_ned_t* set_position_target_local_ned)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	set_position_target_local_ned->time_boot_ms = mavlink_msg_set_position_target_local_ned_get_time_boot_ms(msg);
+	set_position_target_local_ned->x = mavlink_msg_set_position_target_local_ned_get_x(msg);
+	set_position_target_local_ned->y = mavlink_msg_set_position_target_local_ned_get_y(msg);
+	set_position_target_local_ned->z = mavlink_msg_set_position_target_local_ned_get_z(msg);
+	set_position_target_local_ned->vx = mavlink_msg_set_position_target_local_ned_get_vx(msg);
+	set_position_target_local_ned->vy = mavlink_msg_set_position_target_local_ned_get_vy(msg);
+	set_position_target_local_ned->vz = mavlink_msg_set_position_target_local_ned_get_vz(msg);
+	set_position_target_local_ned->afx = mavlink_msg_set_position_target_local_ned_get_afx(msg);
+	set_position_target_local_ned->afy = mavlink_msg_set_position_target_local_ned_get_afy(msg);
+	set_position_target_local_ned->afz = mavlink_msg_set_position_target_local_ned_get_afz(msg);
+	set_position_target_local_ned->yaw = mavlink_msg_set_position_target_local_ned_get_yaw(msg);
+	set_position_target_local_ned->yaw_rate = mavlink_msg_set_position_target_local_ned_get_yaw_rate(msg);
+	set_position_target_local_ned->type_mask = mavlink_msg_set_position_target_local_ned_get_type_mask(msg);
+	set_position_target_local_ned->target_system = mavlink_msg_set_position_target_local_ned_get_target_system(msg);
+	set_position_target_local_ned->target_component = mavlink_msg_set_position_target_local_ned_get_target_component(msg);
+	set_position_target_local_ned->coordinate_frame = mavlink_msg_set_position_target_local_ned_get_coordinate_frame(msg);
+#else
+	memcpy(set_position_target_local_ned, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_sim_state.h v1.0/common/mavlink_msg_sim_state.h
--- v1.0.old/common/mavlink_msg_sim_state.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_sim_state.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,689 @@
+// MESSAGE SIM_STATE PACKING
+
+#define MAVLINK_MSG_ID_SIM_STATE 108
+
+typedef struct __mavlink_sim_state_t
+{
+ float q1; ///< True attitude quaternion component 1, w (1 in null-rotation)
+ float q2; ///< True attitude quaternion component 2, x (0 in null-rotation)
+ float q3; ///< True attitude quaternion component 3, y (0 in null-rotation)
+ float q4; ///< True attitude quaternion component 4, z (0 in null-rotation)
+ float roll; ///< Attitude roll expressed as Euler angles, not recommended except for human-readable outputs
+ float pitch; ///< Attitude pitch expressed as Euler angles, not recommended except for human-readable outputs
+ float yaw; ///< Attitude yaw expressed as Euler angles, not recommended except for human-readable outputs
+ float xacc; ///< X acceleration m/s/s
+ float yacc; ///< Y acceleration m/s/s
+ float zacc; ///< Z acceleration m/s/s
+ float xgyro; ///< Angular speed around X axis rad/s
+ float ygyro; ///< Angular speed around Y axis rad/s
+ float zgyro; ///< Angular speed around Z axis rad/s
+ float lat; ///< Latitude in degrees
+ float lon; ///< Longitude in degrees
+ float alt; ///< Altitude in meters
+ float std_dev_horz; ///< Horizontal position standard deviation
+ float std_dev_vert; ///< Vertical position standard deviation
+ float vn; ///< True velocity in m/s in NORTH direction in earth-fixed NED frame
+ float ve; ///< True velocity in m/s in EAST direction in earth-fixed NED frame
+ float vd; ///< True velocity in m/s in DOWN direction in earth-fixed NED frame
+} mavlink_sim_state_t;
+
+#define MAVLINK_MSG_ID_SIM_STATE_LEN 84
+#define MAVLINK_MSG_ID_108_LEN 84
+
+#define MAVLINK_MSG_ID_SIM_STATE_CRC 32
+#define MAVLINK_MSG_ID_108_CRC 32
+
+
+
+#define MAVLINK_MESSAGE_INFO_SIM_STATE { \
+	"SIM_STATE", \
+	21, \
+	{  { "q1", NULL, MAVLINK_TYPE_FLOAT, 0, 0, offsetof(mavlink_sim_state_t, q1) }, \
+         { "q2", NULL, MAVLINK_TYPE_FLOAT, 0, 4, offsetof(mavlink_sim_state_t, q2) }, \
+         { "q3", NULL, MAVLINK_TYPE_FLOAT, 0, 8, offsetof(mavlink_sim_state_t, q3) }, \
+         { "q4", NULL, MAVLINK_TYPE_FLOAT, 0, 12, offsetof(mavlink_sim_state_t, q4) }, \
+         { "roll", NULL, MAVLINK_TYPE_FLOAT, 0, 16, offsetof(mavlink_sim_state_t, roll) }, \
+         { "pitch", NULL, MAVLINK_TYPE_FLOAT, 0, 20, offsetof(mavlink_sim_state_t, pitch) }, \
+         { "yaw", NULL, MAVLINK_TYPE_FLOAT, 0, 24, offsetof(mavlink_sim_state_t, yaw) }, \
+         { "xacc", NULL, MAVLINK_TYPE_FLOAT, 0, 28, offsetof(mavlink_sim_state_t, xacc) }, \
+         { "yacc", NULL, MAVLINK_TYPE_FLOAT, 0, 32, offsetof(mavlink_sim_state_t, yacc) }, \
+         { "zacc", NULL, MAVLINK_TYPE_FLOAT, 0, 36, offsetof(mavlink_sim_state_t, zacc) }, \
+         { "xgyro", NULL, MAVLINK_TYPE_FLOAT, 0, 40, offsetof(mavlink_sim_state_t, xgyro) }, \
+         { "ygyro", NULL, MAVLINK_TYPE_FLOAT, 0, 44, offsetof(mavlink_sim_state_t, ygyro) }, \
+         { "zgyro", NULL, MAVLINK_TYPE_FLOAT, 0, 48, offsetof(mavlink_sim_state_t, zgyro) }, \
+         { "lat", NULL, MAVLINK_TYPE_FLOAT, 0, 52, offsetof(mavlink_sim_state_t, lat) }, \
+         { "lon", NULL, MAVLINK_TYPE_FLOAT, 0, 56, offsetof(mavlink_sim_state_t, lon) }, \
+         { "alt", NULL, MAVLINK_TYPE_FLOAT, 0, 60, offsetof(mavlink_sim_state_t, alt) }, \
+         { "std_dev_horz", NULL, MAVLINK_TYPE_FLOAT, 0, 64, offsetof(mavlink_sim_state_t, std_dev_horz) }, \
+         { "std_dev_vert", NULL, MAVLINK_TYPE_FLOAT, 0, 68, offsetof(mavlink_sim_state_t, std_dev_vert) }, \
+         { "vn", NULL, MAVLINK_TYPE_FLOAT, 0, 72, offsetof(mavlink_sim_state_t, vn) }, \
+         { "ve", NULL, MAVLINK_TYPE_FLOAT, 0, 76, offsetof(mavlink_sim_state_t, ve) }, \
+         { "vd", NULL, MAVLINK_TYPE_FLOAT, 0, 80, offsetof(mavlink_sim_state_t, vd) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a sim_state message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param q1 True attitude quaternion component 1, w (1 in null-rotation)
+ * @param q2 True attitude quaternion component 2, x (0 in null-rotation)
+ * @param q3 True attitude quaternion component 3, y (0 in null-rotation)
+ * @param q4 True attitude quaternion component 4, z (0 in null-rotation)
+ * @param roll Attitude roll expressed as Euler angles, not recommended except for human-readable outputs
+ * @param pitch Attitude pitch expressed as Euler angles, not recommended except for human-readable outputs
+ * @param yaw Attitude yaw expressed as Euler angles, not recommended except for human-readable outputs
+ * @param xacc X acceleration m/s/s
+ * @param yacc Y acceleration m/s/s
+ * @param zacc Z acceleration m/s/s
+ * @param xgyro Angular speed around X axis rad/s
+ * @param ygyro Angular speed around Y axis rad/s
+ * @param zgyro Angular speed around Z axis rad/s
+ * @param lat Latitude in degrees
+ * @param lon Longitude in degrees
+ * @param alt Altitude in meters
+ * @param std_dev_horz Horizontal position standard deviation
+ * @param std_dev_vert Vertical position standard deviation
+ * @param vn True velocity in m/s in NORTH direction in earth-fixed NED frame
+ * @param ve True velocity in m/s in EAST direction in earth-fixed NED frame
+ * @param vd True velocity in m/s in DOWN direction in earth-fixed NED frame
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_sim_state_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       float q1, float q2, float q3, float q4, float roll, float pitch, float yaw, float xacc, float yacc, float zacc, float xgyro, float ygyro, float zgyro, float lat, float lon, float alt, float std_dev_horz, float std_dev_vert, float vn, float ve, float vd)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SIM_STATE_LEN];
+	_mav_put_float(buf, 0, q1);
+	_mav_put_float(buf, 4, q2);
+	_mav_put_float(buf, 8, q3);
+	_mav_put_float(buf, 12, q4);
+	_mav_put_float(buf, 16, roll);
+	_mav_put_float(buf, 20, pitch);
+	_mav_put_float(buf, 24, yaw);
+	_mav_put_float(buf, 28, xacc);
+	_mav_put_float(buf, 32, yacc);
+	_mav_put_float(buf, 36, zacc);
+	_mav_put_float(buf, 40, xgyro);
+	_mav_put_float(buf, 44, ygyro);
+	_mav_put_float(buf, 48, zgyro);
+	_mav_put_float(buf, 52, lat);
+	_mav_put_float(buf, 56, lon);
+	_mav_put_float(buf, 60, alt);
+	_mav_put_float(buf, 64, std_dev_horz);
+	_mav_put_float(buf, 68, std_dev_vert);
+	_mav_put_float(buf, 72, vn);
+	_mav_put_float(buf, 76, ve);
+	_mav_put_float(buf, 80, vd);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SIM_STATE_LEN);
+#else
+	mavlink_sim_state_t packet;
+	packet.q1 = q1;
+	packet.q2 = q2;
+	packet.q3 = q3;
+	packet.q4 = q4;
+	packet.roll = roll;
+	packet.pitch = pitch;
+	packet.yaw = yaw;
+	packet.xacc = xacc;
+	packet.yacc = yacc;
+	packet.zacc = zacc;
+	packet.xgyro = xgyro;
+	packet.ygyro = ygyro;
+	packet.zgyro = zgyro;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.alt = alt;
+	packet.std_dev_horz = std_dev_horz;
+	packet.std_dev_vert = std_dev_vert;
+	packet.vn = vn;
+	packet.ve = ve;
+	packet.vd = vd;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SIM_STATE_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_SIM_STATE;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SIM_STATE_LEN, MAVLINK_MSG_ID_SIM_STATE_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SIM_STATE_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a sim_state message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param q1 True attitude quaternion component 1, w (1 in null-rotation)
+ * @param q2 True attitude quaternion component 2, x (0 in null-rotation)
+ * @param q3 True attitude quaternion component 3, y (0 in null-rotation)
+ * @param q4 True attitude quaternion component 4, z (0 in null-rotation)
+ * @param roll Attitude roll expressed as Euler angles, not recommended except for human-readable outputs
+ * @param pitch Attitude pitch expressed as Euler angles, not recommended except for human-readable outputs
+ * @param yaw Attitude yaw expressed as Euler angles, not recommended except for human-readable outputs
+ * @param xacc X acceleration m/s/s
+ * @param yacc Y acceleration m/s/s
+ * @param zacc Z acceleration m/s/s
+ * @param xgyro Angular speed around X axis rad/s
+ * @param ygyro Angular speed around Y axis rad/s
+ * @param zgyro Angular speed around Z axis rad/s
+ * @param lat Latitude in degrees
+ * @param lon Longitude in degrees
+ * @param alt Altitude in meters
+ * @param std_dev_horz Horizontal position standard deviation
+ * @param std_dev_vert Vertical position standard deviation
+ * @param vn True velocity in m/s in NORTH direction in earth-fixed NED frame
+ * @param ve True velocity in m/s in EAST direction in earth-fixed NED frame
+ * @param vd True velocity in m/s in DOWN direction in earth-fixed NED frame
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_sim_state_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           float q1,float q2,float q3,float q4,float roll,float pitch,float yaw,float xacc,float yacc,float zacc,float xgyro,float ygyro,float zgyro,float lat,float lon,float alt,float std_dev_horz,float std_dev_vert,float vn,float ve,float vd)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SIM_STATE_LEN];
+	_mav_put_float(buf, 0, q1);
+	_mav_put_float(buf, 4, q2);
+	_mav_put_float(buf, 8, q3);
+	_mav_put_float(buf, 12, q4);
+	_mav_put_float(buf, 16, roll);
+	_mav_put_float(buf, 20, pitch);
+	_mav_put_float(buf, 24, yaw);
+	_mav_put_float(buf, 28, xacc);
+	_mav_put_float(buf, 32, yacc);
+	_mav_put_float(buf, 36, zacc);
+	_mav_put_float(buf, 40, xgyro);
+	_mav_put_float(buf, 44, ygyro);
+	_mav_put_float(buf, 48, zgyro);
+	_mav_put_float(buf, 52, lat);
+	_mav_put_float(buf, 56, lon);
+	_mav_put_float(buf, 60, alt);
+	_mav_put_float(buf, 64, std_dev_horz);
+	_mav_put_float(buf, 68, std_dev_vert);
+	_mav_put_float(buf, 72, vn);
+	_mav_put_float(buf, 76, ve);
+	_mav_put_float(buf, 80, vd);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SIM_STATE_LEN);
+#else
+	mavlink_sim_state_t packet;
+	packet.q1 = q1;
+	packet.q2 = q2;
+	packet.q3 = q3;
+	packet.q4 = q4;
+	packet.roll = roll;
+	packet.pitch = pitch;
+	packet.yaw = yaw;
+	packet.xacc = xacc;
+	packet.yacc = yacc;
+	packet.zacc = zacc;
+	packet.xgyro = xgyro;
+	packet.ygyro = ygyro;
+	packet.zgyro = zgyro;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.alt = alt;
+	packet.std_dev_horz = std_dev_horz;
+	packet.std_dev_vert = std_dev_vert;
+	packet.vn = vn;
+	packet.ve = ve;
+	packet.vd = vd;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SIM_STATE_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_SIM_STATE;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SIM_STATE_LEN, MAVLINK_MSG_ID_SIM_STATE_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SIM_STATE_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a sim_state struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param sim_state C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_sim_state_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_sim_state_t* sim_state)
+{
+	return mavlink_msg_sim_state_pack(system_id, component_id, msg, sim_state->q1, sim_state->q2, sim_state->q3, sim_state->q4, sim_state->roll, sim_state->pitch, sim_state->yaw, sim_state->xacc, sim_state->yacc, sim_state->zacc, sim_state->xgyro, sim_state->ygyro, sim_state->zgyro, sim_state->lat, sim_state->lon, sim_state->alt, sim_state->std_dev_horz, sim_state->std_dev_vert, sim_state->vn, sim_state->ve, sim_state->vd);
+}
+
+/**
+ * @brief Encode a sim_state struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param sim_state C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_sim_state_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_sim_state_t* sim_state)
+{
+	return mavlink_msg_sim_state_pack_chan(system_id, component_id, chan, msg, sim_state->q1, sim_state->q2, sim_state->q3, sim_state->q4, sim_state->roll, sim_state->pitch, sim_state->yaw, sim_state->xacc, sim_state->yacc, sim_state->zacc, sim_state->xgyro, sim_state->ygyro, sim_state->zgyro, sim_state->lat, sim_state->lon, sim_state->alt, sim_state->std_dev_horz, sim_state->std_dev_vert, sim_state->vn, sim_state->ve, sim_state->vd);
+}
+
+/**
+ * @brief Send a sim_state message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param q1 True attitude quaternion component 1, w (1 in null-rotation)
+ * @param q2 True attitude quaternion component 2, x (0 in null-rotation)
+ * @param q3 True attitude quaternion component 3, y (0 in null-rotation)
+ * @param q4 True attitude quaternion component 4, z (0 in null-rotation)
+ * @param roll Attitude roll expressed as Euler angles, not recommended except for human-readable outputs
+ * @param pitch Attitude pitch expressed as Euler angles, not recommended except for human-readable outputs
+ * @param yaw Attitude yaw expressed as Euler angles, not recommended except for human-readable outputs
+ * @param xacc X acceleration m/s/s
+ * @param yacc Y acceleration m/s/s
+ * @param zacc Z acceleration m/s/s
+ * @param xgyro Angular speed around X axis rad/s
+ * @param ygyro Angular speed around Y axis rad/s
+ * @param zgyro Angular speed around Z axis rad/s
+ * @param lat Latitude in degrees
+ * @param lon Longitude in degrees
+ * @param alt Altitude in meters
+ * @param std_dev_horz Horizontal position standard deviation
+ * @param std_dev_vert Vertical position standard deviation
+ * @param vn True velocity in m/s in NORTH direction in earth-fixed NED frame
+ * @param ve True velocity in m/s in EAST direction in earth-fixed NED frame
+ * @param vd True velocity in m/s in DOWN direction in earth-fixed NED frame
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_sim_state_send(mavlink_channel_t chan, float q1, float q2, float q3, float q4, float roll, float pitch, float yaw, float xacc, float yacc, float zacc, float xgyro, float ygyro, float zgyro, float lat, float lon, float alt, float std_dev_horz, float std_dev_vert, float vn, float ve, float vd)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_SIM_STATE_LEN];
+	_mav_put_float(buf, 0, q1);
+	_mav_put_float(buf, 4, q2);
+	_mav_put_float(buf, 8, q3);
+	_mav_put_float(buf, 12, q4);
+	_mav_put_float(buf, 16, roll);
+	_mav_put_float(buf, 20, pitch);
+	_mav_put_float(buf, 24, yaw);
+	_mav_put_float(buf, 28, xacc);
+	_mav_put_float(buf, 32, yacc);
+	_mav_put_float(buf, 36, zacc);
+	_mav_put_float(buf, 40, xgyro);
+	_mav_put_float(buf, 44, ygyro);
+	_mav_put_float(buf, 48, zgyro);
+	_mav_put_float(buf, 52, lat);
+	_mav_put_float(buf, 56, lon);
+	_mav_put_float(buf, 60, alt);
+	_mav_put_float(buf, 64, std_dev_horz);
+	_mav_put_float(buf, 68, std_dev_vert);
+	_mav_put_float(buf, 72, vn);
+	_mav_put_float(buf, 76, ve);
+	_mav_put_float(buf, 80, vd);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SIM_STATE, buf, MAVLINK_MSG_ID_SIM_STATE_LEN, MAVLINK_MSG_ID_SIM_STATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SIM_STATE, buf, MAVLINK_MSG_ID_SIM_STATE_LEN);
+#endif
+#else
+	mavlink_sim_state_t packet;
+	packet.q1 = q1;
+	packet.q2 = q2;
+	packet.q3 = q3;
+	packet.q4 = q4;
+	packet.roll = roll;
+	packet.pitch = pitch;
+	packet.yaw = yaw;
+	packet.xacc = xacc;
+	packet.yacc = yacc;
+	packet.zacc = zacc;
+	packet.xgyro = xgyro;
+	packet.ygyro = ygyro;
+	packet.zgyro = zgyro;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.alt = alt;
+	packet.std_dev_horz = std_dev_horz;
+	packet.std_dev_vert = std_dev_vert;
+	packet.vn = vn;
+	packet.ve = ve;
+	packet.vd = vd;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SIM_STATE, (const char *)&packet, MAVLINK_MSG_ID_SIM_STATE_LEN, MAVLINK_MSG_ID_SIM_STATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SIM_STATE, (const char *)&packet, MAVLINK_MSG_ID_SIM_STATE_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_SIM_STATE_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_sim_state_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  float q1, float q2, float q3, float q4, float roll, float pitch, float yaw, float xacc, float yacc, float zacc, float xgyro, float ygyro, float zgyro, float lat, float lon, float alt, float std_dev_horz, float std_dev_vert, float vn, float ve, float vd)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_float(buf, 0, q1);
+	_mav_put_float(buf, 4, q2);
+	_mav_put_float(buf, 8, q3);
+	_mav_put_float(buf, 12, q4);
+	_mav_put_float(buf, 16, roll);
+	_mav_put_float(buf, 20, pitch);
+	_mav_put_float(buf, 24, yaw);
+	_mav_put_float(buf, 28, xacc);
+	_mav_put_float(buf, 32, yacc);
+	_mav_put_float(buf, 36, zacc);
+	_mav_put_float(buf, 40, xgyro);
+	_mav_put_float(buf, 44, ygyro);
+	_mav_put_float(buf, 48, zgyro);
+	_mav_put_float(buf, 52, lat);
+	_mav_put_float(buf, 56, lon);
+	_mav_put_float(buf, 60, alt);
+	_mav_put_float(buf, 64, std_dev_horz);
+	_mav_put_float(buf, 68, std_dev_vert);
+	_mav_put_float(buf, 72, vn);
+	_mav_put_float(buf, 76, ve);
+	_mav_put_float(buf, 80, vd);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SIM_STATE, buf, MAVLINK_MSG_ID_SIM_STATE_LEN, MAVLINK_MSG_ID_SIM_STATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SIM_STATE, buf, MAVLINK_MSG_ID_SIM_STATE_LEN);
+#endif
+#else
+	mavlink_sim_state_t *packet = (mavlink_sim_state_t *)msgbuf;
+	packet->q1 = q1;
+	packet->q2 = q2;
+	packet->q3 = q3;
+	packet->q4 = q4;
+	packet->roll = roll;
+	packet->pitch = pitch;
+	packet->yaw = yaw;
+	packet->xacc = xacc;
+	packet->yacc = yacc;
+	packet->zacc = zacc;
+	packet->xgyro = xgyro;
+	packet->ygyro = ygyro;
+	packet->zgyro = zgyro;
+	packet->lat = lat;
+	packet->lon = lon;
+	packet->alt = alt;
+	packet->std_dev_horz = std_dev_horz;
+	packet->std_dev_vert = std_dev_vert;
+	packet->vn = vn;
+	packet->ve = ve;
+	packet->vd = vd;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SIM_STATE, (const char *)packet, MAVLINK_MSG_ID_SIM_STATE_LEN, MAVLINK_MSG_ID_SIM_STATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SIM_STATE, (const char *)packet, MAVLINK_MSG_ID_SIM_STATE_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE SIM_STATE UNPACKING
+
+
+/**
+ * @brief Get field q1 from sim_state message
+ *
+ * @return True attitude quaternion component 1, w (1 in null-rotation)
+ */
+static inline float mavlink_msg_sim_state_get_q1(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  0);
+}
+
+/**
+ * @brief Get field q2 from sim_state message
+ *
+ * @return True attitude quaternion component 2, x (0 in null-rotation)
+ */
+static inline float mavlink_msg_sim_state_get_q2(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  4);
+}
+
+/**
+ * @brief Get field q3 from sim_state message
+ *
+ * @return True attitude quaternion component 3, y (0 in null-rotation)
+ */
+static inline float mavlink_msg_sim_state_get_q3(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  8);
+}
+
+/**
+ * @brief Get field q4 from sim_state message
+ *
+ * @return True attitude quaternion component 4, z (0 in null-rotation)
+ */
+static inline float mavlink_msg_sim_state_get_q4(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  12);
+}
+
+/**
+ * @brief Get field roll from sim_state message
+ *
+ * @return Attitude roll expressed as Euler angles, not recommended except for human-readable outputs
+ */
+static inline float mavlink_msg_sim_state_get_roll(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  16);
+}
+
+/**
+ * @brief Get field pitch from sim_state message
+ *
+ * @return Attitude pitch expressed as Euler angles, not recommended except for human-readable outputs
+ */
+static inline float mavlink_msg_sim_state_get_pitch(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  20);
+}
+
+/**
+ * @brief Get field yaw from sim_state message
+ *
+ * @return Attitude yaw expressed as Euler angles, not recommended except for human-readable outputs
+ */
+static inline float mavlink_msg_sim_state_get_yaw(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  24);
+}
+
+/**
+ * @brief Get field xacc from sim_state message
+ *
+ * @return X acceleration m/s/s
+ */
+static inline float mavlink_msg_sim_state_get_xacc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  28);
+}
+
+/**
+ * @brief Get field yacc from sim_state message
+ *
+ * @return Y acceleration m/s/s
+ */
+static inline float mavlink_msg_sim_state_get_yacc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  32);
+}
+
+/**
+ * @brief Get field zacc from sim_state message
+ *
+ * @return Z acceleration m/s/s
+ */
+static inline float mavlink_msg_sim_state_get_zacc(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  36);
+}
+
+/**
+ * @brief Get field xgyro from sim_state message
+ *
+ * @return Angular speed around X axis rad/s
+ */
+static inline float mavlink_msg_sim_state_get_xgyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  40);
+}
+
+/**
+ * @brief Get field ygyro from sim_state message
+ *
+ * @return Angular speed around Y axis rad/s
+ */
+static inline float mavlink_msg_sim_state_get_ygyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  44);
+}
+
+/**
+ * @brief Get field zgyro from sim_state message
+ *
+ * @return Angular speed around Z axis rad/s
+ */
+static inline float mavlink_msg_sim_state_get_zgyro(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  48);
+}
+
+/**
+ * @brief Get field lat from sim_state message
+ *
+ * @return Latitude in degrees
+ */
+static inline float mavlink_msg_sim_state_get_lat(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  52);
+}
+
+/**
+ * @brief Get field lon from sim_state message
+ *
+ * @return Longitude in degrees
+ */
+static inline float mavlink_msg_sim_state_get_lon(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  56);
+}
+
+/**
+ * @brief Get field alt from sim_state message
+ *
+ * @return Altitude in meters
+ */
+static inline float mavlink_msg_sim_state_get_alt(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  60);
+}
+
+/**
+ * @brief Get field std_dev_horz from sim_state message
+ *
+ * @return Horizontal position standard deviation
+ */
+static inline float mavlink_msg_sim_state_get_std_dev_horz(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  64);
+}
+
+/**
+ * @brief Get field std_dev_vert from sim_state message
+ *
+ * @return Vertical position standard deviation
+ */
+static inline float mavlink_msg_sim_state_get_std_dev_vert(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  68);
+}
+
+/**
+ * @brief Get field vn from sim_state message
+ *
+ * @return True velocity in m/s in NORTH direction in earth-fixed NED frame
+ */
+static inline float mavlink_msg_sim_state_get_vn(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  72);
+}
+
+/**
+ * @brief Get field ve from sim_state message
+ *
+ * @return True velocity in m/s in EAST direction in earth-fixed NED frame
+ */
+static inline float mavlink_msg_sim_state_get_ve(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  76);
+}
+
+/**
+ * @brief Get field vd from sim_state message
+ *
+ * @return True velocity in m/s in DOWN direction in earth-fixed NED frame
+ */
+static inline float mavlink_msg_sim_state_get_vd(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  80);
+}
+
+/**
+ * @brief Decode a sim_state message into a struct
+ *
+ * @param msg The message to decode
+ * @param sim_state C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_sim_state_decode(const mavlink_message_t* msg, mavlink_sim_state_t* sim_state)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	sim_state->q1 = mavlink_msg_sim_state_get_q1(msg);
+	sim_state->q2 = mavlink_msg_sim_state_get_q2(msg);
+	sim_state->q3 = mavlink_msg_sim_state_get_q3(msg);
+	sim_state->q4 = mavlink_msg_sim_state_get_q4(msg);
+	sim_state->roll = mavlink_msg_sim_state_get_roll(msg);
+	sim_state->pitch = mavlink_msg_sim_state_get_pitch(msg);
+	sim_state->yaw = mavlink_msg_sim_state_get_yaw(msg);
+	sim_state->xacc = mavlink_msg_sim_state_get_xacc(msg);
+	sim_state->yacc = mavlink_msg_sim_state_get_yacc(msg);
+	sim_state->zacc = mavlink_msg_sim_state_get_zacc(msg);
+	sim_state->xgyro = mavlink_msg_sim_state_get_xgyro(msg);
+	sim_state->ygyro = mavlink_msg_sim_state_get_ygyro(msg);
+	sim_state->zgyro = mavlink_msg_sim_state_get_zgyro(msg);
+	sim_state->lat = mavlink_msg_sim_state_get_lat(msg);
+	sim_state->lon = mavlink_msg_sim_state_get_lon(msg);
+	sim_state->alt = mavlink_msg_sim_state_get_alt(msg);
+	sim_state->std_dev_horz = mavlink_msg_sim_state_get_std_dev_horz(msg);
+	sim_state->std_dev_vert = mavlink_msg_sim_state_get_std_dev_vert(msg);
+	sim_state->vn = mavlink_msg_sim_state_get_vn(msg);
+	sim_state->ve = mavlink_msg_sim_state_get_ve(msg);
+	sim_state->vd = mavlink_msg_sim_state_get_vd(msg);
+#else
+	memcpy(sim_state, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SIM_STATE_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_statustext.h v1.0/common/mavlink_msg_statustext.h
--- v1.0.old/common/mavlink_msg_statustext.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_statustext.h	2015-02-06 11:50:58.000000000 +0500
@@ -11,6 +11,9 @@ typedef struct __mavlink_statustext_t
 #define MAVLINK_MSG_ID_STATUSTEXT_LEN 51
 #define MAVLINK_MSG_ID_253_LEN 51
 
+#define MAVLINK_MSG_ID_STATUSTEXT_CRC 83
+#define MAVLINK_MSG_ID_253_CRC 83
+
 #define MAVLINK_MSG_STATUSTEXT_FIELD_TEXT_LEN 50
 
 #define MAVLINK_MESSAGE_INFO_STATUSTEXT { \
@@ -36,26 +39,30 @@ static inline uint16_t mavlink_msg_statu
 						       uint8_t severity, const char *text)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[51];
+	char buf[MAVLINK_MSG_ID_STATUSTEXT_LEN];
 	_mav_put_uint8_t(buf, 0, severity);
 	_mav_put_char_array(buf, 1, text, 50);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 51);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_STATUSTEXT_LEN);
 #else
 	mavlink_statustext_t packet;
 	packet.severity = severity;
 	mav_array_memcpy(packet.text, text, sizeof(char)*50);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 51);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_STATUSTEXT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_STATUSTEXT;
-	return mavlink_finalize_message(msg, system_id, component_id, 51, 83);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_STATUSTEXT_LEN, MAVLINK_MSG_ID_STATUSTEXT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_STATUSTEXT_LEN);
+#endif
 }
 
 /**
  * @brief Pack a statustext message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param severity Severity of status. Relies on the definitions within RFC-5424. See enum MAV_SEVERITY.
  * @param text Status text message, without null termination character
@@ -66,23 +73,27 @@ static inline uint16_t mavlink_msg_statu
 						           uint8_t severity,const char *text)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[51];
+	char buf[MAVLINK_MSG_ID_STATUSTEXT_LEN];
 	_mav_put_uint8_t(buf, 0, severity);
 	_mav_put_char_array(buf, 1, text, 50);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 51);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_STATUSTEXT_LEN);
 #else
 	mavlink_statustext_t packet;
 	packet.severity = severity;
 	mav_array_memcpy(packet.text, text, sizeof(char)*50);
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 51);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_STATUSTEXT_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_STATUSTEXT;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 51, 83);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_STATUSTEXT_LEN, MAVLINK_MSG_ID_STATUSTEXT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_STATUSTEXT_LEN);
+#endif
 }
 
 /**
- * @brief Encode a statustext struct into a message
+ * @brief Encode a statustext struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -95,6 +106,20 @@ static inline uint16_t mavlink_msg_statu
 }
 
 /**
+ * @brief Encode a statustext struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param statustext C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_statustext_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_statustext_t* statustext)
+{
+	return mavlink_msg_statustext_pack_chan(system_id, component_id, chan, msg, statustext->severity, statustext->text);
+}
+
+/**
  * @brief Send a statustext message
  * @param chan MAVLink channel to send the message
  *
@@ -106,17 +131,57 @@ static inline uint16_t mavlink_msg_statu
 static inline void mavlink_msg_statustext_send(mavlink_channel_t chan, uint8_t severity, const char *text)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[51];
+	char buf[MAVLINK_MSG_ID_STATUSTEXT_LEN];
 	_mav_put_uint8_t(buf, 0, severity);
 	_mav_put_char_array(buf, 1, text, 50);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_STATUSTEXT, buf, 51, 83);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_STATUSTEXT, buf, MAVLINK_MSG_ID_STATUSTEXT_LEN, MAVLINK_MSG_ID_STATUSTEXT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_STATUSTEXT, buf, MAVLINK_MSG_ID_STATUSTEXT_LEN);
+#endif
 #else
 	mavlink_statustext_t packet;
 	packet.severity = severity;
 	mav_array_memcpy(packet.text, text, sizeof(char)*50);
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_STATUSTEXT, (const char *)&packet, 51, 83);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_STATUSTEXT, (const char *)&packet, MAVLINK_MSG_ID_STATUSTEXT_LEN, MAVLINK_MSG_ID_STATUSTEXT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_STATUSTEXT, (const char *)&packet, MAVLINK_MSG_ID_STATUSTEXT_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_STATUSTEXT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_statustext_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t severity, const char *text)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint8_t(buf, 0, severity);
+	_mav_put_char_array(buf, 1, text, 50);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_STATUSTEXT, buf, MAVLINK_MSG_ID_STATUSTEXT_LEN, MAVLINK_MSG_ID_STATUSTEXT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_STATUSTEXT, buf, MAVLINK_MSG_ID_STATUSTEXT_LEN);
+#endif
+#else
+	mavlink_statustext_t *packet = (mavlink_statustext_t *)msgbuf;
+	packet->severity = severity;
+	mav_array_memcpy(packet->text, text, sizeof(char)*50);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_STATUSTEXT, (const char *)packet, MAVLINK_MSG_ID_STATUSTEXT_LEN, MAVLINK_MSG_ID_STATUSTEXT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_STATUSTEXT, (const char *)packet, MAVLINK_MSG_ID_STATUSTEXT_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -155,6 +220,6 @@ static inline void mavlink_msg_statustex
 	statustext->severity = mavlink_msg_statustext_get_severity(msg);
 	mavlink_msg_statustext_get_text(msg, statustext->text);
 #else
-	memcpy(statustext, _MAV_PAYLOAD(msg), 51);
+	memcpy(statustext, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_STATUSTEXT_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_sys_status.h v1.0/common/mavlink_msg_sys_status.h
--- v1.0.old/common/mavlink_msg_sys_status.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_sys_status.h	2015-02-06 11:50:58.000000000 +0500
@@ -4,9 +4,9 @@
 
 typedef struct __mavlink_sys_status_t
 {
- uint32_t onboard_control_sensors_present; ///< Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices: 0: 3D gyro, 1: 3D acc, 2: 3D mag, 3: absolute pressure, 4: differential pressure, 5: GPS, 6: optical flow, 7: computer vision position, 8: laser based position, 9: external ground-truth (Vicon or Leica). Controllers: 10: 3D angular rate control 11: attitude stabilization, 12: yaw position, 13: z/altitude control, 14: x/y position control, 15: motor outputs / control
- uint32_t onboard_control_sensors_enabled; ///< Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices: 0: 3D gyro, 1: 3D acc, 2: 3D mag, 3: absolute pressure, 4: differential pressure, 5: GPS, 6: optical flow, 7: computer vision position, 8: laser based position, 9: external ground-truth (Vicon or Leica). Controllers: 10: 3D angular rate control 11: attitude stabilization, 12: yaw position, 13: z/altitude control, 14: x/y position control, 15: motor outputs / control
- uint32_t onboard_control_sensors_health; ///< Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices: 0: 3D gyro, 1: 3D acc, 2: 3D mag, 3: absolute pressure, 4: differential pressure, 5: GPS, 6: optical flow, 7: computer vision position, 8: laser based position, 9: external ground-truth (Vicon or Leica). Controllers: 10: 3D angular rate control 11: attitude stabilization, 12: yaw position, 13: z/altitude control, 14: x/y position control, 15: motor outputs / control
+ uint32_t onboard_control_sensors_present; ///< Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
+ uint32_t onboard_control_sensors_enabled; ///< Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
+ uint32_t onboard_control_sensors_health; ///< Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
  uint16_t load; ///< Maximum usage in percent of the mainloop time, (0%: 0, 100%: 1000) should be always below 1000
  uint16_t voltage_battery; ///< Battery voltage, in millivolts (1 = 1 millivolt)
  int16_t current_battery; ///< Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
@@ -22,6 +22,9 @@ typedef struct __mavlink_sys_status_t
 #define MAVLINK_MSG_ID_SYS_STATUS_LEN 31
 #define MAVLINK_MSG_ID_1_LEN 31
 
+#define MAVLINK_MSG_ID_SYS_STATUS_CRC 124
+#define MAVLINK_MSG_ID_1_CRC 124
+
 
 
 #define MAVLINK_MESSAGE_INFO_SYS_STATUS { \
@@ -50,9 +53,9 @@ typedef struct __mavlink_sys_status_t
  * @param component_id ID of this component (e.g. 200 for IMU)
  * @param msg The MAVLink message to compress the data into
  *
- * @param onboard_control_sensors_present Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices: 0: 3D gyro, 1: 3D acc, 2: 3D mag, 3: absolute pressure, 4: differential pressure, 5: GPS, 6: optical flow, 7: computer vision position, 8: laser based position, 9: external ground-truth (Vicon or Leica). Controllers: 10: 3D angular rate control 11: attitude stabilization, 12: yaw position, 13: z/altitude control, 14: x/y position control, 15: motor outputs / control
- * @param onboard_control_sensors_enabled Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices: 0: 3D gyro, 1: 3D acc, 2: 3D mag, 3: absolute pressure, 4: differential pressure, 5: GPS, 6: optical flow, 7: computer vision position, 8: laser based position, 9: external ground-truth (Vicon or Leica). Controllers: 10: 3D angular rate control 11: attitude stabilization, 12: yaw position, 13: z/altitude control, 14: x/y position control, 15: motor outputs / control
- * @param onboard_control_sensors_health Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices: 0: 3D gyro, 1: 3D acc, 2: 3D mag, 3: absolute pressure, 4: differential pressure, 5: GPS, 6: optical flow, 7: computer vision position, 8: laser based position, 9: external ground-truth (Vicon or Leica). Controllers: 10: 3D angular rate control 11: attitude stabilization, 12: yaw position, 13: z/altitude control, 14: x/y position control, 15: motor outputs / control
+ * @param onboard_control_sensors_present Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
+ * @param onboard_control_sensors_enabled Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
+ * @param onboard_control_sensors_health Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
  * @param load Maximum usage in percent of the mainloop time, (0%: 0, 100%: 1000) should be always below 1000
  * @param voltage_battery Battery voltage, in millivolts (1 = 1 millivolt)
  * @param current_battery Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
@@ -69,7 +72,7 @@ static inline uint16_t mavlink_msg_sys_s
 						       uint32_t onboard_control_sensors_present, uint32_t onboard_control_sensors_enabled, uint32_t onboard_control_sensors_health, uint16_t load, uint16_t voltage_battery, int16_t current_battery, int8_t battery_remaining, uint16_t drop_rate_comm, uint16_t errors_comm, uint16_t errors_count1, uint16_t errors_count2, uint16_t errors_count3, uint16_t errors_count4)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[31];
+	char buf[MAVLINK_MSG_ID_SYS_STATUS_LEN];
 	_mav_put_uint32_t(buf, 0, onboard_control_sensors_present);
 	_mav_put_uint32_t(buf, 4, onboard_control_sensors_enabled);
 	_mav_put_uint32_t(buf, 8, onboard_control_sensors_health);
@@ -84,7 +87,7 @@ static inline uint16_t mavlink_msg_sys_s
 	_mav_put_uint16_t(buf, 28, errors_count4);
 	_mav_put_int8_t(buf, 30, battery_remaining);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 31);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SYS_STATUS_LEN);
 #else
 	mavlink_sys_status_t packet;
 	packet.onboard_control_sensors_present = onboard_control_sensors_present;
@@ -101,22 +104,26 @@ static inline uint16_t mavlink_msg_sys_s
 	packet.errors_count4 = errors_count4;
 	packet.battery_remaining = battery_remaining;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 31);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SYS_STATUS_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SYS_STATUS;
-	return mavlink_finalize_message(msg, system_id, component_id, 31, 124);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SYS_STATUS_LEN, MAVLINK_MSG_ID_SYS_STATUS_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SYS_STATUS_LEN);
+#endif
 }
 
 /**
  * @brief Pack a sys_status message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
- * @param onboard_control_sensors_present Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices: 0: 3D gyro, 1: 3D acc, 2: 3D mag, 3: absolute pressure, 4: differential pressure, 5: GPS, 6: optical flow, 7: computer vision position, 8: laser based position, 9: external ground-truth (Vicon or Leica). Controllers: 10: 3D angular rate control 11: attitude stabilization, 12: yaw position, 13: z/altitude control, 14: x/y position control, 15: motor outputs / control
- * @param onboard_control_sensors_enabled Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices: 0: 3D gyro, 1: 3D acc, 2: 3D mag, 3: absolute pressure, 4: differential pressure, 5: GPS, 6: optical flow, 7: computer vision position, 8: laser based position, 9: external ground-truth (Vicon or Leica). Controllers: 10: 3D angular rate control 11: attitude stabilization, 12: yaw position, 13: z/altitude control, 14: x/y position control, 15: motor outputs / control
- * @param onboard_control_sensors_health Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices: 0: 3D gyro, 1: 3D acc, 2: 3D mag, 3: absolute pressure, 4: differential pressure, 5: GPS, 6: optical flow, 7: computer vision position, 8: laser based position, 9: external ground-truth (Vicon or Leica). Controllers: 10: 3D angular rate control 11: attitude stabilization, 12: yaw position, 13: z/altitude control, 14: x/y position control, 15: motor outputs / control
+ * @param onboard_control_sensors_present Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
+ * @param onboard_control_sensors_enabled Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
+ * @param onboard_control_sensors_health Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
  * @param load Maximum usage in percent of the mainloop time, (0%: 0, 100%: 1000) should be always below 1000
  * @param voltage_battery Battery voltage, in millivolts (1 = 1 millivolt)
  * @param current_battery Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
@@ -134,7 +141,7 @@ static inline uint16_t mavlink_msg_sys_s
 						           uint32_t onboard_control_sensors_present,uint32_t onboard_control_sensors_enabled,uint32_t onboard_control_sensors_health,uint16_t load,uint16_t voltage_battery,int16_t current_battery,int8_t battery_remaining,uint16_t drop_rate_comm,uint16_t errors_comm,uint16_t errors_count1,uint16_t errors_count2,uint16_t errors_count3,uint16_t errors_count4)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[31];
+	char buf[MAVLINK_MSG_ID_SYS_STATUS_LEN];
 	_mav_put_uint32_t(buf, 0, onboard_control_sensors_present);
 	_mav_put_uint32_t(buf, 4, onboard_control_sensors_enabled);
 	_mav_put_uint32_t(buf, 8, onboard_control_sensors_health);
@@ -149,7 +156,7 @@ static inline uint16_t mavlink_msg_sys_s
 	_mav_put_uint16_t(buf, 28, errors_count4);
 	_mav_put_int8_t(buf, 30, battery_remaining);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 31);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SYS_STATUS_LEN);
 #else
 	mavlink_sys_status_t packet;
 	packet.onboard_control_sensors_present = onboard_control_sensors_present;
@@ -166,15 +173,19 @@ static inline uint16_t mavlink_msg_sys_s
 	packet.errors_count4 = errors_count4;
 	packet.battery_remaining = battery_remaining;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 31);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SYS_STATUS_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SYS_STATUS;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 31, 124);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SYS_STATUS_LEN, MAVLINK_MSG_ID_SYS_STATUS_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SYS_STATUS_LEN);
+#endif
 }
 
 /**
- * @brief Encode a sys_status struct into a message
+ * @brief Encode a sys_status struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -187,12 +198,26 @@ static inline uint16_t mavlink_msg_sys_s
 }
 
 /**
+ * @brief Encode a sys_status struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param sys_status C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_sys_status_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_sys_status_t* sys_status)
+{
+	return mavlink_msg_sys_status_pack_chan(system_id, component_id, chan, msg, sys_status->onboard_control_sensors_present, sys_status->onboard_control_sensors_enabled, sys_status->onboard_control_sensors_health, sys_status->load, sys_status->voltage_battery, sys_status->current_battery, sys_status->battery_remaining, sys_status->drop_rate_comm, sys_status->errors_comm, sys_status->errors_count1, sys_status->errors_count2, sys_status->errors_count3, sys_status->errors_count4);
+}
+
+/**
  * @brief Send a sys_status message
  * @param chan MAVLink channel to send the message
  *
- * @param onboard_control_sensors_present Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices: 0: 3D gyro, 1: 3D acc, 2: 3D mag, 3: absolute pressure, 4: differential pressure, 5: GPS, 6: optical flow, 7: computer vision position, 8: laser based position, 9: external ground-truth (Vicon or Leica). Controllers: 10: 3D angular rate control 11: attitude stabilization, 12: yaw position, 13: z/altitude control, 14: x/y position control, 15: motor outputs / control
- * @param onboard_control_sensors_enabled Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices: 0: 3D gyro, 1: 3D acc, 2: 3D mag, 3: absolute pressure, 4: differential pressure, 5: GPS, 6: optical flow, 7: computer vision position, 8: laser based position, 9: external ground-truth (Vicon or Leica). Controllers: 10: 3D angular rate control 11: attitude stabilization, 12: yaw position, 13: z/altitude control, 14: x/y position control, 15: motor outputs / control
- * @param onboard_control_sensors_health Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices: 0: 3D gyro, 1: 3D acc, 2: 3D mag, 3: absolute pressure, 4: differential pressure, 5: GPS, 6: optical flow, 7: computer vision position, 8: laser based position, 9: external ground-truth (Vicon or Leica). Controllers: 10: 3D angular rate control 11: attitude stabilization, 12: yaw position, 13: z/altitude control, 14: x/y position control, 15: motor outputs / control
+ * @param onboard_control_sensors_present Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
+ * @param onboard_control_sensors_enabled Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
+ * @param onboard_control_sensors_health Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
  * @param load Maximum usage in percent of the mainloop time, (0%: 0, 100%: 1000) should be always below 1000
  * @param voltage_battery Battery voltage, in millivolts (1 = 1 millivolt)
  * @param current_battery Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
@@ -209,7 +234,7 @@ static inline uint16_t mavlink_msg_sys_s
 static inline void mavlink_msg_sys_status_send(mavlink_channel_t chan, uint32_t onboard_control_sensors_present, uint32_t onboard_control_sensors_enabled, uint32_t onboard_control_sensors_health, uint16_t load, uint16_t voltage_battery, int16_t current_battery, int8_t battery_remaining, uint16_t drop_rate_comm, uint16_t errors_comm, uint16_t errors_count1, uint16_t errors_count2, uint16_t errors_count3, uint16_t errors_count4)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[31];
+	char buf[MAVLINK_MSG_ID_SYS_STATUS_LEN];
 	_mav_put_uint32_t(buf, 0, onboard_control_sensors_present);
 	_mav_put_uint32_t(buf, 4, onboard_control_sensors_enabled);
 	_mav_put_uint32_t(buf, 8, onboard_control_sensors_health);
@@ -224,7 +249,11 @@ static inline void mavlink_msg_sys_statu
 	_mav_put_uint16_t(buf, 28, errors_count4);
 	_mav_put_int8_t(buf, 30, battery_remaining);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYS_STATUS, buf, 31, 124);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYS_STATUS, buf, MAVLINK_MSG_ID_SYS_STATUS_LEN, MAVLINK_MSG_ID_SYS_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYS_STATUS, buf, MAVLINK_MSG_ID_SYS_STATUS_LEN);
+#endif
 #else
 	mavlink_sys_status_t packet;
 	packet.onboard_control_sensors_present = onboard_control_sensors_present;
@@ -241,9 +270,69 @@ static inline void mavlink_msg_sys_statu
 	packet.errors_count4 = errors_count4;
 	packet.battery_remaining = battery_remaining;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYS_STATUS, (const char *)&packet, 31, 124);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYS_STATUS, (const char *)&packet, MAVLINK_MSG_ID_SYS_STATUS_LEN, MAVLINK_MSG_ID_SYS_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYS_STATUS, (const char *)&packet, MAVLINK_MSG_ID_SYS_STATUS_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_SYS_STATUS_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_sys_status_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint32_t onboard_control_sensors_present, uint32_t onboard_control_sensors_enabled, uint32_t onboard_control_sensors_health, uint16_t load, uint16_t voltage_battery, int16_t current_battery, int8_t battery_remaining, uint16_t drop_rate_comm, uint16_t errors_comm, uint16_t errors_count1, uint16_t errors_count2, uint16_t errors_count3, uint16_t errors_count4)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint32_t(buf, 0, onboard_control_sensors_present);
+	_mav_put_uint32_t(buf, 4, onboard_control_sensors_enabled);
+	_mav_put_uint32_t(buf, 8, onboard_control_sensors_health);
+	_mav_put_uint16_t(buf, 12, load);
+	_mav_put_uint16_t(buf, 14, voltage_battery);
+	_mav_put_int16_t(buf, 16, current_battery);
+	_mav_put_uint16_t(buf, 18, drop_rate_comm);
+	_mav_put_uint16_t(buf, 20, errors_comm);
+	_mav_put_uint16_t(buf, 22, errors_count1);
+	_mav_put_uint16_t(buf, 24, errors_count2);
+	_mav_put_uint16_t(buf, 26, errors_count3);
+	_mav_put_uint16_t(buf, 28, errors_count4);
+	_mav_put_int8_t(buf, 30, battery_remaining);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYS_STATUS, buf, MAVLINK_MSG_ID_SYS_STATUS_LEN, MAVLINK_MSG_ID_SYS_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYS_STATUS, buf, MAVLINK_MSG_ID_SYS_STATUS_LEN);
+#endif
+#else
+	mavlink_sys_status_t *packet = (mavlink_sys_status_t *)msgbuf;
+	packet->onboard_control_sensors_present = onboard_control_sensors_present;
+	packet->onboard_control_sensors_enabled = onboard_control_sensors_enabled;
+	packet->onboard_control_sensors_health = onboard_control_sensors_health;
+	packet->load = load;
+	packet->voltage_battery = voltage_battery;
+	packet->current_battery = current_battery;
+	packet->drop_rate_comm = drop_rate_comm;
+	packet->errors_comm = errors_comm;
+	packet->errors_count1 = errors_count1;
+	packet->errors_count2 = errors_count2;
+	packet->errors_count3 = errors_count3;
+	packet->errors_count4 = errors_count4;
+	packet->battery_remaining = battery_remaining;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYS_STATUS, (const char *)packet, MAVLINK_MSG_ID_SYS_STATUS_LEN, MAVLINK_MSG_ID_SYS_STATUS_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYS_STATUS, (const char *)packet, MAVLINK_MSG_ID_SYS_STATUS_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -253,7 +342,7 @@ static inline void mavlink_msg_sys_statu
 /**
  * @brief Get field onboard_control_sensors_present from sys_status message
  *
- * @return Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices: 0: 3D gyro, 1: 3D acc, 2: 3D mag, 3: absolute pressure, 4: differential pressure, 5: GPS, 6: optical flow, 7: computer vision position, 8: laser based position, 9: external ground-truth (Vicon or Leica). Controllers: 10: 3D angular rate control 11: attitude stabilization, 12: yaw position, 13: z/altitude control, 14: x/y position control, 15: motor outputs / control
+ * @return Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
  */
 static inline uint32_t mavlink_msg_sys_status_get_onboard_control_sensors_present(const mavlink_message_t* msg)
 {
@@ -263,7 +352,7 @@ static inline uint32_t mavlink_msg_sys_s
 /**
  * @brief Get field onboard_control_sensors_enabled from sys_status message
  *
- * @return Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices: 0: 3D gyro, 1: 3D acc, 2: 3D mag, 3: absolute pressure, 4: differential pressure, 5: GPS, 6: optical flow, 7: computer vision position, 8: laser based position, 9: external ground-truth (Vicon or Leica). Controllers: 10: 3D angular rate control 11: attitude stabilization, 12: yaw position, 13: z/altitude control, 14: x/y position control, 15: motor outputs / control
+ * @return Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
  */
 static inline uint32_t mavlink_msg_sys_status_get_onboard_control_sensors_enabled(const mavlink_message_t* msg)
 {
@@ -273,7 +362,7 @@ static inline uint32_t mavlink_msg_sys_s
 /**
  * @brief Get field onboard_control_sensors_health from sys_status message
  *
- * @return Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices: 0: 3D gyro, 1: 3D acc, 2: 3D mag, 3: absolute pressure, 4: differential pressure, 5: GPS, 6: optical flow, 7: computer vision position, 8: laser based position, 9: external ground-truth (Vicon or Leica). Controllers: 10: 3D angular rate control 11: attitude stabilization, 12: yaw position, 13: z/altitude control, 14: x/y position control, 15: motor outputs / control
+ * @return Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
  */
 static inline uint32_t mavlink_msg_sys_status_get_onboard_control_sensors_health(const mavlink_message_t* msg)
 {
@@ -403,6 +492,6 @@ static inline void mavlink_msg_sys_statu
 	sys_status->errors_count4 = mavlink_msg_sys_status_get_errors_count4(msg);
 	sys_status->battery_remaining = mavlink_msg_sys_status_get_battery_remaining(msg);
 #else
-	memcpy(sys_status, _MAV_PAYLOAD(msg), 31);
+	memcpy(sys_status, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SYS_STATUS_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_system_time.h v1.0/common/mavlink_msg_system_time.h
--- v1.0.old/common/mavlink_msg_system_time.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_system_time.h	2015-02-06 11:50:58.000000000 +0500
@@ -11,6 +11,9 @@ typedef struct __mavlink_system_time_t
 #define MAVLINK_MSG_ID_SYSTEM_TIME_LEN 12
 #define MAVLINK_MSG_ID_2_LEN 12
 
+#define MAVLINK_MSG_ID_SYSTEM_TIME_CRC 137
+#define MAVLINK_MSG_ID_2_CRC 137
+
 
 
 #define MAVLINK_MESSAGE_INFO_SYSTEM_TIME { \
@@ -36,28 +39,32 @@ static inline uint16_t mavlink_msg_syste
 						       uint64_t time_unix_usec, uint32_t time_boot_ms)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[12];
+	char buf[MAVLINK_MSG_ID_SYSTEM_TIME_LEN];
 	_mav_put_uint64_t(buf, 0, time_unix_usec);
 	_mav_put_uint32_t(buf, 8, time_boot_ms);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 12);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SYSTEM_TIME_LEN);
 #else
 	mavlink_system_time_t packet;
 	packet.time_unix_usec = time_unix_usec;
 	packet.time_boot_ms = time_boot_ms;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 12);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SYSTEM_TIME_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SYSTEM_TIME;
-	return mavlink_finalize_message(msg, system_id, component_id, 12, 137);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SYSTEM_TIME_LEN, MAVLINK_MSG_ID_SYSTEM_TIME_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SYSTEM_TIME_LEN);
+#endif
 }
 
 /**
  * @brief Pack a system_time message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param time_unix_usec Timestamp of the master clock in microseconds since UNIX epoch.
  * @param time_boot_ms Timestamp of the component clock since boot time in milliseconds.
@@ -68,25 +75,29 @@ static inline uint16_t mavlink_msg_syste
 						           uint64_t time_unix_usec,uint32_t time_boot_ms)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[12];
+	char buf[MAVLINK_MSG_ID_SYSTEM_TIME_LEN];
 	_mav_put_uint64_t(buf, 0, time_unix_usec);
 	_mav_put_uint32_t(buf, 8, time_boot_ms);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 12);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SYSTEM_TIME_LEN);
 #else
 	mavlink_system_time_t packet;
 	packet.time_unix_usec = time_unix_usec;
 	packet.time_boot_ms = time_boot_ms;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 12);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SYSTEM_TIME_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_SYSTEM_TIME;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 12, 137);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SYSTEM_TIME_LEN, MAVLINK_MSG_ID_SYSTEM_TIME_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SYSTEM_TIME_LEN);
+#endif
 }
 
 /**
- * @brief Encode a system_time struct into a message
+ * @brief Encode a system_time struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -99,6 +110,20 @@ static inline uint16_t mavlink_msg_syste
 }
 
 /**
+ * @brief Encode a system_time struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param system_time C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_system_time_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_system_time_t* system_time)
+{
+	return mavlink_msg_system_time_pack_chan(system_id, component_id, chan, msg, system_time->time_unix_usec, system_time->time_boot_ms);
+}
+
+/**
  * @brief Send a system_time message
  * @param chan MAVLink channel to send the message
  *
@@ -110,20 +135,62 @@ static inline uint16_t mavlink_msg_syste
 static inline void mavlink_msg_system_time_send(mavlink_channel_t chan, uint64_t time_unix_usec, uint32_t time_boot_ms)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[12];
+	char buf[MAVLINK_MSG_ID_SYSTEM_TIME_LEN];
 	_mav_put_uint64_t(buf, 0, time_unix_usec);
 	_mav_put_uint32_t(buf, 8, time_boot_ms);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYSTEM_TIME, buf, 12, 137);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYSTEM_TIME, buf, MAVLINK_MSG_ID_SYSTEM_TIME_LEN, MAVLINK_MSG_ID_SYSTEM_TIME_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYSTEM_TIME, buf, MAVLINK_MSG_ID_SYSTEM_TIME_LEN);
+#endif
 #else
 	mavlink_system_time_t packet;
 	packet.time_unix_usec = time_unix_usec;
 	packet.time_boot_ms = time_boot_ms;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYSTEM_TIME, (const char *)&packet, 12, 137);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYSTEM_TIME, (const char *)&packet, MAVLINK_MSG_ID_SYSTEM_TIME_LEN, MAVLINK_MSG_ID_SYSTEM_TIME_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYSTEM_TIME, (const char *)&packet, MAVLINK_MSG_ID_SYSTEM_TIME_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_SYSTEM_TIME_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_system_time_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t time_unix_usec, uint32_t time_boot_ms)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, time_unix_usec);
+	_mav_put_uint32_t(buf, 8, time_boot_ms);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYSTEM_TIME, buf, MAVLINK_MSG_ID_SYSTEM_TIME_LEN, MAVLINK_MSG_ID_SYSTEM_TIME_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYSTEM_TIME, buf, MAVLINK_MSG_ID_SYSTEM_TIME_LEN);
+#endif
+#else
+	mavlink_system_time_t *packet = (mavlink_system_time_t *)msgbuf;
+	packet->time_unix_usec = time_unix_usec;
+	packet->time_boot_ms = time_boot_ms;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYSTEM_TIME, (const char *)packet, MAVLINK_MSG_ID_SYSTEM_TIME_LEN, MAVLINK_MSG_ID_SYSTEM_TIME_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_SYSTEM_TIME, (const char *)packet, MAVLINK_MSG_ID_SYSTEM_TIME_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE SYSTEM_TIME UNPACKING
@@ -161,6 +228,6 @@ static inline void mavlink_msg_system_ti
 	system_time->time_unix_usec = mavlink_msg_system_time_get_time_unix_usec(msg);
 	system_time->time_boot_ms = mavlink_msg_system_time_get_time_boot_ms(msg);
 #else
-	memcpy(system_time, _MAV_PAYLOAD(msg), 12);
+	memcpy(system_time, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SYSTEM_TIME_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_terrain_check.h v1.0/common/mavlink_msg_terrain_check.h
--- v1.0.old/common/mavlink_msg_terrain_check.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_terrain_check.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,233 @@
+// MESSAGE TERRAIN_CHECK PACKING
+
+#define MAVLINK_MSG_ID_TERRAIN_CHECK 135
+
+typedef struct __mavlink_terrain_check_t
+{
+ int32_t lat; ///< Latitude (degrees *10^7)
+ int32_t lon; ///< Longitude (degrees *10^7)
+} mavlink_terrain_check_t;
+
+#define MAVLINK_MSG_ID_TERRAIN_CHECK_LEN 8
+#define MAVLINK_MSG_ID_135_LEN 8
+
+#define MAVLINK_MSG_ID_TERRAIN_CHECK_CRC 203
+#define MAVLINK_MSG_ID_135_CRC 203
+
+
+
+#define MAVLINK_MESSAGE_INFO_TERRAIN_CHECK { \
+	"TERRAIN_CHECK", \
+	2, \
+	{  { "lat", NULL, MAVLINK_TYPE_INT32_T, 0, 0, offsetof(mavlink_terrain_check_t, lat) }, \
+         { "lon", NULL, MAVLINK_TYPE_INT32_T, 0, 4, offsetof(mavlink_terrain_check_t, lon) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a terrain_check message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param lat Latitude (degrees *10^7)
+ * @param lon Longitude (degrees *10^7)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_terrain_check_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       int32_t lat, int32_t lon)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_TERRAIN_CHECK_LEN];
+	_mav_put_int32_t(buf, 0, lat);
+	_mav_put_int32_t(buf, 4, lon);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_TERRAIN_CHECK_LEN);
+#else
+	mavlink_terrain_check_t packet;
+	packet.lat = lat;
+	packet.lon = lon;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_TERRAIN_CHECK_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_TERRAIN_CHECK;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_TERRAIN_CHECK_LEN, MAVLINK_MSG_ID_TERRAIN_CHECK_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_TERRAIN_CHECK_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a terrain_check message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param lat Latitude (degrees *10^7)
+ * @param lon Longitude (degrees *10^7)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_terrain_check_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           int32_t lat,int32_t lon)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_TERRAIN_CHECK_LEN];
+	_mav_put_int32_t(buf, 0, lat);
+	_mav_put_int32_t(buf, 4, lon);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_TERRAIN_CHECK_LEN);
+#else
+	mavlink_terrain_check_t packet;
+	packet.lat = lat;
+	packet.lon = lon;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_TERRAIN_CHECK_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_TERRAIN_CHECK;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_TERRAIN_CHECK_LEN, MAVLINK_MSG_ID_TERRAIN_CHECK_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_TERRAIN_CHECK_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a terrain_check struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param terrain_check C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_terrain_check_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_terrain_check_t* terrain_check)
+{
+	return mavlink_msg_terrain_check_pack(system_id, component_id, msg, terrain_check->lat, terrain_check->lon);
+}
+
+/**
+ * @brief Encode a terrain_check struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param terrain_check C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_terrain_check_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_terrain_check_t* terrain_check)
+{
+	return mavlink_msg_terrain_check_pack_chan(system_id, component_id, chan, msg, terrain_check->lat, terrain_check->lon);
+}
+
+/**
+ * @brief Send a terrain_check message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param lat Latitude (degrees *10^7)
+ * @param lon Longitude (degrees *10^7)
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_terrain_check_send(mavlink_channel_t chan, int32_t lat, int32_t lon)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_TERRAIN_CHECK_LEN];
+	_mav_put_int32_t(buf, 0, lat);
+	_mav_put_int32_t(buf, 4, lon);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_CHECK, buf, MAVLINK_MSG_ID_TERRAIN_CHECK_LEN, MAVLINK_MSG_ID_TERRAIN_CHECK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_CHECK, buf, MAVLINK_MSG_ID_TERRAIN_CHECK_LEN);
+#endif
+#else
+	mavlink_terrain_check_t packet;
+	packet.lat = lat;
+	packet.lon = lon;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_CHECK, (const char *)&packet, MAVLINK_MSG_ID_TERRAIN_CHECK_LEN, MAVLINK_MSG_ID_TERRAIN_CHECK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_CHECK, (const char *)&packet, MAVLINK_MSG_ID_TERRAIN_CHECK_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_TERRAIN_CHECK_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_terrain_check_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  int32_t lat, int32_t lon)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_int32_t(buf, 0, lat);
+	_mav_put_int32_t(buf, 4, lon);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_CHECK, buf, MAVLINK_MSG_ID_TERRAIN_CHECK_LEN, MAVLINK_MSG_ID_TERRAIN_CHECK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_CHECK, buf, MAVLINK_MSG_ID_TERRAIN_CHECK_LEN);
+#endif
+#else
+	mavlink_terrain_check_t *packet = (mavlink_terrain_check_t *)msgbuf;
+	packet->lat = lat;
+	packet->lon = lon;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_CHECK, (const char *)packet, MAVLINK_MSG_ID_TERRAIN_CHECK_LEN, MAVLINK_MSG_ID_TERRAIN_CHECK_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_CHECK, (const char *)packet, MAVLINK_MSG_ID_TERRAIN_CHECK_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE TERRAIN_CHECK UNPACKING
+
+
+/**
+ * @brief Get field lat from terrain_check message
+ *
+ * @return Latitude (degrees *10^7)
+ */
+static inline int32_t mavlink_msg_terrain_check_get_lat(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  0);
+}
+
+/**
+ * @brief Get field lon from terrain_check message
+ *
+ * @return Longitude (degrees *10^7)
+ */
+static inline int32_t mavlink_msg_terrain_check_get_lon(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  4);
+}
+
+/**
+ * @brief Decode a terrain_check message into a struct
+ *
+ * @param msg The message to decode
+ * @param terrain_check C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_terrain_check_decode(const mavlink_message_t* msg, mavlink_terrain_check_t* terrain_check)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	terrain_check->lat = mavlink_msg_terrain_check_get_lat(msg);
+	terrain_check->lon = mavlink_msg_terrain_check_get_lon(msg);
+#else
+	memcpy(terrain_check, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_TERRAIN_CHECK_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_terrain_data.h v1.0/common/mavlink_msg_terrain_data.h
--- v1.0.old/common/mavlink_msg_terrain_data.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_terrain_data.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,297 @@
+// MESSAGE TERRAIN_DATA PACKING
+
+#define MAVLINK_MSG_ID_TERRAIN_DATA 134
+
+typedef struct __mavlink_terrain_data_t
+{
+ int32_t lat; ///< Latitude of SW corner of first grid (degrees *10^7)
+ int32_t lon; ///< Longitude of SW corner of first grid (in degrees *10^7)
+ uint16_t grid_spacing; ///< Grid spacing in meters
+ int16_t data[16]; ///< Terrain data in meters AMSL
+ uint8_t gridbit; ///< bit within the terrain request mask
+} mavlink_terrain_data_t;
+
+#define MAVLINK_MSG_ID_TERRAIN_DATA_LEN 43
+#define MAVLINK_MSG_ID_134_LEN 43
+
+#define MAVLINK_MSG_ID_TERRAIN_DATA_CRC 229
+#define MAVLINK_MSG_ID_134_CRC 229
+
+#define MAVLINK_MSG_TERRAIN_DATA_FIELD_DATA_LEN 16
+
+#define MAVLINK_MESSAGE_INFO_TERRAIN_DATA { \
+	"TERRAIN_DATA", \
+	5, \
+	{  { "lat", NULL, MAVLINK_TYPE_INT32_T, 0, 0, offsetof(mavlink_terrain_data_t, lat) }, \
+         { "lon", NULL, MAVLINK_TYPE_INT32_T, 0, 4, offsetof(mavlink_terrain_data_t, lon) }, \
+         { "grid_spacing", NULL, MAVLINK_TYPE_UINT16_T, 0, 8, offsetof(mavlink_terrain_data_t, grid_spacing) }, \
+         { "data", NULL, MAVLINK_TYPE_INT16_T, 16, 10, offsetof(mavlink_terrain_data_t, data) }, \
+         { "gridbit", NULL, MAVLINK_TYPE_UINT8_T, 0, 42, offsetof(mavlink_terrain_data_t, gridbit) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a terrain_data message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param lat Latitude of SW corner of first grid (degrees *10^7)
+ * @param lon Longitude of SW corner of first grid (in degrees *10^7)
+ * @param grid_spacing Grid spacing in meters
+ * @param gridbit bit within the terrain request mask
+ * @param data Terrain data in meters AMSL
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_terrain_data_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       int32_t lat, int32_t lon, uint16_t grid_spacing, uint8_t gridbit, const int16_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_TERRAIN_DATA_LEN];
+	_mav_put_int32_t(buf, 0, lat);
+	_mav_put_int32_t(buf, 4, lon);
+	_mav_put_uint16_t(buf, 8, grid_spacing);
+	_mav_put_uint8_t(buf, 42, gridbit);
+	_mav_put_int16_t_array(buf, 10, data, 16);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_TERRAIN_DATA_LEN);
+#else
+	mavlink_terrain_data_t packet;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.grid_spacing = grid_spacing;
+	packet.gridbit = gridbit;
+	mav_array_memcpy(packet.data, data, sizeof(int16_t)*16);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_TERRAIN_DATA_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_TERRAIN_DATA;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_TERRAIN_DATA_LEN, MAVLINK_MSG_ID_TERRAIN_DATA_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_TERRAIN_DATA_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a terrain_data message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param lat Latitude of SW corner of first grid (degrees *10^7)
+ * @param lon Longitude of SW corner of first grid (in degrees *10^7)
+ * @param grid_spacing Grid spacing in meters
+ * @param gridbit bit within the terrain request mask
+ * @param data Terrain data in meters AMSL
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_terrain_data_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           int32_t lat,int32_t lon,uint16_t grid_spacing,uint8_t gridbit,const int16_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_TERRAIN_DATA_LEN];
+	_mav_put_int32_t(buf, 0, lat);
+	_mav_put_int32_t(buf, 4, lon);
+	_mav_put_uint16_t(buf, 8, grid_spacing);
+	_mav_put_uint8_t(buf, 42, gridbit);
+	_mav_put_int16_t_array(buf, 10, data, 16);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_TERRAIN_DATA_LEN);
+#else
+	mavlink_terrain_data_t packet;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.grid_spacing = grid_spacing;
+	packet.gridbit = gridbit;
+	mav_array_memcpy(packet.data, data, sizeof(int16_t)*16);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_TERRAIN_DATA_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_TERRAIN_DATA;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_TERRAIN_DATA_LEN, MAVLINK_MSG_ID_TERRAIN_DATA_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_TERRAIN_DATA_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a terrain_data struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param terrain_data C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_terrain_data_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_terrain_data_t* terrain_data)
+{
+	return mavlink_msg_terrain_data_pack(system_id, component_id, msg, terrain_data->lat, terrain_data->lon, terrain_data->grid_spacing, terrain_data->gridbit, terrain_data->data);
+}
+
+/**
+ * @brief Encode a terrain_data struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param terrain_data C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_terrain_data_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_terrain_data_t* terrain_data)
+{
+	return mavlink_msg_terrain_data_pack_chan(system_id, component_id, chan, msg, terrain_data->lat, terrain_data->lon, terrain_data->grid_spacing, terrain_data->gridbit, terrain_data->data);
+}
+
+/**
+ * @brief Send a terrain_data message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param lat Latitude of SW corner of first grid (degrees *10^7)
+ * @param lon Longitude of SW corner of first grid (in degrees *10^7)
+ * @param grid_spacing Grid spacing in meters
+ * @param gridbit bit within the terrain request mask
+ * @param data Terrain data in meters AMSL
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_terrain_data_send(mavlink_channel_t chan, int32_t lat, int32_t lon, uint16_t grid_spacing, uint8_t gridbit, const int16_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_TERRAIN_DATA_LEN];
+	_mav_put_int32_t(buf, 0, lat);
+	_mav_put_int32_t(buf, 4, lon);
+	_mav_put_uint16_t(buf, 8, grid_spacing);
+	_mav_put_uint8_t(buf, 42, gridbit);
+	_mav_put_int16_t_array(buf, 10, data, 16);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_DATA, buf, MAVLINK_MSG_ID_TERRAIN_DATA_LEN, MAVLINK_MSG_ID_TERRAIN_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_DATA, buf, MAVLINK_MSG_ID_TERRAIN_DATA_LEN);
+#endif
+#else
+	mavlink_terrain_data_t packet;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.grid_spacing = grid_spacing;
+	packet.gridbit = gridbit;
+	mav_array_memcpy(packet.data, data, sizeof(int16_t)*16);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_DATA, (const char *)&packet, MAVLINK_MSG_ID_TERRAIN_DATA_LEN, MAVLINK_MSG_ID_TERRAIN_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_DATA, (const char *)&packet, MAVLINK_MSG_ID_TERRAIN_DATA_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_TERRAIN_DATA_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_terrain_data_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  int32_t lat, int32_t lon, uint16_t grid_spacing, uint8_t gridbit, const int16_t *data)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_int32_t(buf, 0, lat);
+	_mav_put_int32_t(buf, 4, lon);
+	_mav_put_uint16_t(buf, 8, grid_spacing);
+	_mav_put_uint8_t(buf, 42, gridbit);
+	_mav_put_int16_t_array(buf, 10, data, 16);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_DATA, buf, MAVLINK_MSG_ID_TERRAIN_DATA_LEN, MAVLINK_MSG_ID_TERRAIN_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_DATA, buf, MAVLINK_MSG_ID_TERRAIN_DATA_LEN);
+#endif
+#else
+	mavlink_terrain_data_t *packet = (mavlink_terrain_data_t *)msgbuf;
+	packet->lat = lat;
+	packet->lon = lon;
+	packet->grid_spacing = grid_spacing;
+	packet->gridbit = gridbit;
+	mav_array_memcpy(packet->data, data, sizeof(int16_t)*16);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_DATA, (const char *)packet, MAVLINK_MSG_ID_TERRAIN_DATA_LEN, MAVLINK_MSG_ID_TERRAIN_DATA_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_DATA, (const char *)packet, MAVLINK_MSG_ID_TERRAIN_DATA_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE TERRAIN_DATA UNPACKING
+
+
+/**
+ * @brief Get field lat from terrain_data message
+ *
+ * @return Latitude of SW corner of first grid (degrees *10^7)
+ */
+static inline int32_t mavlink_msg_terrain_data_get_lat(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  0);
+}
+
+/**
+ * @brief Get field lon from terrain_data message
+ *
+ * @return Longitude of SW corner of first grid (in degrees *10^7)
+ */
+static inline int32_t mavlink_msg_terrain_data_get_lon(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  4);
+}
+
+/**
+ * @brief Get field grid_spacing from terrain_data message
+ *
+ * @return Grid spacing in meters
+ */
+static inline uint16_t mavlink_msg_terrain_data_get_grid_spacing(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  8);
+}
+
+/**
+ * @brief Get field gridbit from terrain_data message
+ *
+ * @return bit within the terrain request mask
+ */
+static inline uint8_t mavlink_msg_terrain_data_get_gridbit(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  42);
+}
+
+/**
+ * @brief Get field data from terrain_data message
+ *
+ * @return Terrain data in meters AMSL
+ */
+static inline uint16_t mavlink_msg_terrain_data_get_data(const mavlink_message_t* msg, int16_t *data)
+{
+	return _MAV_RETURN_int16_t_array(msg, data, 16,  10);
+}
+
+/**
+ * @brief Decode a terrain_data message into a struct
+ *
+ * @param msg The message to decode
+ * @param terrain_data C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_terrain_data_decode(const mavlink_message_t* msg, mavlink_terrain_data_t* terrain_data)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	terrain_data->lat = mavlink_msg_terrain_data_get_lat(msg);
+	terrain_data->lon = mavlink_msg_terrain_data_get_lon(msg);
+	terrain_data->grid_spacing = mavlink_msg_terrain_data_get_grid_spacing(msg);
+	mavlink_msg_terrain_data_get_data(msg, terrain_data->data);
+	terrain_data->gridbit = mavlink_msg_terrain_data_get_gridbit(msg);
+#else
+	memcpy(terrain_data, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_TERRAIN_DATA_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_terrain_report.h v1.0/common/mavlink_msg_terrain_report.h
--- v1.0.old/common/mavlink_msg_terrain_report.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_terrain_report.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,353 @@
+// MESSAGE TERRAIN_REPORT PACKING
+
+#define MAVLINK_MSG_ID_TERRAIN_REPORT 136
+
+typedef struct __mavlink_terrain_report_t
+{
+ int32_t lat; ///< Latitude (degrees *10^7)
+ int32_t lon; ///< Longitude (degrees *10^7)
+ float terrain_height; ///< Terrain height in meters AMSL
+ float current_height; ///< Current vehicle height above lat/lon terrain height (meters)
+ uint16_t spacing; ///< grid spacing (zero if terrain at this location unavailable)
+ uint16_t pending; ///< Number of 4x4 terrain blocks waiting to be received or read from disk
+ uint16_t loaded; ///< Number of 4x4 terrain blocks in memory
+} mavlink_terrain_report_t;
+
+#define MAVLINK_MSG_ID_TERRAIN_REPORT_LEN 22
+#define MAVLINK_MSG_ID_136_LEN 22
+
+#define MAVLINK_MSG_ID_TERRAIN_REPORT_CRC 1
+#define MAVLINK_MSG_ID_136_CRC 1
+
+
+
+#define MAVLINK_MESSAGE_INFO_TERRAIN_REPORT { \
+	"TERRAIN_REPORT", \
+	7, \
+	{  { "lat", NULL, MAVLINK_TYPE_INT32_T, 0, 0, offsetof(mavlink_terrain_report_t, lat) }, \
+         { "lon", NULL, MAVLINK_TYPE_INT32_T, 0, 4, offsetof(mavlink_terrain_report_t, lon) }, \
+         { "terrain_height", NULL, MAVLINK_TYPE_FLOAT, 0, 8, offsetof(mavlink_terrain_report_t, terrain_height) }, \
+         { "current_height", NULL, MAVLINK_TYPE_FLOAT, 0, 12, offsetof(mavlink_terrain_report_t, current_height) }, \
+         { "spacing", NULL, MAVLINK_TYPE_UINT16_T, 0, 16, offsetof(mavlink_terrain_report_t, spacing) }, \
+         { "pending", NULL, MAVLINK_TYPE_UINT16_T, 0, 18, offsetof(mavlink_terrain_report_t, pending) }, \
+         { "loaded", NULL, MAVLINK_TYPE_UINT16_T, 0, 20, offsetof(mavlink_terrain_report_t, loaded) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a terrain_report message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param lat Latitude (degrees *10^7)
+ * @param lon Longitude (degrees *10^7)
+ * @param spacing grid spacing (zero if terrain at this location unavailable)
+ * @param terrain_height Terrain height in meters AMSL
+ * @param current_height Current vehicle height above lat/lon terrain height (meters)
+ * @param pending Number of 4x4 terrain blocks waiting to be received or read from disk
+ * @param loaded Number of 4x4 terrain blocks in memory
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_terrain_report_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       int32_t lat, int32_t lon, uint16_t spacing, float terrain_height, float current_height, uint16_t pending, uint16_t loaded)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_TERRAIN_REPORT_LEN];
+	_mav_put_int32_t(buf, 0, lat);
+	_mav_put_int32_t(buf, 4, lon);
+	_mav_put_float(buf, 8, terrain_height);
+	_mav_put_float(buf, 12, current_height);
+	_mav_put_uint16_t(buf, 16, spacing);
+	_mav_put_uint16_t(buf, 18, pending);
+	_mav_put_uint16_t(buf, 20, loaded);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_TERRAIN_REPORT_LEN);
+#else
+	mavlink_terrain_report_t packet;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.terrain_height = terrain_height;
+	packet.current_height = current_height;
+	packet.spacing = spacing;
+	packet.pending = pending;
+	packet.loaded = loaded;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_TERRAIN_REPORT_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_TERRAIN_REPORT;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_TERRAIN_REPORT_LEN, MAVLINK_MSG_ID_TERRAIN_REPORT_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_TERRAIN_REPORT_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a terrain_report message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param lat Latitude (degrees *10^7)
+ * @param lon Longitude (degrees *10^7)
+ * @param spacing grid spacing (zero if terrain at this location unavailable)
+ * @param terrain_height Terrain height in meters AMSL
+ * @param current_height Current vehicle height above lat/lon terrain height (meters)
+ * @param pending Number of 4x4 terrain blocks waiting to be received or read from disk
+ * @param loaded Number of 4x4 terrain blocks in memory
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_terrain_report_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           int32_t lat,int32_t lon,uint16_t spacing,float terrain_height,float current_height,uint16_t pending,uint16_t loaded)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_TERRAIN_REPORT_LEN];
+	_mav_put_int32_t(buf, 0, lat);
+	_mav_put_int32_t(buf, 4, lon);
+	_mav_put_float(buf, 8, terrain_height);
+	_mav_put_float(buf, 12, current_height);
+	_mav_put_uint16_t(buf, 16, spacing);
+	_mav_put_uint16_t(buf, 18, pending);
+	_mav_put_uint16_t(buf, 20, loaded);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_TERRAIN_REPORT_LEN);
+#else
+	mavlink_terrain_report_t packet;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.terrain_height = terrain_height;
+	packet.current_height = current_height;
+	packet.spacing = spacing;
+	packet.pending = pending;
+	packet.loaded = loaded;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_TERRAIN_REPORT_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_TERRAIN_REPORT;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_TERRAIN_REPORT_LEN, MAVLINK_MSG_ID_TERRAIN_REPORT_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_TERRAIN_REPORT_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a terrain_report struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param terrain_report C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_terrain_report_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_terrain_report_t* terrain_report)
+{
+	return mavlink_msg_terrain_report_pack(system_id, component_id, msg, terrain_report->lat, terrain_report->lon, terrain_report->spacing, terrain_report->terrain_height, terrain_report->current_height, terrain_report->pending, terrain_report->loaded);
+}
+
+/**
+ * @brief Encode a terrain_report struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param terrain_report C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_terrain_report_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_terrain_report_t* terrain_report)
+{
+	return mavlink_msg_terrain_report_pack_chan(system_id, component_id, chan, msg, terrain_report->lat, terrain_report->lon, terrain_report->spacing, terrain_report->terrain_height, terrain_report->current_height, terrain_report->pending, terrain_report->loaded);
+}
+
+/**
+ * @brief Send a terrain_report message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param lat Latitude (degrees *10^7)
+ * @param lon Longitude (degrees *10^7)
+ * @param spacing grid spacing (zero if terrain at this location unavailable)
+ * @param terrain_height Terrain height in meters AMSL
+ * @param current_height Current vehicle height above lat/lon terrain height (meters)
+ * @param pending Number of 4x4 terrain blocks waiting to be received or read from disk
+ * @param loaded Number of 4x4 terrain blocks in memory
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_terrain_report_send(mavlink_channel_t chan, int32_t lat, int32_t lon, uint16_t spacing, float terrain_height, float current_height, uint16_t pending, uint16_t loaded)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_TERRAIN_REPORT_LEN];
+	_mav_put_int32_t(buf, 0, lat);
+	_mav_put_int32_t(buf, 4, lon);
+	_mav_put_float(buf, 8, terrain_height);
+	_mav_put_float(buf, 12, current_height);
+	_mav_put_uint16_t(buf, 16, spacing);
+	_mav_put_uint16_t(buf, 18, pending);
+	_mav_put_uint16_t(buf, 20, loaded);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_REPORT, buf, MAVLINK_MSG_ID_TERRAIN_REPORT_LEN, MAVLINK_MSG_ID_TERRAIN_REPORT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_REPORT, buf, MAVLINK_MSG_ID_TERRAIN_REPORT_LEN);
+#endif
+#else
+	mavlink_terrain_report_t packet;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.terrain_height = terrain_height;
+	packet.current_height = current_height;
+	packet.spacing = spacing;
+	packet.pending = pending;
+	packet.loaded = loaded;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_REPORT, (const char *)&packet, MAVLINK_MSG_ID_TERRAIN_REPORT_LEN, MAVLINK_MSG_ID_TERRAIN_REPORT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_REPORT, (const char *)&packet, MAVLINK_MSG_ID_TERRAIN_REPORT_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_TERRAIN_REPORT_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_terrain_report_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  int32_t lat, int32_t lon, uint16_t spacing, float terrain_height, float current_height, uint16_t pending, uint16_t loaded)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_int32_t(buf, 0, lat);
+	_mav_put_int32_t(buf, 4, lon);
+	_mav_put_float(buf, 8, terrain_height);
+	_mav_put_float(buf, 12, current_height);
+	_mav_put_uint16_t(buf, 16, spacing);
+	_mav_put_uint16_t(buf, 18, pending);
+	_mav_put_uint16_t(buf, 20, loaded);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_REPORT, buf, MAVLINK_MSG_ID_TERRAIN_REPORT_LEN, MAVLINK_MSG_ID_TERRAIN_REPORT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_REPORT, buf, MAVLINK_MSG_ID_TERRAIN_REPORT_LEN);
+#endif
+#else
+	mavlink_terrain_report_t *packet = (mavlink_terrain_report_t *)msgbuf;
+	packet->lat = lat;
+	packet->lon = lon;
+	packet->terrain_height = terrain_height;
+	packet->current_height = current_height;
+	packet->spacing = spacing;
+	packet->pending = pending;
+	packet->loaded = loaded;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_REPORT, (const char *)packet, MAVLINK_MSG_ID_TERRAIN_REPORT_LEN, MAVLINK_MSG_ID_TERRAIN_REPORT_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_REPORT, (const char *)packet, MAVLINK_MSG_ID_TERRAIN_REPORT_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE TERRAIN_REPORT UNPACKING
+
+
+/**
+ * @brief Get field lat from terrain_report message
+ *
+ * @return Latitude (degrees *10^7)
+ */
+static inline int32_t mavlink_msg_terrain_report_get_lat(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  0);
+}
+
+/**
+ * @brief Get field lon from terrain_report message
+ *
+ * @return Longitude (degrees *10^7)
+ */
+static inline int32_t mavlink_msg_terrain_report_get_lon(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  4);
+}
+
+/**
+ * @brief Get field spacing from terrain_report message
+ *
+ * @return grid spacing (zero if terrain at this location unavailable)
+ */
+static inline uint16_t mavlink_msg_terrain_report_get_spacing(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  16);
+}
+
+/**
+ * @brief Get field terrain_height from terrain_report message
+ *
+ * @return Terrain height in meters AMSL
+ */
+static inline float mavlink_msg_terrain_report_get_terrain_height(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  8);
+}
+
+/**
+ * @brief Get field current_height from terrain_report message
+ *
+ * @return Current vehicle height above lat/lon terrain height (meters)
+ */
+static inline float mavlink_msg_terrain_report_get_current_height(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_float(msg,  12);
+}
+
+/**
+ * @brief Get field pending from terrain_report message
+ *
+ * @return Number of 4x4 terrain blocks waiting to be received or read from disk
+ */
+static inline uint16_t mavlink_msg_terrain_report_get_pending(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  18);
+}
+
+/**
+ * @brief Get field loaded from terrain_report message
+ *
+ * @return Number of 4x4 terrain blocks in memory
+ */
+static inline uint16_t mavlink_msg_terrain_report_get_loaded(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  20);
+}
+
+/**
+ * @brief Decode a terrain_report message into a struct
+ *
+ * @param msg The message to decode
+ * @param terrain_report C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_terrain_report_decode(const mavlink_message_t* msg, mavlink_terrain_report_t* terrain_report)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	terrain_report->lat = mavlink_msg_terrain_report_get_lat(msg);
+	terrain_report->lon = mavlink_msg_terrain_report_get_lon(msg);
+	terrain_report->terrain_height = mavlink_msg_terrain_report_get_terrain_height(msg);
+	terrain_report->current_height = mavlink_msg_terrain_report_get_current_height(msg);
+	terrain_report->spacing = mavlink_msg_terrain_report_get_spacing(msg);
+	terrain_report->pending = mavlink_msg_terrain_report_get_pending(msg);
+	terrain_report->loaded = mavlink_msg_terrain_report_get_loaded(msg);
+#else
+	memcpy(terrain_report, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_TERRAIN_REPORT_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_terrain_request.h v1.0/common/mavlink_msg_terrain_request.h
--- v1.0.old/common/mavlink_msg_terrain_request.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_terrain_request.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,281 @@
+// MESSAGE TERRAIN_REQUEST PACKING
+
+#define MAVLINK_MSG_ID_TERRAIN_REQUEST 133
+
+typedef struct __mavlink_terrain_request_t
+{
+ uint64_t mask; ///< Bitmask of requested 4x4 grids (row major 8x7 array of grids, 56 bits)
+ int32_t lat; ///< Latitude of SW corner of first grid (degrees *10^7)
+ int32_t lon; ///< Longitude of SW corner of first grid (in degrees *10^7)
+ uint16_t grid_spacing; ///< Grid spacing in meters
+} mavlink_terrain_request_t;
+
+#define MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN 18
+#define MAVLINK_MSG_ID_133_LEN 18
+
+#define MAVLINK_MSG_ID_TERRAIN_REQUEST_CRC 6
+#define MAVLINK_MSG_ID_133_CRC 6
+
+
+
+#define MAVLINK_MESSAGE_INFO_TERRAIN_REQUEST { \
+	"TERRAIN_REQUEST", \
+	4, \
+	{  { "mask", "0x%07x", MAVLINK_TYPE_UINT64_T, 0, 0, offsetof(mavlink_terrain_request_t, mask) }, \
+         { "lat", NULL, MAVLINK_TYPE_INT32_T, 0, 8, offsetof(mavlink_terrain_request_t, lat) }, \
+         { "lon", NULL, MAVLINK_TYPE_INT32_T, 0, 12, offsetof(mavlink_terrain_request_t, lon) }, \
+         { "grid_spacing", NULL, MAVLINK_TYPE_UINT16_T, 0, 16, offsetof(mavlink_terrain_request_t, grid_spacing) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a terrain_request message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param lat Latitude of SW corner of first grid (degrees *10^7)
+ * @param lon Longitude of SW corner of first grid (in degrees *10^7)
+ * @param grid_spacing Grid spacing in meters
+ * @param mask Bitmask of requested 4x4 grids (row major 8x7 array of grids, 56 bits)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_terrain_request_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       int32_t lat, int32_t lon, uint16_t grid_spacing, uint64_t mask)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN];
+	_mav_put_uint64_t(buf, 0, mask);
+	_mav_put_int32_t(buf, 8, lat);
+	_mav_put_int32_t(buf, 12, lon);
+	_mav_put_uint16_t(buf, 16, grid_spacing);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN);
+#else
+	mavlink_terrain_request_t packet;
+	packet.mask = mask;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.grid_spacing = grid_spacing;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_TERRAIN_REQUEST;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN, MAVLINK_MSG_ID_TERRAIN_REQUEST_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a terrain_request message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param lat Latitude of SW corner of first grid (degrees *10^7)
+ * @param lon Longitude of SW corner of first grid (in degrees *10^7)
+ * @param grid_spacing Grid spacing in meters
+ * @param mask Bitmask of requested 4x4 grids (row major 8x7 array of grids, 56 bits)
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_terrain_request_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           int32_t lat,int32_t lon,uint16_t grid_spacing,uint64_t mask)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN];
+	_mav_put_uint64_t(buf, 0, mask);
+	_mav_put_int32_t(buf, 8, lat);
+	_mav_put_int32_t(buf, 12, lon);
+	_mav_put_uint16_t(buf, 16, grid_spacing);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN);
+#else
+	mavlink_terrain_request_t packet;
+	packet.mask = mask;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.grid_spacing = grid_spacing;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_TERRAIN_REQUEST;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN, MAVLINK_MSG_ID_TERRAIN_REQUEST_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a terrain_request struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param terrain_request C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_terrain_request_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_terrain_request_t* terrain_request)
+{
+	return mavlink_msg_terrain_request_pack(system_id, component_id, msg, terrain_request->lat, terrain_request->lon, terrain_request->grid_spacing, terrain_request->mask);
+}
+
+/**
+ * @brief Encode a terrain_request struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param terrain_request C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_terrain_request_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_terrain_request_t* terrain_request)
+{
+	return mavlink_msg_terrain_request_pack_chan(system_id, component_id, chan, msg, terrain_request->lat, terrain_request->lon, terrain_request->grid_spacing, terrain_request->mask);
+}
+
+/**
+ * @brief Send a terrain_request message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param lat Latitude of SW corner of first grid (degrees *10^7)
+ * @param lon Longitude of SW corner of first grid (in degrees *10^7)
+ * @param grid_spacing Grid spacing in meters
+ * @param mask Bitmask of requested 4x4 grids (row major 8x7 array of grids, 56 bits)
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_terrain_request_send(mavlink_channel_t chan, int32_t lat, int32_t lon, uint16_t grid_spacing, uint64_t mask)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN];
+	_mav_put_uint64_t(buf, 0, mask);
+	_mav_put_int32_t(buf, 8, lat);
+	_mav_put_int32_t(buf, 12, lon);
+	_mav_put_uint16_t(buf, 16, grid_spacing);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_REQUEST, buf, MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN, MAVLINK_MSG_ID_TERRAIN_REQUEST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_REQUEST, buf, MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN);
+#endif
+#else
+	mavlink_terrain_request_t packet;
+	packet.mask = mask;
+	packet.lat = lat;
+	packet.lon = lon;
+	packet.grid_spacing = grid_spacing;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_REQUEST, (const char *)&packet, MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN, MAVLINK_MSG_ID_TERRAIN_REQUEST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_REQUEST, (const char *)&packet, MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_terrain_request_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  int32_t lat, int32_t lon, uint16_t grid_spacing, uint64_t mask)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, mask);
+	_mav_put_int32_t(buf, 8, lat);
+	_mav_put_int32_t(buf, 12, lon);
+	_mav_put_uint16_t(buf, 16, grid_spacing);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_REQUEST, buf, MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN, MAVLINK_MSG_ID_TERRAIN_REQUEST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_REQUEST, buf, MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN);
+#endif
+#else
+	mavlink_terrain_request_t *packet = (mavlink_terrain_request_t *)msgbuf;
+	packet->mask = mask;
+	packet->lat = lat;
+	packet->lon = lon;
+	packet->grid_spacing = grid_spacing;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_REQUEST, (const char *)packet, MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN, MAVLINK_MSG_ID_TERRAIN_REQUEST_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TERRAIN_REQUEST, (const char *)packet, MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE TERRAIN_REQUEST UNPACKING
+
+
+/**
+ * @brief Get field lat from terrain_request message
+ *
+ * @return Latitude of SW corner of first grid (degrees *10^7)
+ */
+static inline int32_t mavlink_msg_terrain_request_get_lat(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  8);
+}
+
+/**
+ * @brief Get field lon from terrain_request message
+ *
+ * @return Longitude of SW corner of first grid (in degrees *10^7)
+ */
+static inline int32_t mavlink_msg_terrain_request_get_lon(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int32_t(msg,  12);
+}
+
+/**
+ * @brief Get field grid_spacing from terrain_request message
+ *
+ * @return Grid spacing in meters
+ */
+static inline uint16_t mavlink_msg_terrain_request_get_grid_spacing(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  16);
+}
+
+/**
+ * @brief Get field mask from terrain_request message
+ *
+ * @return Bitmask of requested 4x4 grids (row major 8x7 array of grids, 56 bits)
+ */
+static inline uint64_t mavlink_msg_terrain_request_get_mask(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint64_t(msg,  0);
+}
+
+/**
+ * @brief Decode a terrain_request message into a struct
+ *
+ * @param msg The message to decode
+ * @param terrain_request C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_terrain_request_decode(const mavlink_message_t* msg, mavlink_terrain_request_t* terrain_request)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	terrain_request->mask = mavlink_msg_terrain_request_get_mask(msg);
+	terrain_request->lat = mavlink_msg_terrain_request_get_lat(msg);
+	terrain_request->lon = mavlink_msg_terrain_request_get_lon(msg);
+	terrain_request->grid_spacing = mavlink_msg_terrain_request_get_grid_spacing(msg);
+#else
+	memcpy(terrain_request, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_TERRAIN_REQUEST_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_timesync.h v1.0/common/mavlink_msg_timesync.h
--- v1.0.old/common/mavlink_msg_timesync.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_timesync.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,233 @@
+// MESSAGE TIMESYNC PACKING
+
+#define MAVLINK_MSG_ID_TIMESYNC 111
+
+typedef struct __mavlink_timesync_t
+{
+ int64_t tc1; ///< Time sync timestamp 1
+ int64_t ts1; ///< Time sync timestamp 2
+} mavlink_timesync_t;
+
+#define MAVLINK_MSG_ID_TIMESYNC_LEN 16
+#define MAVLINK_MSG_ID_111_LEN 16
+
+#define MAVLINK_MSG_ID_TIMESYNC_CRC 34
+#define MAVLINK_MSG_ID_111_CRC 34
+
+
+
+#define MAVLINK_MESSAGE_INFO_TIMESYNC { \
+	"TIMESYNC", \
+	2, \
+	{  { "tc1", NULL, MAVLINK_TYPE_INT64_T, 0, 0, offsetof(mavlink_timesync_t, tc1) }, \
+         { "ts1", NULL, MAVLINK_TYPE_INT64_T, 0, 8, offsetof(mavlink_timesync_t, ts1) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a timesync message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param tc1 Time sync timestamp 1
+ * @param ts1 Time sync timestamp 2
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_timesync_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       int64_t tc1, int64_t ts1)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_TIMESYNC_LEN];
+	_mav_put_int64_t(buf, 0, tc1);
+	_mav_put_int64_t(buf, 8, ts1);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_TIMESYNC_LEN);
+#else
+	mavlink_timesync_t packet;
+	packet.tc1 = tc1;
+	packet.ts1 = ts1;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_TIMESYNC_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_TIMESYNC;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_TIMESYNC_LEN, MAVLINK_MSG_ID_TIMESYNC_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_TIMESYNC_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a timesync message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param tc1 Time sync timestamp 1
+ * @param ts1 Time sync timestamp 2
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_timesync_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           int64_t tc1,int64_t ts1)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_TIMESYNC_LEN];
+	_mav_put_int64_t(buf, 0, tc1);
+	_mav_put_int64_t(buf, 8, ts1);
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_TIMESYNC_LEN);
+#else
+	mavlink_timesync_t packet;
+	packet.tc1 = tc1;
+	packet.ts1 = ts1;
+
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_TIMESYNC_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_TIMESYNC;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_TIMESYNC_LEN, MAVLINK_MSG_ID_TIMESYNC_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_TIMESYNC_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a timesync struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param timesync C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_timesync_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_timesync_t* timesync)
+{
+	return mavlink_msg_timesync_pack(system_id, component_id, msg, timesync->tc1, timesync->ts1);
+}
+
+/**
+ * @brief Encode a timesync struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param timesync C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_timesync_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_timesync_t* timesync)
+{
+	return mavlink_msg_timesync_pack_chan(system_id, component_id, chan, msg, timesync->tc1, timesync->ts1);
+}
+
+/**
+ * @brief Send a timesync message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param tc1 Time sync timestamp 1
+ * @param ts1 Time sync timestamp 2
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_timesync_send(mavlink_channel_t chan, int64_t tc1, int64_t ts1)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_TIMESYNC_LEN];
+	_mav_put_int64_t(buf, 0, tc1);
+	_mav_put_int64_t(buf, 8, ts1);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TIMESYNC, buf, MAVLINK_MSG_ID_TIMESYNC_LEN, MAVLINK_MSG_ID_TIMESYNC_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TIMESYNC, buf, MAVLINK_MSG_ID_TIMESYNC_LEN);
+#endif
+#else
+	mavlink_timesync_t packet;
+	packet.tc1 = tc1;
+	packet.ts1 = ts1;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TIMESYNC, (const char *)&packet, MAVLINK_MSG_ID_TIMESYNC_LEN, MAVLINK_MSG_ID_TIMESYNC_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TIMESYNC, (const char *)&packet, MAVLINK_MSG_ID_TIMESYNC_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_TIMESYNC_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_timesync_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  int64_t tc1, int64_t ts1)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_int64_t(buf, 0, tc1);
+	_mav_put_int64_t(buf, 8, ts1);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TIMESYNC, buf, MAVLINK_MSG_ID_TIMESYNC_LEN, MAVLINK_MSG_ID_TIMESYNC_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TIMESYNC, buf, MAVLINK_MSG_ID_TIMESYNC_LEN);
+#endif
+#else
+	mavlink_timesync_t *packet = (mavlink_timesync_t *)msgbuf;
+	packet->tc1 = tc1;
+	packet->ts1 = ts1;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TIMESYNC, (const char *)packet, MAVLINK_MSG_ID_TIMESYNC_LEN, MAVLINK_MSG_ID_TIMESYNC_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_TIMESYNC, (const char *)packet, MAVLINK_MSG_ID_TIMESYNC_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE TIMESYNC UNPACKING
+
+
+/**
+ * @brief Get field tc1 from timesync message
+ *
+ * @return Time sync timestamp 1
+ */
+static inline int64_t mavlink_msg_timesync_get_tc1(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int64_t(msg,  0);
+}
+
+/**
+ * @brief Get field ts1 from timesync message
+ *
+ * @return Time sync timestamp 2
+ */
+static inline int64_t mavlink_msg_timesync_get_ts1(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_int64_t(msg,  8);
+}
+
+/**
+ * @brief Decode a timesync message into a struct
+ *
+ * @param msg The message to decode
+ * @param timesync C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_timesync_decode(const mavlink_message_t* msg, mavlink_timesync_t* timesync)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	timesync->tc1 = mavlink_msg_timesync_get_tc1(msg);
+	timesync->ts1 = mavlink_msg_timesync_get_ts1(msg);
+#else
+	memcpy(timesync, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_TIMESYNC_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_v2_extension.h v1.0/common/mavlink_msg_v2_extension.h
--- v1.0.old/common/mavlink_msg_v2_extension.h	1970-01-01 05:00:00.000000000 +0500
+++ v1.0/common/mavlink_msg_v2_extension.h	2015-02-06 11:50:58.000000000 +0500
@@ -0,0 +1,297 @@
+// MESSAGE V2_EXTENSION PACKING
+
+#define MAVLINK_MSG_ID_V2_EXTENSION 248
+
+typedef struct __mavlink_v2_extension_t
+{
+ uint16_t message_type; ///< A code that identifies the software component that understands this message (analogous to usb device classes or mime type strings).  If this code is less than 32768, it is considered a 'registered' protocol extension and the corresponding entry should be added to https://github.com/mavlink/mavlink/extension-message-ids.xml.  Software creators can register blocks of message IDs as needed (useful for GCS specific metadata, etc...). Message_types greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase.
+ uint8_t target_network; ///< Network ID (0 for broadcast)
+ uint8_t target_system; ///< System ID (0 for broadcast)
+ uint8_t target_component; ///< Component ID (0 for broadcast)
+ uint8_t payload[249]; ///< Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.
+} mavlink_v2_extension_t;
+
+#define MAVLINK_MSG_ID_V2_EXTENSION_LEN 254
+#define MAVLINK_MSG_ID_248_LEN 254
+
+#define MAVLINK_MSG_ID_V2_EXTENSION_CRC 8
+#define MAVLINK_MSG_ID_248_CRC 8
+
+#define MAVLINK_MSG_V2_EXTENSION_FIELD_PAYLOAD_LEN 249
+
+#define MAVLINK_MESSAGE_INFO_V2_EXTENSION { \
+	"V2_EXTENSION", \
+	5, \
+	{  { "message_type", NULL, MAVLINK_TYPE_UINT16_T, 0, 0, offsetof(mavlink_v2_extension_t, message_type) }, \
+         { "target_network", NULL, MAVLINK_TYPE_UINT8_T, 0, 2, offsetof(mavlink_v2_extension_t, target_network) }, \
+         { "target_system", NULL, MAVLINK_TYPE_UINT8_T, 0, 3, offsetof(mavlink_v2_extension_t, target_system) }, \
+         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 4, offsetof(mavlink_v2_extension_t, target_component) }, \
+         { "payload", NULL, MAVLINK_TYPE_UINT8_T, 249, 5, offsetof(mavlink_v2_extension_t, payload) }, \
+         } \
+}
+
+
+/**
+ * @brief Pack a v2_extension message
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ *
+ * @param target_network Network ID (0 for broadcast)
+ * @param target_system System ID (0 for broadcast)
+ * @param target_component Component ID (0 for broadcast)
+ * @param message_type A code that identifies the software component that understands this message (analogous to usb device classes or mime type strings).  If this code is less than 32768, it is considered a 'registered' protocol extension and the corresponding entry should be added to https://github.com/mavlink/mavlink/extension-message-ids.xml.  Software creators can register blocks of message IDs as needed (useful for GCS specific metadata, etc...). Message_types greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase.
+ * @param payload Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_v2_extension_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
+						       uint8_t target_network, uint8_t target_system, uint8_t target_component, uint16_t message_type, const uint8_t *payload)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_V2_EXTENSION_LEN];
+	_mav_put_uint16_t(buf, 0, message_type);
+	_mav_put_uint8_t(buf, 2, target_network);
+	_mav_put_uint8_t(buf, 3, target_system);
+	_mav_put_uint8_t(buf, 4, target_component);
+	_mav_put_uint8_t_array(buf, 5, payload, 249);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_V2_EXTENSION_LEN);
+#else
+	mavlink_v2_extension_t packet;
+	packet.message_type = message_type;
+	packet.target_network = target_network;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	mav_array_memcpy(packet.payload, payload, sizeof(uint8_t)*249);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_V2_EXTENSION_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_V2_EXTENSION;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_V2_EXTENSION_LEN, MAVLINK_MSG_ID_V2_EXTENSION_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_V2_EXTENSION_LEN);
+#endif
+}
+
+/**
+ * @brief Pack a v2_extension message on a channel
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param target_network Network ID (0 for broadcast)
+ * @param target_system System ID (0 for broadcast)
+ * @param target_component Component ID (0 for broadcast)
+ * @param message_type A code that identifies the software component that understands this message (analogous to usb device classes or mime type strings).  If this code is less than 32768, it is considered a 'registered' protocol extension and the corresponding entry should be added to https://github.com/mavlink/mavlink/extension-message-ids.xml.  Software creators can register blocks of message IDs as needed (useful for GCS specific metadata, etc...). Message_types greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase.
+ * @param payload Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.
+ * @return length of the message in bytes (excluding serial stream start sign)
+ */
+static inline uint16_t mavlink_msg_v2_extension_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
+							   mavlink_message_t* msg,
+						           uint8_t target_network,uint8_t target_system,uint8_t target_component,uint16_t message_type,const uint8_t *payload)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_V2_EXTENSION_LEN];
+	_mav_put_uint16_t(buf, 0, message_type);
+	_mav_put_uint8_t(buf, 2, target_network);
+	_mav_put_uint8_t(buf, 3, target_system);
+	_mav_put_uint8_t(buf, 4, target_component);
+	_mav_put_uint8_t_array(buf, 5, payload, 249);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_V2_EXTENSION_LEN);
+#else
+	mavlink_v2_extension_t packet;
+	packet.message_type = message_type;
+	packet.target_network = target_network;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	mav_array_memcpy(packet.payload, payload, sizeof(uint8_t)*249);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_V2_EXTENSION_LEN);
+#endif
+
+	msg->msgid = MAVLINK_MSG_ID_V2_EXTENSION;
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_V2_EXTENSION_LEN, MAVLINK_MSG_ID_V2_EXTENSION_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_V2_EXTENSION_LEN);
+#endif
+}
+
+/**
+ * @brief Encode a v2_extension struct
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param msg The MAVLink message to compress the data into
+ * @param v2_extension C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_v2_extension_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_v2_extension_t* v2_extension)
+{
+	return mavlink_msg_v2_extension_pack(system_id, component_id, msg, v2_extension->target_network, v2_extension->target_system, v2_extension->target_component, v2_extension->message_type, v2_extension->payload);
+}
+
+/**
+ * @brief Encode a v2_extension struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param v2_extension C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_v2_extension_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_v2_extension_t* v2_extension)
+{
+	return mavlink_msg_v2_extension_pack_chan(system_id, component_id, chan, msg, v2_extension->target_network, v2_extension->target_system, v2_extension->target_component, v2_extension->message_type, v2_extension->payload);
+}
+
+/**
+ * @brief Send a v2_extension message
+ * @param chan MAVLink channel to send the message
+ *
+ * @param target_network Network ID (0 for broadcast)
+ * @param target_system System ID (0 for broadcast)
+ * @param target_component Component ID (0 for broadcast)
+ * @param message_type A code that identifies the software component that understands this message (analogous to usb device classes or mime type strings).  If this code is less than 32768, it is considered a 'registered' protocol extension and the corresponding entry should be added to https://github.com/mavlink/mavlink/extension-message-ids.xml.  Software creators can register blocks of message IDs as needed (useful for GCS specific metadata, etc...). Message_types greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase.
+ * @param payload Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.
+ */
+#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
+
+static inline void mavlink_msg_v2_extension_send(mavlink_channel_t chan, uint8_t target_network, uint8_t target_system, uint8_t target_component, uint16_t message_type, const uint8_t *payload)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char buf[MAVLINK_MSG_ID_V2_EXTENSION_LEN];
+	_mav_put_uint16_t(buf, 0, message_type);
+	_mav_put_uint8_t(buf, 2, target_network);
+	_mav_put_uint8_t(buf, 3, target_system);
+	_mav_put_uint8_t(buf, 4, target_component);
+	_mav_put_uint8_t_array(buf, 5, payload, 249);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_V2_EXTENSION, buf, MAVLINK_MSG_ID_V2_EXTENSION_LEN, MAVLINK_MSG_ID_V2_EXTENSION_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_V2_EXTENSION, buf, MAVLINK_MSG_ID_V2_EXTENSION_LEN);
+#endif
+#else
+	mavlink_v2_extension_t packet;
+	packet.message_type = message_type;
+	packet.target_network = target_network;
+	packet.target_system = target_system;
+	packet.target_component = target_component;
+	mav_array_memcpy(packet.payload, payload, sizeof(uint8_t)*249);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_V2_EXTENSION, (const char *)&packet, MAVLINK_MSG_ID_V2_EXTENSION_LEN, MAVLINK_MSG_ID_V2_EXTENSION_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_V2_EXTENSION, (const char *)&packet, MAVLINK_MSG_ID_V2_EXTENSION_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_V2_EXTENSION_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_v2_extension_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint8_t target_network, uint8_t target_system, uint8_t target_component, uint16_t message_type, const uint8_t *payload)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint16_t(buf, 0, message_type);
+	_mav_put_uint8_t(buf, 2, target_network);
+	_mav_put_uint8_t(buf, 3, target_system);
+	_mav_put_uint8_t(buf, 4, target_component);
+	_mav_put_uint8_t_array(buf, 5, payload, 249);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_V2_EXTENSION, buf, MAVLINK_MSG_ID_V2_EXTENSION_LEN, MAVLINK_MSG_ID_V2_EXTENSION_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_V2_EXTENSION, buf, MAVLINK_MSG_ID_V2_EXTENSION_LEN);
+#endif
+#else
+	mavlink_v2_extension_t *packet = (mavlink_v2_extension_t *)msgbuf;
+	packet->message_type = message_type;
+	packet->target_network = target_network;
+	packet->target_system = target_system;
+	packet->target_component = target_component;
+	mav_array_memcpy(packet->payload, payload, sizeof(uint8_t)*249);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_V2_EXTENSION, (const char *)packet, MAVLINK_MSG_ID_V2_EXTENSION_LEN, MAVLINK_MSG_ID_V2_EXTENSION_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_V2_EXTENSION, (const char *)packet, MAVLINK_MSG_ID_V2_EXTENSION_LEN);
+#endif
+#endif
+}
+#endif
+
+#endif
+
+// MESSAGE V2_EXTENSION UNPACKING
+
+
+/**
+ * @brief Get field target_network from v2_extension message
+ *
+ * @return Network ID (0 for broadcast)
+ */
+static inline uint8_t mavlink_msg_v2_extension_get_target_network(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  2);
+}
+
+/**
+ * @brief Get field target_system from v2_extension message
+ *
+ * @return System ID (0 for broadcast)
+ */
+static inline uint8_t mavlink_msg_v2_extension_get_target_system(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  3);
+}
+
+/**
+ * @brief Get field target_component from v2_extension message
+ *
+ * @return Component ID (0 for broadcast)
+ */
+static inline uint8_t mavlink_msg_v2_extension_get_target_component(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint8_t(msg,  4);
+}
+
+/**
+ * @brief Get field message_type from v2_extension message
+ *
+ * @return A code that identifies the software component that understands this message (analogous to usb device classes or mime type strings).  If this code is less than 32768, it is considered a 'registered' protocol extension and the corresponding entry should be added to https://github.com/mavlink/mavlink/extension-message-ids.xml.  Software creators can register blocks of message IDs as needed (useful for GCS specific metadata, etc...). Message_types greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase.
+ */
+static inline uint16_t mavlink_msg_v2_extension_get_message_type(const mavlink_message_t* msg)
+{
+	return _MAV_RETURN_uint16_t(msg,  0);
+}
+
+/**
+ * @brief Get field payload from v2_extension message
+ *
+ * @return Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.
+ */
+static inline uint16_t mavlink_msg_v2_extension_get_payload(const mavlink_message_t* msg, uint8_t *payload)
+{
+	return _MAV_RETURN_uint8_t_array(msg, payload, 249,  5);
+}
+
+/**
+ * @brief Decode a v2_extension message into a struct
+ *
+ * @param msg The message to decode
+ * @param v2_extension C-struct to decode the message contents into
+ */
+static inline void mavlink_msg_v2_extension_decode(const mavlink_message_t* msg, mavlink_v2_extension_t* v2_extension)
+{
+#if MAVLINK_NEED_BYTE_SWAP
+	v2_extension->message_type = mavlink_msg_v2_extension_get_message_type(msg);
+	v2_extension->target_network = mavlink_msg_v2_extension_get_target_network(msg);
+	v2_extension->target_system = mavlink_msg_v2_extension_get_target_system(msg);
+	v2_extension->target_component = mavlink_msg_v2_extension_get_target_component(msg);
+	mavlink_msg_v2_extension_get_payload(msg, v2_extension->payload);
+#else
+	memcpy(v2_extension, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_V2_EXTENSION_LEN);
+#endif
+}
diff -BburpN v1.0.old/common/mavlink_msg_vfr_hud.h v1.0/common/mavlink_msg_vfr_hud.h
--- v1.0.old/common/mavlink_msg_vfr_hud.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_vfr_hud.h	2015-02-06 11:50:58.000000000 +0500
@@ -15,6 +15,9 @@ typedef struct __mavlink_vfr_hud_t
 #define MAVLINK_MSG_ID_VFR_HUD_LEN 20
 #define MAVLINK_MSG_ID_74_LEN 20
 
+#define MAVLINK_MSG_ID_VFR_HUD_CRC 20
+#define MAVLINK_MSG_ID_74_CRC 20
+
 
 
 #define MAVLINK_MESSAGE_INFO_VFR_HUD { \
@@ -48,7 +51,7 @@ static inline uint16_t mavlink_msg_vfr_h
 						       float airspeed, float groundspeed, int16_t heading, uint16_t throttle, float alt, float climb)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[20];
+	char buf[MAVLINK_MSG_ID_VFR_HUD_LEN];
 	_mav_put_float(buf, 0, airspeed);
 	_mav_put_float(buf, 4, groundspeed);
 	_mav_put_float(buf, 8, alt);
@@ -56,7 +59,7 @@ static inline uint16_t mavlink_msg_vfr_h
 	_mav_put_int16_t(buf, 16, heading);
 	_mav_put_uint16_t(buf, 18, throttle);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 20);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_VFR_HUD_LEN);
 #else
 	mavlink_vfr_hud_t packet;
 	packet.airspeed = airspeed;
@@ -66,18 +69,22 @@ static inline uint16_t mavlink_msg_vfr_h
 	packet.heading = heading;
 	packet.throttle = throttle;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 20);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_VFR_HUD_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_VFR_HUD;
-	return mavlink_finalize_message(msg, system_id, component_id, 20, 20);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_VFR_HUD_LEN, MAVLINK_MSG_ID_VFR_HUD_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_VFR_HUD_LEN);
+#endif
 }
 
 /**
  * @brief Pack a vfr_hud message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
  * @param airspeed Current airspeed in m/s
  * @param groundspeed Current ground speed in m/s
@@ -92,7 +99,7 @@ static inline uint16_t mavlink_msg_vfr_h
 						           float airspeed,float groundspeed,int16_t heading,uint16_t throttle,float alt,float climb)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[20];
+	char buf[MAVLINK_MSG_ID_VFR_HUD_LEN];
 	_mav_put_float(buf, 0, airspeed);
 	_mav_put_float(buf, 4, groundspeed);
 	_mav_put_float(buf, 8, alt);
@@ -100,7 +107,7 @@ static inline uint16_t mavlink_msg_vfr_h
 	_mav_put_int16_t(buf, 16, heading);
 	_mav_put_uint16_t(buf, 18, throttle);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 20);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_VFR_HUD_LEN);
 #else
 	mavlink_vfr_hud_t packet;
 	packet.airspeed = airspeed;
@@ -110,15 +117,19 @@ static inline uint16_t mavlink_msg_vfr_h
 	packet.heading = heading;
 	packet.throttle = throttle;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 20);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_VFR_HUD_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_VFR_HUD;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 20, 20);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_VFR_HUD_LEN, MAVLINK_MSG_ID_VFR_HUD_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_VFR_HUD_LEN);
+#endif
 }
 
 /**
- * @brief Encode a vfr_hud struct into a message
+ * @brief Encode a vfr_hud struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -131,6 +142,20 @@ static inline uint16_t mavlink_msg_vfr_h
 }
 
 /**
+ * @brief Encode a vfr_hud struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param vfr_hud C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_vfr_hud_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_vfr_hud_t* vfr_hud)
+{
+	return mavlink_msg_vfr_hud_pack_chan(system_id, component_id, chan, msg, vfr_hud->airspeed, vfr_hud->groundspeed, vfr_hud->heading, vfr_hud->throttle, vfr_hud->alt, vfr_hud->climb);
+}
+
+/**
  * @brief Send a vfr_hud message
  * @param chan MAVLink channel to send the message
  *
@@ -146,7 +171,7 @@ static inline uint16_t mavlink_msg_vfr_h
 static inline void mavlink_msg_vfr_hud_send(mavlink_channel_t chan, float airspeed, float groundspeed, int16_t heading, uint16_t throttle, float alt, float climb)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[20];
+	char buf[MAVLINK_MSG_ID_VFR_HUD_LEN];
 	_mav_put_float(buf, 0, airspeed);
 	_mav_put_float(buf, 4, groundspeed);
 	_mav_put_float(buf, 8, alt);
@@ -154,7 +179,11 @@ static inline void mavlink_msg_vfr_hud_s
 	_mav_put_int16_t(buf, 16, heading);
 	_mav_put_uint16_t(buf, 18, throttle);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VFR_HUD, buf, 20, 20);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VFR_HUD, buf, MAVLINK_MSG_ID_VFR_HUD_LEN, MAVLINK_MSG_ID_VFR_HUD_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VFR_HUD, buf, MAVLINK_MSG_ID_VFR_HUD_LEN);
+#endif
 #else
 	mavlink_vfr_hud_t packet;
 	packet.airspeed = airspeed;
@@ -164,10 +193,56 @@ static inline void mavlink_msg_vfr_hud_s
 	packet.heading = heading;
 	packet.throttle = throttle;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VFR_HUD, (const char *)&packet, 20, 20);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VFR_HUD, (const char *)&packet, MAVLINK_MSG_ID_VFR_HUD_LEN, MAVLINK_MSG_ID_VFR_HUD_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VFR_HUD, (const char *)&packet, MAVLINK_MSG_ID_VFR_HUD_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_VFR_HUD_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_vfr_hud_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  float airspeed, float groundspeed, int16_t heading, uint16_t throttle, float alt, float climb)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_float(buf, 0, airspeed);
+	_mav_put_float(buf, 4, groundspeed);
+	_mav_put_float(buf, 8, alt);
+	_mav_put_float(buf, 12, climb);
+	_mav_put_int16_t(buf, 16, heading);
+	_mav_put_uint16_t(buf, 18, throttle);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VFR_HUD, buf, MAVLINK_MSG_ID_VFR_HUD_LEN, MAVLINK_MSG_ID_VFR_HUD_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VFR_HUD, buf, MAVLINK_MSG_ID_VFR_HUD_LEN);
+#endif
+#else
+	mavlink_vfr_hud_t *packet = (mavlink_vfr_hud_t *)msgbuf;
+	packet->airspeed = airspeed;
+	packet->groundspeed = groundspeed;
+	packet->alt = alt;
+	packet->climb = climb;
+	packet->heading = heading;
+	packet->throttle = throttle;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VFR_HUD, (const char *)packet, MAVLINK_MSG_ID_VFR_HUD_LEN, MAVLINK_MSG_ID_VFR_HUD_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VFR_HUD, (const char *)packet, MAVLINK_MSG_ID_VFR_HUD_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE VFR_HUD UNPACKING
@@ -249,6 +324,6 @@ static inline void mavlink_msg_vfr_hud_d
 	vfr_hud->heading = mavlink_msg_vfr_hud_get_heading(msg);
 	vfr_hud->throttle = mavlink_msg_vfr_hud_get_throttle(msg);
 #else
-	memcpy(vfr_hud, _MAV_PAYLOAD(msg), 20);
+	memcpy(vfr_hud, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_VFR_HUD_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_vicon_position_estimate.h v1.0/common/mavlink_msg_vicon_position_estimate.h
--- v1.0.old/common/mavlink_msg_vicon_position_estimate.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_vicon_position_estimate.h	2015-02-06 11:50:58.000000000 +0500
@@ -4,7 +4,7 @@
 
 typedef struct __mavlink_vicon_position_estimate_t
 {
- uint64_t usec; ///< Timestamp (milliseconds)
+ uint64_t usec; ///< Timestamp (microseconds, synced to UNIX time or since system boot)
  float x; ///< Global X position
  float y; ///< Global Y position
  float z; ///< Global Z position
@@ -16,6 +16,9 @@ typedef struct __mavlink_vicon_position_
 #define MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN 32
 #define MAVLINK_MSG_ID_104_LEN 32
 
+#define MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_CRC 56
+#define MAVLINK_MSG_ID_104_CRC 56
+
 
 
 #define MAVLINK_MESSAGE_INFO_VICON_POSITION_ESTIMATE { \
@@ -38,7 +41,7 @@ typedef struct __mavlink_vicon_position_
  * @param component_id ID of this component (e.g. 200 for IMU)
  * @param msg The MAVLink message to compress the data into
  *
- * @param usec Timestamp (milliseconds)
+ * @param usec Timestamp (microseconds, synced to UNIX time or since system boot)
  * @param x Global X position
  * @param y Global Y position
  * @param z Global Z position
@@ -51,7 +54,7 @@ static inline uint16_t mavlink_msg_vicon
 						       uint64_t usec, float x, float y, float z, float roll, float pitch, float yaw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[32];
+	char buf[MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN];
 	_mav_put_uint64_t(buf, 0, usec);
 	_mav_put_float(buf, 8, x);
 	_mav_put_float(buf, 12, y);
@@ -60,7 +63,7 @@ static inline uint16_t mavlink_msg_vicon
 	_mav_put_float(buf, 24, pitch);
 	_mav_put_float(buf, 28, yaw);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN);
 #else
 	mavlink_vicon_position_estimate_t packet;
 	packet.usec = usec;
@@ -71,20 +74,24 @@ static inline uint16_t mavlink_msg_vicon
 	packet.pitch = pitch;
 	packet.yaw = yaw;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE;
-	return mavlink_finalize_message(msg, system_id, component_id, 32, 56);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN);
+#endif
 }
 
 /**
  * @brief Pack a vicon_position_estimate message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
- * @param usec Timestamp (milliseconds)
+ * @param usec Timestamp (microseconds, synced to UNIX time or since system boot)
  * @param x Global X position
  * @param y Global Y position
  * @param z Global Z position
@@ -98,7 +105,7 @@ static inline uint16_t mavlink_msg_vicon
 						           uint64_t usec,float x,float y,float z,float roll,float pitch,float yaw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[32];
+	char buf[MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN];
 	_mav_put_uint64_t(buf, 0, usec);
 	_mav_put_float(buf, 8, x);
 	_mav_put_float(buf, 12, y);
@@ -107,7 +114,7 @@ static inline uint16_t mavlink_msg_vicon
 	_mav_put_float(buf, 24, pitch);
 	_mav_put_float(buf, 28, yaw);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN);
 #else
 	mavlink_vicon_position_estimate_t packet;
 	packet.usec = usec;
@@ -118,15 +125,19 @@ static inline uint16_t mavlink_msg_vicon
 	packet.pitch = pitch;
 	packet.yaw = yaw;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 32, 56);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN);
+#endif
 }
 
 /**
- * @brief Encode a vicon_position_estimate struct into a message
+ * @brief Encode a vicon_position_estimate struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -139,10 +150,24 @@ static inline uint16_t mavlink_msg_vicon
 }
 
 /**
+ * @brief Encode a vicon_position_estimate struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param vicon_position_estimate C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_vicon_position_estimate_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_vicon_position_estimate_t* vicon_position_estimate)
+{
+	return mavlink_msg_vicon_position_estimate_pack_chan(system_id, component_id, chan, msg, vicon_position_estimate->usec, vicon_position_estimate->x, vicon_position_estimate->y, vicon_position_estimate->z, vicon_position_estimate->roll, vicon_position_estimate->pitch, vicon_position_estimate->yaw);
+}
+
+/**
  * @brief Send a vicon_position_estimate message
  * @param chan MAVLink channel to send the message
  *
- * @param usec Timestamp (milliseconds)
+ * @param usec Timestamp (microseconds, synced to UNIX time or since system boot)
  * @param x Global X position
  * @param y Global Y position
  * @param z Global Z position
@@ -155,7 +180,7 @@ static inline uint16_t mavlink_msg_vicon
 static inline void mavlink_msg_vicon_position_estimate_send(mavlink_channel_t chan, uint64_t usec, float x, float y, float z, float roll, float pitch, float yaw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[32];
+	char buf[MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN];
 	_mav_put_uint64_t(buf, 0, usec);
 	_mav_put_float(buf, 8, x);
 	_mav_put_float(buf, 12, y);
@@ -164,7 +189,11 @@ static inline void mavlink_msg_vicon_pos
 	_mav_put_float(buf, 24, pitch);
 	_mav_put_float(buf, 28, yaw);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE, buf, 32, 56);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE, buf, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE, buf, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN);
+#endif
 #else
 	mavlink_vicon_position_estimate_t packet;
 	packet.usec = usec;
@@ -175,9 +204,57 @@ static inline void mavlink_msg_vicon_pos
 	packet.pitch = pitch;
 	packet.yaw = yaw;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE, (const char *)&packet, 32, 56);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE, (const char *)&packet, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE, (const char *)&packet, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_vicon_position_estimate_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t usec, float x, float y, float z, float roll, float pitch, float yaw)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, usec);
+	_mav_put_float(buf, 8, x);
+	_mav_put_float(buf, 12, y);
+	_mav_put_float(buf, 16, z);
+	_mav_put_float(buf, 20, roll);
+	_mav_put_float(buf, 24, pitch);
+	_mav_put_float(buf, 28, yaw);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE, buf, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE, buf, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN);
+#endif
+#else
+	mavlink_vicon_position_estimate_t *packet = (mavlink_vicon_position_estimate_t *)msgbuf;
+	packet->usec = usec;
+	packet->x = x;
+	packet->y = y;
+	packet->z = z;
+	packet->roll = roll;
+	packet->pitch = pitch;
+	packet->yaw = yaw;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE, (const char *)packet, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE, (const char *)packet, MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -187,7 +264,7 @@ static inline void mavlink_msg_vicon_pos
 /**
  * @brief Get field usec from vicon_position_estimate message
  *
- * @return Timestamp (milliseconds)
+ * @return Timestamp (microseconds, synced to UNIX time or since system boot)
  */
 static inline uint64_t mavlink_msg_vicon_position_estimate_get_usec(const mavlink_message_t* msg)
 {
@@ -271,6 +348,6 @@ static inline void mavlink_msg_vicon_pos
 	vicon_position_estimate->pitch = mavlink_msg_vicon_position_estimate_get_pitch(msg);
 	vicon_position_estimate->yaw = mavlink_msg_vicon_position_estimate_get_yaw(msg);
 #else
-	memcpy(vicon_position_estimate, _MAV_PAYLOAD(msg), 32);
+	memcpy(vicon_position_estimate, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_vision_position_estimate.h v1.0/common/mavlink_msg_vision_position_estimate.h
--- v1.0.old/common/mavlink_msg_vision_position_estimate.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_vision_position_estimate.h	2015-02-06 11:50:58.000000000 +0500
@@ -4,7 +4,7 @@
 
 typedef struct __mavlink_vision_position_estimate_t
 {
- uint64_t usec; ///< Timestamp (milliseconds)
+ uint64_t usec; ///< Timestamp (microseconds, synced to UNIX time or since system boot)
  float x; ///< Global X position
  float y; ///< Global Y position
  float z; ///< Global Z position
@@ -16,6 +16,9 @@ typedef struct __mavlink_vision_position
 #define MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN 32
 #define MAVLINK_MSG_ID_102_LEN 32
 
+#define MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_CRC 158
+#define MAVLINK_MSG_ID_102_CRC 158
+
 
 
 #define MAVLINK_MESSAGE_INFO_VISION_POSITION_ESTIMATE { \
@@ -38,7 +41,7 @@ typedef struct __mavlink_vision_position
  * @param component_id ID of this component (e.g. 200 for IMU)
  * @param msg The MAVLink message to compress the data into
  *
- * @param usec Timestamp (milliseconds)
+ * @param usec Timestamp (microseconds, synced to UNIX time or since system boot)
  * @param x Global X position
  * @param y Global Y position
  * @param z Global Z position
@@ -51,7 +54,7 @@ static inline uint16_t mavlink_msg_visio
 						       uint64_t usec, float x, float y, float z, float roll, float pitch, float yaw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[32];
+	char buf[MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN];
 	_mav_put_uint64_t(buf, 0, usec);
 	_mav_put_float(buf, 8, x);
 	_mav_put_float(buf, 12, y);
@@ -60,7 +63,7 @@ static inline uint16_t mavlink_msg_visio
 	_mav_put_float(buf, 24, pitch);
 	_mav_put_float(buf, 28, yaw);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN);
 #else
 	mavlink_vision_position_estimate_t packet;
 	packet.usec = usec;
@@ -71,20 +74,24 @@ static inline uint16_t mavlink_msg_visio
 	packet.pitch = pitch;
 	packet.yaw = yaw;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE;
-	return mavlink_finalize_message(msg, system_id, component_id, 32, 158);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN);
+#endif
 }
 
 /**
  * @brief Pack a vision_position_estimate message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
- * @param usec Timestamp (milliseconds)
+ * @param usec Timestamp (microseconds, synced to UNIX time or since system boot)
  * @param x Global X position
  * @param y Global Y position
  * @param z Global Z position
@@ -98,7 +105,7 @@ static inline uint16_t mavlink_msg_visio
 						           uint64_t usec,float x,float y,float z,float roll,float pitch,float yaw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[32];
+	char buf[MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN];
 	_mav_put_uint64_t(buf, 0, usec);
 	_mav_put_float(buf, 8, x);
 	_mav_put_float(buf, 12, y);
@@ -107,7 +114,7 @@ static inline uint16_t mavlink_msg_visio
 	_mav_put_float(buf, 24, pitch);
 	_mav_put_float(buf, 28, yaw);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN);
 #else
 	mavlink_vision_position_estimate_t packet;
 	packet.usec = usec;
@@ -118,15 +125,19 @@ static inline uint16_t mavlink_msg_visio
 	packet.pitch = pitch;
 	packet.yaw = yaw;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 32);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 32, 158);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN);
+#endif
 }
 
 /**
- * @brief Encode a vision_position_estimate struct into a message
+ * @brief Encode a vision_position_estimate struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -139,10 +150,24 @@ static inline uint16_t mavlink_msg_visio
 }
 
 /**
+ * @brief Encode a vision_position_estimate struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param vision_position_estimate C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_vision_position_estimate_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_vision_position_estimate_t* vision_position_estimate)
+{
+	return mavlink_msg_vision_position_estimate_pack_chan(system_id, component_id, chan, msg, vision_position_estimate->usec, vision_position_estimate->x, vision_position_estimate->y, vision_position_estimate->z, vision_position_estimate->roll, vision_position_estimate->pitch, vision_position_estimate->yaw);
+}
+
+/**
  * @brief Send a vision_position_estimate message
  * @param chan MAVLink channel to send the message
  *
- * @param usec Timestamp (milliseconds)
+ * @param usec Timestamp (microseconds, synced to UNIX time or since system boot)
  * @param x Global X position
  * @param y Global Y position
  * @param z Global Z position
@@ -155,7 +180,7 @@ static inline uint16_t mavlink_msg_visio
 static inline void mavlink_msg_vision_position_estimate_send(mavlink_channel_t chan, uint64_t usec, float x, float y, float z, float roll, float pitch, float yaw)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[32];
+	char buf[MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN];
 	_mav_put_uint64_t(buf, 0, usec);
 	_mav_put_float(buf, 8, x);
 	_mav_put_float(buf, 12, y);
@@ -164,7 +189,11 @@ static inline void mavlink_msg_vision_po
 	_mav_put_float(buf, 24, pitch);
 	_mav_put_float(buf, 28, yaw);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE, buf, 32, 158);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE, buf, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE, buf, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN);
+#endif
 #else
 	mavlink_vision_position_estimate_t packet;
 	packet.usec = usec;
@@ -175,9 +204,57 @@ static inline void mavlink_msg_vision_po
 	packet.pitch = pitch;
 	packet.yaw = yaw;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE, (const char *)&packet, 32, 158);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE, (const char *)&packet, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE, (const char *)&packet, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN);
+#endif
+#endif
+}
+
+#if MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_vision_position_estimate_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t usec, float x, float y, float z, float roll, float pitch, float yaw)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, usec);
+	_mav_put_float(buf, 8, x);
+	_mav_put_float(buf, 12, y);
+	_mav_put_float(buf, 16, z);
+	_mav_put_float(buf, 20, roll);
+	_mav_put_float(buf, 24, pitch);
+	_mav_put_float(buf, 28, yaw);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE, buf, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE, buf, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN);
+#endif
+#else
+	mavlink_vision_position_estimate_t *packet = (mavlink_vision_position_estimate_t *)msgbuf;
+	packet->usec = usec;
+	packet->x = x;
+	packet->y = y;
+	packet->z = z;
+	packet->roll = roll;
+	packet->pitch = pitch;
+	packet->yaw = yaw;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE, (const char *)packet, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE, (const char *)packet, MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN);
+#endif
 #endif
 }
+#endif
 
 #endif
 
@@ -187,7 +264,7 @@ static inline void mavlink_msg_vision_po
 /**
  * @brief Get field usec from vision_position_estimate message
  *
- * @return Timestamp (milliseconds)
+ * @return Timestamp (microseconds, synced to UNIX time or since system boot)
  */
 static inline uint64_t mavlink_msg_vision_position_estimate_get_usec(const mavlink_message_t* msg)
 {
@@ -271,6 +348,6 @@ static inline void mavlink_msg_vision_po
 	vision_position_estimate->pitch = mavlink_msg_vision_position_estimate_get_pitch(msg);
 	vision_position_estimate->yaw = mavlink_msg_vision_position_estimate_get_yaw(msg);
 #else
-	memcpy(vision_position_estimate, _MAV_PAYLOAD(msg), 32);
+	memcpy(vision_position_estimate, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/mavlink_msg_vision_speed_estimate.h v1.0/common/mavlink_msg_vision_speed_estimate.h
--- v1.0.old/common/mavlink_msg_vision_speed_estimate.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/mavlink_msg_vision_speed_estimate.h	2015-02-06 11:50:58.000000000 +0500
@@ -4,7 +4,7 @@
 
 typedef struct __mavlink_vision_speed_estimate_t
 {
- uint64_t usec; ///< Timestamp (milliseconds)
+ uint64_t usec; ///< Timestamp (microseconds, synced to UNIX time or since system boot)
  float x; ///< Global X speed
  float y; ///< Global Y speed
  float z; ///< Global Z speed
@@ -13,6 +13,9 @@ typedef struct __mavlink_vision_speed_es
 #define MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN 20
 #define MAVLINK_MSG_ID_103_LEN 20
 
+#define MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_CRC 208
+#define MAVLINK_MSG_ID_103_CRC 208
+
 
 
 #define MAVLINK_MESSAGE_INFO_VISION_SPEED_ESTIMATE { \
@@ -32,7 +35,7 @@ typedef struct __mavlink_vision_speed_es
  * @param component_id ID of this component (e.g. 200 for IMU)
  * @param msg The MAVLink message to compress the data into
  *
- * @param usec Timestamp (milliseconds)
+ * @param usec Timestamp (microseconds, synced to UNIX time or since system boot)
  * @param x Global X speed
  * @param y Global Y speed
  * @param z Global Z speed
@@ -42,13 +45,13 @@ static inline uint16_t mavlink_msg_visio
 						       uint64_t usec, float x, float y, float z)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[20];
+	char buf[MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN];
 	_mav_put_uint64_t(buf, 0, usec);
 	_mav_put_float(buf, 8, x);
 	_mav_put_float(buf, 12, y);
 	_mav_put_float(buf, 16, z);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 20);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN);
 #else
 	mavlink_vision_speed_estimate_t packet;
 	packet.usec = usec;
@@ -56,20 +59,24 @@ static inline uint16_t mavlink_msg_visio
 	packet.y = y;
 	packet.z = z;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 20);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE;
-	return mavlink_finalize_message(msg, system_id, component_id, 20, 208);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_CRC);
+#else
+    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN);
+#endif
 }
 
 /**
  * @brief Pack a vision_speed_estimate message on a channel
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
- * @param chan The MAVLink channel this message was sent over
+ * @param chan The MAVLink channel this message will be sent over
  * @param msg The MAVLink message to compress the data into
- * @param usec Timestamp (milliseconds)
+ * @param usec Timestamp (microseconds, synced to UNIX time or since system boot)
  * @param x Global X speed
  * @param y Global Y speed
  * @param z Global Z speed
@@ -80,13 +87,13 @@ static inline uint16_t mavlink_msg_visio
 						           uint64_t usec,float x,float y,float z)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[20];
+	char buf[MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN];
 	_mav_put_uint64_t(buf, 0, usec);
 	_mav_put_float(buf, 8, x);
 	_mav_put_float(buf, 12, y);
 	_mav_put_float(buf, 16, z);
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, 20);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN);
 #else
 	mavlink_vision_speed_estimate_t packet;
 	packet.usec = usec;
@@ -94,15 +101,19 @@ static inline uint16_t mavlink_msg_visio
 	packet.y = y;
 	packet.z = z;
 
-        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, 20);
+        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN);
 #endif
 
 	msg->msgid = MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE;
-	return mavlink_finalize_message_chan(msg, system_id, component_id, chan, 20, 208);
+#if MAVLINK_CRC_EXTRA
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_CRC);
+#else
+    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN);
+#endif
 }
 
 /**
- * @brief Encode a vision_speed_estimate struct into a message
+ * @brief Encode a vision_speed_estimate struct
  *
  * @param system_id ID of this system
  * @param component_id ID of this component (e.g. 200 for IMU)
@@ -115,10 +126,24 @@ static inline uint16_t mavlink_msg_visio
 }
 
 /**
+ * @brief Encode a vision_speed_estimate struct on a channel
+ *
+ * @param system_id ID of this system
+ * @param component_id ID of this component (e.g. 200 for IMU)
+ * @param chan The MAVLink channel this message will be sent over
+ * @param msg The MAVLink message to compress the data into
+ * @param vision_speed_estimate C-struct to read the message contents from
+ */
+static inline uint16_t mavlink_msg_vision_speed_estimate_encode_chan(uint8_t system_id, uint8_t component_id, uint8_t chan, mavlink_message_t* msg, const mavlink_vision_speed_estimate_t* vision_speed_estimate)
+{
+	return mavlink_msg_vision_speed_estimate_pack_chan(system_id, component_id, chan, msg, vision_speed_estimate->usec, vision_speed_estimate->x, vision_speed_estimate->y, vision_speed_estimate->z);
+}
+
+/**
  * @brief Send a vision_speed_estimate message
  * @param chan MAVLink channel to send the message
  *
- * @param usec Timestamp (milliseconds)
+ * @param usec Timestamp (microseconds, synced to UNIX time or since system boot)
  * @param x Global X speed
  * @param y Global Y speed
  * @param z Global Z speed
@@ -128,13 +153,17 @@ static inline uint16_t mavlink_msg_visio
 static inline void mavlink_msg_vision_speed_estimate_send(mavlink_channel_t chan, uint64_t usec, float x, float y, float z)
 {
 #if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
-	char buf[20];
+	char buf[MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN];
 	_mav_put_uint64_t(buf, 0, usec);
 	_mav_put_float(buf, 8, x);
 	_mav_put_float(buf, 12, y);
 	_mav_put_float(buf, 16, z);
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE, buf, 20, 208);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE, buf, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE, buf, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN);
+#endif
 #else
 	mavlink_vision_speed_estimate_t packet;
 	packet.usec = usec;
@@ -142,10 +171,52 @@ static inline void mavlink_msg_vision_sp
 	packet.y = y;
 	packet.z = z;
 
-	_mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE, (const char *)&packet, 20, 208);
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE, (const char *)&packet, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE, (const char *)&packet, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN);
+#endif
 #endif
 }
 
+#if MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN <= MAVLINK_MAX_PAYLOAD_LEN
+/*
+  This varient of _send() can be used to save stack space by re-using
+  memory from the receive buffer.  The caller provides a
+  mavlink_message_t which is the size of a full mavlink message. This
+  is usually the receive buffer for the channel, and allows a reply to an
+  incoming message with minimum stack space usage.
+ */
+static inline void mavlink_msg_vision_speed_estimate_send_buf(mavlink_message_t *msgbuf, mavlink_channel_t chan,  uint64_t usec, float x, float y, float z)
+{
+#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
+	char *buf = (char *)msgbuf;
+	_mav_put_uint64_t(buf, 0, usec);
+	_mav_put_float(buf, 8, x);
+	_mav_put_float(buf, 12, y);
+	_mav_put_float(buf, 16, z);
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE, buf, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE, buf, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN);
+#endif
+#else
+	mavlink_vision_speed_estimate_t *packet = (mavlink_vision_speed_estimate_t *)msgbuf;
+	packet->usec = usec;
+	packet->x = x;
+	packet->y = y;
+	packet->z = z;
+
+#if MAVLINK_CRC_EXTRA
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE, (const char *)packet, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_CRC);
+#else
+    _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE, (const char *)packet, MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN);
+#endif
+#endif
+}
+#endif
+
 #endif
 
 // MESSAGE VISION_SPEED_ESTIMATE UNPACKING
@@ -154,7 +225,7 @@ static inline void mavlink_msg_vision_sp
 /**
  * @brief Get field usec from vision_speed_estimate message
  *
- * @return Timestamp (milliseconds)
+ * @return Timestamp (microseconds, synced to UNIX time or since system boot)
  */
 static inline uint64_t mavlink_msg_vision_speed_estimate_get_usec(const mavlink_message_t* msg)
 {
@@ -205,6 +276,6 @@ static inline void mavlink_msg_vision_sp
 	vision_speed_estimate->y = mavlink_msg_vision_speed_estimate_get_y(msg);
 	vision_speed_estimate->z = mavlink_msg_vision_speed_estimate_get_z(msg);
 #else
-	memcpy(vision_speed_estimate, _MAV_PAYLOAD(msg), 20);
+	memcpy(vision_speed_estimate, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE_LEN);
 #endif
 }
diff -BburpN v1.0.old/common/testsuite.h v1.0/common/testsuite.h
--- v1.0.old/common/testsuite.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/testsuite.h	2015-02-06 11:50:58.000000000 +0500
@@ -30,12 +30,7 @@ static void mavlink_test_heartbeat(uint8
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_heartbeat_t packet_in = {
-		963497464,
-	17,
-	84,
-	151,
-	218,
-	3,
+		963497464,17,84,151,218,3
 	};
 	mavlink_heartbeat_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -83,19 +78,7 @@ static void mavlink_test_sys_status(uint
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_sys_status_t packet_in = {
-		963497464,
-	963497672,
-	963497880,
-	17859,
-	17963,
-	18067,
-	18171,
-	18275,
-	18379,
-	18483,
-	18587,
-	18691,
-	223,
+		963497464,963497672,963497880,17859,17963,18067,18171,18275,18379,18483,18587,18691,223
 	};
 	mavlink_sys_status_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -150,8 +133,7 @@ static void mavlink_test_system_time(uin
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_system_time_t packet_in = {
-		93372036854775807ULL,
-	963497880,
+		93372036854775807ULL,963497880
 	};
 	mavlink_system_time_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -195,10 +177,7 @@ static void mavlink_test_ping(uint8_t sy
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_ping_t packet_in = {
-		93372036854775807ULL,
-	963497880,
-	41,
-	108,
+		93372036854775807ULL,963497880,41,108
 	};
 	mavlink_ping_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -244,10 +223,7 @@ static void mavlink_test_change_operator
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_change_operator_control_t packet_in = {
-		5,
-	72,
-	139,
-	"DEFGHIJKLMNOPQRSTUVWXYZA",
+		5,72,139,"DEFGHIJKLMNOPQRSTUVWXYZA"
 	};
 	mavlink_change_operator_control_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -293,9 +269,7 @@ static void mavlink_test_change_operator
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_change_operator_control_ack_t packet_in = {
-		5,
-	72,
-	139,
+		5,72,139
 	};
 	mavlink_change_operator_control_ack_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -340,7 +314,7 @@ static void mavlink_test_auth_key(uint8_
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_auth_key_t packet_in = {
-		"ABCDEFGHIJKLMNOPQRSTUVWXYZABCDE",
+		"ABCDEFGHIJKLMNOPQRSTUVWXYZABCDE"
 	};
 	mavlink_auth_key_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -383,9 +357,7 @@ static void mavlink_test_set_mode(uint8_
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_set_mode_t packet_in = {
-		963497464,
-	17,
-	84,
+		963497464,17,84
 	};
 	mavlink_set_mode_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -430,10 +402,7 @@ static void mavlink_test_param_request_r
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_param_request_read_t packet_in = {
-		17235,
-	139,
-	206,
-	"EFGHIJKLMNOPQRS",
+		17235,139,206,"EFGHIJKLMNOPQRS"
 	};
 	mavlink_param_request_read_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -479,8 +448,7 @@ static void mavlink_test_param_request_l
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_param_request_list_t packet_in = {
-		5,
-	72,
+		5,72
 	};
 	mavlink_param_request_list_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -524,11 +492,7 @@ static void mavlink_test_param_value(uin
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_param_value_t packet_in = {
-		17.0,
-	17443,
-	17547,
-	"IJKLMNOPQRSTUVW",
-	77,
+		17.0,17443,17547,"IJKLMNOPQRSTUVW",77
 	};
 	mavlink_param_value_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -575,11 +539,7 @@ static void mavlink_test_param_set(uint8
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_param_set_t packet_in = {
-		17.0,
-	17,
-	84,
-	"GHIJKLMNOPQRSTU",
-	199,
+		17.0,17,84,"GHIJKLMNOPQRSTU",199
 	};
 	mavlink_param_set_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -626,16 +586,7 @@ static void mavlink_test_gps_raw_int(uin
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_gps_raw_int_t packet_in = {
-		93372036854775807ULL,
-	963497880,
-	963498088,
-	963498296,
-	18275,
-	18379,
-	18483,
-	18587,
-	89,
-	156,
+		93372036854775807ULL,963497880,963498088,963498296,18275,18379,18483,18587,89,156
 	};
 	mavlink_gps_raw_int_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -687,12 +638,7 @@ static void mavlink_test_gps_status(uint
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_gps_status_t packet_in = {
-		5,
-	{ 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91 },
-	{ 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151 },
-	{ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211 },
-	{ 252, 253, 254, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
-	{ 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75 },
+		5,{ 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91 },{ 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151 },{ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211 },{ 252, 253, 254, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },{ 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75 }
 	};
 	mavlink_gps_status_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -740,16 +686,7 @@ static void mavlink_test_scaled_imu(uint
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_scaled_imu_t packet_in = {
-		963497464,
-	17443,
-	17547,
-	17651,
-	17755,
-	17859,
-	17963,
-	18067,
-	18171,
-	18275,
+		963497464,17443,17547,17651,17755,17859,17963,18067,18171,18275
 	};
 	mavlink_scaled_imu_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -801,16 +738,7 @@ static void mavlink_test_raw_imu(uint8_t
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_raw_imu_t packet_in = {
-		93372036854775807ULL,
-	17651,
-	17755,
-	17859,
-	17963,
-	18067,
-	18171,
-	18275,
-	18379,
-	18483,
+		93372036854775807ULL,17651,17755,17859,17963,18067,18171,18275,18379,18483
 	};
 	mavlink_raw_imu_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -862,11 +790,7 @@ static void mavlink_test_raw_pressure(ui
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_raw_pressure_t packet_in = {
-		93372036854775807ULL,
-	17651,
-	17755,
-	17859,
-	17963,
+		93372036854775807ULL,17651,17755,17859,17963
 	};
 	mavlink_raw_pressure_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -913,10 +837,7 @@ static void mavlink_test_scaled_pressure
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_scaled_pressure_t packet_in = {
-		963497464,
-	45.0,
-	73.0,
-	17859,
+		963497464,45.0,73.0,17859
 	};
 	mavlink_scaled_pressure_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -962,13 +883,7 @@ static void mavlink_test_attitude(uint8_
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_attitude_t packet_in = {
-		963497464,
-	45.0,
-	73.0,
-	101.0,
-	129.0,
-	157.0,
-	185.0,
+		963497464,45.0,73.0,101.0,129.0,157.0,185.0
 	};
 	mavlink_attitude_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1017,14 +932,7 @@ static void mavlink_test_attitude_quater
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_attitude_quaternion_t packet_in = {
-		963497464,
-	45.0,
-	73.0,
-	101.0,
-	129.0,
-	157.0,
-	185.0,
-	213.0,
+		963497464,45.0,73.0,101.0,129.0,157.0,185.0,213.0
 	};
 	mavlink_attitude_quaternion_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1074,13 +982,7 @@ static void mavlink_test_local_position_
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_local_position_ned_t packet_in = {
-		963497464,
-	45.0,
-	73.0,
-	101.0,
-	129.0,
-	157.0,
-	185.0,
+		963497464,45.0,73.0,101.0,129.0,157.0,185.0
 	};
 	mavlink_local_position_ned_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1129,15 +1031,7 @@ static void mavlink_test_global_position
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_global_position_int_t packet_in = {
-		963497464,
-	963497672,
-	963497880,
-	963498088,
-	963498296,
-	18275,
-	18379,
-	18483,
-	18587,
+		963497464,963497672,963497880,963498088,963498296,18275,18379,18483,18587
 	};
 	mavlink_global_position_int_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1188,17 +1082,7 @@ static void mavlink_test_rc_channels_sca
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_rc_channels_scaled_t packet_in = {
-		963497464,
-	17443,
-	17547,
-	17651,
-	17755,
-	17859,
-	17963,
-	18067,
-	18171,
-	65,
-	132,
+		963497464,17443,17547,17651,17755,17859,17963,18067,18171,65,132
 	};
 	mavlink_rc_channels_scaled_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1251,17 +1135,7 @@ static void mavlink_test_rc_channels_raw
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_rc_channels_raw_t packet_in = {
-		963497464,
-	17443,
-	17547,
-	17651,
-	17755,
-	17859,
-	17963,
-	18067,
-	18171,
-	65,
-	132,
+		963497464,17443,17547,17651,17755,17859,17963,18067,18171,65,132
 	};
 	mavlink_rc_channels_raw_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1314,16 +1188,7 @@ static void mavlink_test_servo_output_ra
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_servo_output_raw_t packet_in = {
-		963497464,
-	17443,
-	17547,
-	17651,
-	17755,
-	17859,
-	17963,
-	18067,
-	18171,
-	65,
+		963497464,17443,17547,17651,17755,17859,17963,18067,18171,65
 	};
 	mavlink_servo_output_raw_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1375,10 +1240,7 @@ static void mavlink_test_mission_request
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_mission_request_partial_list_t packet_in = {
-		17235,
-	17339,
-	17,
-	84,
+		17235,17339,17,84
 	};
 	mavlink_mission_request_partial_list_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1424,10 +1286,7 @@ static void mavlink_test_mission_write_p
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_mission_write_partial_list_t packet_in = {
-		17235,
-	17339,
-	17,
-	84,
+		17235,17339,17,84
 	};
 	mavlink_mission_write_partial_list_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1473,20 +1332,7 @@ static void mavlink_test_mission_item(ui
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_mission_item_t packet_in = {
-		17.0,
-	45.0,
-	73.0,
-	101.0,
-	129.0,
-	157.0,
-	185.0,
-	18691,
-	18795,
-	101,
-	168,
-	235,
-	46,
-	113,
+		17.0,45.0,73.0,101.0,129.0,157.0,185.0,18691,18795,101,168,235,46,113
 	};
 	mavlink_mission_item_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1542,9 +1388,7 @@ static void mavlink_test_mission_request
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_mission_request_t packet_in = {
-		17235,
-	139,
-	206,
+		17235,139,206
 	};
 	mavlink_mission_request_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1589,9 +1433,7 @@ static void mavlink_test_mission_set_cur
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_mission_set_current_t packet_in = {
-		17235,
-	139,
-	206,
+		17235,139,206
 	};
 	mavlink_mission_set_current_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1636,7 +1478,7 @@ static void mavlink_test_mission_current
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_mission_current_t packet_in = {
-		17235,
+		17235
 	};
 	mavlink_mission_current_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1679,8 +1521,7 @@ static void mavlink_test_mission_request
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_mission_request_list_t packet_in = {
-		5,
-	72,
+		5,72
 	};
 	mavlink_mission_request_list_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1724,9 +1565,7 @@ static void mavlink_test_mission_count(u
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_mission_count_t packet_in = {
-		17235,
-	139,
-	206,
+		17235,139,206
 	};
 	mavlink_mission_count_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1771,8 +1610,7 @@ static void mavlink_test_mission_clear_a
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_mission_clear_all_t packet_in = {
-		5,
-	72,
+		5,72
 	};
 	mavlink_mission_clear_all_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1816,7 +1654,7 @@ static void mavlink_test_mission_item_re
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_mission_item_reached_t packet_in = {
-		17235,
+		17235
 	};
 	mavlink_mission_item_reached_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1859,9 +1697,7 @@ static void mavlink_test_mission_ack(uin
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_mission_ack_t packet_in = {
-		5,
-	72,
-	139,
+		5,72,139
 	};
 	mavlink_mission_ack_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1906,10 +1742,7 @@ static void mavlink_test_set_gps_global_
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_set_gps_global_origin_t packet_in = {
-		963497464,
-	963497672,
-	963497880,
-	41,
+		963497464,963497672,963497880,41
 	};
 	mavlink_set_gps_global_origin_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1955,9 +1788,7 @@ static void mavlink_test_gps_global_orig
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_gps_global_origin_t packet_in = {
-		963497464,
-	963497672,
-	963497880,
+		963497464,963497672,963497880
 	};
 	mavlink_gps_global_origin_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -1996,198 +1827,41 @@ static void mavlink_test_gps_global_orig
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_set_local_position_setpoint(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_param_map_rc(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_set_local_position_setpoint_t packet_in = {
-		17.0,
-	45.0,
-	73.0,
-	101.0,
-	53,
-	120,
-	187,
+	mavlink_param_map_rc_t packet_in = {
+		17.0,45.0,73.0,101.0,18067,187,254,"UVWXYZABCDEFGHI",113
 	};
-	mavlink_set_local_position_setpoint_t packet1, packet2;
+	mavlink_param_map_rc_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.x = packet_in.x;
-        	packet1.y = packet_in.y;
-        	packet1.z = packet_in.z;
-        	packet1.yaw = packet_in.yaw;
+        	packet1.param_value0 = packet_in.param_value0;
+        	packet1.scale = packet_in.scale;
+        	packet1.param_value_min = packet_in.param_value_min;
+        	packet1.param_value_max = packet_in.param_value_max;
+        	packet1.param_index = packet_in.param_index;
         	packet1.target_system = packet_in.target_system;
         	packet1.target_component = packet_in.target_component;
-        	packet1.coordinate_frame = packet_in.coordinate_frame;
-        
-        
-
-        memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_local_position_setpoint_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_set_local_position_setpoint_decode(&msg, &packet2);
-        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
-
-        memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_local_position_setpoint_pack(system_id, component_id, &msg , packet1.target_system , packet1.target_component , packet1.coordinate_frame , packet1.x , packet1.y , packet1.z , packet1.yaw );
-	mavlink_msg_set_local_position_setpoint_decode(&msg, &packet2);
-        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
-
-        memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_local_position_setpoint_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.target_component , packet1.coordinate_frame , packet1.x , packet1.y , packet1.z , packet1.yaw );
-	mavlink_msg_set_local_position_setpoint_decode(&msg, &packet2);
-        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
-
-        memset(&packet2, 0, sizeof(packet2));
-        mavlink_msg_to_send_buffer(buffer, &msg);
-        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
-        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
-        }
-	mavlink_msg_set_local_position_setpoint_decode(last_msg, &packet2);
-        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
-        
-        memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_local_position_setpoint_send(MAVLINK_COMM_1 , packet1.target_system , packet1.target_component , packet1.coordinate_frame , packet1.x , packet1.y , packet1.z , packet1.yaw );
-	mavlink_msg_set_local_position_setpoint_decode(last_msg, &packet2);
-        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
-}
-
-static void mavlink_test_local_position_setpoint(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
-{
-	mavlink_message_t msg;
-        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
-        uint16_t i;
-	mavlink_local_position_setpoint_t packet_in = {
-		17.0,
-	45.0,
-	73.0,
-	101.0,
-	53,
-	};
-	mavlink_local_position_setpoint_t packet1, packet2;
-        memset(&packet1, 0, sizeof(packet1));
-        	packet1.x = packet_in.x;
-        	packet1.y = packet_in.y;
-        	packet1.z = packet_in.z;
-        	packet1.yaw = packet_in.yaw;
-        	packet1.coordinate_frame = packet_in.coordinate_frame;
-        
-        
-
-        memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_local_position_setpoint_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_local_position_setpoint_decode(&msg, &packet2);
-        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
-
-        memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_local_position_setpoint_pack(system_id, component_id, &msg , packet1.coordinate_frame , packet1.x , packet1.y , packet1.z , packet1.yaw );
-	mavlink_msg_local_position_setpoint_decode(&msg, &packet2);
-        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
-
-        memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_local_position_setpoint_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.coordinate_frame , packet1.x , packet1.y , packet1.z , packet1.yaw );
-	mavlink_msg_local_position_setpoint_decode(&msg, &packet2);
-        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
-
-        memset(&packet2, 0, sizeof(packet2));
-        mavlink_msg_to_send_buffer(buffer, &msg);
-        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
-        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
-        }
-	mavlink_msg_local_position_setpoint_decode(last_msg, &packet2);
-        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
-        
-        memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_local_position_setpoint_send(MAVLINK_COMM_1 , packet1.coordinate_frame , packet1.x , packet1.y , packet1.z , packet1.yaw );
-	mavlink_msg_local_position_setpoint_decode(last_msg, &packet2);
-        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
-}
-
-static void mavlink_test_global_position_setpoint_int(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
-{
-	mavlink_message_t msg;
-        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
-        uint16_t i;
-	mavlink_global_position_setpoint_int_t packet_in = {
-		963497464,
-	963497672,
-	963497880,
-	17859,
-	175,
-	};
-	mavlink_global_position_setpoint_int_t packet1, packet2;
-        memset(&packet1, 0, sizeof(packet1));
-        	packet1.latitude = packet_in.latitude;
-        	packet1.longitude = packet_in.longitude;
-        	packet1.altitude = packet_in.altitude;
-        	packet1.yaw = packet_in.yaw;
-        	packet1.coordinate_frame = packet_in.coordinate_frame;
-        
-        
-
-        memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_global_position_setpoint_int_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_global_position_setpoint_int_decode(&msg, &packet2);
-        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
-
-        memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_global_position_setpoint_int_pack(system_id, component_id, &msg , packet1.coordinate_frame , packet1.latitude , packet1.longitude , packet1.altitude , packet1.yaw );
-	mavlink_msg_global_position_setpoint_int_decode(&msg, &packet2);
-        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
-
-        memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_global_position_setpoint_int_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.coordinate_frame , packet1.latitude , packet1.longitude , packet1.altitude , packet1.yaw );
-	mavlink_msg_global_position_setpoint_int_decode(&msg, &packet2);
-        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
-
-        memset(&packet2, 0, sizeof(packet2));
-        mavlink_msg_to_send_buffer(buffer, &msg);
-        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
-        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
-        }
-	mavlink_msg_global_position_setpoint_int_decode(last_msg, &packet2);
-        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
-        
-        memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_global_position_setpoint_int_send(MAVLINK_COMM_1 , packet1.coordinate_frame , packet1.latitude , packet1.longitude , packet1.altitude , packet1.yaw );
-	mavlink_msg_global_position_setpoint_int_decode(last_msg, &packet2);
-        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
-}
-
-static void mavlink_test_set_global_position_setpoint_int(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
-{
-	mavlink_message_t msg;
-        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
-        uint16_t i;
-	mavlink_set_global_position_setpoint_int_t packet_in = {
-		963497464,
-	963497672,
-	963497880,
-	17859,
-	175,
-	};
-	mavlink_set_global_position_setpoint_int_t packet1, packet2;
-        memset(&packet1, 0, sizeof(packet1));
-        	packet1.latitude = packet_in.latitude;
-        	packet1.longitude = packet_in.longitude;
-        	packet1.altitude = packet_in.altitude;
-        	packet1.yaw = packet_in.yaw;
-        	packet1.coordinate_frame = packet_in.coordinate_frame;
+        	packet1.parameter_rc_channel_index = packet_in.parameter_rc_channel_index;
         
+        	mav_array_memcpy(packet1.param_id, packet_in.param_id, sizeof(char)*16);
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_global_position_setpoint_int_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_set_global_position_setpoint_int_decode(&msg, &packet2);
+	mavlink_msg_param_map_rc_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_param_map_rc_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_global_position_setpoint_int_pack(system_id, component_id, &msg , packet1.coordinate_frame , packet1.latitude , packet1.longitude , packet1.altitude , packet1.yaw );
-	mavlink_msg_set_global_position_setpoint_int_decode(&msg, &packet2);
+	mavlink_msg_param_map_rc_pack(system_id, component_id, &msg , packet1.target_system , packet1.target_component , packet1.param_id , packet1.param_index , packet1.parameter_rc_channel_index , packet1.param_value0 , packet1.scale , packet1.param_value_min , packet1.param_value_max );
+	mavlink_msg_param_map_rc_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_global_position_setpoint_int_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.coordinate_frame , packet1.latitude , packet1.longitude , packet1.altitude , packet1.yaw );
-	mavlink_msg_set_global_position_setpoint_int_decode(&msg, &packet2);
+	mavlink_msg_param_map_rc_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.target_component , packet1.param_id , packet1.param_index , packet1.parameter_rc_channel_index , packet1.param_value0 , packet1.scale , packet1.param_value_min , packet1.param_value_max );
+	mavlink_msg_param_map_rc_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -2195,12 +1869,12 @@ static void mavlink_test_set_global_posi
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_set_global_position_setpoint_int_decode(last_msg, &packet2);
+	mavlink_msg_param_map_rc_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_global_position_setpoint_int_send(MAVLINK_COMM_1 , packet1.coordinate_frame , packet1.latitude , packet1.longitude , packet1.altitude , packet1.yaw );
-	mavlink_msg_set_global_position_setpoint_int_decode(last_msg, &packet2);
+	mavlink_msg_param_map_rc_send(MAVLINK_COMM_1 , packet1.target_system , packet1.target_component , packet1.param_id , packet1.param_index , packet1.parameter_rc_channel_index , packet1.param_value0 , packet1.scale , packet1.param_value_min , packet1.param_value_max );
+	mavlink_msg_param_map_rc_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
@@ -2210,15 +1884,7 @@ static void mavlink_test_safety_set_allo
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_safety_set_allowed_area_t packet_in = {
-		17.0,
-	45.0,
-	73.0,
-	101.0,
-	129.0,
-	157.0,
-	77,
-	144,
-	211,
+		17.0,45.0,73.0,101.0,129.0,157.0,77,144,211
 	};
 	mavlink_safety_set_allowed_area_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -2269,13 +1935,7 @@ static void mavlink_test_safety_allowed_
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_safety_allowed_area_t packet_in = {
-		17.0,
-	45.0,
-	73.0,
-	101.0,
-	129.0,
-	157.0,
-	77,
+		17.0,45.0,73.0,101.0,129.0,157.0,77
 	};
 	mavlink_safety_allowed_area_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -2318,43 +1978,38 @@ static void mavlink_test_safety_allowed_
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_set_roll_pitch_yaw_thrust(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_attitude_quaternion_cov(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_set_roll_pitch_yaw_thrust_t packet_in = {
-		17.0,
-	45.0,
-	73.0,
-	101.0,
-	53,
-	120,
+	mavlink_attitude_quaternion_cov_t packet_in = {
+		963497464,{ 45.0, 46.0, 47.0, 48.0 },157.0,185.0,213.0,{ 241.0, 242.0, 243.0, 244.0, 245.0, 246.0, 247.0, 248.0, 249.0 }
 	};
-	mavlink_set_roll_pitch_yaw_thrust_t packet1, packet2;
+	mavlink_attitude_quaternion_cov_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.roll = packet_in.roll;
-        	packet1.pitch = packet_in.pitch;
-        	packet1.yaw = packet_in.yaw;
-        	packet1.thrust = packet_in.thrust;
-        	packet1.target_system = packet_in.target_system;
-        	packet1.target_component = packet_in.target_component;
+        	packet1.time_boot_ms = packet_in.time_boot_ms;
+        	packet1.rollspeed = packet_in.rollspeed;
+        	packet1.pitchspeed = packet_in.pitchspeed;
+        	packet1.yawspeed = packet_in.yawspeed;
         
+        	mav_array_memcpy(packet1.q, packet_in.q, sizeof(float)*4);
+        	mav_array_memcpy(packet1.covariance, packet_in.covariance, sizeof(float)*9);
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_roll_pitch_yaw_thrust_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_set_roll_pitch_yaw_thrust_decode(&msg, &packet2);
+	mavlink_msg_attitude_quaternion_cov_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_attitude_quaternion_cov_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_roll_pitch_yaw_thrust_pack(system_id, component_id, &msg , packet1.target_system , packet1.target_component , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust );
-	mavlink_msg_set_roll_pitch_yaw_thrust_decode(&msg, &packet2);
+	mavlink_msg_attitude_quaternion_cov_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.q , packet1.rollspeed , packet1.pitchspeed , packet1.yawspeed , packet1.covariance );
+	mavlink_msg_attitude_quaternion_cov_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_roll_pitch_yaw_thrust_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.target_component , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust );
-	mavlink_msg_set_roll_pitch_yaw_thrust_decode(&msg, &packet2);
+	mavlink_msg_attitude_quaternion_cov_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.q , packet1.rollspeed , packet1.pitchspeed , packet1.yawspeed , packet1.covariance );
+	mavlink_msg_attitude_quaternion_cov_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -2362,52 +2017,49 @@ static void mavlink_test_set_roll_pitch_
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_set_roll_pitch_yaw_thrust_decode(last_msg, &packet2);
+	mavlink_msg_attitude_quaternion_cov_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_roll_pitch_yaw_thrust_send(MAVLINK_COMM_1 , packet1.target_system , packet1.target_component , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust );
-	mavlink_msg_set_roll_pitch_yaw_thrust_decode(last_msg, &packet2);
+	mavlink_msg_attitude_quaternion_cov_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.q , packet1.rollspeed , packet1.pitchspeed , packet1.yawspeed , packet1.covariance );
+	mavlink_msg_attitude_quaternion_cov_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_set_roll_pitch_yaw_speed_thrust(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_nav_controller_output(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_set_roll_pitch_yaw_speed_thrust_t packet_in = {
-		17.0,
-	45.0,
-	73.0,
-	101.0,
-	53,
-	120,
+	mavlink_nav_controller_output_t packet_in = {
+		17.0,45.0,73.0,101.0,129.0,18275,18379,18483
 	};
-	mavlink_set_roll_pitch_yaw_speed_thrust_t packet1, packet2;
+	mavlink_nav_controller_output_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.roll_speed = packet_in.roll_speed;
-        	packet1.pitch_speed = packet_in.pitch_speed;
-        	packet1.yaw_speed = packet_in.yaw_speed;
-        	packet1.thrust = packet_in.thrust;
-        	packet1.target_system = packet_in.target_system;
-        	packet1.target_component = packet_in.target_component;
+        	packet1.nav_roll = packet_in.nav_roll;
+        	packet1.nav_pitch = packet_in.nav_pitch;
+        	packet1.alt_error = packet_in.alt_error;
+        	packet1.aspd_error = packet_in.aspd_error;
+        	packet1.xtrack_error = packet_in.xtrack_error;
+        	packet1.nav_bearing = packet_in.nav_bearing;
+        	packet1.target_bearing = packet_in.target_bearing;
+        	packet1.wp_dist = packet_in.wp_dist;
         
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_roll_pitch_yaw_speed_thrust_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_set_roll_pitch_yaw_speed_thrust_decode(&msg, &packet2);
+	mavlink_msg_nav_controller_output_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_nav_controller_output_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_roll_pitch_yaw_speed_thrust_pack(system_id, component_id, &msg , packet1.target_system , packet1.target_component , packet1.roll_speed , packet1.pitch_speed , packet1.yaw_speed , packet1.thrust );
-	mavlink_msg_set_roll_pitch_yaw_speed_thrust_decode(&msg, &packet2);
+	mavlink_msg_nav_controller_output_pack(system_id, component_id, &msg , packet1.nav_roll , packet1.nav_pitch , packet1.nav_bearing , packet1.target_bearing , packet1.wp_dist , packet1.alt_error , packet1.aspd_error , packet1.xtrack_error );
+	mavlink_msg_nav_controller_output_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_roll_pitch_yaw_speed_thrust_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.target_component , packet1.roll_speed , packet1.pitch_speed , packet1.yaw_speed , packet1.thrust );
-	mavlink_msg_set_roll_pitch_yaw_speed_thrust_decode(&msg, &packet2);
+	mavlink_msg_nav_controller_output_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.nav_roll , packet1.nav_pitch , packet1.nav_bearing , packet1.target_bearing , packet1.wp_dist , packet1.alt_error , packet1.aspd_error , packet1.xtrack_error );
+	mavlink_msg_nav_controller_output_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -2415,50 +2067,52 @@ static void mavlink_test_set_roll_pitch_
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_set_roll_pitch_yaw_speed_thrust_decode(last_msg, &packet2);
+	mavlink_msg_nav_controller_output_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_roll_pitch_yaw_speed_thrust_send(MAVLINK_COMM_1 , packet1.target_system , packet1.target_component , packet1.roll_speed , packet1.pitch_speed , packet1.yaw_speed , packet1.thrust );
-	mavlink_msg_set_roll_pitch_yaw_speed_thrust_decode(last_msg, &packet2);
+	mavlink_msg_nav_controller_output_send(MAVLINK_COMM_1 , packet1.nav_roll , packet1.nav_pitch , packet1.nav_bearing , packet1.target_bearing , packet1.wp_dist , packet1.alt_error , packet1.aspd_error , packet1.xtrack_error );
+	mavlink_msg_nav_controller_output_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_roll_pitch_yaw_thrust_setpoint(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_global_position_int_cov(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_roll_pitch_yaw_thrust_setpoint_t packet_in = {
-		963497464,
-	45.0,
-	73.0,
-	101.0,
-	129.0,
+	mavlink_global_position_int_cov_t packet_in = {
+		93372036854775807ULL,963497880,963498088,963498296,963498504,963498712,213.0,241.0,269.0,{ 297.0, 298.0, 299.0, 300.0, 301.0, 302.0, 303.0, 304.0, 305.0, 306.0, 307.0, 308.0, 309.0, 310.0, 311.0, 312.0, 313.0, 314.0, 315.0, 316.0, 317.0, 318.0, 319.0, 320.0, 321.0, 322.0, 323.0, 324.0, 325.0, 326.0, 327.0, 328.0, 329.0, 330.0, 331.0, 332.0 },45
 	};
-	mavlink_roll_pitch_yaw_thrust_setpoint_t packet1, packet2;
+	mavlink_global_position_int_cov_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_utc = packet_in.time_utc;
         	packet1.time_boot_ms = packet_in.time_boot_ms;
-        	packet1.roll = packet_in.roll;
-        	packet1.pitch = packet_in.pitch;
-        	packet1.yaw = packet_in.yaw;
-        	packet1.thrust = packet_in.thrust;
+        	packet1.lat = packet_in.lat;
+        	packet1.lon = packet_in.lon;
+        	packet1.alt = packet_in.alt;
+        	packet1.relative_alt = packet_in.relative_alt;
+        	packet1.vx = packet_in.vx;
+        	packet1.vy = packet_in.vy;
+        	packet1.vz = packet_in.vz;
+        	packet1.estimator_type = packet_in.estimator_type;
         
+        	mav_array_memcpy(packet1.covariance, packet_in.covariance, sizeof(float)*36);
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_roll_pitch_yaw_thrust_setpoint_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_roll_pitch_yaw_thrust_setpoint_decode(&msg, &packet2);
+	mavlink_msg_global_position_int_cov_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_global_position_int_cov_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_roll_pitch_yaw_thrust_setpoint_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust );
-	mavlink_msg_roll_pitch_yaw_thrust_setpoint_decode(&msg, &packet2);
+	mavlink_msg_global_position_int_cov_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.time_utc , packet1.estimator_type , packet1.lat , packet1.lon , packet1.alt , packet1.relative_alt , packet1.vx , packet1.vy , packet1.vz , packet1.covariance );
+	mavlink_msg_global_position_int_cov_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_roll_pitch_yaw_thrust_setpoint_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust );
-	mavlink_msg_roll_pitch_yaw_thrust_setpoint_decode(&msg, &packet2);
+	mavlink_msg_global_position_int_cov_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.time_utc , packet1.estimator_type , packet1.lat , packet1.lon , packet1.alt , packet1.relative_alt , packet1.vx , packet1.vy , packet1.vz , packet1.covariance );
+	mavlink_msg_global_position_int_cov_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -2466,50 +2120,51 @@ static void mavlink_test_roll_pitch_yaw_
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_roll_pitch_yaw_thrust_setpoint_decode(last_msg, &packet2);
+	mavlink_msg_global_position_int_cov_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_roll_pitch_yaw_thrust_setpoint_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust );
-	mavlink_msg_roll_pitch_yaw_thrust_setpoint_decode(last_msg, &packet2);
+	mavlink_msg_global_position_int_cov_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.time_utc , packet1.estimator_type , packet1.lat , packet1.lon , packet1.alt , packet1.relative_alt , packet1.vx , packet1.vy , packet1.vz , packet1.covariance );
+	mavlink_msg_global_position_int_cov_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_roll_pitch_yaw_speed_thrust_setpoint(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_local_position_ned_cov(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_roll_pitch_yaw_speed_thrust_setpoint_t packet_in = {
-		963497464,
-	45.0,
-	73.0,
-	101.0,
-	129.0,
+	mavlink_local_position_ned_cov_t packet_in = {
+		93372036854775807ULL,963497880,101.0,129.0,157.0,185.0,213.0,241.0,{ 269.0, 270.0, 271.0, 272.0, 273.0, 274.0, 275.0, 276.0, 277.0, 278.0, 279.0, 280.0, 281.0, 282.0, 283.0, 284.0, 285.0, 286.0, 287.0, 288.0, 289.0, 290.0, 291.0, 292.0, 293.0, 294.0, 295.0, 296.0, 297.0, 298.0, 299.0, 300.0, 301.0, 302.0, 303.0, 304.0 },33
 	};
-	mavlink_roll_pitch_yaw_speed_thrust_setpoint_t packet1, packet2;
+	mavlink_local_position_ned_cov_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_utc = packet_in.time_utc;
         	packet1.time_boot_ms = packet_in.time_boot_ms;
-        	packet1.roll_speed = packet_in.roll_speed;
-        	packet1.pitch_speed = packet_in.pitch_speed;
-        	packet1.yaw_speed = packet_in.yaw_speed;
-        	packet1.thrust = packet_in.thrust;
+        	packet1.x = packet_in.x;
+        	packet1.y = packet_in.y;
+        	packet1.z = packet_in.z;
+        	packet1.vx = packet_in.vx;
+        	packet1.vy = packet_in.vy;
+        	packet1.vz = packet_in.vz;
+        	packet1.estimator_type = packet_in.estimator_type;
         
+        	mav_array_memcpy(packet1.covariance, packet_in.covariance, sizeof(float)*36);
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_roll_pitch_yaw_speed_thrust_setpoint_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_roll_pitch_yaw_speed_thrust_setpoint_decode(&msg, &packet2);
+	mavlink_msg_local_position_ned_cov_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_local_position_ned_cov_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_roll_pitch_yaw_speed_thrust_setpoint_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.roll_speed , packet1.pitch_speed , packet1.yaw_speed , packet1.thrust );
-	mavlink_msg_roll_pitch_yaw_speed_thrust_setpoint_decode(&msg, &packet2);
+	mavlink_msg_local_position_ned_cov_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.time_utc , packet1.estimator_type , packet1.x , packet1.y , packet1.z , packet1.vx , packet1.vy , packet1.vz , packet1.covariance );
+	mavlink_msg_local_position_ned_cov_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_roll_pitch_yaw_speed_thrust_setpoint_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.roll_speed , packet1.pitch_speed , packet1.yaw_speed , packet1.thrust );
-	mavlink_msg_roll_pitch_yaw_speed_thrust_setpoint_decode(&msg, &packet2);
+	mavlink_msg_local_position_ned_cov_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.time_utc , packet1.estimator_type , packet1.x , packet1.y , packet1.z , packet1.vx , packet1.vy , packet1.vz , packet1.covariance );
+	mavlink_msg_local_position_ned_cov_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -2517,50 +2172,62 @@ static void mavlink_test_roll_pitch_yaw_
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_roll_pitch_yaw_speed_thrust_setpoint_decode(last_msg, &packet2);
+	mavlink_msg_local_position_ned_cov_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_roll_pitch_yaw_speed_thrust_setpoint_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.roll_speed , packet1.pitch_speed , packet1.yaw_speed , packet1.thrust );
-	mavlink_msg_roll_pitch_yaw_speed_thrust_setpoint_decode(last_msg, &packet2);
+	mavlink_msg_local_position_ned_cov_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.time_utc , packet1.estimator_type , packet1.x , packet1.y , packet1.z , packet1.vx , packet1.vy , packet1.vz , packet1.covariance );
+	mavlink_msg_local_position_ned_cov_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_set_quad_motors_setpoint(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_rc_channels(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_set_quad_motors_setpoint_t packet_in = {
-		17235,
-	17339,
-	17443,
-	17547,
-	29,
+	mavlink_rc_channels_t packet_in = {
+		963497464,17443,17547,17651,17755,17859,17963,18067,18171,18275,18379,18483,18587,18691,18795,18899,19003,19107,19211,125,192
 	};
-	mavlink_set_quad_motors_setpoint_t packet1, packet2;
+	mavlink_rc_channels_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.motor_front_nw = packet_in.motor_front_nw;
-        	packet1.motor_right_ne = packet_in.motor_right_ne;
-        	packet1.motor_back_se = packet_in.motor_back_se;
-        	packet1.motor_left_sw = packet_in.motor_left_sw;
-        	packet1.target_system = packet_in.target_system;
+        	packet1.time_boot_ms = packet_in.time_boot_ms;
+        	packet1.chan1_raw = packet_in.chan1_raw;
+        	packet1.chan2_raw = packet_in.chan2_raw;
+        	packet1.chan3_raw = packet_in.chan3_raw;
+        	packet1.chan4_raw = packet_in.chan4_raw;
+        	packet1.chan5_raw = packet_in.chan5_raw;
+        	packet1.chan6_raw = packet_in.chan6_raw;
+        	packet1.chan7_raw = packet_in.chan7_raw;
+        	packet1.chan8_raw = packet_in.chan8_raw;
+        	packet1.chan9_raw = packet_in.chan9_raw;
+        	packet1.chan10_raw = packet_in.chan10_raw;
+        	packet1.chan11_raw = packet_in.chan11_raw;
+        	packet1.chan12_raw = packet_in.chan12_raw;
+        	packet1.chan13_raw = packet_in.chan13_raw;
+        	packet1.chan14_raw = packet_in.chan14_raw;
+        	packet1.chan15_raw = packet_in.chan15_raw;
+        	packet1.chan16_raw = packet_in.chan16_raw;
+        	packet1.chan17_raw = packet_in.chan17_raw;
+        	packet1.chan18_raw = packet_in.chan18_raw;
+        	packet1.chancount = packet_in.chancount;
+        	packet1.rssi = packet_in.rssi;
         
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_quad_motors_setpoint_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_set_quad_motors_setpoint_decode(&msg, &packet2);
+	mavlink_msg_rc_channels_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_rc_channels_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_quad_motors_setpoint_pack(system_id, component_id, &msg , packet1.target_system , packet1.motor_front_nw , packet1.motor_right_ne , packet1.motor_back_se , packet1.motor_left_sw );
-	mavlink_msg_set_quad_motors_setpoint_decode(&msg, &packet2);
+	mavlink_msg_rc_channels_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.chancount , packet1.chan1_raw , packet1.chan2_raw , packet1.chan3_raw , packet1.chan4_raw , packet1.chan5_raw , packet1.chan6_raw , packet1.chan7_raw , packet1.chan8_raw , packet1.chan9_raw , packet1.chan10_raw , packet1.chan11_raw , packet1.chan12_raw , packet1.chan13_raw , packet1.chan14_raw , packet1.chan15_raw , packet1.chan16_raw , packet1.chan17_raw , packet1.chan18_raw , packet1.rssi );
+	mavlink_msg_rc_channels_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_quad_motors_setpoint_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.motor_front_nw , packet1.motor_right_ne , packet1.motor_back_se , packet1.motor_left_sw );
-	mavlink_msg_set_quad_motors_setpoint_decode(&msg, &packet2);
+	mavlink_msg_rc_channels_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.chancount , packet1.chan1_raw , packet1.chan2_raw , packet1.chan3_raw , packet1.chan4_raw , packet1.chan5_raw , packet1.chan6_raw , packet1.chan7_raw , packet1.chan8_raw , packet1.chan9_raw , packet1.chan10_raw , packet1.chan11_raw , packet1.chan12_raw , packet1.chan13_raw , packet1.chan14_raw , packet1.chan15_raw , packet1.chan16_raw , packet1.chan17_raw , packet1.chan18_raw , packet1.rssi );
+	mavlink_msg_rc_channels_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -2568,52 +2235,46 @@ static void mavlink_test_set_quad_motors
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_set_quad_motors_setpoint_decode(last_msg, &packet2);
+	mavlink_msg_rc_channels_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_quad_motors_setpoint_send(MAVLINK_COMM_1 , packet1.target_system , packet1.motor_front_nw , packet1.motor_right_ne , packet1.motor_back_se , packet1.motor_left_sw );
-	mavlink_msg_set_quad_motors_setpoint_decode(last_msg, &packet2);
+	mavlink_msg_rc_channels_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.chancount , packet1.chan1_raw , packet1.chan2_raw , packet1.chan3_raw , packet1.chan4_raw , packet1.chan5_raw , packet1.chan6_raw , packet1.chan7_raw , packet1.chan8_raw , packet1.chan9_raw , packet1.chan10_raw , packet1.chan11_raw , packet1.chan12_raw , packet1.chan13_raw , packet1.chan14_raw , packet1.chan15_raw , packet1.chan16_raw , packet1.chan17_raw , packet1.chan18_raw , packet1.rssi );
+	mavlink_msg_rc_channels_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_set_quad_swarm_roll_pitch_yaw_thrust(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_request_data_stream(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_set_quad_swarm_roll_pitch_yaw_thrust_t packet_in = {
-		{ 17235, 17236, 17237, 17238 },
-	{ 17651, 17652, 17653, 17654 },
-	{ 18067, 18068, 18069, 18070 },
-	{ 18483, 18484, 18485, 18486 },
-	101,
-	168,
+	mavlink_request_data_stream_t packet_in = {
+		17235,139,206,17,84
 	};
-	mavlink_set_quad_swarm_roll_pitch_yaw_thrust_t packet1, packet2;
+	mavlink_request_data_stream_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.group = packet_in.group;
-        	packet1.mode = packet_in.mode;
+        	packet1.req_message_rate = packet_in.req_message_rate;
+        	packet1.target_system = packet_in.target_system;
+        	packet1.target_component = packet_in.target_component;
+        	packet1.req_stream_id = packet_in.req_stream_id;
+        	packet1.start_stop = packet_in.start_stop;
         
-        	mav_array_memcpy(packet1.roll, packet_in.roll, sizeof(int16_t)*4);
-        	mav_array_memcpy(packet1.pitch, packet_in.pitch, sizeof(int16_t)*4);
-        	mav_array_memcpy(packet1.yaw, packet_in.yaw, sizeof(int16_t)*4);
-        	mav_array_memcpy(packet1.thrust, packet_in.thrust, sizeof(uint16_t)*4);
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_quad_swarm_roll_pitch_yaw_thrust_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_set_quad_swarm_roll_pitch_yaw_thrust_decode(&msg, &packet2);
+	mavlink_msg_request_data_stream_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_request_data_stream_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_quad_swarm_roll_pitch_yaw_thrust_pack(system_id, component_id, &msg , packet1.group , packet1.mode , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust );
-	mavlink_msg_set_quad_swarm_roll_pitch_yaw_thrust_decode(&msg, &packet2);
+	mavlink_msg_request_data_stream_pack(system_id, component_id, &msg , packet1.target_system , packet1.target_component , packet1.req_stream_id , packet1.req_message_rate , packet1.start_stop );
+	mavlink_msg_request_data_stream_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_quad_swarm_roll_pitch_yaw_thrust_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.group , packet1.mode , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust );
-	mavlink_msg_set_quad_swarm_roll_pitch_yaw_thrust_decode(&msg, &packet2);
+	mavlink_msg_request_data_stream_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.target_component , packet1.req_stream_id , packet1.req_message_rate , packet1.start_stop );
+	mavlink_msg_request_data_stream_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -2621,56 +2282,44 @@ static void mavlink_test_set_quad_swarm_
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_set_quad_swarm_roll_pitch_yaw_thrust_decode(last_msg, &packet2);
+	mavlink_msg_request_data_stream_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_quad_swarm_roll_pitch_yaw_thrust_send(MAVLINK_COMM_1 , packet1.group , packet1.mode , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust );
-	mavlink_msg_set_quad_swarm_roll_pitch_yaw_thrust_decode(last_msg, &packet2);
+	mavlink_msg_request_data_stream_send(MAVLINK_COMM_1 , packet1.target_system , packet1.target_component , packet1.req_stream_id , packet1.req_message_rate , packet1.start_stop );
+	mavlink_msg_request_data_stream_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_nav_controller_output(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_data_stream(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_nav_controller_output_t packet_in = {
-		17.0,
-	45.0,
-	73.0,
-	101.0,
-	129.0,
-	18275,
-	18379,
-	18483,
+	mavlink_data_stream_t packet_in = {
+		17235,139,206
 	};
-	mavlink_nav_controller_output_t packet1, packet2;
+	mavlink_data_stream_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.nav_roll = packet_in.nav_roll;
-        	packet1.nav_pitch = packet_in.nav_pitch;
-        	packet1.alt_error = packet_in.alt_error;
-        	packet1.aspd_error = packet_in.aspd_error;
-        	packet1.xtrack_error = packet_in.xtrack_error;
-        	packet1.nav_bearing = packet_in.nav_bearing;
-        	packet1.target_bearing = packet_in.target_bearing;
-        	packet1.wp_dist = packet_in.wp_dist;
+        	packet1.message_rate = packet_in.message_rate;
+        	packet1.stream_id = packet_in.stream_id;
+        	packet1.on_off = packet_in.on_off;
         
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_nav_controller_output_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_nav_controller_output_decode(&msg, &packet2);
+	mavlink_msg_data_stream_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_data_stream_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_nav_controller_output_pack(system_id, component_id, &msg , packet1.nav_roll , packet1.nav_pitch , packet1.nav_bearing , packet1.target_bearing , packet1.wp_dist , packet1.alt_error , packet1.aspd_error , packet1.xtrack_error );
-	mavlink_msg_nav_controller_output_decode(&msg, &packet2);
+	mavlink_msg_data_stream_pack(system_id, component_id, &msg , packet1.stream_id , packet1.message_rate , packet1.on_off );
+	mavlink_msg_data_stream_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_nav_controller_output_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.nav_roll , packet1.nav_pitch , packet1.nav_bearing , packet1.target_bearing , packet1.wp_dist , packet1.alt_error , packet1.aspd_error , packet1.xtrack_error );
-	mavlink_msg_nav_controller_output_decode(&msg, &packet2);
+	mavlink_msg_data_stream_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.stream_id , packet1.message_rate , packet1.on_off );
+	mavlink_msg_data_stream_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -2678,58 +2327,47 @@ static void mavlink_test_nav_controller_
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_nav_controller_output_decode(last_msg, &packet2);
+	mavlink_msg_data_stream_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_nav_controller_output_send(MAVLINK_COMM_1 , packet1.nav_roll , packet1.nav_pitch , packet1.nav_bearing , packet1.target_bearing , packet1.wp_dist , packet1.alt_error , packet1.aspd_error , packet1.xtrack_error );
-	mavlink_msg_nav_controller_output_decode(last_msg, &packet2);
+	mavlink_msg_data_stream_send(MAVLINK_COMM_1 , packet1.stream_id , packet1.message_rate , packet1.on_off );
+	mavlink_msg_data_stream_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_set_quad_swarm_led_roll_pitch_yaw_thrust(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_manual_control(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_set_quad_swarm_led_roll_pitch_yaw_thrust_t packet_in = {
-		{ 17235, 17236, 17237, 17238 },
-	{ 17651, 17652, 17653, 17654 },
-	{ 18067, 18068, 18069, 18070 },
-	{ 18483, 18484, 18485, 18486 },
-	101,
-	168,
-	{ 235, 236, 237, 238 },
-	{ 247, 248, 249, 250 },
-	{ 3, 4, 5, 6 },
+	mavlink_manual_control_t packet_in = {
+		17235,17339,17443,17547,17651,163
 	};
-	mavlink_set_quad_swarm_led_roll_pitch_yaw_thrust_t packet1, packet2;
+	mavlink_manual_control_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.group = packet_in.group;
-        	packet1.mode = packet_in.mode;
+        	packet1.x = packet_in.x;
+        	packet1.y = packet_in.y;
+        	packet1.z = packet_in.z;
+        	packet1.r = packet_in.r;
+        	packet1.buttons = packet_in.buttons;
+        	packet1.target = packet_in.target;
         
-        	mav_array_memcpy(packet1.roll, packet_in.roll, sizeof(int16_t)*4);
-        	mav_array_memcpy(packet1.pitch, packet_in.pitch, sizeof(int16_t)*4);
-        	mav_array_memcpy(packet1.yaw, packet_in.yaw, sizeof(int16_t)*4);
-        	mav_array_memcpy(packet1.thrust, packet_in.thrust, sizeof(uint16_t)*4);
-        	mav_array_memcpy(packet1.led_red, packet_in.led_red, sizeof(uint8_t)*4);
-        	mav_array_memcpy(packet1.led_blue, packet_in.led_blue, sizeof(uint8_t)*4);
-        	mav_array_memcpy(packet1.led_green, packet_in.led_green, sizeof(uint8_t)*4);
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_quad_swarm_led_roll_pitch_yaw_thrust_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_set_quad_swarm_led_roll_pitch_yaw_thrust_decode(&msg, &packet2);
+	mavlink_msg_manual_control_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_manual_control_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_quad_swarm_led_roll_pitch_yaw_thrust_pack(system_id, component_id, &msg , packet1.group , packet1.mode , packet1.led_red , packet1.led_blue , packet1.led_green , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust );
-	mavlink_msg_set_quad_swarm_led_roll_pitch_yaw_thrust_decode(&msg, &packet2);
+	mavlink_msg_manual_control_pack(system_id, component_id, &msg , packet1.target , packet1.x , packet1.y , packet1.z , packet1.r , packet1.buttons );
+	mavlink_msg_manual_control_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_quad_swarm_led_roll_pitch_yaw_thrust_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.group , packet1.mode , packet1.led_red , packet1.led_blue , packet1.led_green , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust );
-	mavlink_msg_set_quad_swarm_led_roll_pitch_yaw_thrust_decode(&msg, &packet2);
+	mavlink_msg_manual_control_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target , packet1.x , packet1.y , packet1.z , packet1.r , packet1.buttons );
+	mavlink_msg_manual_control_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -2737,58 +2375,51 @@ static void mavlink_test_set_quad_swarm_
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_set_quad_swarm_led_roll_pitch_yaw_thrust_decode(last_msg, &packet2);
+	mavlink_msg_manual_control_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_set_quad_swarm_led_roll_pitch_yaw_thrust_send(MAVLINK_COMM_1 , packet1.group , packet1.mode , packet1.led_red , packet1.led_blue , packet1.led_green , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust );
-	mavlink_msg_set_quad_swarm_led_roll_pitch_yaw_thrust_decode(last_msg, &packet2);
+	mavlink_msg_manual_control_send(MAVLINK_COMM_1 , packet1.target , packet1.x , packet1.y , packet1.z , packet1.r , packet1.buttons );
+	mavlink_msg_manual_control_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_state_correction(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_rc_channels_override(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_state_correction_t packet_in = {
-		17.0,
-	45.0,
-	73.0,
-	101.0,
-	129.0,
-	157.0,
-	185.0,
-	213.0,
-	241.0,
+	mavlink_rc_channels_override_t packet_in = {
+		17235,17339,17443,17547,17651,17755,17859,17963,53,120
 	};
-	mavlink_state_correction_t packet1, packet2;
+	mavlink_rc_channels_override_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.xErr = packet_in.xErr;
-        	packet1.yErr = packet_in.yErr;
-        	packet1.zErr = packet_in.zErr;
-        	packet1.rollErr = packet_in.rollErr;
-        	packet1.pitchErr = packet_in.pitchErr;
-        	packet1.yawErr = packet_in.yawErr;
-        	packet1.vxErr = packet_in.vxErr;
-        	packet1.vyErr = packet_in.vyErr;
-        	packet1.vzErr = packet_in.vzErr;
+        	packet1.chan1_raw = packet_in.chan1_raw;
+        	packet1.chan2_raw = packet_in.chan2_raw;
+        	packet1.chan3_raw = packet_in.chan3_raw;
+        	packet1.chan4_raw = packet_in.chan4_raw;
+        	packet1.chan5_raw = packet_in.chan5_raw;
+        	packet1.chan6_raw = packet_in.chan6_raw;
+        	packet1.chan7_raw = packet_in.chan7_raw;
+        	packet1.chan8_raw = packet_in.chan8_raw;
+        	packet1.target_system = packet_in.target_system;
+        	packet1.target_component = packet_in.target_component;
         
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_state_correction_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_state_correction_decode(&msg, &packet2);
-        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+	mavlink_msg_rc_channels_override_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_rc_channels_override_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_state_correction_pack(system_id, component_id, &msg , packet1.xErr , packet1.yErr , packet1.zErr , packet1.rollErr , packet1.pitchErr , packet1.yawErr , packet1.vxErr , packet1.vyErr , packet1.vzErr );
-	mavlink_msg_state_correction_decode(&msg, &packet2);
+	mavlink_msg_rc_channels_override_pack(system_id, component_id, &msg , packet1.target_system , packet1.target_component , packet1.chan1_raw , packet1.chan2_raw , packet1.chan3_raw , packet1.chan4_raw , packet1.chan5_raw , packet1.chan6_raw , packet1.chan7_raw , packet1.chan8_raw );
+	mavlink_msg_rc_channels_override_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_state_correction_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.xErr , packet1.yErr , packet1.zErr , packet1.rollErr , packet1.pitchErr , packet1.yawErr , packet1.vxErr , packet1.vyErr , packet1.vzErr );
-	mavlink_msg_state_correction_decode(&msg, &packet2);
+	mavlink_msg_rc_channels_override_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.target_component , packet1.chan1_raw , packet1.chan2_raw , packet1.chan3_raw , packet1.chan4_raw , packet1.chan5_raw , packet1.chan6_raw , packet1.chan7_raw , packet1.chan8_raw );
+	mavlink_msg_rc_channels_override_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -2796,50 +2427,55 @@ static void mavlink_test_state_correctio
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_state_correction_decode(last_msg, &packet2);
+	mavlink_msg_rc_channels_override_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_state_correction_send(MAVLINK_COMM_1 , packet1.xErr , packet1.yErr , packet1.zErr , packet1.rollErr , packet1.pitchErr , packet1.yawErr , packet1.vxErr , packet1.vyErr , packet1.vzErr );
-	mavlink_msg_state_correction_decode(last_msg, &packet2);
+	mavlink_msg_rc_channels_override_send(MAVLINK_COMM_1 , packet1.target_system , packet1.target_component , packet1.chan1_raw , packet1.chan2_raw , packet1.chan3_raw , packet1.chan4_raw , packet1.chan5_raw , packet1.chan6_raw , packet1.chan7_raw , packet1.chan8_raw );
+	mavlink_msg_rc_channels_override_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_request_data_stream(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_mission_item_int(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_request_data_stream_t packet_in = {
-		17235,
-	139,
-	206,
-	17,
-	84,
+	mavlink_mission_item_int_t packet_in = {
+		17.0,45.0,73.0,101.0,963498296,963498504,185.0,18691,18795,101,168,235,46,113
 	};
-	mavlink_request_data_stream_t packet1, packet2;
+	mavlink_mission_item_int_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.req_message_rate = packet_in.req_message_rate;
+        	packet1.param1 = packet_in.param1;
+        	packet1.param2 = packet_in.param2;
+        	packet1.param3 = packet_in.param3;
+        	packet1.param4 = packet_in.param4;
+        	packet1.x = packet_in.x;
+        	packet1.y = packet_in.y;
+        	packet1.z = packet_in.z;
+        	packet1.seq = packet_in.seq;
+        	packet1.command = packet_in.command;
         	packet1.target_system = packet_in.target_system;
         	packet1.target_component = packet_in.target_component;
-        	packet1.req_stream_id = packet_in.req_stream_id;
-        	packet1.start_stop = packet_in.start_stop;
+        	packet1.frame = packet_in.frame;
+        	packet1.current = packet_in.current;
+        	packet1.autocontinue = packet_in.autocontinue;
         
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_request_data_stream_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_request_data_stream_decode(&msg, &packet2);
+	mavlink_msg_mission_item_int_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_mission_item_int_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_request_data_stream_pack(system_id, component_id, &msg , packet1.target_system , packet1.target_component , packet1.req_stream_id , packet1.req_message_rate , packet1.start_stop );
-	mavlink_msg_request_data_stream_decode(&msg, &packet2);
+	mavlink_msg_mission_item_int_pack(system_id, component_id, &msg , packet1.target_system , packet1.target_component , packet1.seq , packet1.frame , packet1.command , packet1.current , packet1.autocontinue , packet1.param1 , packet1.param2 , packet1.param3 , packet1.param4 , packet1.x , packet1.y , packet1.z );
+	mavlink_msg_mission_item_int_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_request_data_stream_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.target_component , packet1.req_stream_id , packet1.req_message_rate , packet1.start_stop );
-	mavlink_msg_request_data_stream_decode(&msg, &packet2);
+	mavlink_msg_mission_item_int_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.target_component , packet1.seq , packet1.frame , packet1.command , packet1.current , packet1.autocontinue , packet1.param1 , packet1.param2 , packet1.param3 , packet1.param4 , packet1.x , packet1.y , packet1.z );
+	mavlink_msg_mission_item_int_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -2847,46 +2483,47 @@ static void mavlink_test_request_data_st
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_request_data_stream_decode(last_msg, &packet2);
+	mavlink_msg_mission_item_int_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_request_data_stream_send(MAVLINK_COMM_1 , packet1.target_system , packet1.target_component , packet1.req_stream_id , packet1.req_message_rate , packet1.start_stop );
-	mavlink_msg_request_data_stream_decode(last_msg, &packet2);
+	mavlink_msg_mission_item_int_send(MAVLINK_COMM_1 , packet1.target_system , packet1.target_component , packet1.seq , packet1.frame , packet1.command , packet1.current , packet1.autocontinue , packet1.param1 , packet1.param2 , packet1.param3 , packet1.param4 , packet1.x , packet1.y , packet1.z );
+	mavlink_msg_mission_item_int_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_data_stream(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_vfr_hud(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_data_stream_t packet_in = {
-		17235,
-	139,
-	206,
+	mavlink_vfr_hud_t packet_in = {
+		17.0,45.0,73.0,101.0,18067,18171
 	};
-	mavlink_data_stream_t packet1, packet2;
+	mavlink_vfr_hud_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.message_rate = packet_in.message_rate;
-        	packet1.stream_id = packet_in.stream_id;
-        	packet1.on_off = packet_in.on_off;
+        	packet1.airspeed = packet_in.airspeed;
+        	packet1.groundspeed = packet_in.groundspeed;
+        	packet1.alt = packet_in.alt;
+        	packet1.climb = packet_in.climb;
+        	packet1.heading = packet_in.heading;
+        	packet1.throttle = packet_in.throttle;
         
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_data_stream_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_data_stream_decode(&msg, &packet2);
+	mavlink_msg_vfr_hud_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_vfr_hud_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_data_stream_pack(system_id, component_id, &msg , packet1.stream_id , packet1.message_rate , packet1.on_off );
-	mavlink_msg_data_stream_decode(&msg, &packet2);
+	mavlink_msg_vfr_hud_pack(system_id, component_id, &msg , packet1.airspeed , packet1.groundspeed , packet1.heading , packet1.throttle , packet1.alt , packet1.climb );
+	mavlink_msg_vfr_hud_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_data_stream_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.stream_id , packet1.message_rate , packet1.on_off );
-	mavlink_msg_data_stream_decode(&msg, &packet2);
+	mavlink_msg_vfr_hud_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.airspeed , packet1.groundspeed , packet1.heading , packet1.throttle , packet1.alt , packet1.climb );
+	mavlink_msg_vfr_hud_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -2894,58 +2531,200 @@ static void mavlink_test_data_stream(uin
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_data_stream_decode(last_msg, &packet2);
+	mavlink_msg_vfr_hud_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_data_stream_send(MAVLINK_COMM_1 , packet1.stream_id , packet1.message_rate , packet1.on_off );
-	mavlink_msg_data_stream_decode(last_msg, &packet2);
+	mavlink_msg_vfr_hud_send(MAVLINK_COMM_1 , packet1.airspeed , packet1.groundspeed , packet1.heading , packet1.throttle , packet1.alt , packet1.climb );
+	mavlink_msg_vfr_hud_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_manual_control(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_command_int(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_manual_control_t packet_in = {
-		17.0,
-	45.0,
-	73.0,
-	101.0,
-	53,
-	120,
-	187,
-	254,
-	65,
+	mavlink_command_int_t packet_in = {
+		17.0,45.0,73.0,101.0,963498296,963498504,185.0,18691,223,34,101,168,235
 	};
-	mavlink_manual_control_t packet1, packet2;
+	mavlink_command_int_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.param1 = packet_in.param1;
+        	packet1.param2 = packet_in.param2;
+        	packet1.param3 = packet_in.param3;
+        	packet1.param4 = packet_in.param4;
+        	packet1.x = packet_in.x;
+        	packet1.y = packet_in.y;
+        	packet1.z = packet_in.z;
+        	packet1.command = packet_in.command;
+        	packet1.target_system = packet_in.target_system;
+        	packet1.target_component = packet_in.target_component;
+        	packet1.frame = packet_in.frame;
+        	packet1.current = packet_in.current;
+        	packet1.autocontinue = packet_in.autocontinue;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_command_int_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_command_int_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_command_int_pack(system_id, component_id, &msg , packet1.target_system , packet1.target_component , packet1.frame , packet1.command , packet1.current , packet1.autocontinue , packet1.param1 , packet1.param2 , packet1.param3 , packet1.param4 , packet1.x , packet1.y , packet1.z );
+	mavlink_msg_command_int_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_command_int_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.target_component , packet1.frame , packet1.command , packet1.current , packet1.autocontinue , packet1.param1 , packet1.param2 , packet1.param3 , packet1.param4 , packet1.x , packet1.y , packet1.z );
+	mavlink_msg_command_int_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_command_int_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_command_int_send(MAVLINK_COMM_1 , packet1.target_system , packet1.target_component , packet1.frame , packet1.command , packet1.current , packet1.autocontinue , packet1.param1 , packet1.param2 , packet1.param3 , packet1.param4 , packet1.x , packet1.y , packet1.z );
+	mavlink_msg_command_int_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_command_long(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_command_long_t packet_in = {
+		17.0,45.0,73.0,101.0,129.0,157.0,185.0,18691,223,34,101
+    };
+	mavlink_command_long_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.param1 = packet_in.param1;
+        	packet1.param2 = packet_in.param2;
+        	packet1.param3 = packet_in.param3;
+        	packet1.param4 = packet_in.param4;
+        	packet1.param5 = packet_in.param5;
+        	packet1.param6 = packet_in.param6;
+        	packet1.param7 = packet_in.param7;
+        	packet1.command = packet_in.command;
+        	packet1.target_system = packet_in.target_system;
+        	packet1.target_component = packet_in.target_component;
+        	packet1.confirmation = packet_in.confirmation;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_command_long_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_command_long_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_command_long_pack(system_id, component_id, &msg , packet1.target_system , packet1.target_component , packet1.command , packet1.confirmation , packet1.param1 , packet1.param2 , packet1.param3 , packet1.param4 , packet1.param5 , packet1.param6 , packet1.param7 );
+	mavlink_msg_command_long_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_command_long_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.target_component , packet1.command , packet1.confirmation , packet1.param1 , packet1.param2 , packet1.param3 , packet1.param4 , packet1.param5 , packet1.param6 , packet1.param7 );
+	mavlink_msg_command_long_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_command_long_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_command_long_send(MAVLINK_COMM_1 , packet1.target_system , packet1.target_component , packet1.command , packet1.confirmation , packet1.param1 , packet1.param2 , packet1.param3 , packet1.param4 , packet1.param5 , packet1.param6 , packet1.param7 );
+	mavlink_msg_command_long_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_command_ack(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_command_ack_t packet_in = {
+		17235,139
+    };
+	mavlink_command_ack_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.command = packet_in.command;
+        	packet1.result = packet_in.result;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_command_ack_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_command_ack_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_command_ack_pack(system_id, component_id, &msg , packet1.command , packet1.result );
+	mavlink_msg_command_ack_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_command_ack_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.command , packet1.result );
+	mavlink_msg_command_ack_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_command_ack_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_command_ack_send(MAVLINK_COMM_1 , packet1.command , packet1.result );
+	mavlink_msg_command_ack_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_manual_setpoint(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_manual_setpoint_t packet_in = {
+		963497464,45.0,73.0,101.0,129.0,65,132
+    };
+	mavlink_manual_setpoint_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_boot_ms = packet_in.time_boot_ms;
         	packet1.roll = packet_in.roll;
         	packet1.pitch = packet_in.pitch;
         	packet1.yaw = packet_in.yaw;
         	packet1.thrust = packet_in.thrust;
-        	packet1.target = packet_in.target;
-        	packet1.roll_manual = packet_in.roll_manual;
-        	packet1.pitch_manual = packet_in.pitch_manual;
-        	packet1.yaw_manual = packet_in.yaw_manual;
-        	packet1.thrust_manual = packet_in.thrust_manual;
+        	packet1.mode_switch = packet_in.mode_switch;
+        	packet1.manual_override_switch = packet_in.manual_override_switch;
         
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_manual_control_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_manual_control_decode(&msg, &packet2);
+	mavlink_msg_manual_setpoint_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_manual_setpoint_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_manual_control_pack(system_id, component_id, &msg , packet1.target , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust , packet1.roll_manual , packet1.pitch_manual , packet1.yaw_manual , packet1.thrust_manual );
-	mavlink_msg_manual_control_decode(&msg, &packet2);
+	mavlink_msg_manual_setpoint_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust , packet1.mode_switch , packet1.manual_override_switch );
+	mavlink_msg_manual_setpoint_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_manual_control_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust , packet1.roll_manual , packet1.pitch_manual , packet1.yaw_manual , packet1.thrust_manual );
-	mavlink_msg_manual_control_decode(&msg, &packet2);
+	mavlink_msg_manual_setpoint_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust , packet1.mode_switch , packet1.manual_override_switch );
+	mavlink_msg_manual_setpoint_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -2953,60 +2732,50 @@ static void mavlink_test_manual_control(
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_manual_control_decode(last_msg, &packet2);
+	mavlink_msg_manual_setpoint_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_manual_control_send(MAVLINK_COMM_1 , packet1.target , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust , packet1.roll_manual , packet1.pitch_manual , packet1.yaw_manual , packet1.thrust_manual );
-	mavlink_msg_manual_control_decode(last_msg, &packet2);
+	mavlink_msg_manual_setpoint_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.roll , packet1.pitch , packet1.yaw , packet1.thrust , packet1.mode_switch , packet1.manual_override_switch );
+	mavlink_msg_manual_setpoint_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_rc_channels_override(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_set_attitude_target(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_rc_channels_override_t packet_in = {
-		17235,
-	17339,
-	17443,
-	17547,
-	17651,
-	17755,
-	17859,
-	17963,
-	53,
-	120,
+	mavlink_set_attitude_target_t packet_in = {
+		963497464,{ 45.0, 46.0, 47.0, 48.0 },157.0,185.0,213.0,241.0,113,180,247
 	};
-	mavlink_rc_channels_override_t packet1, packet2;
+	mavlink_set_attitude_target_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.chan1_raw = packet_in.chan1_raw;
-        	packet1.chan2_raw = packet_in.chan2_raw;
-        	packet1.chan3_raw = packet_in.chan3_raw;
-        	packet1.chan4_raw = packet_in.chan4_raw;
-        	packet1.chan5_raw = packet_in.chan5_raw;
-        	packet1.chan6_raw = packet_in.chan6_raw;
-        	packet1.chan7_raw = packet_in.chan7_raw;
-        	packet1.chan8_raw = packet_in.chan8_raw;
+        	packet1.time_boot_ms = packet_in.time_boot_ms;
+        	packet1.body_roll_rate = packet_in.body_roll_rate;
+        	packet1.body_pitch_rate = packet_in.body_pitch_rate;
+        	packet1.body_yaw_rate = packet_in.body_yaw_rate;
+        	packet1.thrust = packet_in.thrust;
         	packet1.target_system = packet_in.target_system;
         	packet1.target_component = packet_in.target_component;
+        	packet1.type_mask = packet_in.type_mask;
         
+        	mav_array_memcpy(packet1.q, packet_in.q, sizeof(float)*4);
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_rc_channels_override_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_rc_channels_override_decode(&msg, &packet2);
+	mavlink_msg_set_attitude_target_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_set_attitude_target_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_rc_channels_override_pack(system_id, component_id, &msg , packet1.target_system , packet1.target_component , packet1.chan1_raw , packet1.chan2_raw , packet1.chan3_raw , packet1.chan4_raw , packet1.chan5_raw , packet1.chan6_raw , packet1.chan7_raw , packet1.chan8_raw );
-	mavlink_msg_rc_channels_override_decode(&msg, &packet2);
+	mavlink_msg_set_attitude_target_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.target_system , packet1.target_component , packet1.type_mask , packet1.q , packet1.body_roll_rate , packet1.body_pitch_rate , packet1.body_yaw_rate , packet1.thrust );
+	mavlink_msg_set_attitude_target_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_rc_channels_override_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.target_component , packet1.chan1_raw , packet1.chan2_raw , packet1.chan3_raw , packet1.chan4_raw , packet1.chan5_raw , packet1.chan6_raw , packet1.chan7_raw , packet1.chan8_raw );
-	mavlink_msg_rc_channels_override_decode(&msg, &packet2);
+	mavlink_msg_set_attitude_target_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.target_system , packet1.target_component , packet1.type_mask , packet1.q , packet1.body_roll_rate , packet1.body_pitch_rate , packet1.body_yaw_rate , packet1.thrust );
+	mavlink_msg_set_attitude_target_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -3014,52 +2783,1901 @@ static void mavlink_test_rc_channels_ove
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_rc_channels_override_decode(last_msg, &packet2);
+	mavlink_msg_set_attitude_target_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_rc_channels_override_send(MAVLINK_COMM_1 , packet1.target_system , packet1.target_component , packet1.chan1_raw , packet1.chan2_raw , packet1.chan3_raw , packet1.chan4_raw , packet1.chan5_raw , packet1.chan6_raw , packet1.chan7_raw , packet1.chan8_raw );
-	mavlink_msg_rc_channels_override_decode(last_msg, &packet2);
+	mavlink_msg_set_attitude_target_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.target_system , packet1.target_component , packet1.type_mask , packet1.q , packet1.body_roll_rate , packet1.body_pitch_rate , packet1.body_yaw_rate , packet1.thrust );
+	mavlink_msg_set_attitude_target_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_vfr_hud(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_attitude_target(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_vfr_hud_t packet_in = {
-		17.0,
-	45.0,
-	73.0,
-	101.0,
-	18067,
-	18171,
+	mavlink_attitude_target_t packet_in = {
+		963497464,{ 45.0, 46.0, 47.0, 48.0 },157.0,185.0,213.0,241.0,113
 	};
-	mavlink_vfr_hud_t packet1, packet2;
+	mavlink_attitude_target_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_boot_ms = packet_in.time_boot_ms;
+        	packet1.body_roll_rate = packet_in.body_roll_rate;
+        	packet1.body_pitch_rate = packet_in.body_pitch_rate;
+        	packet1.body_yaw_rate = packet_in.body_yaw_rate;
+        	packet1.thrust = packet_in.thrust;
+        	packet1.type_mask = packet_in.type_mask;
+        
+        	mav_array_memcpy(packet1.q, packet_in.q, sizeof(float)*4);
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_attitude_target_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_attitude_target_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_attitude_target_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.type_mask , packet1.q , packet1.body_roll_rate , packet1.body_pitch_rate , packet1.body_yaw_rate , packet1.thrust );
+	mavlink_msg_attitude_target_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_attitude_target_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.type_mask , packet1.q , packet1.body_roll_rate , packet1.body_pitch_rate , packet1.body_yaw_rate , packet1.thrust );
+	mavlink_msg_attitude_target_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_attitude_target_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_attitude_target_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.type_mask , packet1.q , packet1.body_roll_rate , packet1.body_pitch_rate , packet1.body_yaw_rate , packet1.thrust );
+	mavlink_msg_attitude_target_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_set_position_target_local_ned(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_set_position_target_local_ned_t packet_in = {
+		963497464,45.0,73.0,101.0,129.0,157.0,185.0,213.0,241.0,269.0,297.0,325.0,19731,27,94,161
+    };
+	mavlink_set_position_target_local_ned_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_boot_ms = packet_in.time_boot_ms;
+        	packet1.x = packet_in.x;
+        	packet1.y = packet_in.y;
+        	packet1.z = packet_in.z;
+        	packet1.vx = packet_in.vx;
+        	packet1.vy = packet_in.vy;
+        	packet1.vz = packet_in.vz;
+        	packet1.afx = packet_in.afx;
+        	packet1.afy = packet_in.afy;
+        	packet1.afz = packet_in.afz;
+        	packet1.yaw = packet_in.yaw;
+        	packet1.yaw_rate = packet_in.yaw_rate;
+        	packet1.type_mask = packet_in.type_mask;
+        	packet1.target_system = packet_in.target_system;
+        	packet1.target_component = packet_in.target_component;
+        	packet1.coordinate_frame = packet_in.coordinate_frame;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_set_position_target_local_ned_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_set_position_target_local_ned_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_set_position_target_local_ned_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.target_system , packet1.target_component , packet1.coordinate_frame , packet1.type_mask , packet1.x , packet1.y , packet1.z , packet1.vx , packet1.vy , packet1.vz , packet1.afx , packet1.afy , packet1.afz , packet1.yaw , packet1.yaw_rate );
+	mavlink_msg_set_position_target_local_ned_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_set_position_target_local_ned_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.target_system , packet1.target_component , packet1.coordinate_frame , packet1.type_mask , packet1.x , packet1.y , packet1.z , packet1.vx , packet1.vy , packet1.vz , packet1.afx , packet1.afy , packet1.afz , packet1.yaw , packet1.yaw_rate );
+	mavlink_msg_set_position_target_local_ned_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_set_position_target_local_ned_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_set_position_target_local_ned_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.target_system , packet1.target_component , packet1.coordinate_frame , packet1.type_mask , packet1.x , packet1.y , packet1.z , packet1.vx , packet1.vy , packet1.vz , packet1.afx , packet1.afy , packet1.afz , packet1.yaw , packet1.yaw_rate );
+	mavlink_msg_set_position_target_local_ned_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_position_target_local_ned(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_position_target_local_ned_t packet_in = {
+		963497464,45.0,73.0,101.0,129.0,157.0,185.0,213.0,241.0,269.0,297.0,325.0,19731,27
+    };
+	mavlink_position_target_local_ned_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_boot_ms = packet_in.time_boot_ms;
+        	packet1.x = packet_in.x;
+        	packet1.y = packet_in.y;
+        	packet1.z = packet_in.z;
+        	packet1.vx = packet_in.vx;
+        	packet1.vy = packet_in.vy;
+        	packet1.vz = packet_in.vz;
+        	packet1.afx = packet_in.afx;
+        	packet1.afy = packet_in.afy;
+        	packet1.afz = packet_in.afz;
+        	packet1.yaw = packet_in.yaw;
+        	packet1.yaw_rate = packet_in.yaw_rate;
+        	packet1.type_mask = packet_in.type_mask;
+        	packet1.coordinate_frame = packet_in.coordinate_frame;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_position_target_local_ned_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_position_target_local_ned_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_position_target_local_ned_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.coordinate_frame , packet1.type_mask , packet1.x , packet1.y , packet1.z , packet1.vx , packet1.vy , packet1.vz , packet1.afx , packet1.afy , packet1.afz , packet1.yaw , packet1.yaw_rate );
+	mavlink_msg_position_target_local_ned_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_position_target_local_ned_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.coordinate_frame , packet1.type_mask , packet1.x , packet1.y , packet1.z , packet1.vx , packet1.vy , packet1.vz , packet1.afx , packet1.afy , packet1.afz , packet1.yaw , packet1.yaw_rate );
+	mavlink_msg_position_target_local_ned_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_position_target_local_ned_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_position_target_local_ned_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.coordinate_frame , packet1.type_mask , packet1.x , packet1.y , packet1.z , packet1.vx , packet1.vy , packet1.vz , packet1.afx , packet1.afy , packet1.afz , packet1.yaw , packet1.yaw_rate );
+	mavlink_msg_position_target_local_ned_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_set_position_target_global_int(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_set_position_target_global_int_t packet_in = {
+		963497464,963497672,963497880,101.0,129.0,157.0,185.0,213.0,241.0,269.0,297.0,325.0,19731,27,94,161
+    };
+	mavlink_set_position_target_global_int_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_boot_ms = packet_in.time_boot_ms;
+        	packet1.lat_int = packet_in.lat_int;
+        	packet1.lon_int = packet_in.lon_int;
+        	packet1.alt = packet_in.alt;
+        	packet1.vx = packet_in.vx;
+        	packet1.vy = packet_in.vy;
+        	packet1.vz = packet_in.vz;
+        	packet1.afx = packet_in.afx;
+        	packet1.afy = packet_in.afy;
+        	packet1.afz = packet_in.afz;
+        	packet1.yaw = packet_in.yaw;
+        	packet1.yaw_rate = packet_in.yaw_rate;
+        	packet1.type_mask = packet_in.type_mask;
+        	packet1.target_system = packet_in.target_system;
+        	packet1.target_component = packet_in.target_component;
+        	packet1.coordinate_frame = packet_in.coordinate_frame;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_set_position_target_global_int_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_set_position_target_global_int_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_set_position_target_global_int_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.target_system , packet1.target_component , packet1.coordinate_frame , packet1.type_mask , packet1.lat_int , packet1.lon_int , packet1.alt , packet1.vx , packet1.vy , packet1.vz , packet1.afx , packet1.afy , packet1.afz , packet1.yaw , packet1.yaw_rate );
+	mavlink_msg_set_position_target_global_int_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_set_position_target_global_int_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.target_system , packet1.target_component , packet1.coordinate_frame , packet1.type_mask , packet1.lat_int , packet1.lon_int , packet1.alt , packet1.vx , packet1.vy , packet1.vz , packet1.afx , packet1.afy , packet1.afz , packet1.yaw , packet1.yaw_rate );
+	mavlink_msg_set_position_target_global_int_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_set_position_target_global_int_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_set_position_target_global_int_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.target_system , packet1.target_component , packet1.coordinate_frame , packet1.type_mask , packet1.lat_int , packet1.lon_int , packet1.alt , packet1.vx , packet1.vy , packet1.vz , packet1.afx , packet1.afy , packet1.afz , packet1.yaw , packet1.yaw_rate );
+	mavlink_msg_set_position_target_global_int_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_position_target_global_int(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_position_target_global_int_t packet_in = {
+		963497464,963497672,963497880,101.0,129.0,157.0,185.0,213.0,241.0,269.0,297.0,325.0,19731,27
+    };
+	mavlink_position_target_global_int_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_boot_ms = packet_in.time_boot_ms;
+        	packet1.lat_int = packet_in.lat_int;
+        	packet1.lon_int = packet_in.lon_int;
+        	packet1.alt = packet_in.alt;
+        	packet1.vx = packet_in.vx;
+        	packet1.vy = packet_in.vy;
+        	packet1.vz = packet_in.vz;
+        	packet1.afx = packet_in.afx;
+        	packet1.afy = packet_in.afy;
+        	packet1.afz = packet_in.afz;
+        	packet1.yaw = packet_in.yaw;
+        	packet1.yaw_rate = packet_in.yaw_rate;
+        	packet1.type_mask = packet_in.type_mask;
+        	packet1.coordinate_frame = packet_in.coordinate_frame;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_position_target_global_int_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_position_target_global_int_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_position_target_global_int_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.coordinate_frame , packet1.type_mask , packet1.lat_int , packet1.lon_int , packet1.alt , packet1.vx , packet1.vy , packet1.vz , packet1.afx , packet1.afy , packet1.afz , packet1.yaw , packet1.yaw_rate );
+	mavlink_msg_position_target_global_int_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_position_target_global_int_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.coordinate_frame , packet1.type_mask , packet1.lat_int , packet1.lon_int , packet1.alt , packet1.vx , packet1.vy , packet1.vz , packet1.afx , packet1.afy , packet1.afz , packet1.yaw , packet1.yaw_rate );
+	mavlink_msg_position_target_global_int_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_position_target_global_int_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_position_target_global_int_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.coordinate_frame , packet1.type_mask , packet1.lat_int , packet1.lon_int , packet1.alt , packet1.vx , packet1.vy , packet1.vz , packet1.afx , packet1.afy , packet1.afz , packet1.yaw , packet1.yaw_rate );
+	mavlink_msg_position_target_global_int_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_local_position_ned_system_global_offset(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_local_position_ned_system_global_offset_t packet_in = {
+		963497464,45.0,73.0,101.0,129.0,157.0,185.0
+    };
+	mavlink_local_position_ned_system_global_offset_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_boot_ms = packet_in.time_boot_ms;
+        	packet1.x = packet_in.x;
+        	packet1.y = packet_in.y;
+        	packet1.z = packet_in.z;
+        	packet1.roll = packet_in.roll;
+        	packet1.pitch = packet_in.pitch;
+        	packet1.yaw = packet_in.yaw;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_local_position_ned_system_global_offset_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_local_position_ned_system_global_offset_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_local_position_ned_system_global_offset_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
+	mavlink_msg_local_position_ned_system_global_offset_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_local_position_ned_system_global_offset_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
+	mavlink_msg_local_position_ned_system_global_offset_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_local_position_ned_system_global_offset_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_local_position_ned_system_global_offset_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
+	mavlink_msg_local_position_ned_system_global_offset_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_hil_state(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_hil_state_t packet_in = {
+		93372036854775807ULL,73.0,101.0,129.0,157.0,185.0,213.0,963499128,963499336,963499544,19523,19627,19731,19835,19939,20043
+    };
+	mavlink_hil_state_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_usec = packet_in.time_usec;
+        	packet1.roll = packet_in.roll;
+        	packet1.pitch = packet_in.pitch;
+        	packet1.yaw = packet_in.yaw;
+        	packet1.rollspeed = packet_in.rollspeed;
+        	packet1.pitchspeed = packet_in.pitchspeed;
+        	packet1.yawspeed = packet_in.yawspeed;
+        	packet1.lat = packet_in.lat;
+        	packet1.lon = packet_in.lon;
+        	packet1.alt = packet_in.alt;
+        	packet1.vx = packet_in.vx;
+        	packet1.vy = packet_in.vy;
+        	packet1.vz = packet_in.vz;
+        	packet1.xacc = packet_in.xacc;
+        	packet1.yacc = packet_in.yacc;
+        	packet1.zacc = packet_in.zacc;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_state_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_hil_state_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_state_pack(system_id, component_id, &msg , packet1.time_usec , packet1.roll , packet1.pitch , packet1.yaw , packet1.rollspeed , packet1.pitchspeed , packet1.yawspeed , packet1.lat , packet1.lon , packet1.alt , packet1.vx , packet1.vy , packet1.vz , packet1.xacc , packet1.yacc , packet1.zacc );
+	mavlink_msg_hil_state_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_state_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_usec , packet1.roll , packet1.pitch , packet1.yaw , packet1.rollspeed , packet1.pitchspeed , packet1.yawspeed , packet1.lat , packet1.lon , packet1.alt , packet1.vx , packet1.vy , packet1.vz , packet1.xacc , packet1.yacc , packet1.zacc );
+	mavlink_msg_hil_state_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_hil_state_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_state_send(MAVLINK_COMM_1 , packet1.time_usec , packet1.roll , packet1.pitch , packet1.yaw , packet1.rollspeed , packet1.pitchspeed , packet1.yawspeed , packet1.lat , packet1.lon , packet1.alt , packet1.vx , packet1.vy , packet1.vz , packet1.xacc , packet1.yacc , packet1.zacc );
+	mavlink_msg_hil_state_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_hil_controls(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_hil_controls_t packet_in = {
+		93372036854775807ULL,73.0,101.0,129.0,157.0,185.0,213.0,241.0,269.0,125,192
+    };
+	mavlink_hil_controls_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_usec = packet_in.time_usec;
+        	packet1.roll_ailerons = packet_in.roll_ailerons;
+        	packet1.pitch_elevator = packet_in.pitch_elevator;
+        	packet1.yaw_rudder = packet_in.yaw_rudder;
+        	packet1.throttle = packet_in.throttle;
+        	packet1.aux1 = packet_in.aux1;
+        	packet1.aux2 = packet_in.aux2;
+        	packet1.aux3 = packet_in.aux3;
+        	packet1.aux4 = packet_in.aux4;
+        	packet1.mode = packet_in.mode;
+        	packet1.nav_mode = packet_in.nav_mode;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_controls_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_hil_controls_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_controls_pack(system_id, component_id, &msg , packet1.time_usec , packet1.roll_ailerons , packet1.pitch_elevator , packet1.yaw_rudder , packet1.throttle , packet1.aux1 , packet1.aux2 , packet1.aux3 , packet1.aux4 , packet1.mode , packet1.nav_mode );
+	mavlink_msg_hil_controls_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_controls_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_usec , packet1.roll_ailerons , packet1.pitch_elevator , packet1.yaw_rudder , packet1.throttle , packet1.aux1 , packet1.aux2 , packet1.aux3 , packet1.aux4 , packet1.mode , packet1.nav_mode );
+	mavlink_msg_hil_controls_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_hil_controls_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_controls_send(MAVLINK_COMM_1 , packet1.time_usec , packet1.roll_ailerons , packet1.pitch_elevator , packet1.yaw_rudder , packet1.throttle , packet1.aux1 , packet1.aux2 , packet1.aux3 , packet1.aux4 , packet1.mode , packet1.nav_mode );
+	mavlink_msg_hil_controls_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_hil_rc_inputs_raw(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_hil_rc_inputs_raw_t packet_in = {
+		93372036854775807ULL,17651,17755,17859,17963,18067,18171,18275,18379,18483,18587,18691,18795,101
+    };
+	mavlink_hil_rc_inputs_raw_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_usec = packet_in.time_usec;
+        	packet1.chan1_raw = packet_in.chan1_raw;
+        	packet1.chan2_raw = packet_in.chan2_raw;
+        	packet1.chan3_raw = packet_in.chan3_raw;
+        	packet1.chan4_raw = packet_in.chan4_raw;
+        	packet1.chan5_raw = packet_in.chan5_raw;
+        	packet1.chan6_raw = packet_in.chan6_raw;
+        	packet1.chan7_raw = packet_in.chan7_raw;
+        	packet1.chan8_raw = packet_in.chan8_raw;
+        	packet1.chan9_raw = packet_in.chan9_raw;
+        	packet1.chan10_raw = packet_in.chan10_raw;
+        	packet1.chan11_raw = packet_in.chan11_raw;
+        	packet1.chan12_raw = packet_in.chan12_raw;
+        	packet1.rssi = packet_in.rssi;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_rc_inputs_raw_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_hil_rc_inputs_raw_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_rc_inputs_raw_pack(system_id, component_id, &msg , packet1.time_usec , packet1.chan1_raw , packet1.chan2_raw , packet1.chan3_raw , packet1.chan4_raw , packet1.chan5_raw , packet1.chan6_raw , packet1.chan7_raw , packet1.chan8_raw , packet1.chan9_raw , packet1.chan10_raw , packet1.chan11_raw , packet1.chan12_raw , packet1.rssi );
+	mavlink_msg_hil_rc_inputs_raw_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_rc_inputs_raw_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_usec , packet1.chan1_raw , packet1.chan2_raw , packet1.chan3_raw , packet1.chan4_raw , packet1.chan5_raw , packet1.chan6_raw , packet1.chan7_raw , packet1.chan8_raw , packet1.chan9_raw , packet1.chan10_raw , packet1.chan11_raw , packet1.chan12_raw , packet1.rssi );
+	mavlink_msg_hil_rc_inputs_raw_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_hil_rc_inputs_raw_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_rc_inputs_raw_send(MAVLINK_COMM_1 , packet1.time_usec , packet1.chan1_raw , packet1.chan2_raw , packet1.chan3_raw , packet1.chan4_raw , packet1.chan5_raw , packet1.chan6_raw , packet1.chan7_raw , packet1.chan8_raw , packet1.chan9_raw , packet1.chan10_raw , packet1.chan11_raw , packet1.chan12_raw , packet1.rssi );
+	mavlink_msg_hil_rc_inputs_raw_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_optical_flow(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_optical_flow_t packet_in = {
+		93372036854775807ULL,73.0,101.0,129.0,18275,18379,77,144
+    };
+	mavlink_optical_flow_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_usec = packet_in.time_usec;
+        	packet1.flow_comp_m_x = packet_in.flow_comp_m_x;
+        	packet1.flow_comp_m_y = packet_in.flow_comp_m_y;
+        	packet1.ground_distance = packet_in.ground_distance;
+        	packet1.flow_x = packet_in.flow_x;
+        	packet1.flow_y = packet_in.flow_y;
+        	packet1.sensor_id = packet_in.sensor_id;
+        	packet1.quality = packet_in.quality;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_optical_flow_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_optical_flow_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_optical_flow_pack(system_id, component_id, &msg , packet1.time_usec , packet1.sensor_id , packet1.flow_x , packet1.flow_y , packet1.flow_comp_m_x , packet1.flow_comp_m_y , packet1.quality , packet1.ground_distance );
+	mavlink_msg_optical_flow_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_optical_flow_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_usec , packet1.sensor_id , packet1.flow_x , packet1.flow_y , packet1.flow_comp_m_x , packet1.flow_comp_m_y , packet1.quality , packet1.ground_distance );
+	mavlink_msg_optical_flow_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_optical_flow_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_optical_flow_send(MAVLINK_COMM_1 , packet1.time_usec , packet1.sensor_id , packet1.flow_x , packet1.flow_y , packet1.flow_comp_m_x , packet1.flow_comp_m_y , packet1.quality , packet1.ground_distance );
+	mavlink_msg_optical_flow_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_global_vision_position_estimate(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_global_vision_position_estimate_t packet_in = {
+		93372036854775807ULL,73.0,101.0,129.0,157.0,185.0,213.0
+    };
+	mavlink_global_vision_position_estimate_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.usec = packet_in.usec;
+        	packet1.x = packet_in.x;
+        	packet1.y = packet_in.y;
+        	packet1.z = packet_in.z;
+        	packet1.roll = packet_in.roll;
+        	packet1.pitch = packet_in.pitch;
+        	packet1.yaw = packet_in.yaw;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_global_vision_position_estimate_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_global_vision_position_estimate_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_global_vision_position_estimate_pack(system_id, component_id, &msg , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
+	mavlink_msg_global_vision_position_estimate_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_global_vision_position_estimate_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
+	mavlink_msg_global_vision_position_estimate_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_global_vision_position_estimate_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_global_vision_position_estimate_send(MAVLINK_COMM_1 , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
+	mavlink_msg_global_vision_position_estimate_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_vision_position_estimate(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_vision_position_estimate_t packet_in = {
+		93372036854775807ULL,73.0,101.0,129.0,157.0,185.0,213.0
+    };
+	mavlink_vision_position_estimate_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.usec = packet_in.usec;
+        	packet1.x = packet_in.x;
+        	packet1.y = packet_in.y;
+        	packet1.z = packet_in.z;
+        	packet1.roll = packet_in.roll;
+        	packet1.pitch = packet_in.pitch;
+        	packet1.yaw = packet_in.yaw;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_vision_position_estimate_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_vision_position_estimate_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_vision_position_estimate_pack(system_id, component_id, &msg , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
+	mavlink_msg_vision_position_estimate_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_vision_position_estimate_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
+	mavlink_msg_vision_position_estimate_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_vision_position_estimate_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_vision_position_estimate_send(MAVLINK_COMM_1 , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
+	mavlink_msg_vision_position_estimate_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_vision_speed_estimate(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_vision_speed_estimate_t packet_in = {
+		93372036854775807ULL,73.0,101.0,129.0
+    };
+	mavlink_vision_speed_estimate_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.usec = packet_in.usec;
+        	packet1.x = packet_in.x;
+        	packet1.y = packet_in.y;
+        	packet1.z = packet_in.z;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_vision_speed_estimate_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_vision_speed_estimate_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_vision_speed_estimate_pack(system_id, component_id, &msg , packet1.usec , packet1.x , packet1.y , packet1.z );
+	mavlink_msg_vision_speed_estimate_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_vision_speed_estimate_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.usec , packet1.x , packet1.y , packet1.z );
+	mavlink_msg_vision_speed_estimate_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_vision_speed_estimate_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_vision_speed_estimate_send(MAVLINK_COMM_1 , packet1.usec , packet1.x , packet1.y , packet1.z );
+	mavlink_msg_vision_speed_estimate_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_vicon_position_estimate(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_vicon_position_estimate_t packet_in = {
+		93372036854775807ULL,73.0,101.0,129.0,157.0,185.0,213.0
+    };
+	mavlink_vicon_position_estimate_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.usec = packet_in.usec;
+        	packet1.x = packet_in.x;
+        	packet1.y = packet_in.y;
+        	packet1.z = packet_in.z;
+        	packet1.roll = packet_in.roll;
+        	packet1.pitch = packet_in.pitch;
+        	packet1.yaw = packet_in.yaw;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_vicon_position_estimate_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_vicon_position_estimate_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_vicon_position_estimate_pack(system_id, component_id, &msg , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
+	mavlink_msg_vicon_position_estimate_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_vicon_position_estimate_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
+	mavlink_msg_vicon_position_estimate_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_vicon_position_estimate_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_vicon_position_estimate_send(MAVLINK_COMM_1 , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
+	mavlink_msg_vicon_position_estimate_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_highres_imu(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_highres_imu_t packet_in = {
+		93372036854775807ULL,73.0,101.0,129.0,157.0,185.0,213.0,241.0,269.0,297.0,325.0,353.0,381.0,409.0,20355
+    };
+	mavlink_highres_imu_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_usec = packet_in.time_usec;
+        	packet1.xacc = packet_in.xacc;
+        	packet1.yacc = packet_in.yacc;
+        	packet1.zacc = packet_in.zacc;
+        	packet1.xgyro = packet_in.xgyro;
+        	packet1.ygyro = packet_in.ygyro;
+        	packet1.zgyro = packet_in.zgyro;
+        	packet1.xmag = packet_in.xmag;
+        	packet1.ymag = packet_in.ymag;
+        	packet1.zmag = packet_in.zmag;
+        	packet1.abs_pressure = packet_in.abs_pressure;
+        	packet1.diff_pressure = packet_in.diff_pressure;
+        	packet1.pressure_alt = packet_in.pressure_alt;
+        	packet1.temperature = packet_in.temperature;
+        	packet1.fields_updated = packet_in.fields_updated;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_highres_imu_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_highres_imu_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_highres_imu_pack(system_id, component_id, &msg , packet1.time_usec , packet1.xacc , packet1.yacc , packet1.zacc , packet1.xgyro , packet1.ygyro , packet1.zgyro , packet1.xmag , packet1.ymag , packet1.zmag , packet1.abs_pressure , packet1.diff_pressure , packet1.pressure_alt , packet1.temperature , packet1.fields_updated );
+	mavlink_msg_highres_imu_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_highres_imu_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_usec , packet1.xacc , packet1.yacc , packet1.zacc , packet1.xgyro , packet1.ygyro , packet1.zgyro , packet1.xmag , packet1.ymag , packet1.zmag , packet1.abs_pressure , packet1.diff_pressure , packet1.pressure_alt , packet1.temperature , packet1.fields_updated );
+	mavlink_msg_highres_imu_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_highres_imu_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_highres_imu_send(MAVLINK_COMM_1 , packet1.time_usec , packet1.xacc , packet1.yacc , packet1.zacc , packet1.xgyro , packet1.ygyro , packet1.zgyro , packet1.xmag , packet1.ymag , packet1.zmag , packet1.abs_pressure , packet1.diff_pressure , packet1.pressure_alt , packet1.temperature , packet1.fields_updated );
+	mavlink_msg_highres_imu_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_optical_flow_rad(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_optical_flow_rad_t packet_in = {
+		93372036854775807ULL,963497880,101.0,129.0,157.0,185.0,213.0,963499128,269.0,19315,3,70
+    };
+	mavlink_optical_flow_rad_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_usec = packet_in.time_usec;
+        	packet1.integration_time_us = packet_in.integration_time_us;
+        	packet1.integrated_x = packet_in.integrated_x;
+        	packet1.integrated_y = packet_in.integrated_y;
+        	packet1.integrated_xgyro = packet_in.integrated_xgyro;
+        	packet1.integrated_ygyro = packet_in.integrated_ygyro;
+        	packet1.integrated_zgyro = packet_in.integrated_zgyro;
+        	packet1.time_delta_distance_us = packet_in.time_delta_distance_us;
+        	packet1.distance = packet_in.distance;
+        	packet1.temperature = packet_in.temperature;
+        	packet1.sensor_id = packet_in.sensor_id;
+        	packet1.quality = packet_in.quality;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_optical_flow_rad_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_optical_flow_rad_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_optical_flow_rad_pack(system_id, component_id, &msg , packet1.time_usec , packet1.sensor_id , packet1.integration_time_us , packet1.integrated_x , packet1.integrated_y , packet1.integrated_xgyro , packet1.integrated_ygyro , packet1.integrated_zgyro , packet1.temperature , packet1.quality , packet1.time_delta_distance_us , packet1.distance );
+	mavlink_msg_optical_flow_rad_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_optical_flow_rad_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_usec , packet1.sensor_id , packet1.integration_time_us , packet1.integrated_x , packet1.integrated_y , packet1.integrated_xgyro , packet1.integrated_ygyro , packet1.integrated_zgyro , packet1.temperature , packet1.quality , packet1.time_delta_distance_us , packet1.distance );
+	mavlink_msg_optical_flow_rad_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_optical_flow_rad_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_optical_flow_rad_send(MAVLINK_COMM_1 , packet1.time_usec , packet1.sensor_id , packet1.integration_time_us , packet1.integrated_x , packet1.integrated_y , packet1.integrated_xgyro , packet1.integrated_ygyro , packet1.integrated_zgyro , packet1.temperature , packet1.quality , packet1.time_delta_distance_us , packet1.distance );
+	mavlink_msg_optical_flow_rad_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_hil_sensor(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_hil_sensor_t packet_in = {
+		93372036854775807ULL,73.0,101.0,129.0,157.0,185.0,213.0,241.0,269.0,297.0,325.0,353.0,381.0,409.0,963500584
+    };
+	mavlink_hil_sensor_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_usec = packet_in.time_usec;
+        	packet1.xacc = packet_in.xacc;
+        	packet1.yacc = packet_in.yacc;
+        	packet1.zacc = packet_in.zacc;
+        	packet1.xgyro = packet_in.xgyro;
+        	packet1.ygyro = packet_in.ygyro;
+        	packet1.zgyro = packet_in.zgyro;
+        	packet1.xmag = packet_in.xmag;
+        	packet1.ymag = packet_in.ymag;
+        	packet1.zmag = packet_in.zmag;
+        	packet1.abs_pressure = packet_in.abs_pressure;
+        	packet1.diff_pressure = packet_in.diff_pressure;
+        	packet1.pressure_alt = packet_in.pressure_alt;
+        	packet1.temperature = packet_in.temperature;
+        	packet1.fields_updated = packet_in.fields_updated;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_sensor_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_hil_sensor_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_sensor_pack(system_id, component_id, &msg , packet1.time_usec , packet1.xacc , packet1.yacc , packet1.zacc , packet1.xgyro , packet1.ygyro , packet1.zgyro , packet1.xmag , packet1.ymag , packet1.zmag , packet1.abs_pressure , packet1.diff_pressure , packet1.pressure_alt , packet1.temperature , packet1.fields_updated );
+	mavlink_msg_hil_sensor_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_sensor_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_usec , packet1.xacc , packet1.yacc , packet1.zacc , packet1.xgyro , packet1.ygyro , packet1.zgyro , packet1.xmag , packet1.ymag , packet1.zmag , packet1.abs_pressure , packet1.diff_pressure , packet1.pressure_alt , packet1.temperature , packet1.fields_updated );
+	mavlink_msg_hil_sensor_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_hil_sensor_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_sensor_send(MAVLINK_COMM_1 , packet1.time_usec , packet1.xacc , packet1.yacc , packet1.zacc , packet1.xgyro , packet1.ygyro , packet1.zgyro , packet1.xmag , packet1.ymag , packet1.zmag , packet1.abs_pressure , packet1.diff_pressure , packet1.pressure_alt , packet1.temperature , packet1.fields_updated );
+	mavlink_msg_hil_sensor_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_sim_state(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_sim_state_t packet_in = {
+		17.0,45.0,73.0,101.0,129.0,157.0,185.0,213.0,241.0,269.0,297.0,325.0,353.0,381.0,409.0,437.0,465.0,493.0,521.0,549.0,577.0
+    };
+	mavlink_sim_state_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.q1 = packet_in.q1;
+        	packet1.q2 = packet_in.q2;
+        	packet1.q3 = packet_in.q3;
+        	packet1.q4 = packet_in.q4;
+        	packet1.roll = packet_in.roll;
+        	packet1.pitch = packet_in.pitch;
+        	packet1.yaw = packet_in.yaw;
+        	packet1.xacc = packet_in.xacc;
+        	packet1.yacc = packet_in.yacc;
+        	packet1.zacc = packet_in.zacc;
+        	packet1.xgyro = packet_in.xgyro;
+        	packet1.ygyro = packet_in.ygyro;
+        	packet1.zgyro = packet_in.zgyro;
+        	packet1.lat = packet_in.lat;
+        	packet1.lon = packet_in.lon;
+        	packet1.alt = packet_in.alt;
+        	packet1.std_dev_horz = packet_in.std_dev_horz;
+        	packet1.std_dev_vert = packet_in.std_dev_vert;
+        	packet1.vn = packet_in.vn;
+        	packet1.ve = packet_in.ve;
+        	packet1.vd = packet_in.vd;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_sim_state_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_sim_state_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_sim_state_pack(system_id, component_id, &msg , packet1.q1 , packet1.q2 , packet1.q3 , packet1.q4 , packet1.roll , packet1.pitch , packet1.yaw , packet1.xacc , packet1.yacc , packet1.zacc , packet1.xgyro , packet1.ygyro , packet1.zgyro , packet1.lat , packet1.lon , packet1.alt , packet1.std_dev_horz , packet1.std_dev_vert , packet1.vn , packet1.ve , packet1.vd );
+	mavlink_msg_sim_state_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_sim_state_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.q1 , packet1.q2 , packet1.q3 , packet1.q4 , packet1.roll , packet1.pitch , packet1.yaw , packet1.xacc , packet1.yacc , packet1.zacc , packet1.xgyro , packet1.ygyro , packet1.zgyro , packet1.lat , packet1.lon , packet1.alt , packet1.std_dev_horz , packet1.std_dev_vert , packet1.vn , packet1.ve , packet1.vd );
+	mavlink_msg_sim_state_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_sim_state_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_sim_state_send(MAVLINK_COMM_1 , packet1.q1 , packet1.q2 , packet1.q3 , packet1.q4 , packet1.roll , packet1.pitch , packet1.yaw , packet1.xacc , packet1.yacc , packet1.zacc , packet1.xgyro , packet1.ygyro , packet1.zgyro , packet1.lat , packet1.lon , packet1.alt , packet1.std_dev_horz , packet1.std_dev_vert , packet1.vn , packet1.ve , packet1.vd );
+	mavlink_msg_sim_state_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_radio_status(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_radio_status_t packet_in = {
+		17235,17339,17,84,151,218,29
+    };
+	mavlink_radio_status_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.rxerrors = packet_in.rxerrors;
+        	packet1.fixed = packet_in.fixed;
+        	packet1.rssi = packet_in.rssi;
+        	packet1.remrssi = packet_in.remrssi;
+        	packet1.txbuf = packet_in.txbuf;
+        	packet1.noise = packet_in.noise;
+        	packet1.remnoise = packet_in.remnoise;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_radio_status_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_radio_status_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_radio_status_pack(system_id, component_id, &msg , packet1.rssi , packet1.remrssi , packet1.txbuf , packet1.noise , packet1.remnoise , packet1.rxerrors , packet1.fixed );
+	mavlink_msg_radio_status_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_radio_status_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.rssi , packet1.remrssi , packet1.txbuf , packet1.noise , packet1.remnoise , packet1.rxerrors , packet1.fixed );
+	mavlink_msg_radio_status_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_radio_status_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_radio_status_send(MAVLINK_COMM_1 , packet1.rssi , packet1.remrssi , packet1.txbuf , packet1.noise , packet1.remnoise , packet1.rxerrors , packet1.fixed );
+	mavlink_msg_radio_status_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_file_transfer_protocol(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_file_transfer_protocol_t packet_in = {
+		5,72,139,{ 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200 }
+    };
+	mavlink_file_transfer_protocol_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.target_network = packet_in.target_network;
+        	packet1.target_system = packet_in.target_system;
+        	packet1.target_component = packet_in.target_component;
+        
+        	mav_array_memcpy(packet1.payload, packet_in.payload, sizeof(uint8_t)*251);
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_file_transfer_protocol_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_file_transfer_protocol_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_file_transfer_protocol_pack(system_id, component_id, &msg , packet1.target_network , packet1.target_system , packet1.target_component , packet1.payload );
+	mavlink_msg_file_transfer_protocol_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_file_transfer_protocol_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_network , packet1.target_system , packet1.target_component , packet1.payload );
+	mavlink_msg_file_transfer_protocol_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_file_transfer_protocol_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_file_transfer_protocol_send(MAVLINK_COMM_1 , packet1.target_network , packet1.target_system , packet1.target_component , packet1.payload );
+	mavlink_msg_file_transfer_protocol_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_timesync(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_timesync_t packet_in = {
+		93372036854775807LL,93372036854776311LL
+    };
+	mavlink_timesync_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.tc1 = packet_in.tc1;
+        	packet1.ts1 = packet_in.ts1;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_timesync_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_timesync_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_timesync_pack(system_id, component_id, &msg , packet1.tc1 , packet1.ts1 );
+	mavlink_msg_timesync_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_timesync_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.tc1 , packet1.ts1 );
+	mavlink_msg_timesync_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_timesync_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_timesync_send(MAVLINK_COMM_1 , packet1.tc1 , packet1.ts1 );
+	mavlink_msg_timesync_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_hil_gps(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_hil_gps_t packet_in = {
+		93372036854775807ULL,963497880,963498088,963498296,18275,18379,18483,18587,18691,18795,18899,235,46
+    };
+	mavlink_hil_gps_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_usec = packet_in.time_usec;
+        	packet1.lat = packet_in.lat;
+        	packet1.lon = packet_in.lon;
+        	packet1.alt = packet_in.alt;
+        	packet1.eph = packet_in.eph;
+        	packet1.epv = packet_in.epv;
+        	packet1.vel = packet_in.vel;
+        	packet1.vn = packet_in.vn;
+        	packet1.ve = packet_in.ve;
+        	packet1.vd = packet_in.vd;
+        	packet1.cog = packet_in.cog;
+        	packet1.fix_type = packet_in.fix_type;
+        	packet1.satellites_visible = packet_in.satellites_visible;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_gps_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_hil_gps_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_gps_pack(system_id, component_id, &msg , packet1.time_usec , packet1.fix_type , packet1.lat , packet1.lon , packet1.alt , packet1.eph , packet1.epv , packet1.vel , packet1.vn , packet1.ve , packet1.vd , packet1.cog , packet1.satellites_visible );
+	mavlink_msg_hil_gps_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_gps_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_usec , packet1.fix_type , packet1.lat , packet1.lon , packet1.alt , packet1.eph , packet1.epv , packet1.vel , packet1.vn , packet1.ve , packet1.vd , packet1.cog , packet1.satellites_visible );
+	mavlink_msg_hil_gps_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_hil_gps_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_gps_send(MAVLINK_COMM_1 , packet1.time_usec , packet1.fix_type , packet1.lat , packet1.lon , packet1.alt , packet1.eph , packet1.epv , packet1.vel , packet1.vn , packet1.ve , packet1.vd , packet1.cog , packet1.satellites_visible );
+	mavlink_msg_hil_gps_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_hil_optical_flow(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_hil_optical_flow_t packet_in = {
+		93372036854775807ULL,963497880,101.0,129.0,157.0,185.0,213.0,963499128,269.0,19315,3,70
+    };
+	mavlink_hil_optical_flow_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_usec = packet_in.time_usec;
+        	packet1.integration_time_us = packet_in.integration_time_us;
+        	packet1.integrated_x = packet_in.integrated_x;
+        	packet1.integrated_y = packet_in.integrated_y;
+        	packet1.integrated_xgyro = packet_in.integrated_xgyro;
+        	packet1.integrated_ygyro = packet_in.integrated_ygyro;
+        	packet1.integrated_zgyro = packet_in.integrated_zgyro;
+        	packet1.time_delta_distance_us = packet_in.time_delta_distance_us;
+        	packet1.distance = packet_in.distance;
+        	packet1.temperature = packet_in.temperature;
+        	packet1.sensor_id = packet_in.sensor_id;
+        	packet1.quality = packet_in.quality;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_optical_flow_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_hil_optical_flow_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_optical_flow_pack(system_id, component_id, &msg , packet1.time_usec , packet1.sensor_id , packet1.integration_time_us , packet1.integrated_x , packet1.integrated_y , packet1.integrated_xgyro , packet1.integrated_ygyro , packet1.integrated_zgyro , packet1.temperature , packet1.quality , packet1.time_delta_distance_us , packet1.distance );
+	mavlink_msg_hil_optical_flow_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_optical_flow_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_usec , packet1.sensor_id , packet1.integration_time_us , packet1.integrated_x , packet1.integrated_y , packet1.integrated_xgyro , packet1.integrated_ygyro , packet1.integrated_zgyro , packet1.temperature , packet1.quality , packet1.time_delta_distance_us , packet1.distance );
+	mavlink_msg_hil_optical_flow_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_hil_optical_flow_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_optical_flow_send(MAVLINK_COMM_1 , packet1.time_usec , packet1.sensor_id , packet1.integration_time_us , packet1.integrated_x , packet1.integrated_y , packet1.integrated_xgyro , packet1.integrated_ygyro , packet1.integrated_zgyro , packet1.temperature , packet1.quality , packet1.time_delta_distance_us , packet1.distance );
+	mavlink_msg_hil_optical_flow_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_hil_state_quaternion(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_hil_state_quaternion_t packet_in = {
+		93372036854775807ULL,{ 73.0, 74.0, 75.0, 76.0 },185.0,213.0,241.0,963499336,963499544,963499752,19731,19835,19939,20043,20147,20251,20355,20459
+    };
+	mavlink_hil_state_quaternion_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_usec = packet_in.time_usec;
+        	packet1.rollspeed = packet_in.rollspeed;
+        	packet1.pitchspeed = packet_in.pitchspeed;
+        	packet1.yawspeed = packet_in.yawspeed;
+        	packet1.lat = packet_in.lat;
+        	packet1.lon = packet_in.lon;
+        	packet1.alt = packet_in.alt;
+        	packet1.vx = packet_in.vx;
+        	packet1.vy = packet_in.vy;
+        	packet1.vz = packet_in.vz;
+        	packet1.ind_airspeed = packet_in.ind_airspeed;
+        	packet1.true_airspeed = packet_in.true_airspeed;
+        	packet1.xacc = packet_in.xacc;
+        	packet1.yacc = packet_in.yacc;
+        	packet1.zacc = packet_in.zacc;
+        
+        	mav_array_memcpy(packet1.attitude_quaternion, packet_in.attitude_quaternion, sizeof(float)*4);
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_state_quaternion_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_hil_state_quaternion_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_state_quaternion_pack(system_id, component_id, &msg , packet1.time_usec , packet1.attitude_quaternion , packet1.rollspeed , packet1.pitchspeed , packet1.yawspeed , packet1.lat , packet1.lon , packet1.alt , packet1.vx , packet1.vy , packet1.vz , packet1.ind_airspeed , packet1.true_airspeed , packet1.xacc , packet1.yacc , packet1.zacc );
+	mavlink_msg_hil_state_quaternion_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_state_quaternion_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_usec , packet1.attitude_quaternion , packet1.rollspeed , packet1.pitchspeed , packet1.yawspeed , packet1.lat , packet1.lon , packet1.alt , packet1.vx , packet1.vy , packet1.vz , packet1.ind_airspeed , packet1.true_airspeed , packet1.xacc , packet1.yacc , packet1.zacc );
+	mavlink_msg_hil_state_quaternion_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_hil_state_quaternion_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_hil_state_quaternion_send(MAVLINK_COMM_1 , packet1.time_usec , packet1.attitude_quaternion , packet1.rollspeed , packet1.pitchspeed , packet1.yawspeed , packet1.lat , packet1.lon , packet1.alt , packet1.vx , packet1.vy , packet1.vz , packet1.ind_airspeed , packet1.true_airspeed , packet1.xacc , packet1.yacc , packet1.zacc );
+	mavlink_msg_hil_state_quaternion_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_scaled_imu2(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_scaled_imu2_t packet_in = {
+		963497464,17443,17547,17651,17755,17859,17963,18067,18171,18275
+    };
+	mavlink_scaled_imu2_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_boot_ms = packet_in.time_boot_ms;
+        	packet1.xacc = packet_in.xacc;
+        	packet1.yacc = packet_in.yacc;
+        	packet1.zacc = packet_in.zacc;
+        	packet1.xgyro = packet_in.xgyro;
+        	packet1.ygyro = packet_in.ygyro;
+        	packet1.zgyro = packet_in.zgyro;
+        	packet1.xmag = packet_in.xmag;
+        	packet1.ymag = packet_in.ymag;
+        	packet1.zmag = packet_in.zmag;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_scaled_imu2_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_scaled_imu2_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_scaled_imu2_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.xacc , packet1.yacc , packet1.zacc , packet1.xgyro , packet1.ygyro , packet1.zgyro , packet1.xmag , packet1.ymag , packet1.zmag );
+	mavlink_msg_scaled_imu2_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_scaled_imu2_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.xacc , packet1.yacc , packet1.zacc , packet1.xgyro , packet1.ygyro , packet1.zgyro , packet1.xmag , packet1.ymag , packet1.zmag );
+	mavlink_msg_scaled_imu2_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_scaled_imu2_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_scaled_imu2_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.xacc , packet1.yacc , packet1.zacc , packet1.xgyro , packet1.ygyro , packet1.zgyro , packet1.xmag , packet1.ymag , packet1.zmag );
+	mavlink_msg_scaled_imu2_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_log_request_list(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_log_request_list_t packet_in = {
+		17235,17339,17,84
+    };
+	mavlink_log_request_list_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.start = packet_in.start;
+        	packet1.end = packet_in.end;
+        	packet1.target_system = packet_in.target_system;
+        	packet1.target_component = packet_in.target_component;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_request_list_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_log_request_list_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_request_list_pack(system_id, component_id, &msg , packet1.target_system , packet1.target_component , packet1.start , packet1.end );
+	mavlink_msg_log_request_list_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_request_list_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.target_component , packet1.start , packet1.end );
+	mavlink_msg_log_request_list_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_log_request_list_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_request_list_send(MAVLINK_COMM_1 , packet1.target_system , packet1.target_component , packet1.start , packet1.end );
+	mavlink_msg_log_request_list_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_log_entry(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_log_entry_t packet_in = {
+		963497464,963497672,17651,17755,17859
+    };
+	mavlink_log_entry_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_utc = packet_in.time_utc;
+        	packet1.size = packet_in.size;
+        	packet1.id = packet_in.id;
+        	packet1.num_logs = packet_in.num_logs;
+        	packet1.last_log_num = packet_in.last_log_num;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_entry_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_log_entry_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_entry_pack(system_id, component_id, &msg , packet1.id , packet1.num_logs , packet1.last_log_num , packet1.time_utc , packet1.size );
+	mavlink_msg_log_entry_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_entry_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.id , packet1.num_logs , packet1.last_log_num , packet1.time_utc , packet1.size );
+	mavlink_msg_log_entry_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_log_entry_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_entry_send(MAVLINK_COMM_1 , packet1.id , packet1.num_logs , packet1.last_log_num , packet1.time_utc , packet1.size );
+	mavlink_msg_log_entry_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_log_request_data(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_log_request_data_t packet_in = {
+		963497464,963497672,17651,163,230
+    };
+	mavlink_log_request_data_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.ofs = packet_in.ofs;
+        	packet1.count = packet_in.count;
+        	packet1.id = packet_in.id;
+        	packet1.target_system = packet_in.target_system;
+        	packet1.target_component = packet_in.target_component;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_request_data_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_log_request_data_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_request_data_pack(system_id, component_id, &msg , packet1.target_system , packet1.target_component , packet1.id , packet1.ofs , packet1.count );
+	mavlink_msg_log_request_data_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_request_data_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.target_component , packet1.id , packet1.ofs , packet1.count );
+	mavlink_msg_log_request_data_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_log_request_data_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_request_data_send(MAVLINK_COMM_1 , packet1.target_system , packet1.target_component , packet1.id , packet1.ofs , packet1.count );
+	mavlink_msg_log_request_data_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_log_data(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_log_data_t packet_in = {
+		963497464,17443,151,{ 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51 }
+    };
+	mavlink_log_data_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.ofs = packet_in.ofs;
+        	packet1.id = packet_in.id;
+        	packet1.count = packet_in.count;
+        
+        	mav_array_memcpy(packet1.data, packet_in.data, sizeof(uint8_t)*90);
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_data_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_log_data_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_data_pack(system_id, component_id, &msg , packet1.id , packet1.ofs , packet1.count , packet1.data );
+	mavlink_msg_log_data_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_data_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.id , packet1.ofs , packet1.count , packet1.data );
+	mavlink_msg_log_data_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_log_data_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_data_send(MAVLINK_COMM_1 , packet1.id , packet1.ofs , packet1.count , packet1.data );
+	mavlink_msg_log_data_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_log_erase(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_log_erase_t packet_in = {
+		5,72
+    };
+	mavlink_log_erase_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.target_system = packet_in.target_system;
+        	packet1.target_component = packet_in.target_component;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_erase_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_log_erase_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_erase_pack(system_id, component_id, &msg , packet1.target_system , packet1.target_component );
+	mavlink_msg_log_erase_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_erase_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.target_component );
+	mavlink_msg_log_erase_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_log_erase_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_erase_send(MAVLINK_COMM_1 , packet1.target_system , packet1.target_component );
+	mavlink_msg_log_erase_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_log_request_end(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_log_request_end_t packet_in = {
+		5,72
+    };
+	mavlink_log_request_end_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.target_system = packet_in.target_system;
+        	packet1.target_component = packet_in.target_component;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_request_end_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_log_request_end_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_request_end_pack(system_id, component_id, &msg , packet1.target_system , packet1.target_component );
+	mavlink_msg_log_request_end_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_request_end_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.target_component );
+	mavlink_msg_log_request_end_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_log_request_end_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_log_request_end_send(MAVLINK_COMM_1 , packet1.target_system , packet1.target_component );
+	mavlink_msg_log_request_end_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_gps_inject_data(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_gps_inject_data_t packet_in = {
+		5,72,139,{ 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59 }
+    };
+	mavlink_gps_inject_data_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.target_system = packet_in.target_system;
+        	packet1.target_component = packet_in.target_component;
+        	packet1.len = packet_in.len;
+        
+        	mav_array_memcpy(packet1.data, packet_in.data, sizeof(uint8_t)*110);
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_gps_inject_data_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_gps_inject_data_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_gps_inject_data_pack(system_id, component_id, &msg , packet1.target_system , packet1.target_component , packet1.len , packet1.data );
+	mavlink_msg_gps_inject_data_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_gps_inject_data_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.target_component , packet1.len , packet1.data );
+	mavlink_msg_gps_inject_data_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_gps_inject_data_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_gps_inject_data_send(MAVLINK_COMM_1 , packet1.target_system , packet1.target_component , packet1.len , packet1.data );
+	mavlink_msg_gps_inject_data_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_gps2_raw(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_gps2_raw_t packet_in = {
+		93372036854775807ULL,963497880,963498088,963498296,963498504,18483,18587,18691,18795,101,168,235
+    };
+	mavlink_gps2_raw_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_usec = packet_in.time_usec;
+        	packet1.lat = packet_in.lat;
+        	packet1.lon = packet_in.lon;
+        	packet1.alt = packet_in.alt;
+        	packet1.dgps_age = packet_in.dgps_age;
+        	packet1.eph = packet_in.eph;
+        	packet1.epv = packet_in.epv;
+        	packet1.vel = packet_in.vel;
+        	packet1.cog = packet_in.cog;
+        	packet1.fix_type = packet_in.fix_type;
+        	packet1.satellites_visible = packet_in.satellites_visible;
+        	packet1.dgps_numch = packet_in.dgps_numch;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_gps2_raw_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_gps2_raw_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_gps2_raw_pack(system_id, component_id, &msg , packet1.time_usec , packet1.fix_type , packet1.lat , packet1.lon , packet1.alt , packet1.eph , packet1.epv , packet1.vel , packet1.cog , packet1.satellites_visible , packet1.dgps_numch , packet1.dgps_age );
+	mavlink_msg_gps2_raw_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_gps2_raw_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_usec , packet1.fix_type , packet1.lat , packet1.lon , packet1.alt , packet1.eph , packet1.epv , packet1.vel , packet1.cog , packet1.satellites_visible , packet1.dgps_numch , packet1.dgps_age );
+	mavlink_msg_gps2_raw_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_gps2_raw_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_gps2_raw_send(MAVLINK_COMM_1 , packet1.time_usec , packet1.fix_type , packet1.lat , packet1.lon , packet1.alt , packet1.eph , packet1.epv , packet1.vel , packet1.cog , packet1.satellites_visible , packet1.dgps_numch , packet1.dgps_age );
+	mavlink_msg_gps2_raw_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_power_status(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_power_status_t packet_in = {
+		17235,17339,17443
+    };
+	mavlink_power_status_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.Vcc = packet_in.Vcc;
+        	packet1.Vservo = packet_in.Vservo;
+        	packet1.flags = packet_in.flags;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_power_status_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_power_status_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_power_status_pack(system_id, component_id, &msg , packet1.Vcc , packet1.Vservo , packet1.flags );
+	mavlink_msg_power_status_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_power_status_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.Vcc , packet1.Vservo , packet1.flags );
+	mavlink_msg_power_status_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_power_status_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_power_status_send(MAVLINK_COMM_1 , packet1.Vcc , packet1.Vservo , packet1.flags );
+	mavlink_msg_power_status_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_serial_control(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_serial_control_t packet_in = {
+		963497464,17443,151,218,29,{ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165 }
+    };
+	mavlink_serial_control_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.baudrate = packet_in.baudrate;
+        	packet1.timeout = packet_in.timeout;
+        	packet1.device = packet_in.device;
+        	packet1.flags = packet_in.flags;
+        	packet1.count = packet_in.count;
+        
+        	mav_array_memcpy(packet1.data, packet_in.data, sizeof(uint8_t)*70);
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_serial_control_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_serial_control_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_serial_control_pack(system_id, component_id, &msg , packet1.device , packet1.flags , packet1.timeout , packet1.baudrate , packet1.count , packet1.data );
+	mavlink_msg_serial_control_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_serial_control_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.device , packet1.flags , packet1.timeout , packet1.baudrate , packet1.count , packet1.data );
+	mavlink_msg_serial_control_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_serial_control_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_serial_control_send(MAVLINK_COMM_1 , packet1.device , packet1.flags , packet1.timeout , packet1.baudrate , packet1.count , packet1.data );
+	mavlink_msg_serial_control_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_gps_rtk(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_gps_rtk_t packet_in = {
+		963497464,963497672,963497880,963498088,963498296,963498504,963498712,18691,223,34,101,168,235
+    };
+	mavlink_gps_rtk_t packet1, packet2;
+        memset(&packet1, 0, sizeof(packet1));
+        	packet1.time_last_baseline_ms = packet_in.time_last_baseline_ms;
+        	packet1.tow = packet_in.tow;
+        	packet1.baseline_a_mm = packet_in.baseline_a_mm;
+        	packet1.baseline_b_mm = packet_in.baseline_b_mm;
+        	packet1.baseline_c_mm = packet_in.baseline_c_mm;
+        	packet1.accuracy = packet_in.accuracy;
+        	packet1.iar_num_hypotheses = packet_in.iar_num_hypotheses;
+        	packet1.wn = packet_in.wn;
+        	packet1.rtk_receiver_id = packet_in.rtk_receiver_id;
+        	packet1.rtk_health = packet_in.rtk_health;
+        	packet1.rtk_rate = packet_in.rtk_rate;
+        	packet1.nsats = packet_in.nsats;
+        	packet1.baseline_coords_type = packet_in.baseline_coords_type;
+        
+        
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_gps_rtk_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_gps_rtk_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_gps_rtk_pack(system_id, component_id, &msg , packet1.time_last_baseline_ms , packet1.rtk_receiver_id , packet1.wn , packet1.tow , packet1.rtk_health , packet1.rtk_rate , packet1.nsats , packet1.baseline_coords_type , packet1.baseline_a_mm , packet1.baseline_b_mm , packet1.baseline_c_mm , packet1.accuracy , packet1.iar_num_hypotheses );
+	mavlink_msg_gps_rtk_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_gps_rtk_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_last_baseline_ms , packet1.rtk_receiver_id , packet1.wn , packet1.tow , packet1.rtk_health , packet1.rtk_rate , packet1.nsats , packet1.baseline_coords_type , packet1.baseline_a_mm , packet1.baseline_b_mm , packet1.baseline_c_mm , packet1.accuracy , packet1.iar_num_hypotheses );
+	mavlink_msg_gps_rtk_decode(&msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+
+        memset(&packet2, 0, sizeof(packet2));
+        mavlink_msg_to_send_buffer(buffer, &msg);
+        for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
+        	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
+        }
+	mavlink_msg_gps_rtk_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+        
+        memset(&packet2, 0, sizeof(packet2));
+	mavlink_msg_gps_rtk_send(MAVLINK_COMM_1 , packet1.time_last_baseline_ms , packet1.rtk_receiver_id , packet1.wn , packet1.tow , packet1.rtk_health , packet1.rtk_rate , packet1.nsats , packet1.baseline_coords_type , packet1.baseline_a_mm , packet1.baseline_b_mm , packet1.baseline_c_mm , packet1.accuracy , packet1.iar_num_hypotheses );
+	mavlink_msg_gps_rtk_decode(last_msg, &packet2);
+        MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
+}
+
+static void mavlink_test_gps2_rtk(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+{
+	mavlink_message_t msg;
+        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
+        uint16_t i;
+	mavlink_gps2_rtk_t packet_in = {
+		963497464,963497672,963497880,963498088,963498296,963498504,963498712,18691,223,34,101,168,235
+    };
+	mavlink_gps2_rtk_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.airspeed = packet_in.airspeed;
-        	packet1.groundspeed = packet_in.groundspeed;
-        	packet1.alt = packet_in.alt;
-        	packet1.climb = packet_in.climb;
-        	packet1.heading = packet_in.heading;
-        	packet1.throttle = packet_in.throttle;
+        	packet1.time_last_baseline_ms = packet_in.time_last_baseline_ms;
+        	packet1.tow = packet_in.tow;
+        	packet1.baseline_a_mm = packet_in.baseline_a_mm;
+        	packet1.baseline_b_mm = packet_in.baseline_b_mm;
+        	packet1.baseline_c_mm = packet_in.baseline_c_mm;
+        	packet1.accuracy = packet_in.accuracy;
+        	packet1.iar_num_hypotheses = packet_in.iar_num_hypotheses;
+        	packet1.wn = packet_in.wn;
+        	packet1.rtk_receiver_id = packet_in.rtk_receiver_id;
+        	packet1.rtk_health = packet_in.rtk_health;
+        	packet1.rtk_rate = packet_in.rtk_rate;
+        	packet1.nsats = packet_in.nsats;
+        	packet1.baseline_coords_type = packet_in.baseline_coords_type;
         
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_vfr_hud_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_vfr_hud_decode(&msg, &packet2);
+	mavlink_msg_gps2_rtk_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_gps2_rtk_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_vfr_hud_pack(system_id, component_id, &msg , packet1.airspeed , packet1.groundspeed , packet1.heading , packet1.throttle , packet1.alt , packet1.climb );
-	mavlink_msg_vfr_hud_decode(&msg, &packet2);
+	mavlink_msg_gps2_rtk_pack(system_id, component_id, &msg , packet1.time_last_baseline_ms , packet1.rtk_receiver_id , packet1.wn , packet1.tow , packet1.rtk_health , packet1.rtk_rate , packet1.nsats , packet1.baseline_coords_type , packet1.baseline_a_mm , packet1.baseline_b_mm , packet1.baseline_c_mm , packet1.accuracy , packet1.iar_num_hypotheses );
+	mavlink_msg_gps2_rtk_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_vfr_hud_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.airspeed , packet1.groundspeed , packet1.heading , packet1.throttle , packet1.alt , packet1.climb );
-	mavlink_msg_vfr_hud_decode(&msg, &packet2);
+	mavlink_msg_gps2_rtk_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_last_baseline_ms , packet1.rtk_receiver_id , packet1.wn , packet1.tow , packet1.rtk_health , packet1.rtk_rate , packet1.nsats , packet1.baseline_coords_type , packet1.baseline_a_mm , packet1.baseline_b_mm , packet1.baseline_c_mm , packet1.accuracy , packet1.iar_num_hypotheses );
+	mavlink_msg_gps2_rtk_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -3067,62 +4685,48 @@ static void mavlink_test_vfr_hud(uint8_t
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_vfr_hud_decode(last_msg, &packet2);
+	mavlink_msg_gps2_rtk_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_vfr_hud_send(MAVLINK_COMM_1 , packet1.airspeed , packet1.groundspeed , packet1.heading , packet1.throttle , packet1.alt , packet1.climb );
-	mavlink_msg_vfr_hud_decode(last_msg, &packet2);
+	mavlink_msg_gps2_rtk_send(MAVLINK_COMM_1 , packet1.time_last_baseline_ms , packet1.rtk_receiver_id , packet1.wn , packet1.tow , packet1.rtk_health , packet1.rtk_rate , packet1.nsats , packet1.baseline_coords_type , packet1.baseline_a_mm , packet1.baseline_b_mm , packet1.baseline_c_mm , packet1.accuracy , packet1.iar_num_hypotheses );
+	mavlink_msg_gps2_rtk_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_command_long(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_data_transmission_handshake(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_command_long_t packet_in = {
-		17.0,
-	45.0,
-	73.0,
-	101.0,
-	129.0,
-	157.0,
-	185.0,
-	18691,
-	223,
-	34,
-	101,
+	mavlink_data_transmission_handshake_t packet_in = {
+		963497464,17443,17547,17651,163,230,41
 	};
-	mavlink_command_long_t packet1, packet2;
+	mavlink_data_transmission_handshake_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.param1 = packet_in.param1;
-        	packet1.param2 = packet_in.param2;
-        	packet1.param3 = packet_in.param3;
-        	packet1.param4 = packet_in.param4;
-        	packet1.param5 = packet_in.param5;
-        	packet1.param6 = packet_in.param6;
-        	packet1.param7 = packet_in.param7;
-        	packet1.command = packet_in.command;
-        	packet1.target_system = packet_in.target_system;
-        	packet1.target_component = packet_in.target_component;
-        	packet1.confirmation = packet_in.confirmation;
+        	packet1.size = packet_in.size;
+        	packet1.width = packet_in.width;
+        	packet1.height = packet_in.height;
+        	packet1.packets = packet_in.packets;
+        	packet1.type = packet_in.type;
+        	packet1.payload = packet_in.payload;
+        	packet1.jpg_quality = packet_in.jpg_quality;
         
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_command_long_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_command_long_decode(&msg, &packet2);
+	mavlink_msg_data_transmission_handshake_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_data_transmission_handshake_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_command_long_pack(system_id, component_id, &msg , packet1.target_system , packet1.target_component , packet1.command , packet1.confirmation , packet1.param1 , packet1.param2 , packet1.param3 , packet1.param4 , packet1.param5 , packet1.param6 , packet1.param7 );
-	mavlink_msg_command_long_decode(&msg, &packet2);
+	mavlink_msg_data_transmission_handshake_pack(system_id, component_id, &msg , packet1.type , packet1.size , packet1.width , packet1.height , packet1.packets , packet1.payload , packet1.jpg_quality );
+	mavlink_msg_data_transmission_handshake_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_command_long_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_system , packet1.target_component , packet1.command , packet1.confirmation , packet1.param1 , packet1.param2 , packet1.param3 , packet1.param4 , packet1.param5 , packet1.param6 , packet1.param7 );
-	mavlink_msg_command_long_decode(&msg, &packet2);
+	mavlink_msg_data_transmission_handshake_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.type , packet1.size , packet1.width , packet1.height , packet1.packets , packet1.payload , packet1.jpg_quality );
+	mavlink_msg_data_transmission_handshake_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -3130,44 +4734,43 @@ static void mavlink_test_command_long(ui
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_command_long_decode(last_msg, &packet2);
+	mavlink_msg_data_transmission_handshake_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_command_long_send(MAVLINK_COMM_1 , packet1.target_system , packet1.target_component , packet1.command , packet1.confirmation , packet1.param1 , packet1.param2 , packet1.param3 , packet1.param4 , packet1.param5 , packet1.param6 , packet1.param7 );
-	mavlink_msg_command_long_decode(last_msg, &packet2);
+	mavlink_msg_data_transmission_handshake_send(MAVLINK_COMM_1 , packet1.type , packet1.size , packet1.width , packet1.height , packet1.packets , packet1.payload , packet1.jpg_quality );
+	mavlink_msg_data_transmission_handshake_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_command_ack(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_encapsulated_data(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_command_ack_t packet_in = {
-		17235,
-	139,
+	mavlink_encapsulated_data_t packet_in = {
+		17235,{ 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135 }
 	};
-	mavlink_command_ack_t packet1, packet2;
+	mavlink_encapsulated_data_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.command = packet_in.command;
-        	packet1.result = packet_in.result;
+        	packet1.seqnr = packet_in.seqnr;
         
+        	mav_array_memcpy(packet1.data, packet_in.data, sizeof(uint8_t)*253);
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_command_ack_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_command_ack_decode(&msg, &packet2);
+	mavlink_msg_encapsulated_data_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_encapsulated_data_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_command_ack_pack(system_id, component_id, &msg , packet1.command , packet1.result );
-	mavlink_msg_command_ack_decode(&msg, &packet2);
+	mavlink_msg_encapsulated_data_pack(system_id, component_id, &msg , packet1.seqnr , packet1.data );
+	mavlink_msg_encapsulated_data_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_command_ack_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.command , packet1.result );
-	mavlink_msg_command_ack_decode(&msg, &packet2);
+	mavlink_msg_encapsulated_data_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.seqnr , packet1.data );
+	mavlink_msg_encapsulated_data_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -3175,54 +4778,49 @@ static void mavlink_test_command_ack(uin
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_command_ack_decode(last_msg, &packet2);
+	mavlink_msg_encapsulated_data_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_command_ack_send(MAVLINK_COMM_1 , packet1.command , packet1.result );
-	mavlink_msg_command_ack_decode(last_msg, &packet2);
+	mavlink_msg_encapsulated_data_send(MAVLINK_COMM_1 , packet1.seqnr , packet1.data );
+	mavlink_msg_encapsulated_data_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_local_position_ned_system_global_offset(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_distance_sensor(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_local_position_ned_system_global_offset_t packet_in = {
-		963497464,
-	45.0,
-	73.0,
-	101.0,
-	129.0,
-	157.0,
-	185.0,
+	mavlink_distance_sensor_t packet_in = {
+		963497464,17443,17547,17651,163,230,41,108
 	};
-	mavlink_local_position_ned_system_global_offset_t packet1, packet2;
+	mavlink_distance_sensor_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
         	packet1.time_boot_ms = packet_in.time_boot_ms;
-        	packet1.x = packet_in.x;
-        	packet1.y = packet_in.y;
-        	packet1.z = packet_in.z;
-        	packet1.roll = packet_in.roll;
-        	packet1.pitch = packet_in.pitch;
-        	packet1.yaw = packet_in.yaw;
+        	packet1.min_distance = packet_in.min_distance;
+        	packet1.max_distance = packet_in.max_distance;
+        	packet1.current_distance = packet_in.current_distance;
+        	packet1.type = packet_in.type;
+        	packet1.id = packet_in.id;
+        	packet1.orientation = packet_in.orientation;
+        	packet1.covariance = packet_in.covariance;
         
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_local_position_ned_system_global_offset_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_local_position_ned_system_global_offset_decode(&msg, &packet2);
+	mavlink_msg_distance_sensor_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_distance_sensor_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_local_position_ned_system_global_offset_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
-	mavlink_msg_local_position_ned_system_global_offset_decode(&msg, &packet2);
+	mavlink_msg_distance_sensor_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.min_distance , packet1.max_distance , packet1.current_distance , packet1.type , packet1.id , packet1.orientation , packet1.covariance );
+	mavlink_msg_distance_sensor_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_local_position_ned_system_global_offset_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
-	mavlink_msg_local_position_ned_system_global_offset_decode(&msg, &packet2);
+	mavlink_msg_distance_sensor_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.min_distance , packet1.max_distance , packet1.current_distance , packet1.type , packet1.id , packet1.orientation , packet1.covariance );
+	mavlink_msg_distance_sensor_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -3230,72 +4828,45 @@ static void mavlink_test_local_position_
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_local_position_ned_system_global_offset_decode(last_msg, &packet2);
+	mavlink_msg_distance_sensor_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_local_position_ned_system_global_offset_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
-	mavlink_msg_local_position_ned_system_global_offset_decode(last_msg, &packet2);
+	mavlink_msg_distance_sensor_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.min_distance , packet1.max_distance , packet1.current_distance , packet1.type , packet1.id , packet1.orientation , packet1.covariance );
+	mavlink_msg_distance_sensor_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_hil_state(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_terrain_request(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_hil_state_t packet_in = {
-		93372036854775807ULL,
-	73.0,
-	101.0,
-	129.0,
-	157.0,
-	185.0,
-	213.0,
-	963499128,
-	963499336,
-	963499544,
-	19523,
-	19627,
-	19731,
-	19835,
-	19939,
-	20043,
+	mavlink_terrain_request_t packet_in = {
+		93372036854775807ULL,963497880,963498088,18067
 	};
-	mavlink_hil_state_t packet1, packet2;
+	mavlink_terrain_request_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.time_usec = packet_in.time_usec;
-        	packet1.roll = packet_in.roll;
-        	packet1.pitch = packet_in.pitch;
-        	packet1.yaw = packet_in.yaw;
-        	packet1.rollspeed = packet_in.rollspeed;
-        	packet1.pitchspeed = packet_in.pitchspeed;
-        	packet1.yawspeed = packet_in.yawspeed;
+        	packet1.mask = packet_in.mask;
         	packet1.lat = packet_in.lat;
         	packet1.lon = packet_in.lon;
-        	packet1.alt = packet_in.alt;
-        	packet1.vx = packet_in.vx;
-        	packet1.vy = packet_in.vy;
-        	packet1.vz = packet_in.vz;
-        	packet1.xacc = packet_in.xacc;
-        	packet1.yacc = packet_in.yacc;
-        	packet1.zacc = packet_in.zacc;
+        	packet1.grid_spacing = packet_in.grid_spacing;
         
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_hil_state_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_hil_state_decode(&msg, &packet2);
+	mavlink_msg_terrain_request_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_terrain_request_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_hil_state_pack(system_id, component_id, &msg , packet1.time_usec , packet1.roll , packet1.pitch , packet1.yaw , packet1.rollspeed , packet1.pitchspeed , packet1.yawspeed , packet1.lat , packet1.lon , packet1.alt , packet1.vx , packet1.vy , packet1.vz , packet1.xacc , packet1.yacc , packet1.zacc );
-	mavlink_msg_hil_state_decode(&msg, &packet2);
+	mavlink_msg_terrain_request_pack(system_id, component_id, &msg , packet1.lat , packet1.lon , packet1.grid_spacing , packet1.mask );
+	mavlink_msg_terrain_request_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_hil_state_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_usec , packet1.roll , packet1.pitch , packet1.yaw , packet1.rollspeed , packet1.pitchspeed , packet1.yawspeed , packet1.lat , packet1.lon , packet1.alt , packet1.vx , packet1.vy , packet1.vz , packet1.xacc , packet1.yacc , packet1.zacc );
-	mavlink_msg_hil_state_decode(&msg, &packet2);
+	mavlink_msg_terrain_request_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.lat , packet1.lon , packet1.grid_spacing , packet1.mask );
+	mavlink_msg_terrain_request_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -3303,62 +4874,46 @@ static void mavlink_test_hil_state(uint8
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_hil_state_decode(last_msg, &packet2);
+	mavlink_msg_terrain_request_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_hil_state_send(MAVLINK_COMM_1 , packet1.time_usec , packet1.roll , packet1.pitch , packet1.yaw , packet1.rollspeed , packet1.pitchspeed , packet1.yawspeed , packet1.lat , packet1.lon , packet1.alt , packet1.vx , packet1.vy , packet1.vz , packet1.xacc , packet1.yacc , packet1.zacc );
-	mavlink_msg_hil_state_decode(last_msg, &packet2);
+	mavlink_msg_terrain_request_send(MAVLINK_COMM_1 , packet1.lat , packet1.lon , packet1.grid_spacing , packet1.mask );
+	mavlink_msg_terrain_request_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_hil_controls(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_terrain_data(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_hil_controls_t packet_in = {
-		93372036854775807ULL,
-	73.0,
-	101.0,
-	129.0,
-	157.0,
-	185.0,
-	213.0,
-	241.0,
-	269.0,
-	125,
-	192,
+	mavlink_terrain_data_t packet_in = {
+		963497464,963497672,17651,{ 17755, 17756, 17757, 17758, 17759, 17760, 17761, 17762, 17763, 17764, 17765, 17766, 17767, 17768, 17769, 17770 },3
 	};
-	mavlink_hil_controls_t packet1, packet2;
+	mavlink_terrain_data_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.time_usec = packet_in.time_usec;
-        	packet1.roll_ailerons = packet_in.roll_ailerons;
-        	packet1.pitch_elevator = packet_in.pitch_elevator;
-        	packet1.yaw_rudder = packet_in.yaw_rudder;
-        	packet1.throttle = packet_in.throttle;
-        	packet1.aux1 = packet_in.aux1;
-        	packet1.aux2 = packet_in.aux2;
-        	packet1.aux3 = packet_in.aux3;
-        	packet1.aux4 = packet_in.aux4;
-        	packet1.mode = packet_in.mode;
-        	packet1.nav_mode = packet_in.nav_mode;
+        	packet1.lat = packet_in.lat;
+        	packet1.lon = packet_in.lon;
+        	packet1.grid_spacing = packet_in.grid_spacing;
+        	packet1.gridbit = packet_in.gridbit;
         
+        	mav_array_memcpy(packet1.data, packet_in.data, sizeof(int16_t)*16);
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_hil_controls_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_hil_controls_decode(&msg, &packet2);
+	mavlink_msg_terrain_data_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_terrain_data_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_hil_controls_pack(system_id, component_id, &msg , packet1.time_usec , packet1.roll_ailerons , packet1.pitch_elevator , packet1.yaw_rudder , packet1.throttle , packet1.aux1 , packet1.aux2 , packet1.aux3 , packet1.aux4 , packet1.mode , packet1.nav_mode );
-	mavlink_msg_hil_controls_decode(&msg, &packet2);
+	mavlink_msg_terrain_data_pack(system_id, component_id, &msg , packet1.lat , packet1.lon , packet1.grid_spacing , packet1.gridbit , packet1.data );
+	mavlink_msg_terrain_data_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_hil_controls_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_usec , packet1.roll_ailerons , packet1.pitch_elevator , packet1.yaw_rudder , packet1.throttle , packet1.aux1 , packet1.aux2 , packet1.aux3 , packet1.aux4 , packet1.mode , packet1.nav_mode );
-	mavlink_msg_hil_controls_decode(&msg, &packet2);
+	mavlink_msg_terrain_data_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.lat , packet1.lon , packet1.grid_spacing , packet1.gridbit , packet1.data );
+	mavlink_msg_terrain_data_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -3366,68 +4921,43 @@ static void mavlink_test_hil_controls(ui
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_hil_controls_decode(last_msg, &packet2);
+	mavlink_msg_terrain_data_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_hil_controls_send(MAVLINK_COMM_1 , packet1.time_usec , packet1.roll_ailerons , packet1.pitch_elevator , packet1.yaw_rudder , packet1.throttle , packet1.aux1 , packet1.aux2 , packet1.aux3 , packet1.aux4 , packet1.mode , packet1.nav_mode );
-	mavlink_msg_hil_controls_decode(last_msg, &packet2);
+	mavlink_msg_terrain_data_send(MAVLINK_COMM_1 , packet1.lat , packet1.lon , packet1.grid_spacing , packet1.gridbit , packet1.data );
+	mavlink_msg_terrain_data_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_hil_rc_inputs_raw(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_terrain_check(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_hil_rc_inputs_raw_t packet_in = {
-		93372036854775807ULL,
-	17651,
-	17755,
-	17859,
-	17963,
-	18067,
-	18171,
-	18275,
-	18379,
-	18483,
-	18587,
-	18691,
-	18795,
-	101,
+	mavlink_terrain_check_t packet_in = {
+		963497464,963497672
 	};
-	mavlink_hil_rc_inputs_raw_t packet1, packet2;
+	mavlink_terrain_check_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.time_usec = packet_in.time_usec;
-        	packet1.chan1_raw = packet_in.chan1_raw;
-        	packet1.chan2_raw = packet_in.chan2_raw;
-        	packet1.chan3_raw = packet_in.chan3_raw;
-        	packet1.chan4_raw = packet_in.chan4_raw;
-        	packet1.chan5_raw = packet_in.chan5_raw;
-        	packet1.chan6_raw = packet_in.chan6_raw;
-        	packet1.chan7_raw = packet_in.chan7_raw;
-        	packet1.chan8_raw = packet_in.chan8_raw;
-        	packet1.chan9_raw = packet_in.chan9_raw;
-        	packet1.chan10_raw = packet_in.chan10_raw;
-        	packet1.chan11_raw = packet_in.chan11_raw;
-        	packet1.chan12_raw = packet_in.chan12_raw;
-        	packet1.rssi = packet_in.rssi;
+        	packet1.lat = packet_in.lat;
+        	packet1.lon = packet_in.lon;
         
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_hil_rc_inputs_raw_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_hil_rc_inputs_raw_decode(&msg, &packet2);
+	mavlink_msg_terrain_check_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_terrain_check_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_hil_rc_inputs_raw_pack(system_id, component_id, &msg , packet1.time_usec , packet1.chan1_raw , packet1.chan2_raw , packet1.chan3_raw , packet1.chan4_raw , packet1.chan5_raw , packet1.chan6_raw , packet1.chan7_raw , packet1.chan8_raw , packet1.chan9_raw , packet1.chan10_raw , packet1.chan11_raw , packet1.chan12_raw , packet1.rssi );
-	mavlink_msg_hil_rc_inputs_raw_decode(&msg, &packet2);
+	mavlink_msg_terrain_check_pack(system_id, component_id, &msg , packet1.lat , packet1.lon );
+	mavlink_msg_terrain_check_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_hil_rc_inputs_raw_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_usec , packet1.chan1_raw , packet1.chan2_raw , packet1.chan3_raw , packet1.chan4_raw , packet1.chan5_raw , packet1.chan6_raw , packet1.chan7_raw , packet1.chan8_raw , packet1.chan9_raw , packet1.chan10_raw , packet1.chan11_raw , packet1.chan12_raw , packet1.rssi );
-	mavlink_msg_hil_rc_inputs_raw_decode(&msg, &packet2);
+	mavlink_msg_terrain_check_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.lat , packet1.lon );
+	mavlink_msg_terrain_check_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -3435,56 +4965,48 @@ static void mavlink_test_hil_rc_inputs_r
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_hil_rc_inputs_raw_decode(last_msg, &packet2);
+	mavlink_msg_terrain_check_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_hil_rc_inputs_raw_send(MAVLINK_COMM_1 , packet1.time_usec , packet1.chan1_raw , packet1.chan2_raw , packet1.chan3_raw , packet1.chan4_raw , packet1.chan5_raw , packet1.chan6_raw , packet1.chan7_raw , packet1.chan8_raw , packet1.chan9_raw , packet1.chan10_raw , packet1.chan11_raw , packet1.chan12_raw , packet1.rssi );
-	mavlink_msg_hil_rc_inputs_raw_decode(last_msg, &packet2);
+	mavlink_msg_terrain_check_send(MAVLINK_COMM_1 , packet1.lat , packet1.lon );
+	mavlink_msg_terrain_check_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_optical_flow(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_terrain_report(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_optical_flow_t packet_in = {
-		93372036854775807ULL,
-	73.0,
-	101.0,
-	129.0,
-	18275,
-	18379,
-	77,
-	144,
+	mavlink_terrain_report_t packet_in = {
+		963497464,963497672,73.0,101.0,18067,18171,18275
 	};
-	mavlink_optical_flow_t packet1, packet2;
+	mavlink_terrain_report_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.time_usec = packet_in.time_usec;
-        	packet1.flow_comp_m_x = packet_in.flow_comp_m_x;
-        	packet1.flow_comp_m_y = packet_in.flow_comp_m_y;
-        	packet1.ground_distance = packet_in.ground_distance;
-        	packet1.flow_x = packet_in.flow_x;
-        	packet1.flow_y = packet_in.flow_y;
-        	packet1.sensor_id = packet_in.sensor_id;
-        	packet1.quality = packet_in.quality;
+        	packet1.lat = packet_in.lat;
+        	packet1.lon = packet_in.lon;
+        	packet1.terrain_height = packet_in.terrain_height;
+        	packet1.current_height = packet_in.current_height;
+        	packet1.spacing = packet_in.spacing;
+        	packet1.pending = packet_in.pending;
+        	packet1.loaded = packet_in.loaded;
         
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_optical_flow_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_optical_flow_decode(&msg, &packet2);
+	mavlink_msg_terrain_report_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_terrain_report_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_optical_flow_pack(system_id, component_id, &msg , packet1.time_usec , packet1.sensor_id , packet1.flow_x , packet1.flow_y , packet1.flow_comp_m_x , packet1.flow_comp_m_y , packet1.quality , packet1.ground_distance );
-	mavlink_msg_optical_flow_decode(&msg, &packet2);
+	mavlink_msg_terrain_report_pack(system_id, component_id, &msg , packet1.lat , packet1.lon , packet1.spacing , packet1.terrain_height , packet1.current_height , packet1.pending , packet1.loaded );
+	mavlink_msg_terrain_report_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_optical_flow_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_usec , packet1.sensor_id , packet1.flow_x , packet1.flow_y , packet1.flow_comp_m_x , packet1.flow_comp_m_y , packet1.quality , packet1.ground_distance );
-	mavlink_msg_optical_flow_decode(&msg, &packet2);
+	mavlink_msg_terrain_report_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.lat , packet1.lon , packet1.spacing , packet1.terrain_height , packet1.current_height , packet1.pending , packet1.loaded );
+	mavlink_msg_terrain_report_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -3492,54 +5014,45 @@ static void mavlink_test_optical_flow(ui
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_optical_flow_decode(last_msg, &packet2);
+	mavlink_msg_terrain_report_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_optical_flow_send(MAVLINK_COMM_1 , packet1.time_usec , packet1.sensor_id , packet1.flow_x , packet1.flow_y , packet1.flow_comp_m_x , packet1.flow_comp_m_y , packet1.quality , packet1.ground_distance );
-	mavlink_msg_optical_flow_decode(last_msg, &packet2);
+	mavlink_msg_terrain_report_send(MAVLINK_COMM_1 , packet1.lat , packet1.lon , packet1.spacing , packet1.terrain_height , packet1.current_height , packet1.pending , packet1.loaded );
+	mavlink_msg_terrain_report_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_global_vision_position_estimate(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_scaled_pressure2(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_global_vision_position_estimate_t packet_in = {
-		93372036854775807ULL,
-	73.0,
-	101.0,
-	129.0,
-	157.0,
-	185.0,
-	213.0,
+	mavlink_scaled_pressure2_t packet_in = {
+		963497464,45.0,73.0,17859
 	};
-	mavlink_global_vision_position_estimate_t packet1, packet2;
+	mavlink_scaled_pressure2_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.usec = packet_in.usec;
-        	packet1.x = packet_in.x;
-        	packet1.y = packet_in.y;
-        	packet1.z = packet_in.z;
-        	packet1.roll = packet_in.roll;
-        	packet1.pitch = packet_in.pitch;
-        	packet1.yaw = packet_in.yaw;
+        	packet1.time_boot_ms = packet_in.time_boot_ms;
+        	packet1.press_abs = packet_in.press_abs;
+        	packet1.press_diff = packet_in.press_diff;
+        	packet1.temperature = packet_in.temperature;
         
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_global_vision_position_estimate_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_global_vision_position_estimate_decode(&msg, &packet2);
+	mavlink_msg_scaled_pressure2_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_scaled_pressure2_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_global_vision_position_estimate_pack(system_id, component_id, &msg , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
-	mavlink_msg_global_vision_position_estimate_decode(&msg, &packet2);
+	mavlink_msg_scaled_pressure2_pack(system_id, component_id, &msg , packet1.time_boot_ms , packet1.press_abs , packet1.press_diff , packet1.temperature );
+	mavlink_msg_scaled_pressure2_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_global_vision_position_estimate_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
-	mavlink_msg_global_vision_position_estimate_decode(&msg, &packet2);
+	mavlink_msg_scaled_pressure2_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.time_boot_ms , packet1.press_abs , packet1.press_diff , packet1.temperature );
+	mavlink_msg_scaled_pressure2_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -3547,54 +5060,50 @@ static void mavlink_test_global_vision_p
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_global_vision_position_estimate_decode(last_msg, &packet2);
+	mavlink_msg_scaled_pressure2_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_global_vision_position_estimate_send(MAVLINK_COMM_1 , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
-	mavlink_msg_global_vision_position_estimate_decode(last_msg, &packet2);
+	mavlink_msg_scaled_pressure2_send(MAVLINK_COMM_1 , packet1.time_boot_ms , packet1.press_abs , packet1.press_diff , packet1.temperature );
+	mavlink_msg_scaled_pressure2_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_vision_position_estimate(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_battery_status(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_vision_position_estimate_t packet_in = {
-		93372036854775807ULL,
-	73.0,
-	101.0,
-	129.0,
-	157.0,
-	185.0,
-	213.0,
+	mavlink_battery_status_t packet_in = {
+		963497464,963497672,17651,{ 17755, 17756, 17757, 17758, 17759, 17760, 17761, 17762, 17763, 17764 },18795,101,168,235,46
 	};
-	mavlink_vision_position_estimate_t packet1, packet2;
+	mavlink_battery_status_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.usec = packet_in.usec;
-        	packet1.x = packet_in.x;
-        	packet1.y = packet_in.y;
-        	packet1.z = packet_in.z;
-        	packet1.roll = packet_in.roll;
-        	packet1.pitch = packet_in.pitch;
-        	packet1.yaw = packet_in.yaw;
+        	packet1.current_consumed = packet_in.current_consumed;
+        	packet1.energy_consumed = packet_in.energy_consumed;
+        	packet1.temperature = packet_in.temperature;
+        	packet1.current_battery = packet_in.current_battery;
+        	packet1.id = packet_in.id;
+        	packet1.battery_function = packet_in.battery_function;
+        	packet1.type = packet_in.type;
+        	packet1.battery_remaining = packet_in.battery_remaining;
         
+        	mav_array_memcpy(packet1.voltages, packet_in.voltages, sizeof(uint16_t)*10);
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_vision_position_estimate_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_vision_position_estimate_decode(&msg, &packet2);
+	mavlink_msg_battery_status_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_battery_status_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_vision_position_estimate_pack(system_id, component_id, &msg , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
-	mavlink_msg_vision_position_estimate_decode(&msg, &packet2);
+	mavlink_msg_battery_status_pack(system_id, component_id, &msg , packet1.id , packet1.battery_function , packet1.type , packet1.temperature , packet1.voltages , packet1.current_battery , packet1.current_consumed , packet1.energy_consumed , packet1.battery_remaining );
+	mavlink_msg_battery_status_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_vision_position_estimate_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
-	mavlink_msg_vision_position_estimate_decode(&msg, &packet2);
+	mavlink_msg_battery_status_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.id , packet1.battery_function , packet1.type , packet1.temperature , packet1.voltages , packet1.current_battery , packet1.current_consumed , packet1.energy_consumed , packet1.battery_remaining );
+	mavlink_msg_battery_status_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -3602,48 +5111,52 @@ static void mavlink_test_vision_position
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_vision_position_estimate_decode(last_msg, &packet2);
+	mavlink_msg_battery_status_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_vision_position_estimate_send(MAVLINK_COMM_1 , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
-	mavlink_msg_vision_position_estimate_decode(last_msg, &packet2);
+	mavlink_msg_battery_status_send(MAVLINK_COMM_1 , packet1.id , packet1.battery_function , packet1.type , packet1.temperature , packet1.voltages , packet1.current_battery , packet1.current_consumed , packet1.energy_consumed , packet1.battery_remaining );
+	mavlink_msg_battery_status_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_vision_speed_estimate(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_autopilot_version(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_vision_speed_estimate_t packet_in = {
-		93372036854775807ULL,
-	73.0,
-	101.0,
-	129.0,
+	mavlink_autopilot_version_t packet_in = {
+		93372036854775807ULL,93372036854776311ULL,963498296,963498504,963498712,963498920,18899,19003,{ 113, 114, 115, 116, 117, 118, 119, 120 },{ 137, 138, 139, 140, 141, 142, 143, 144 },{ 161, 162, 163, 164, 165, 166, 167, 168 }
 	};
-	mavlink_vision_speed_estimate_t packet1, packet2;
+	mavlink_autopilot_version_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.usec = packet_in.usec;
-        	packet1.x = packet_in.x;
-        	packet1.y = packet_in.y;
-        	packet1.z = packet_in.z;
+        	packet1.capabilities = packet_in.capabilities;
+        	packet1.uid = packet_in.uid;
+        	packet1.flight_sw_version = packet_in.flight_sw_version;
+        	packet1.middleware_sw_version = packet_in.middleware_sw_version;
+        	packet1.os_sw_version = packet_in.os_sw_version;
+        	packet1.board_version = packet_in.board_version;
+        	packet1.vendor_id = packet_in.vendor_id;
+        	packet1.product_id = packet_in.product_id;
         
+        	mav_array_memcpy(packet1.flight_custom_version, packet_in.flight_custom_version, sizeof(uint8_t)*8);
+        	mav_array_memcpy(packet1.middleware_custom_version, packet_in.middleware_custom_version, sizeof(uint8_t)*8);
+        	mav_array_memcpy(packet1.os_custom_version, packet_in.os_custom_version, sizeof(uint8_t)*8);
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_vision_speed_estimate_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_vision_speed_estimate_decode(&msg, &packet2);
+	mavlink_msg_autopilot_version_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_autopilot_version_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_vision_speed_estimate_pack(system_id, component_id, &msg , packet1.usec , packet1.x , packet1.y , packet1.z );
-	mavlink_msg_vision_speed_estimate_decode(&msg, &packet2);
+	mavlink_msg_autopilot_version_pack(system_id, component_id, &msg , packet1.capabilities , packet1.flight_sw_version , packet1.middleware_sw_version , packet1.os_sw_version , packet1.board_version , packet1.flight_custom_version , packet1.middleware_custom_version , packet1.os_custom_version , packet1.vendor_id , packet1.product_id , packet1.uid );
+	mavlink_msg_autopilot_version_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_vision_speed_estimate_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.usec , packet1.x , packet1.y , packet1.z );
-	mavlink_msg_vision_speed_estimate_decode(&msg, &packet2);
+	mavlink_msg_autopilot_version_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.capabilities , packet1.flight_sw_version , packet1.middleware_sw_version , packet1.os_sw_version , packet1.board_version , packet1.flight_custom_version , packet1.middleware_custom_version , packet1.os_custom_version , packet1.vendor_id , packet1.product_id , packet1.uid );
+	mavlink_msg_autopilot_version_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -3651,54 +5164,46 @@ static void mavlink_test_vision_speed_es
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_vision_speed_estimate_decode(last_msg, &packet2);
+	mavlink_msg_autopilot_version_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_vision_speed_estimate_send(MAVLINK_COMM_1 , packet1.usec , packet1.x , packet1.y , packet1.z );
-	mavlink_msg_vision_speed_estimate_decode(last_msg, &packet2);
+	mavlink_msg_autopilot_version_send(MAVLINK_COMM_1 , packet1.capabilities , packet1.flight_sw_version , packet1.middleware_sw_version , packet1.os_sw_version , packet1.board_version , packet1.flight_custom_version , packet1.middleware_custom_version , packet1.os_custom_version , packet1.vendor_id , packet1.product_id , packet1.uid );
+	mavlink_msg_autopilot_version_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
-static void mavlink_test_vicon_position_estimate(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
+static void mavlink_test_v2_extension(uint8_t system_id, uint8_t component_id, mavlink_message_t *last_msg)
 {
 	mavlink_message_t msg;
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
-	mavlink_vicon_position_estimate_t packet_in = {
-		93372036854775807ULL,
-	73.0,
-	101.0,
-	129.0,
-	157.0,
-	185.0,
-	213.0,
+	mavlink_v2_extension_t packet_in = {
+		17235,139,206,17,{ 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76 }
 	};
-	mavlink_vicon_position_estimate_t packet1, packet2;
+	mavlink_v2_extension_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
-        	packet1.usec = packet_in.usec;
-        	packet1.x = packet_in.x;
-        	packet1.y = packet_in.y;
-        	packet1.z = packet_in.z;
-        	packet1.roll = packet_in.roll;
-        	packet1.pitch = packet_in.pitch;
-        	packet1.yaw = packet_in.yaw;
+        	packet1.message_type = packet_in.message_type;
+        	packet1.target_network = packet_in.target_network;
+        	packet1.target_system = packet_in.target_system;
+        	packet1.target_component = packet_in.target_component;
         
+        	mav_array_memcpy(packet1.payload, packet_in.payload, sizeof(uint8_t)*249);
         
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_vicon_position_estimate_encode(system_id, component_id, &msg, &packet1);
-	mavlink_msg_vicon_position_estimate_decode(&msg, &packet2);
+	mavlink_msg_v2_extension_encode(system_id, component_id, &msg, &packet1);
+	mavlink_msg_v2_extension_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_vicon_position_estimate_pack(system_id, component_id, &msg , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
-	mavlink_msg_vicon_position_estimate_decode(&msg, &packet2);
+	mavlink_msg_v2_extension_pack(system_id, component_id, &msg , packet1.target_network , packet1.target_system , packet1.target_component , packet1.message_type , packet1.payload );
+	mavlink_msg_v2_extension_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_vicon_position_estimate_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
-	mavlink_msg_vicon_position_estimate_decode(&msg, &packet2);
+	mavlink_msg_v2_extension_pack_chan(system_id, component_id, MAVLINK_COMM_0, &msg , packet1.target_network , packet1.target_system , packet1.target_component , packet1.message_type , packet1.payload );
+	mavlink_msg_v2_extension_decode(&msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 
         memset(&packet2, 0, sizeof(packet2));
@@ -3706,12 +5211,12 @@ static void mavlink_test_vicon_position_
         for (i=0; i<mavlink_msg_get_send_buffer_length(&msg); i++) {
         	comm_send_ch(MAVLINK_COMM_0, buffer[i]);
         }
-	mavlink_msg_vicon_position_estimate_decode(last_msg, &packet2);
+	mavlink_msg_v2_extension_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
         
         memset(&packet2, 0, sizeof(packet2));
-	mavlink_msg_vicon_position_estimate_send(MAVLINK_COMM_1 , packet1.usec , packet1.x , packet1.y , packet1.z , packet1.roll , packet1.pitch , packet1.yaw );
-	mavlink_msg_vicon_position_estimate_decode(last_msg, &packet2);
+	mavlink_msg_v2_extension_send(MAVLINK_COMM_1 , packet1.target_network , packet1.target_system , packet1.target_component , packet1.message_type , packet1.payload );
+	mavlink_msg_v2_extension_decode(last_msg, &packet2);
         MAVLINK_ASSERT(memcmp(&packet1, &packet2, sizeof(packet1)) == 0);
 }
 
@@ -3721,10 +5226,7 @@ static void mavlink_test_memory_vect(uin
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_memory_vect_t packet_in = {
-		17235,
-	139,
-	206,
-	{ 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48 },
+		17235,139,206,{ 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48 }
 	};
 	mavlink_memory_vect_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -3770,11 +5272,7 @@ static void mavlink_test_debug_vect(uint
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_debug_vect_t packet_in = {
-		93372036854775807ULL,
-	73.0,
-	101.0,
-	129.0,
-	"UVWXYZABC",
+		93372036854775807ULL,73.0,101.0,129.0,"UVWXYZABC"
 	};
 	mavlink_debug_vect_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -3821,9 +5319,7 @@ static void mavlink_test_named_value_flo
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_named_value_float_t packet_in = {
-		963497464,
-	45.0,
-	"IJKLMNOPQ",
+		963497464,45.0,"IJKLMNOPQ"
 	};
 	mavlink_named_value_float_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -3868,9 +5364,7 @@ static void mavlink_test_named_value_int
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_named_value_int_t packet_in = {
-		963497464,
-	963497672,
-	"IJKLMNOPQ",
+		963497464,963497672,"IJKLMNOPQ"
 	};
 	mavlink_named_value_int_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -3915,8 +5409,7 @@ static void mavlink_test_statustext(uint
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_statustext_t packet_in = {
-		5,
-	"BCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWX",
+		5,"BCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWX"
 	};
 	mavlink_statustext_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -3960,9 +5453,7 @@ static void mavlink_test_debug(uint8_t s
         uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
         uint16_t i;
 	mavlink_debug_t packet_in = {
-		963497464,
-	45.0,
-	29,
+		963497464,45.0,29
 	};
 	mavlink_debug_t packet1, packet2;
         memset(&packet1, 0, sizeof(packet1));
@@ -4041,28 +5532,30 @@ static void mavlink_test_common(uint8_t
 	mavlink_test_mission_ack(system_id, component_id, last_msg);
 	mavlink_test_set_gps_global_origin(system_id, component_id, last_msg);
 	mavlink_test_gps_global_origin(system_id, component_id, last_msg);
-	mavlink_test_set_local_position_setpoint(system_id, component_id, last_msg);
-	mavlink_test_local_position_setpoint(system_id, component_id, last_msg);
-	mavlink_test_global_position_setpoint_int(system_id, component_id, last_msg);
-	mavlink_test_set_global_position_setpoint_int(system_id, component_id, last_msg);
+	mavlink_test_param_map_rc(system_id, component_id, last_msg);
 	mavlink_test_safety_set_allowed_area(system_id, component_id, last_msg);
 	mavlink_test_safety_allowed_area(system_id, component_id, last_msg);
-	mavlink_test_set_roll_pitch_yaw_thrust(system_id, component_id, last_msg);
-	mavlink_test_set_roll_pitch_yaw_speed_thrust(system_id, component_id, last_msg);
-	mavlink_test_roll_pitch_yaw_thrust_setpoint(system_id, component_id, last_msg);
-	mavlink_test_roll_pitch_yaw_speed_thrust_setpoint(system_id, component_id, last_msg);
-	mavlink_test_set_quad_motors_setpoint(system_id, component_id, last_msg);
-	mavlink_test_set_quad_swarm_roll_pitch_yaw_thrust(system_id, component_id, last_msg);
+	mavlink_test_attitude_quaternion_cov(system_id, component_id, last_msg);
 	mavlink_test_nav_controller_output(system_id, component_id, last_msg);
-	mavlink_test_set_quad_swarm_led_roll_pitch_yaw_thrust(system_id, component_id, last_msg);
-	mavlink_test_state_correction(system_id, component_id, last_msg);
+	mavlink_test_global_position_int_cov(system_id, component_id, last_msg);
+	mavlink_test_local_position_ned_cov(system_id, component_id, last_msg);
+	mavlink_test_rc_channels(system_id, component_id, last_msg);
 	mavlink_test_request_data_stream(system_id, component_id, last_msg);
 	mavlink_test_data_stream(system_id, component_id, last_msg);
 	mavlink_test_manual_control(system_id, component_id, last_msg);
 	mavlink_test_rc_channels_override(system_id, component_id, last_msg);
+	mavlink_test_mission_item_int(system_id, component_id, last_msg);
 	mavlink_test_vfr_hud(system_id, component_id, last_msg);
+	mavlink_test_command_int(system_id, component_id, last_msg);
 	mavlink_test_command_long(system_id, component_id, last_msg);
 	mavlink_test_command_ack(system_id, component_id, last_msg);
+	mavlink_test_manual_setpoint(system_id, component_id, last_msg);
+	mavlink_test_set_attitude_target(system_id, component_id, last_msg);
+	mavlink_test_attitude_target(system_id, component_id, last_msg);
+	mavlink_test_set_position_target_local_ned(system_id, component_id, last_msg);
+	mavlink_test_position_target_local_ned(system_id, component_id, last_msg);
+	mavlink_test_set_position_target_global_int(system_id, component_id, last_msg);
+	mavlink_test_position_target_global_int(system_id, component_id, last_msg);
 	mavlink_test_local_position_ned_system_global_offset(system_id, component_id, last_msg);
 	mavlink_test_hil_state(system_id, component_id, last_msg);
 	mavlink_test_hil_controls(system_id, component_id, last_msg);
@@ -4072,6 +5565,40 @@ static void mavlink_test_common(uint8_t
 	mavlink_test_vision_position_estimate(system_id, component_id, last_msg);
 	mavlink_test_vision_speed_estimate(system_id, component_id, last_msg);
 	mavlink_test_vicon_position_estimate(system_id, component_id, last_msg);
+	mavlink_test_highres_imu(system_id, component_id, last_msg);
+	mavlink_test_optical_flow_rad(system_id, component_id, last_msg);
+	mavlink_test_hil_sensor(system_id, component_id, last_msg);
+	mavlink_test_sim_state(system_id, component_id, last_msg);
+	mavlink_test_radio_status(system_id, component_id, last_msg);
+	mavlink_test_file_transfer_protocol(system_id, component_id, last_msg);
+	mavlink_test_timesync(system_id, component_id, last_msg);
+	mavlink_test_hil_gps(system_id, component_id, last_msg);
+	mavlink_test_hil_optical_flow(system_id, component_id, last_msg);
+	mavlink_test_hil_state_quaternion(system_id, component_id, last_msg);
+	mavlink_test_scaled_imu2(system_id, component_id, last_msg);
+	mavlink_test_log_request_list(system_id, component_id, last_msg);
+	mavlink_test_log_entry(system_id, component_id, last_msg);
+	mavlink_test_log_request_data(system_id, component_id, last_msg);
+	mavlink_test_log_data(system_id, component_id, last_msg);
+	mavlink_test_log_erase(system_id, component_id, last_msg);
+	mavlink_test_log_request_end(system_id, component_id, last_msg);
+	mavlink_test_gps_inject_data(system_id, component_id, last_msg);
+	mavlink_test_gps2_raw(system_id, component_id, last_msg);
+	mavlink_test_power_status(system_id, component_id, last_msg);
+	mavlink_test_serial_control(system_id, component_id, last_msg);
+	mavlink_test_gps_rtk(system_id, component_id, last_msg);
+	mavlink_test_gps2_rtk(system_id, component_id, last_msg);
+	mavlink_test_data_transmission_handshake(system_id, component_id, last_msg);
+	mavlink_test_encapsulated_data(system_id, component_id, last_msg);
+	mavlink_test_distance_sensor(system_id, component_id, last_msg);
+	mavlink_test_terrain_request(system_id, component_id, last_msg);
+	mavlink_test_terrain_data(system_id, component_id, last_msg);
+	mavlink_test_terrain_check(system_id, component_id, last_msg);
+	mavlink_test_terrain_report(system_id, component_id, last_msg);
+	mavlink_test_scaled_pressure2(system_id, component_id, last_msg);
+	mavlink_test_battery_status(system_id, component_id, last_msg);
+	mavlink_test_autopilot_version(system_id, component_id, last_msg);
+	mavlink_test_v2_extension(system_id, component_id, last_msg);
 	mavlink_test_memory_vect(system_id, component_id, last_msg);
 	mavlink_test_debug_vect(system_id, component_id, last_msg);
 	mavlink_test_named_value_float(system_id, component_id, last_msg);
diff -BburpN v1.0.old/common/version.h v1.0/common/version.h
--- v1.0.old/common/version.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/common/version.h	2015-02-06 11:50:58.000000000 +0500
@@ -1,12 +1,12 @@
 /** @file
  *	@brief MAVLink comm protocol built from common.xml
- *	@see http://pixhawk.ethz.ch/software/mavlink
+ *	@see http://mavlink.org
  */
 #ifndef MAVLINK_VERSION_H
 #define MAVLINK_VERSION_H
 
-#define MAVLINK_BUILD_DATE "Sat Aug 11 14:26:42 2012"
+#define MAVLINK_BUILD_DATE "Fri Jan 30 17:25:59 2015"
 #define MAVLINK_WIRE_PROTOCOL_VERSION "1.0"
-#define MAVLINK_MAX_DIALECT_PAYLOAD_SIZE 101
+#define MAVLINK_MAX_DIALECT_PAYLOAD_SIZE 255
  
 #endif // MAVLINK_VERSION_H
diff -BburpN v1.0.old/mavlink_helpers.h v1.0/mavlink_helpers.h
--- v1.0.old/mavlink_helpers.h	2016-04-02 17:57:54.000000000 +0500
+++ v1.0/mavlink_helpers.h	2016-06-15 10:02:30.000000000 +0500
@@ -30,6 +30,7 @@ MAVLINK_HELPER mavlink_message_t* mavlin
 #ifndef m_mavlink_message
 #error ERROR: IF #define MAVLINK_EXTERNAL_RX_BUFFER IS SET, THE BUFFER HAS TO BE ALLOCATED OUTSIDE OF THIS FUNCTION (mavlink_message_t m_mavlink_buffer[MAVLINK_COMM_NUM_BUFFERS];)
 #endif
+//    extern mavlink_message_t m_mavlink_buffer[];
 #else
 	static mavlink_message_t m_mavlink_buffer[MAVLINK_COMM_NUM_BUFFERS];
 #endif
@@ -175,7 +176,7 @@ MAVLINK_HELPER void mavlink_start_checks
 	crc_init(&msg->checksum);
 }
 
-MAVLINK_HELPER void mavlink_update_checksum(mavlink_message_t* msg, uint8_t c)
+MAVLINK_HELPER void NOINLINE mavlink_update_checksum(mavlink_message_t* msg, uint8_t c)
 {
 	crc_accumulate(c, &msg->checksum);
 }
@@ -204,11 +205,9 @@ MAVLINK_HELPER void mavlink_update_check
  * int chan = 0;
  *
  *
- * while(serial.bytesAvailable > 0)
- * {
- *   uint8_t byte = serial.getNextByte();
- *   if (mavlink_parse_char(chan, byte, &msg))
- *     {
+ * while(serial.available > 0) {
+ *   uint8_t byte = serial.read();
+ *   if (mavlink_parse_char(chan, byte, &msg)) {
  *     printf("Received message with ID %d, sequence: %d from component %d of system %d", msg.msgid, msg.seq, msg.compid, msg.sysid);
  *     }
  * }
@@ -216,6 +215,9 @@ MAVLINK_HELPER void mavlink_update_check
  *
  * @endcode
  */
+ 
+//#define MAV_DEBUG 1
+ 
 MAVLINK_HELPER uint8_t mavlink_parse_char(uint8_t chan, uint8_t c, mavlink_message_t* r_message, mavlink_status_t* r_mavlink_status)
 {
         /*
@@ -224,8 +226,8 @@ MAVLINK_HELPER uint8_t mavlink_parse_cha
 	*/
 #if MAVLINK_CRC_EXTRA
 #ifndef MAVLINK_MESSAGE_CRC
-	static const uint8_t mavlink_message_crcs[256] = MAVLINK_MESSAGE_CRCS;
-#define MAVLINK_MESSAGE_CRC(msgid) mavlink_message_crcs[msgid]
+	static const uint8_t PROGMEM mavlink_message_crcs[256] = MAVLINK_MESSAGE_CRCS;
+#define MAVLINK_MESSAGE_CRC(msgid) pgm_read_byte(&mavlink_message_crcs[msgid])
 #endif
 #endif
 
@@ -235,17 +237,21 @@ MAVLINK_HELPER uint8_t mavlink_parse_cha
 
 	status->msg_received = 0;
 
-	switch (status->parse_state)
-	{
+	switch (status->parse_state) {
 	case MAVLINK_PARSE_STATE_UNINIT:
+	    status->packet_rx_drop_count = 0;
 	case MAVLINK_PARSE_STATE_IDLE:
-		if (c == MAVLINK_STX)
-		{
-			status->parse_state = MAVLINK_PARSE_STATE_GOT_STX;
+		if (c == MAVLINK_STX) {
+do_ctx:			status->parse_state = MAVLINK_PARSE_STATE_GOT_STX;
 			rxmsg->len = 0;
-			rxmsg->magic = c;
+//			rxmsg->magic = c;
 			mavlink_start_checksum(rxmsg);
-		}
+#ifdef MAV_DEBUG
+mavlink_comm_0_port->printf_P(PSTR("\n\ngot STX!"));
+#endif
+		} else
+		    goto lost_sync;
+		
 		break;
 
 	case MAVLINK_PARSE_STATE_GOT_STX:
@@ -255,15 +261,19 @@ MAVLINK_HELPER uint8_t mavlink_parse_cha
 #if (MAVLINK_MAX_PAYLOAD_LEN < 255)
 				|| c > MAVLINK_MAX_PAYLOAD_LEN
 #endif
-				)
-		{
+				){
 			status->buffer_overrun++;
 			status->parse_error++;
 			status->msg_received = 0;
-			status->parse_state = MAVLINK_PARSE_STATE_IDLE;
+			//status->parse_state = MAVLINK_PARSE_STATE_IDLE;
+			goto lost_sync;
 		}
 		else
 		{
+#ifdef MAV_DEBUG
+mavlink_comm_0_port->printf_P(PSTR(" got Length!"));
+#endif
+
 			// NOT counting STX, LENGTH, SEQ, SYSID, COMPID, MSGID, CRC1 and CRC2
 			rxmsg->len = c;
 			status->packet_idx = 0;
@@ -273,18 +283,27 @@ MAVLINK_HELPER uint8_t mavlink_parse_cha
 		break;
 
 	case MAVLINK_PARSE_STATE_GOT_LENGTH:
+#ifdef MAV_DEBUG
+mavlink_comm_0_port->printf_P(PSTR(" got Seq!"));
+#endif
 		rxmsg->seq = c;
 		mavlink_update_checksum(rxmsg, c);
 		status->parse_state = MAVLINK_PARSE_STATE_GOT_SEQ;
 		break;
 
 	case MAVLINK_PARSE_STATE_GOT_SEQ:
+#ifdef MAV_DEBUG
+mavlink_comm_0_port->printf_P(PSTR(" got Sysid!"));
+#endif
 		rxmsg->sysid = c;
 		mavlink_update_checksum(rxmsg, c);
 		status->parse_state = MAVLINK_PARSE_STATE_GOT_SYSID;
 		break;
 
 	case MAVLINK_PARSE_STATE_GOT_SYSID:
+#ifdef MAV_DEBUG
+mavlink_comm_0_port->printf_P(PSTR(" got Compid!"));
+#endif
 		rxmsg->compid = c;
 		mavlink_update_checksum(rxmsg, c);
 		status->parse_state = MAVLINK_PARSE_STATE_GOT_COMPID;
@@ -293,43 +312,52 @@ MAVLINK_HELPER uint8_t mavlink_parse_cha
 	case MAVLINK_PARSE_STATE_GOT_COMPID:
 		rxmsg->msgid = c;
 		mavlink_update_checksum(rxmsg, c);
-		if (rxmsg->len == 0)
-		{
+		if (rxmsg->len == 0) {
 			status->parse_state = MAVLINK_PARSE_STATE_GOT_PAYLOAD;
-		}
-		else
-		{
+		} else {
 			status->parse_state = MAVLINK_PARSE_STATE_GOT_MSGID;
 		}
+#ifdef MAV_DEBUG
+mavlink_comm_0_port->printf_P(PSTR(" got Msgid!"));
+#endif
 		break;
 
 	case MAVLINK_PARSE_STATE_GOT_MSGID:
 		_MAV_PAYLOAD_NON_CONST(rxmsg)[status->packet_idx++] = (char)c;
 		mavlink_update_checksum(rxmsg, c);
-		if (status->packet_idx == rxmsg->len)
-		{
+		if (status->packet_idx == rxmsg->len) {
 			status->parse_state = MAVLINK_PARSE_STATE_GOT_PAYLOAD;
+#ifdef MAV_DEBUG
+mavlink_comm_0_port->printf_P(PSTR(" got payload!"));
+#endif
 		}
 		break;
 
 	case MAVLINK_PARSE_STATE_GOT_PAYLOAD:
 #if MAVLINK_CRC_EXTRA
 		mavlink_update_checksum(rxmsg, MAVLINK_MESSAGE_CRC(rxmsg->msgid));
+#ifdef MAV_DEBUG
+mavlink_comm_0_port->printf_P(PSTR("\nCRC updated by %d msg_id=%d\n"), MAVLINK_MESSAGE_CRC(rxmsg->msgid), rxmsg->msgid);
+#endif
+
 #endif
 		if (c != (rxmsg->checksum & 0xFF)) {
+#ifdef MAV_DEBUG
+mavlink_comm_0_port->printf_P(PSTR("\nCRC1! want=%d got=%d\n"), rxmsg->checksum & 0xFF, c);
+#endif
 			// Check first checksum byte
 			status->parse_error++;
 			status->msg_received = 0;
-			status->parse_state = MAVLINK_PARSE_STATE_IDLE;
-			if (c == MAVLINK_STX)
-			{
-				status->parse_state = MAVLINK_PARSE_STATE_GOT_STX;
-				rxmsg->len = 0;
-				mavlink_start_checksum(rxmsg);
+			if (c == MAVLINK_STX) {
+				//status->parse_state = MAVLINK_PARSE_STATE_GOT_STX;
+				//rxmsg->len = 0;
+				//mavlink_start_checksum(rxmsg);
+				goto do_ctx;
+			} else {
+				//status->parse_state = MAVLINK_PARSE_STATE_IDLE;
+				goto lost_sync;
 			}
-		}
-		else
-		{
+		} else {
 			status->parse_state = MAVLINK_PARSE_STATE_GOT_CRC1;
 			_MAV_PAYLOAD_NON_CONST(rxmsg)[status->packet_idx] = (char)c;
 		}
@@ -338,22 +366,29 @@ MAVLINK_HELPER uint8_t mavlink_parse_cha
 	case MAVLINK_PARSE_STATE_GOT_CRC1:
 		if (c != (rxmsg->checksum >> 8)) {
 			// Check second checksum byte
+#ifdef MAV_DEBUG
+mavlink_comm_0_port->printf_P(PSTR("\nCRC2! want=%d got=%d\n"), rxmsg->checksum >> 8, c);
+#endif
+
 			status->parse_error++;
 			status->msg_received = 0;
-			status->parse_state = MAVLINK_PARSE_STATE_IDLE;
-			if (c == MAVLINK_STX)
-			{
-				status->parse_state = MAVLINK_PARSE_STATE_GOT_STX;
-				rxmsg->len = 0;
-				mavlink_start_checksum(rxmsg);
-			}
+			
+			if (c == MAVLINK_STX) {
+				//status->parse_state = MAVLINK_PARSE_STATE_GOT_STX;
+				//rxmsg->len = 0;
+				//mavlink_start_checksum(rxmsg);
+				goto do_ctx;
+			} else {
+				//status->parse_state = MAVLINK_PARSE_STATE_IDLE;
+lost_sync:
+			    status->parse_state=MAVLINK_PARSE_STATE_IDLE;
 		}
-		else
-		{
+		} else {
 			// Successfully got message
 			status->msg_received = 1;
 			status->parse_state = MAVLINK_PARSE_STATE_IDLE;
 			_MAV_PAYLOAD_NON_CONST(rxmsg)[status->packet_idx+1] = (char)c;
+			if(r_message)
 			memcpy(r_message, rxmsg, sizeof(mavlink_message_t));
 		}
 		break;
@@ -361,8 +396,7 @@ MAVLINK_HELPER uint8_t mavlink_parse_cha
 
 	bufferIndex++;
 	// If a message has been sucessfully decoded, check index
-	if (status->msg_received == 1)
-	{
+	if (status->msg_received) {
 		//while(status->current_seq != rxmsg->seq)
 		//{
 		//	status->packet_rx_drop_count++;
@@ -378,7 +412,9 @@ MAVLINK_HELPER uint8_t mavlink_parse_cha
 	r_mavlink_status->current_rx_seq = status->current_rx_seq+1;
 	r_mavlink_status->packet_rx_success_count = status->packet_rx_success_count;
 	r_mavlink_status->packet_rx_drop_count = status->parse_error;
+	r_mavlink_status->buffer_overrun = status->buffer_overrun;
 	status->parse_error = 0;
+
 	return status->msg_received;
 }
 
diff -BburpN v1.0.old/mavlink_types.h v1.0/mavlink_types.h
--- v1.0.old/mavlink_types.h	2015-02-17 19:04:31.000000000 +0500
+++ v1.0/mavlink_types.h	2016-02-22 16:20:32.000000000 +0500
@@ -123,7 +123,7 @@ typedef enum {
 #if (defined linux) | (defined __linux) | (defined  __MACH__) | (defined _WIN32)
 # define MAVLINK_COMM_NUM_BUFFERS 16
 #else
-# define MAVLINK_COMM_NUM_BUFFERS 4
+# define MAVLINK_COMM_NUM_BUFFERS 1
 #endif
 #endif
 
